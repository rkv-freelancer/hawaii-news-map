import { r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";

//#region node_modules/.pnpm/maplibre-gl@5.6.2/node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/maplibre-gl@5.6.2/node_modules/maplibre-gl/dist/maplibre-gl.js": ((exports, module) => {
	/**
	* MapLibre GL JS
	* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
	*/
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global$1 = typeof globalThis !== "undefined" ? globalThis : global$1 || self, global$1.maplibregl = factory());
	})(exports, (function() {
		var maplibregl = {};
		var modules = {};
		function define$1(moduleName, _dependencies, moduleFactory) {
			modules[moduleName] = moduleFactory;
			if (moduleName !== "index") return;
			var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
			var sharedModule = {};
			modules.shared(sharedModule);
			modules.index(maplibregl, sharedModule);
			if (typeof window !== "undefined") maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
			return maplibregl;
		}
		define$1("shared", ["exports"], (function(t) {
			function e(t$1, e$1, r$1, n$1) {
				return new (r$1 || (r$1 = Promise))((function(i$1, s$1) {
					function a(t$2) {
						try {
							l$1(n$1.next(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function o$1(t$2) {
						try {
							l$1(n$1.throw(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function l$1(t$2) {
						var e$2;
						t$2.done ? i$1(t$2.value) : (e$2 = t$2.value, e$2 instanceof r$1 ? e$2 : new r$1((function(t$3) {
							t$3(e$2);
						}))).then(a, o$1);
					}
					l$1((n$1 = n$1.apply(t$1, e$1 || [])).next());
				}));
			}
			function r(t$1, e$1) {
				this.x = t$1, this.y = e$1;
			}
			function n(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var i, s;
			r.prototype = {
				clone() {
					return new r(this.x, this.y);
				},
				add(t$1) {
					return this.clone()._add(t$1);
				},
				sub(t$1) {
					return this.clone()._sub(t$1);
				},
				multByPoint(t$1) {
					return this.clone()._multByPoint(t$1);
				},
				divByPoint(t$1) {
					return this.clone()._divByPoint(t$1);
				},
				mult(t$1) {
					return this.clone()._mult(t$1);
				},
				div(t$1) {
					return this.clone()._div(t$1);
				},
				rotate(t$1) {
					return this.clone()._rotate(t$1);
				},
				rotateAround(t$1, e$1) {
					return this.clone()._rotateAround(t$1, e$1);
				},
				matMult(t$1) {
					return this.clone()._matMult(t$1);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(t$1) {
					return this.x === t$1.x && this.y === t$1.y;
				},
				dist(t$1) {
					return Math.sqrt(this.distSqr(t$1));
				},
				distSqr(t$1) {
					const e$1 = t$1.x - this.x, r$1 = t$1.y - this.y;
					return e$1 * e$1 + r$1 * r$1;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(t$1) {
					return Math.atan2(this.y - t$1.y, this.x - t$1.x);
				},
				angleWith(t$1) {
					return this.angleWithSep(t$1.x, t$1.y);
				},
				angleWithSep(t$1, e$1) {
					return Math.atan2(this.x * e$1 - this.y * t$1, this.x * t$1 + this.y * e$1);
				},
				_matMult(t$1) {
					const e$1 = t$1[2] * this.x + t$1[3] * this.y;
					return this.x = t$1[0] * this.x + t$1[1] * this.y, this.y = e$1, this;
				},
				_add(t$1) {
					return this.x += t$1.x, this.y += t$1.y, this;
				},
				_sub(t$1) {
					return this.x -= t$1.x, this.y -= t$1.y, this;
				},
				_mult(t$1) {
					return this.x *= t$1, this.y *= t$1, this;
				},
				_div(t$1) {
					return this.x /= t$1, this.y /= t$1, this;
				},
				_multByPoint(t$1) {
					return this.x *= t$1.x, this.y *= t$1.y, this;
				},
				_divByPoint(t$1) {
					return this.x /= t$1.x, this.y /= t$1.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					const t$1 = this.y;
					return this.y = this.x, this.x = -t$1, this;
				},
				_rotate(t$1) {
					const e$1 = Math.cos(t$1), r$1 = Math.sin(t$1), n$1 = r$1 * this.x + e$1 * this.y;
					return this.x = e$1 * this.x - r$1 * this.y, this.y = n$1, this;
				},
				_rotateAround(t$1, e$1) {
					const r$1 = Math.cos(t$1), n$1 = Math.sin(t$1), i$1 = e$1.y + n$1 * (this.x - e$1.x) + r$1 * (this.y - e$1.y);
					return this.x = e$1.x + r$1 * (this.x - e$1.x) - n$1 * (this.y - e$1.y), this.y = i$1, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: r
			}, r.convert = function(t$1) {
				if (t$1 instanceof r) return t$1;
				if (Array.isArray(t$1)) return new r(+t$1[0], +t$1[1]);
				if (void 0 !== t$1.x && void 0 !== t$1.y) return new r(+t$1.x, +t$1.y);
				throw new Error("Expected [x, y] or {x, y} point format");
			};
			var o = n(function() {
				if (s) return i;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return s = 1, i = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a) + a;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, i;
			}());
			let l, u;
			function c() {
				return l ??= "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap, l;
			}
			function h() {
				if (null == u && (u = !1, c())) {
					const t$1 = 5, e$1 = new OffscreenCanvas(t$1, t$1).getContext("2d", { willReadFrequently: !0 });
					if (e$1) {
						for (let r$2 = 0; r$2 < t$1 * t$1; r$2++) {
							const n$1 = 4 * r$2;
							e$1.fillStyle = `rgb(${n$1},${n$1 + 1},${n$1 + 2})`, e$1.fillRect(r$2 % t$1, Math.floor(r$2 / t$1), 1, 1);
						}
						const r$1 = e$1.getImageData(0, 0, t$1, t$1).data;
						for (let e$2 = 0; e$2 < t$1 * t$1 * 4; e$2++) if (e$2 % 4 != 3 && r$1[e$2] !== e$2) {
							u = !0;
							break;
						}
					}
				}
				return u || !1;
			}
			var p = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array;
			function d() {
				var t$1 = new f(9);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0), t$1[0] = 1, t$1[4] = 1, t$1[8] = 1, t$1;
			}
			function y(t$1) {
				return t$1[0] = 1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = 1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function m() {
				var t$1 = new f(3);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1;
			}
			function g$1(t$1) {
				return Math.hypot(t$1[0], t$1[1], t$1[2]);
			}
			function x(t$1, e$1, r$1) {
				var n$1 = new f(3);
				return n$1[0] = t$1, n$1[1] = e$1, n$1[2] = r$1, n$1;
			}
			function v(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1[2] = e$1[2] + r$1[2], t$1;
			}
			function b$1(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1;
			}
			function w(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = r$1[0], o$1 = r$1[1], l$1 = r$1[2];
				return t$1[0] = i$1 * l$1 - s$1 * o$1, t$1[1] = s$1 * a - n$1 * l$1, t$1[2] = n$1 * o$1 - i$1 * a, t$1;
			}
			Math.hypot || (Math.hypot = function() {
				for (var t$1 = 0, e$1 = arguments.length; e$1--;) t$1 += arguments[e$1] * arguments[e$1];
				return Math.sqrt(t$1);
			});
			var _$1, S$1 = g$1;
			function A(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = e$1[3];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12] * a, t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13] * a, t$1[2] = r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14] * a, t$1[3] = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15] * a, t$1;
			}
			function k$1() {
				var t$1 = new f(4);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1[3] = 1, t$1;
			}
			function M$1(t$1, e$1, r$1, n$1) {
				var i$1 = .5 * Math.PI / 180;
				e$1 *= i$1, r$1 *= i$1, n$1 *= i$1;
				var s$1 = Math.sin(e$1), a = Math.cos(e$1), o$1 = Math.sin(r$1), l$1 = Math.cos(r$1), u$1 = Math.sin(n$1), c$1 = Math.cos(n$1);
				return t$1[0] = s$1 * l$1 * c$1 - a * o$1 * u$1, t$1[1] = a * o$1 * c$1 + s$1 * l$1 * u$1, t$1[2] = a * l$1 * u$1 - s$1 * o$1 * c$1, t$1[3] = a * l$1 * c$1 + s$1 * o$1 * u$1, t$1;
			}
			function I$1() {
				var t$1 = new f(2);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0), t$1;
			}
			function z$1(t$1, e$1) {
				var r$1 = new f(2);
				return r$1[0] = t$1, r$1[1] = e$1, r$1;
			}
			m(), _$1 = new f(4), f != Float32Array && (_$1[0] = 0, _$1[1] = 0, _$1[2] = 0, _$1[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), k$1(), k$1(), d(), I$1();
			const P$1 = 8192;
			function C(t$1, e$1, r$1) {
				return e$1 * (P$1 / (t$1.tileSize * Math.pow(2, r$1 - t$1.tileID.overscaledZ)));
			}
			function E(t$1, e$1) {
				return (t$1 % e$1 + e$1) % e$1;
			}
			function B$1(t$1, e$1, r$1) {
				return t$1 * (1 - r$1) + e$1 * r$1;
			}
			function V(t$1) {
				if (t$1 <= 0) return 0;
				if (t$1 >= 1) return 1;
				const e$1 = t$1 * t$1, r$1 = e$1 * t$1;
				return 4 * (t$1 < .5 ? r$1 : 3 * (t$1 - e$1) + r$1 - .75);
			}
			function T$1(t$1, e$1, r$1, n$1) {
				const i$1 = new o(t$1, e$1, r$1, n$1);
				return (t$2) => i$1.solve(t$2);
			}
			const F$1 = T$1(.25, .1, .25, 1);
			function $$1(t$1, e$1, r$1) {
				return Math.min(r$1, Math.max(e$1, t$1));
			}
			function L$1(t$1, e$1, r$1) {
				const n$1 = r$1 - e$1, i$1 = ((t$1 - e$1) % n$1 + n$1) % n$1 + e$1;
				return i$1 === e$1 ? r$1 : i$1;
			}
			function O$1(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			let D$1 = 1;
			function R$2(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) n$1[r$2] = e$1.call(this, t$1[r$2], r$2, t$1);
				return n$1;
			}
			function U$1(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) e$1.call(this, t$1[r$2], r$2, t$1) && (n$1[r$2] = t$1[r$2]);
				return n$1;
			}
			function j$1(t$1) {
				return Array.isArray(t$1) ? t$1.map(j$1) : "object" == typeof t$1 && t$1 ? R$2(t$1, j$1) : t$1;
			}
			const N = {};
			function q$1(t$1) {
				N[t$1] || ("undefined" != typeof console && console.warn(t$1), N[t$1] = !0);
			}
			function G$1(t$1, e$1, r$1) {
				return (r$1.y - t$1.y) * (e$1.x - t$1.x) > (e$1.y - t$1.y) * (r$1.x - t$1.x);
			}
			function X$1(t$1) {
				return "undefined" != typeof WorkerGlobalScope && void 0 !== t$1 && t$1 instanceof WorkerGlobalScope;
			}
			let Z$1 = null;
			function Y$1(t$1) {
				return "undefined" != typeof ImageBitmap && t$1 instanceof ImageBitmap;
			}
			const H$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			function K$1(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
					const e$1 = new VideoFrame(t$1, { timestamp: 0 });
					try {
						const a = null == e$1 ? void 0 : e$1.format;
						if (!a || !a.startsWith("BGR") && !a.startsWith("RGB")) throw new Error(`Unrecognized format ${a}`);
						const o$1 = a.startsWith("BGR"), l$1 = new Uint8ClampedArray(i$1 * s$1 * 4);
						if (yield e$1.copyTo(l$1, function(t$2, e$2, r$2, n$2, i$2) {
							const s$2 = 4 * Math.max(-e$2, 0), a$1 = (Math.max(0, r$2) - r$2) * n$2 * 4 + s$2, o$2 = 4 * n$2, l$2 = Math.max(0, e$2), u$1 = Math.max(0, r$2);
							return {
								rect: {
									x: l$2,
									y: u$1,
									width: Math.min(t$2.width, e$2 + n$2) - l$2,
									height: Math.min(t$2.height, r$2 + i$2) - u$1
								},
								layout: [{
									offset: a$1,
									stride: o$2
								}]
							};
						}(t$1, r$1, n$1, i$1, s$1)), o$1) for (let t$2 = 0; t$2 < l$1.length; t$2 += 4) {
							const e$2 = l$1[t$2];
							l$1[t$2] = l$1[t$2 + 2], l$1[t$2 + 2] = e$2;
						}
						return l$1;
					} finally {
						e$1.close();
					}
				}));
			}
			let J$1, W$1;
			function Q$1(t$1, e$1, r$1, n$1) {
				return t$1.addEventListener(e$1, r$1, n$1), { unsubscribe: () => {
					t$1.removeEventListener(e$1, r$1, n$1);
				} };
			}
			function tt$1(t$1) {
				return t$1 * Math.PI / 180;
			}
			function et$1(t$1) {
				return t$1 / Math.PI * 180;
			}
			const rt$1 = {
				touchstart: !0,
				touchmove: !0,
				touchmoveWindow: !0,
				touchend: !0,
				touchcancel: !0
			}, nt$1 = {
				dblclick: !0,
				click: !0,
				mouseover: !0,
				mouseout: !0,
				mousedown: !0,
				mousemove: !0,
				mousemoveWindow: !0,
				mouseup: !0,
				mouseupWindow: !0,
				contextmenu: !0,
				wheel: !0
			}, it$1 = "AbortError";
			function st$1() {
				return new Error(it$1);
			}
			const at$2 = {
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
				MAX_TILE_CACHE_ZOOM_LEVELS: 5,
				REGISTERED_PROTOCOLS: {},
				WORKER_URL: ""
			};
			function ot$1(t$1) {
				return at$2.REGISTERED_PROTOCOLS[t$1.substring(0, t$1.indexOf("://"))];
			}
			const lt$1 = "global-dispatcher";
			class ut$1 extends Error {
				constructor(t$1, e$1, r$1, n$1) {
					super(`AJAXError: ${e$1} (${t$1}): ${r$1}`), this.status = t$1, this.statusText = e$1, this.url = r$1, this.body = n$1;
				}
			}
			const ct = () => X$1(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, ht = function(t$1, r$1) {
				if (/:\/\//.test(t$1.url) && !/^https?:|^file:/.test(t$1.url)) {
					const e$1 = ot$1(t$1.url);
					if (e$1) return e$1(t$1, r$1);
					if (X$1(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						targetMapId: lt$1
					}, r$1);
				}
				if (!(/^file:/.test(n$1 = t$1.url) || /^file:/.test(ct()) && !/^\w+:/.test(n$1))) {
					if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t$2, r$2) {
						return e(this, void 0, void 0, (function* () {
							const e$1 = new Request(t$2.url, {
								method: t$2.method || "GET",
								body: t$2.body,
								credentials: t$2.credentials,
								headers: t$2.headers,
								cache: t$2.cache,
								referrer: ct(),
								signal: r$2.signal
							});
							let n$2, i$1;
							"json" !== t$2.type || e$1.headers.has("Accept") || e$1.headers.set("Accept", "application/json");
							try {
								n$2 = yield fetch(e$1);
							} catch (e$2) {
								throw new ut$1(0, e$2.message, t$2.url, new Blob());
							}
							if (!n$2.ok) {
								const e$2 = yield n$2.blob();
								throw new ut$1(n$2.status, n$2.statusText, t$2.url, e$2);
							}
							i$1 = "arrayBuffer" === t$2.type || "image" === t$2.type ? n$2.arrayBuffer() : "json" === t$2.type ? n$2.json() : n$2.text();
							const s$1 = yield i$1;
							if (r$2.signal.aborted) throw st$1();
							return {
								data: s$1,
								cacheControl: n$2.headers.get("Cache-Control"),
								expires: n$2.headers.get("Expires")
							};
						}));
					}(t$1, r$1);
					if (X$1(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						mustQueue: !0,
						targetMapId: lt$1
					}, r$1);
				}
				var n$1;
				return function(t$2, e$1) {
					return new Promise(((r$2, n$2) => {
						var i$1;
						const s$1 = new XMLHttpRequest();
						s$1.open(t$2.method || "GET", t$2.url, !0), "arrayBuffer" !== t$2.type && "image" !== t$2.type || (s$1.responseType = "arraybuffer");
						for (const e$2 in t$2.headers) s$1.setRequestHeader(e$2, t$2.headers[e$2]);
						"json" === t$2.type && (s$1.responseType = "text", !(null === (i$1 = t$2.headers) || void 0 === i$1) && i$1.Accept || s$1.setRequestHeader("Accept", "application/json")), s$1.withCredentials = "include" === t$2.credentials, s$1.onerror = () => {
							n$2(new Error(s$1.statusText));
						}, s$1.onload = () => {
							if (!e$1.signal.aborted) if ((s$1.status >= 200 && s$1.status < 300 || 0 === s$1.status) && null !== s$1.response) {
								let e$2 = s$1.response;
								if ("json" === t$2.type) try {
									e$2 = JSON.parse(s$1.response);
								} catch (t$3) {
									n$2(t$3);
									return;
								}
								r$2({
									data: e$2,
									cacheControl: s$1.getResponseHeader("Cache-Control"),
									expires: s$1.getResponseHeader("Expires")
								});
							} else {
								const e$2 = new Blob([s$1.response], { type: s$1.getResponseHeader("Content-Type") });
								n$2(new ut$1(s$1.status, s$1.statusText, t$2.url, e$2));
							}
						}, e$1.signal.addEventListener("abort", (() => {
							s$1.abort(), n$2(st$1());
						})), s$1.send(t$2.body);
					}));
				}(t$1, r$1);
			};
			function pt$1(t$1) {
				if (!t$1 || t$1.indexOf("://") <= 0 || 0 === t$1.indexOf("data:image/") || 0 === t$1.indexOf("blob:")) return !0;
				const e$1 = new URL(t$1), r$1 = window.location;
				return e$1.protocol === r$1.protocol && e$1.host === r$1.host;
			}
			function ft$1(t$1, e$1, r$1) {
				r$1[t$1] && -1 !== r$1[t$1].indexOf(e$1) || (r$1[t$1] = r$1[t$1] || [], r$1[t$1].push(e$1));
			}
			function dt$1(t$1, e$1, r$1) {
				if (r$1 && r$1[t$1]) {
					const n$1 = r$1[t$1].indexOf(e$1);
					-1 !== n$1 && r$1[t$1].splice(n$1, 1);
				}
			}
			class yt$1 {
				constructor(t$1, e$1 = {}) {
					O$1(this, e$1), this.type = t$1;
				}
			}
			class mt$1 extends yt$1 {
				constructor(t$1, e$1 = {}) {
					super("error", O$1({ error: t$1 }, e$1));
				}
			}
			class gt$1 {
				on(t$1, e$1) {
					return this._listeners = this._listeners || {}, ft$1(t$1, e$1, this._listeners), { unsubscribe: () => {
						this.off(t$1, e$1);
					} };
				}
				off(t$1, e$1) {
					return dt$1(t$1, e$1, this._listeners), dt$1(t$1, e$1, this._oneTimeListeners), this;
				}
				once(t$1, e$1) {
					return e$1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, ft$1(t$1, e$1, this._oneTimeListeners), this) : new Promise(((e$2) => this.once(t$1, e$2)));
				}
				fire(t$1, e$1) {
					"string" == typeof t$1 && (t$1 = new yt$1(t$1, e$1 || {}));
					const r$1 = t$1.type;
					if (this.listens(r$1)) {
						t$1.target = this;
						const e$2 = this._listeners && this._listeners[r$1] ? this._listeners[r$1].slice() : [];
						for (const r$2 of e$2) r$2.call(this, t$1);
						const n$1 = this._oneTimeListeners && this._oneTimeListeners[r$1] ? this._oneTimeListeners[r$1].slice() : [];
						for (const e$3 of n$1) dt$1(r$1, e$3, this._oneTimeListeners), e$3.call(this, t$1);
						const i$1 = this._eventedParent;
						i$1 && (O$1(t$1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i$1.fire(t$1));
					} else t$1 instanceof mt$1 && console.error(t$1.error);
					return this;
				}
				listens(t$1) {
					return this._listeners && this._listeners[t$1] && this._listeners[t$1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t$1] && this._oneTimeListeners[t$1].length > 0 || this._eventedParent && this._eventedParent.listens(t$1);
				}
				setEventedParent(t$1, e$1) {
					return this._eventedParent = t$1, this._eventedParentData = e$1, this;
				}
			}
			var xt$1 = {
				$version: 8,
				$root: {
					version: {
						required: !0,
						type: "enum",
						values: [8]
					},
					name: { type: "string" },
					metadata: { type: "*" },
					center: {
						type: "array",
						value: "number"
					},
					centerAltitude: { type: "number" },
					zoom: { type: "number" },
					bearing: {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees"
					},
					pitch: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					roll: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					state: {
						type: "state",
						default: {}
					},
					light: { type: "light" },
					sky: { type: "sky" },
					projection: { type: "projection" },
					terrain: { type: "terrain" },
					sources: {
						required: !0,
						type: "sources"
					},
					sprite: { type: "sprite" },
					glyphs: { type: "string" },
					transition: { type: "transition" },
					layers: {
						required: !0,
						type: "array",
						value: "layer"
					}
				},
				sources: { "*": { type: "source" } },
				source: [
					"source_vector",
					"source_raster",
					"source_raster_dem",
					"source_geojson",
					"source_video",
					"source_image"
				],
				source_vector: {
					type: {
						required: !0,
						type: "enum",
						values: { vector: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					attribution: { type: "string" },
					promoteId: { type: "promoteId" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster: {
					type: {
						required: !0,
						type: "enum",
						values: { raster: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					attribution: { type: "string" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster_dem: {
					type: {
						required: !0,
						type: "enum",
						values: { "raster-dem": {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					attribution: { type: "string" },
					encoding: {
						type: "enum",
						values: {
							terrarium: {},
							mapbox: {},
							custom: {}
						},
						default: "mapbox"
					},
					redFactor: {
						type: "number",
						default: 1
					},
					blueFactor: {
						type: "number",
						default: 1
					},
					greenFactor: {
						type: "number",
						default: 1
					},
					baseShift: {
						type: "number",
						default: 0
					},
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_geojson: {
					type: {
						required: !0,
						type: "enum",
						values: { geojson: {} }
					},
					data: {
						required: !0,
						type: "*"
					},
					maxzoom: {
						type: "number",
						default: 18
					},
					attribution: { type: "string" },
					buffer: {
						type: "number",
						default: 128,
						maximum: 512,
						minimum: 0
					},
					filter: { type: "*" },
					tolerance: {
						type: "number",
						default: .375
					},
					cluster: {
						type: "boolean",
						default: !1
					},
					clusterRadius: {
						type: "number",
						default: 50,
						minimum: 0
					},
					clusterMaxZoom: { type: "number" },
					clusterMinPoints: { type: "number" },
					clusterProperties: { type: "*" },
					lineMetrics: {
						type: "boolean",
						default: !1
					},
					generateId: {
						type: "boolean",
						default: !1
					},
					promoteId: { type: "promoteId" }
				},
				source_video: {
					type: {
						required: !0,
						type: "enum",
						values: { video: {} }
					},
					urls: {
						required: !0,
						type: "array",
						value: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				source_image: {
					type: {
						required: !0,
						type: "enum",
						values: { image: {} }
					},
					url: {
						required: !0,
						type: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				layer: {
					id: {
						type: "string",
						required: !0
					},
					type: {
						type: "enum",
						values: {
							fill: {},
							line: {},
							symbol: {},
							circle: {},
							heatmap: {},
							"fill-extrusion": {},
							raster: {},
							hillshade: {},
							"color-relief": {},
							background: {}
						},
						required: !0
					},
					metadata: { type: "*" },
					source: { type: "string" },
					"source-layer": { type: "string" },
					minzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					maxzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					filter: { type: "filter" },
					layout: { type: "layout" },
					paint: { type: "paint" }
				},
				layout: [
					"layout_fill",
					"layout_line",
					"layout_circle",
					"layout_heatmap",
					"layout_fill-extrusion",
					"layout_symbol",
					"layout_raster",
					"layout_hillshade",
					"layout_color-relief",
					"layout_background"
				],
				layout_background: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_fill: {
					"fill-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_circle: {
					"circle-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_heatmap: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_fill-extrusion": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_line: {
					"line-cap": {
						type: "enum",
						values: {
							butt: {},
							round: {},
							square: {}
						},
						default: "butt",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-join": {
						type: "enum",
						values: {
							bevel: {},
							round: {},
							miter: {}
						},
						default: "miter",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"line-miter-limit": {
						type: "number",
						default: 2,
						requires: [{ "line-join": "miter" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-round-limit": {
						type: "number",
						default: 1.05,
						requires: [{ "line-join": "round" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_symbol: {
					"symbol-placement": {
						type: "enum",
						values: {
							point: {},
							line: {},
							"line-center": {}
						},
						default: "point",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-spacing": {
						type: "number",
						default: 250,
						minimum: 1,
						units: "pixels",
						requires: [{ "symbol-placement": "line" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-avoid-edges": {
						type: "boolean",
						default: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"symbol-z-order": {
						type: "enum",
						values: {
							auto: {},
							"viewport-y": {},
							source: {}
						},
						default: "auto",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", { "!": "icon-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-optional": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-size": {
						type: "number",
						default: 1,
						minimum: 0,
						units: "factor of the original icon size",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-text-fit": {
						type: "enum",
						values: {
							none: {},
							width: {},
							height: {},
							both: {}
						},
						default: "none",
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-text-fit-padding": {
						type: "array",
						value: "number",
						length: 4,
						default: [
							0,
							0,
							0,
							0
						],
						units: "pixels",
						requires: [
							"icon-image",
							"text-field",
							{ "icon-text-fit": [
								"both",
								"width",
								"height"
							] }
						],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-image": {
						type: "resolvedImage",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-padding": {
						type: "padding",
						default: [2],
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-keep-upright": {
						type: "boolean",
						default: !1,
						requires: [
							"icon-image",
							{ "icon-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-offset": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							"viewport-glyph": {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-field": {
						type: "formatted",
						default: "",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-font": {
						type: "array",
						value: "string",
						default: ["Open Sans Regular", "Arial Unicode MS Regular"],
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-size": {
						type: "number",
						default: 16,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-width": {
						type: "number",
						default: 10,
						minimum: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-line-height": {
						type: "number",
						default: 1.2,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-letter-spacing": {
						type: "number",
						default: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-justify": {
						type: "enum",
						values: {
							auto: {},
							left: {},
							center: {},
							right: {}
						},
						default: "center",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-radial-offset": {
						type: "number",
						units: "ems",
						default: 0,
						requires: ["text-field"],
						"property-type": "data-driven",
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						}
					},
					"text-variable-anchor": {
						type: "array",
						value: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-variable-anchor-offset": {
						type: "variableAnchorOffsetCollection",
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["text-field", { "!": "text-variable-anchor" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-angle": {
						type: "number",
						default: 45,
						units: "degrees",
						requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-writing-mode": {
						type: "array",
						value: "enum",
						values: {
							horizontal: {},
							vertical: {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-padding": {
						type: "number",
						default: 2,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-keep-upright": {
						type: "boolean",
						default: !0,
						requires: [
							"text-field",
							{ "text-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-transform": {
						type: "enum",
						values: {
							none: {},
							uppercase: {},
							lowercase: {}
						},
						default: "none",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-offset": {
						type: "array",
						value: "number",
						units: "ems",
						length: 2,
						default: [0, 0],
						requires: ["text-field", { "!": "text-radial-offset" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["text-field", { "!": "text-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-optional": {
						type: "boolean",
						default: !1,
						requires: ["text-field", "icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_raster: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_hillshade: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_color-relief": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				filter: {
					type: "array",
					value: "*"
				},
				filter_operator: {
					type: "enum",
					values: {
						"==": {},
						"!=": {},
						">": {},
						">=": {},
						"<": {},
						"<=": {},
						in: {},
						"!in": {},
						all: {},
						any: {},
						none: {},
						has: {},
						"!has": {}
					}
				},
				geometry_type: {
					type: "enum",
					values: {
						Point: {},
						LineString: {},
						Polygon: {}
					}
				},
				function: {
					expression: { type: "expression" },
					stops: {
						type: "array",
						value: "function_stop"
					},
					base: {
						type: "number",
						default: 1,
						minimum: 0
					},
					property: {
						type: "string",
						default: "$zoom"
					},
					type: {
						type: "enum",
						values: {
							identity: {},
							exponential: {},
							interval: {},
							categorical: {}
						},
						default: "exponential"
					},
					colorSpace: {
						type: "enum",
						values: {
							rgb: {},
							lab: {},
							hcl: {}
						},
						default: "rgb"
					},
					default: {
						type: "*",
						required: !1
					}
				},
				function_stop: {
					type: "array",
					minimum: 0,
					maximum: 24,
					value: ["number", "color"],
					length: 2
				},
				expression: {
					type: "array",
					value: "*",
					minimum: 1
				},
				light: {
					anchor: {
						type: "enum",
						default: "viewport",
						values: {
							map: {},
							viewport: {}
						},
						"property-type": "data-constant",
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						}
					},
					position: {
						type: "array",
						default: [
							1.15,
							210,
							30
						],
						length: 3,
						value: "number",
						"property-type": "data-constant",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						}
					},
					color: {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					intensity: {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				sky: {
					"sky-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#88C6FC",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-ground-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-fog-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"sky-horizon-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"atmosphere-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				terrain: {
					source: {
						type: "string",
						required: !0
					},
					exaggeration: {
						type: "number",
						minimum: 0,
						default: 1
					}
				},
				projection: { type: {
					type: "projectionDefinition",
					default: "mercator",
					"property-type": "data-constant",
					transition: !1,
					expression: {
						interpolated: !0,
						parameters: ["zoom"]
					}
				} },
				paint: [
					"paint_fill",
					"paint_line",
					"paint_circle",
					"paint_heatmap",
					"paint_fill-extrusion",
					"paint_symbol",
					"paint_raster",
					"paint_hillshade",
					"paint_color-relief",
					"paint_background"
				],
				paint_fill: {
					"fill-antialias": {
						type: "boolean",
						default: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-outline-color": {
						type: "color",
						transition: !0,
						requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					}
				},
				"paint_fill-extrusion": {
					"fill-extrusion-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-extrusion-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-extrusion-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"fill-extrusion-height": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-base": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						requires: ["fill-extrusion-height"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-vertical-gradient": {
						type: "boolean",
						default: !0,
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_line: {
					"line-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["line-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-width": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-gap-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-offset": {
						type: "number",
						default: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-dasharray": {
						type: "array",
						value: "number",
						minimum: 0,
						transition: !0,
						units: "line widths",
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"line-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-gradient": {
						type: "color",
						transition: !1,
						requires: [
							{ "!": "line-dasharray" },
							{ "!": "line-pattern" },
							{
								source: "geojson",
								has: { lineMetrics: !0 }
							}
						],
						expression: {
							interpolated: !0,
							parameters: ["line-progress"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_circle: {
					"circle-radius": {
						type: "number",
						default: 5,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-blur": {
						type: "number",
						default: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["circle-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-scale": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-stroke-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					}
				},
				paint_heatmap: {
					"heatmap-radius": {
						type: "number",
						default: 30,
						minimum: 1,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-weight": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-intensity": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"heatmap-color": {
						type: "color",
						default: [
							"interpolate",
							["linear"],
							["heatmap-density"],
							0,
							"rgba(0, 0, 255, 0)",
							.1,
							"royalblue",
							.3,
							"cyan",
							.5,
							"lime",
							.7,
							"yellow",
							1,
							"red"
						],
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["heatmap-density"]
						},
						"property-type": "color-ramp"
					},
					"heatmap-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_symbol: {
					"icon-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["icon-image", "icon-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						overridable: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["text-field", "text-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_raster: {
					"raster-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-hue-rotate": {
						type: "number",
						default: 0,
						period: 360,
						transition: !0,
						units: "degrees",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-min": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-max": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-saturation": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-contrast": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-resampling": {
						type: "enum",
						values: {
							linear: {},
							nearest: {}
						},
						default: "linear",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-fade-duration": {
						type: "number",
						default: 300,
						minimum: 0,
						transition: !1,
						units: "milliseconds",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_hillshade: {
					"hillshade-illumination-direction": {
						type: "numberArray",
						default: 335,
						minimum: 0,
						maximum: 359,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-altitude": {
						type: "numberArray",
						default: 45,
						minimum: 0,
						maximum: 90,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-exaggeration": {
						type: "number",
						default: .5,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-shadow-color": {
						type: "colorArray",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-highlight-color": {
						type: "colorArray",
						default: "#FFFFFF",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-accent-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-method": {
						type: "enum",
						values: {
							standard: {},
							basic: {},
							combined: {},
							igor: {},
							multidirectional: {}
						},
						default: "standard",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				"paint_color-relief": {
					"color-relief-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"color-relief-color": {
						type: "color",
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["elevation"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_background: {
					"background-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "background-pattern" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"background-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"background-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				transition: {
					duration: {
						type: "number",
						default: 300,
						minimum: 0,
						units: "milliseconds"
					},
					delay: {
						type: "number",
						default: 0,
						minimum: 0,
						units: "milliseconds"
					}
				},
				"property-type": {
					"data-driven": { type: "property-type" },
					"cross-faded": { type: "property-type" },
					"cross-faded-data-driven": { type: "property-type" },
					"color-ramp": { type: "property-type" },
					"data-constant": { type: "property-type" },
					constant: { type: "property-type" }
				},
				promoteId: { "*": { type: "string" } }
			};
			const vt$1 = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			];
			function bt$1(t$1, e$1) {
				const r$1 = {};
				for (const e$2 in t$1) "ref" !== e$2 && (r$1[e$2] = t$1[e$2]);
				return vt$1.forEach(((t$2) => {
					t$2 in e$1 && (r$1[t$2] = e$1[t$2]);
				})), r$1;
			}
			function wt$1(t$1, e$1) {
				if (Array.isArray(t$1)) {
					if (!Array.isArray(e$1) || t$1.length !== e$1.length) return !1;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) if (!wt$1(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				if ("object" == typeof t$1 && null !== t$1 && null !== e$1) {
					if ("object" != typeof e$1) return !1;
					if (Object.keys(t$1).length !== Object.keys(e$1).length) return !1;
					for (const r$1 in t$1) if (!wt$1(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				return t$1 === e$1;
			}
			function _t$1(t$1, e$1) {
				t$1.push(e$1);
			}
			function St$1(t$1, e$1, r$1) {
				_t$1(r$1, {
					command: "addSource",
					args: [t$1, e$1[t$1]]
				});
			}
			function At$1(t$1, e$1, r$1) {
				_t$1(e$1, {
					command: "removeSource",
					args: [t$1]
				}), r$1[t$1] = !0;
			}
			function kt$1(t$1, e$1, r$1, n$1) {
				At$1(t$1, r$1, n$1), St$1(t$1, e$1, r$1);
			}
			function Mt$1(t$1, e$1, r$1) {
				let n$1;
				for (n$1 in t$1[r$1]) if (Object.prototype.hasOwnProperty.call(t$1[r$1], n$1) && "data" !== n$1 && !wt$1(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				for (n$1 in e$1[r$1]) if (Object.prototype.hasOwnProperty.call(e$1[r$1], n$1) && "data" !== n$1 && !wt$1(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				return !0;
			}
			function It$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				t$1 = t$1 || {}, e$1 = e$1 || {};
				for (const a in t$1) Object.prototype.hasOwnProperty.call(t$1, a) && (wt$1(t$1[a], e$1[a]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a,
						e$1[a],
						i$1
					]
				}));
				for (const a in e$1) Object.prototype.hasOwnProperty.call(e$1, a) && !Object.prototype.hasOwnProperty.call(t$1, a) && (wt$1(t$1[a], e$1[a]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a,
						e$1[a],
						i$1
					]
				}));
			}
			function zt(t$1) {
				return t$1.id;
			}
			function Pt$1(t$1, e$1) {
				return t$1[e$1.id] = e$1, t$1;
			}
			class Ct$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.message = (t$1 ? `${t$1}: ` : "") + r$1, n$1 && (this.identifier = n$1), null != e$1 && e$1.__line__ && (this.line = e$1.__line__);
				}
			}
			function Et$1(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			class Bt$1 extends Error {
				constructor(t$1, e$1) {
					super(e$1), this.message = e$1, this.key = t$1;
				}
			}
			class Vt$1 {
				constructor(t$1, e$1 = []) {
					this.parent = t$1, this.bindings = {};
					for (const [t$2, r$1] of e$1) this.bindings[t$2] = r$1;
				}
				concat(t$1) {
					return new Vt$1(this, t$1);
				}
				get(t$1) {
					if (this.bindings[t$1]) return this.bindings[t$1];
					if (this.parent) return this.parent.get(t$1);
					throw new Error(`${t$1} not found in scope.`);
				}
				has(t$1) {
					return !!this.bindings[t$1] || !!this.parent && this.parent.has(t$1);
				}
			}
			const Tt$1 = { kind: "null" }, Ft = { kind: "number" }, $t = { kind: "string" }, Lt$1 = { kind: "boolean" }, Ot = { kind: "color" }, Dt = { kind: "projectionDefinition" }, Rt$1 = { kind: "object" }, Ut$1 = { kind: "value" }, jt = { kind: "collator" }, Nt = { kind: "formatted" }, qt$1 = { kind: "padding" }, Gt$1 = { kind: "colorArray" }, Xt$1 = { kind: "numberArray" }, Zt$1 = { kind: "resolvedImage" }, Yt$1 = { kind: "variableAnchorOffsetCollection" };
			function Ht$1(t$1, e$1) {
				return {
					kind: "array",
					itemType: t$1,
					N: e$1
				};
			}
			function Kt$1(t$1) {
				if ("array" === t$1.kind) {
					const e$1 = Kt$1(t$1.itemType);
					return "number" == typeof t$1.N ? `array<${e$1}, ${t$1.N}>` : "value" === t$1.itemType.kind ? "array" : `array<${e$1}>`;
				}
				return t$1.kind;
			}
			const Jt$1 = [
				Tt$1,
				Ft,
				$t,
				Lt$1,
				Ot,
				Dt,
				Nt,
				Rt$1,
				Ht$1(Ut$1),
				qt$1,
				Xt$1,
				Gt$1,
				Zt$1,
				Yt$1
			];
			function Wt$1(t$1, e$1) {
				if ("error" === e$1.kind) return null;
				if ("array" === t$1.kind) {
					if ("array" === e$1.kind && (0 === e$1.N && "value" === e$1.itemType.kind || !Wt$1(t$1.itemType, e$1.itemType)) && ("number" != typeof t$1.N || t$1.N === e$1.N)) return null;
				} else {
					if (t$1.kind === e$1.kind) return null;
					if ("value" === t$1.kind) {
						for (const t$2 of Jt$1) if (!Wt$1(t$2, e$1)) return null;
					}
				}
				return `Expected ${Kt$1(t$1)} but found ${Kt$1(e$1)} instead.`;
			}
			function Qt$1(t$1, e$1) {
				return e$1.some(((e$2) => e$2.kind === t$1.kind));
			}
			function te$1(t$1, e$1) {
				return e$1.some(((e$2) => "null" === e$2 ? null === t$1 : "array" === e$2 ? Array.isArray(t$1) : "object" === e$2 ? t$1 && !Array.isArray(t$1) && "object" == typeof t$1 : e$2 === typeof t$1));
			}
			function ee(t$1, e$1) {
				return "array" === t$1.kind && "array" === e$1.kind ? t$1.itemType.kind === e$1.itemType.kind && "number" == typeof t$1.N : t$1.kind === e$1.kind;
			}
			const re$1 = .96422, ne$1 = .82521, ie$1 = 4 / 29, se$1 = 6 / 29, ae$1 = 3 * se$1 * se$1, oe$1 = se$1 * se$1 * se$1, le$1 = Math.PI / 180, ue$1 = 180 / Math.PI;
			function ce$1(t$1) {
				return (t$1 %= 360) < 0 && (t$1 += 360), t$1;
			}
			function he$1([t$1, e$1, r$1, n$1]) {
				let i$1, s$1;
				const a = fe$1((.2225045 * (t$1 = pe$1(t$1)) + .7168786 * (e$1 = pe$1(e$1)) + .0606169 * (r$1 = pe$1(r$1))) / 1);
				t$1 === e$1 && e$1 === r$1 ? i$1 = s$1 = a : (i$1 = fe$1((.4360747 * t$1 + .3850649 * e$1 + .1430804 * r$1) / re$1), s$1 = fe$1((.0139322 * t$1 + .0971045 * e$1 + .7141733 * r$1) / ne$1));
				const o$1 = 116 * a - 16;
				return [
					o$1 < 0 ? 0 : o$1,
					500 * (i$1 - a),
					200 * (a - s$1),
					n$1
				];
			}
			function pe$1(t$1) {
				return t$1 <= .04045 ? t$1 / 12.92 : Math.pow((t$1 + .055) / 1.055, 2.4);
			}
			function fe$1(t$1) {
				return t$1 > oe$1 ? Math.pow(t$1, 1 / 3) : t$1 / ae$1 + ie$1;
			}
			function de$1([t$1, e$1, r$1, n$1]) {
				let i$1 = (t$1 + 16) / 116, s$1 = isNaN(e$1) ? i$1 : i$1 + e$1 / 500, a = isNaN(r$1) ? i$1 : i$1 - r$1 / 200;
				return i$1 = 1 * me$1(i$1), s$1 = re$1 * me$1(s$1), a = ne$1 * me$1(a), [
					ye$1(3.1338561 * s$1 - 1.6168667 * i$1 - .4906146 * a),
					ye$1(-.9787684 * s$1 + 1.9161415 * i$1 + .033454 * a),
					ye$1(.0719453 * s$1 - .2289914 * i$1 + 1.4052427 * a),
					n$1
				];
			}
			function ye$1(t$1) {
				return (t$1 = t$1 <= .00304 ? 12.92 * t$1 : 1.055 * Math.pow(t$1, 1 / 2.4) - .055) < 0 ? 0 : t$1 > 1 ? 1 : t$1;
			}
			function me$1(t$1) {
				return t$1 > se$1 ? t$1 * t$1 * t$1 : ae$1 * (t$1 - ie$1);
			}
			const ge$1 = Object.hasOwn || function(t$1, e$1) {
				return Object.prototype.hasOwnProperty.call(t$1, e$1);
			};
			function xe$1(t$1, e$1) {
				return ge$1(t$1, e$1) ? t$1[e$1] : void 0;
			}
			function ve$1(t$1) {
				return parseInt(t$1.padEnd(2, t$1), 16) / 255;
			}
			function be(t$1, e$1) {
				return we$1(e$1 ? t$1 / 100 : t$1, 0, 1);
			}
			function we$1(t$1, e$1, r$1) {
				return Math.min(Math.max(e$1, t$1), r$1);
			}
			function _e$1(t$1) {
				return !t$1.some(Number.isNaN);
			}
			const Se$1 = {
				aliceblue: [
					240,
					248,
					255
				],
				antiquewhite: [
					250,
					235,
					215
				],
				aqua: [
					0,
					255,
					255
				],
				aquamarine: [
					127,
					255,
					212
				],
				azure: [
					240,
					255,
					255
				],
				beige: [
					245,
					245,
					220
				],
				bisque: [
					255,
					228,
					196
				],
				black: [
					0,
					0,
					0
				],
				blanchedalmond: [
					255,
					235,
					205
				],
				blue: [
					0,
					0,
					255
				],
				blueviolet: [
					138,
					43,
					226
				],
				brown: [
					165,
					42,
					42
				],
				burlywood: [
					222,
					184,
					135
				],
				cadetblue: [
					95,
					158,
					160
				],
				chartreuse: [
					127,
					255,
					0
				],
				chocolate: [
					210,
					105,
					30
				],
				coral: [
					255,
					127,
					80
				],
				cornflowerblue: [
					100,
					149,
					237
				],
				cornsilk: [
					255,
					248,
					220
				],
				crimson: [
					220,
					20,
					60
				],
				cyan: [
					0,
					255,
					255
				],
				darkblue: [
					0,
					0,
					139
				],
				darkcyan: [
					0,
					139,
					139
				],
				darkgoldenrod: [
					184,
					134,
					11
				],
				darkgray: [
					169,
					169,
					169
				],
				darkgreen: [
					0,
					100,
					0
				],
				darkgrey: [
					169,
					169,
					169
				],
				darkkhaki: [
					189,
					183,
					107
				],
				darkmagenta: [
					139,
					0,
					139
				],
				darkolivegreen: [
					85,
					107,
					47
				],
				darkorange: [
					255,
					140,
					0
				],
				darkorchid: [
					153,
					50,
					204
				],
				darkred: [
					139,
					0,
					0
				],
				darksalmon: [
					233,
					150,
					122
				],
				darkseagreen: [
					143,
					188,
					143
				],
				darkslateblue: [
					72,
					61,
					139
				],
				darkslategray: [
					47,
					79,
					79
				],
				darkslategrey: [
					47,
					79,
					79
				],
				darkturquoise: [
					0,
					206,
					209
				],
				darkviolet: [
					148,
					0,
					211
				],
				deeppink: [
					255,
					20,
					147
				],
				deepskyblue: [
					0,
					191,
					255
				],
				dimgray: [
					105,
					105,
					105
				],
				dimgrey: [
					105,
					105,
					105
				],
				dodgerblue: [
					30,
					144,
					255
				],
				firebrick: [
					178,
					34,
					34
				],
				floralwhite: [
					255,
					250,
					240
				],
				forestgreen: [
					34,
					139,
					34
				],
				fuchsia: [
					255,
					0,
					255
				],
				gainsboro: [
					220,
					220,
					220
				],
				ghostwhite: [
					248,
					248,
					255
				],
				gold: [
					255,
					215,
					0
				],
				goldenrod: [
					218,
					165,
					32
				],
				gray: [
					128,
					128,
					128
				],
				green: [
					0,
					128,
					0
				],
				greenyellow: [
					173,
					255,
					47
				],
				grey: [
					128,
					128,
					128
				],
				honeydew: [
					240,
					255,
					240
				],
				hotpink: [
					255,
					105,
					180
				],
				indianred: [
					205,
					92,
					92
				],
				indigo: [
					75,
					0,
					130
				],
				ivory: [
					255,
					255,
					240
				],
				khaki: [
					240,
					230,
					140
				],
				lavender: [
					230,
					230,
					250
				],
				lavenderblush: [
					255,
					240,
					245
				],
				lawngreen: [
					124,
					252,
					0
				],
				lemonchiffon: [
					255,
					250,
					205
				],
				lightblue: [
					173,
					216,
					230
				],
				lightcoral: [
					240,
					128,
					128
				],
				lightcyan: [
					224,
					255,
					255
				],
				lightgoldenrodyellow: [
					250,
					250,
					210
				],
				lightgray: [
					211,
					211,
					211
				],
				lightgreen: [
					144,
					238,
					144
				],
				lightgrey: [
					211,
					211,
					211
				],
				lightpink: [
					255,
					182,
					193
				],
				lightsalmon: [
					255,
					160,
					122
				],
				lightseagreen: [
					32,
					178,
					170
				],
				lightskyblue: [
					135,
					206,
					250
				],
				lightslategray: [
					119,
					136,
					153
				],
				lightslategrey: [
					119,
					136,
					153
				],
				lightsteelblue: [
					176,
					196,
					222
				],
				lightyellow: [
					255,
					255,
					224
				],
				lime: [
					0,
					255,
					0
				],
				limegreen: [
					50,
					205,
					50
				],
				linen: [
					250,
					240,
					230
				],
				magenta: [
					255,
					0,
					255
				],
				maroon: [
					128,
					0,
					0
				],
				mediumaquamarine: [
					102,
					205,
					170
				],
				mediumblue: [
					0,
					0,
					205
				],
				mediumorchid: [
					186,
					85,
					211
				],
				mediumpurple: [
					147,
					112,
					219
				],
				mediumseagreen: [
					60,
					179,
					113
				],
				mediumslateblue: [
					123,
					104,
					238
				],
				mediumspringgreen: [
					0,
					250,
					154
				],
				mediumturquoise: [
					72,
					209,
					204
				],
				mediumvioletred: [
					199,
					21,
					133
				],
				midnightblue: [
					25,
					25,
					112
				],
				mintcream: [
					245,
					255,
					250
				],
				mistyrose: [
					255,
					228,
					225
				],
				moccasin: [
					255,
					228,
					181
				],
				navajowhite: [
					255,
					222,
					173
				],
				navy: [
					0,
					0,
					128
				],
				oldlace: [
					253,
					245,
					230
				],
				olive: [
					128,
					128,
					0
				],
				olivedrab: [
					107,
					142,
					35
				],
				orange: [
					255,
					165,
					0
				],
				orangered: [
					255,
					69,
					0
				],
				orchid: [
					218,
					112,
					214
				],
				palegoldenrod: [
					238,
					232,
					170
				],
				palegreen: [
					152,
					251,
					152
				],
				paleturquoise: [
					175,
					238,
					238
				],
				palevioletred: [
					219,
					112,
					147
				],
				papayawhip: [
					255,
					239,
					213
				],
				peachpuff: [
					255,
					218,
					185
				],
				peru: [
					205,
					133,
					63
				],
				pink: [
					255,
					192,
					203
				],
				plum: [
					221,
					160,
					221
				],
				powderblue: [
					176,
					224,
					230
				],
				purple: [
					128,
					0,
					128
				],
				rebeccapurple: [
					102,
					51,
					153
				],
				red: [
					255,
					0,
					0
				],
				rosybrown: [
					188,
					143,
					143
				],
				royalblue: [
					65,
					105,
					225
				],
				saddlebrown: [
					139,
					69,
					19
				],
				salmon: [
					250,
					128,
					114
				],
				sandybrown: [
					244,
					164,
					96
				],
				seagreen: [
					46,
					139,
					87
				],
				seashell: [
					255,
					245,
					238
				],
				sienna: [
					160,
					82,
					45
				],
				silver: [
					192,
					192,
					192
				],
				skyblue: [
					135,
					206,
					235
				],
				slateblue: [
					106,
					90,
					205
				],
				slategray: [
					112,
					128,
					144
				],
				slategrey: [
					112,
					128,
					144
				],
				snow: [
					255,
					250,
					250
				],
				springgreen: [
					0,
					255,
					127
				],
				steelblue: [
					70,
					130,
					180
				],
				tan: [
					210,
					180,
					140
				],
				teal: [
					0,
					128,
					128
				],
				thistle: [
					216,
					191,
					216
				],
				tomato: [
					255,
					99,
					71
				],
				turquoise: [
					64,
					224,
					208
				],
				violet: [
					238,
					130,
					238
				],
				wheat: [
					245,
					222,
					179
				],
				white: [
					255,
					255,
					255
				],
				whitesmoke: [
					245,
					245,
					245
				],
				yellow: [
					255,
					255,
					0
				],
				yellowgreen: [
					154,
					205,
					50
				]
			};
			function Ae$1(t$1, e$1, r$1) {
				return t$1 + r$1 * (e$1 - t$1);
			}
			function ke$1(t$1, e$1, r$1) {
				return t$1.map(((t$2, n$1) => Ae$1(t$2, e$1[n$1], r$1)));
			}
			class Me$1 {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = !0) {
					this.r = t$1, this.g = e$1, this.b = r$1, this.a = n$1, i$1 || (this.r *= n$1, this.g *= n$1, this.b *= n$1, n$1 || this.overwriteGetter("rgb", [
						t$1,
						e$1,
						r$1,
						n$1
					]));
				}
				static parse(t$1) {
					if (t$1 instanceof Me$1) return t$1;
					if ("string" != typeof t$1) return;
					const e$1 = function(t$2) {
						if ("transparent" === (t$2 = t$2.toLowerCase().trim())) return [
							0,
							0,
							0,
							0
						];
						const e$2 = xe$1(Se$1, t$2);
						if (e$2) {
							const [t$3, r$2, n$1] = e$2;
							return [
								t$3 / 255,
								r$2 / 255,
								n$1 / 255,
								1
							];
						}
						if (t$2.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t$2)) {
							const e$3 = t$2.length < 6 ? 1 : 2;
							let r$2 = 1;
							return [
								ve$1(t$2.slice(r$2, r$2 += e$3)),
								ve$1(t$2.slice(r$2, r$2 += e$3)),
								ve$1(t$2.slice(r$2, r$2 += e$3)),
								ve$1(t$2.slice(r$2, r$2 + e$3) || "ff")
							];
						}
						if (t$2.startsWith("rgb")) {
							const e$3 = t$2.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
							if (e$3) {
								const [t$3, r$2, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1] = e$3, f$1 = [
									i$1 || " ",
									o$1 || " ",
									c$1
								].join("");
								if ("  " === f$1 || "  /" === f$1 || ",," === f$1 || ",,," === f$1) {
									const t$4 = [
										n$1,
										a,
										u$1
									].join(""), e$4 = "%%%" === t$4 ? 100 : "" === t$4 ? 255 : 0;
									if (e$4) {
										const t$5 = [
											we$1(+r$2 / e$4, 0, 1),
											we$1(+s$1 / e$4, 0, 1),
											we$1(+l$1 / e$4, 0, 1),
											h$1 ? be(+h$1, p$1) : 1
										];
										if (_e$1(t$5)) return t$5;
									}
								}
								return;
							}
						}
						const r$1 = t$2.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
						if (r$1) {
							const [t$3, e$3, n$1, i$1, s$1, a, o$1, l$1, u$1] = r$1, c$1 = [
								n$1 || " ",
								s$1 || " ",
								o$1
							].join("");
							if ("  " === c$1 || "  /" === c$1 || ",," === c$1 || ",,," === c$1) {
								const t$4 = [
									+e$3,
									we$1(+i$1, 0, 100),
									we$1(+a, 0, 100),
									l$1 ? be(+l$1, u$1) : 1
								];
								if (_e$1(t$4)) return function([t$5, e$4, r$2, n$2]) {
									function i$2(n$3) {
										const i$3 = (n$3 + t$5 / 30) % 12, s$2 = e$4 * Math.min(r$2, 1 - r$2);
										return r$2 - s$2 * Math.max(-1, Math.min(i$3 - 3, 9 - i$3, 1));
									}
									return t$5 = ce$1(t$5), e$4 /= 100, r$2 /= 100, [
										i$2(0),
										i$2(8),
										i$2(4),
										n$2
									];
								}(t$4);
							}
						}
					}(t$1);
					return e$1 ? new Me$1(...e$1, !1) : void 0;
				}
				get rgb() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this, i$1 = n$1 || Infinity;
					return this.overwriteGetter("rgb", [
						t$1 / i$1,
						e$1 / i$1,
						r$1 / i$1,
						n$1
					]);
				}
				get hcl() {
					return this.overwriteGetter("hcl", function(t$1) {
						const [e$1, r$1, n$1, i$1] = he$1(t$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
						return [
							Math.round(1e4 * s$1) ? ce$1(Math.atan2(n$1, r$1) * ue$1) : NaN,
							s$1,
							e$1,
							i$1
						];
					}(this.rgb));
				}
				get lab() {
					return this.overwriteGetter("lab", he$1(this.rgb));
				}
				overwriteGetter(t$1, e$1) {
					return Object.defineProperty(this, t$1, { value: e$1 }), e$1;
				}
				toString() {
					const [t$1, e$1, r$1, n$1] = this.rgb;
					return `rgba(${[
						t$1,
						e$1,
						r$1
					].map(((t$2) => Math.round(255 * t$2))).join(",")},${n$1})`;
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					switch (n$1) {
						case "rgb": {
							const [n$2, i$1, s$1, a] = ke$1(t$1.rgb, e$1.rgb, r$1);
							return new Me$1(n$2, i$1, s$1, a, !1);
						}
						case "hcl": {
							const [n$2, i$1, s$1, a] = t$1.hcl, [o$1, l$1, u$1, c$1] = e$1.hcl;
							let h$1, p$1;
							if (isNaN(n$2) || isNaN(o$1)) isNaN(n$2) ? isNaN(o$1) ? h$1 = NaN : (h$1 = o$1, 1 !== s$1 && 0 !== s$1 || (p$1 = l$1)) : (h$1 = n$2, 1 !== u$1 && 0 !== u$1 || (p$1 = i$1));
							else {
								let t$2 = o$1 - n$2;
								o$1 > n$2 && t$2 > 180 ? t$2 -= 360 : o$1 < n$2 && n$2 - o$1 > 180 && (t$2 += 360), h$1 = n$2 + r$1 * t$2;
							}
							const [f$1, d$1, y$1, m$1] = function([t$2, e$2, r$2, n$3]) {
								return t$2 = isNaN(t$2) ? 0 : t$2 * le$1, de$1([
									r$2,
									Math.cos(t$2) * e$2,
									Math.sin(t$2) * e$2,
									n$3
								]);
							}([
								h$1,
								null != p$1 ? p$1 : Ae$1(i$1, l$1, r$1),
								Ae$1(s$1, u$1, r$1),
								Ae$1(a, c$1, r$1)
							]);
							return new Me$1(f$1, d$1, y$1, m$1, !1);
						}
						case "lab": {
							const [n$2, i$1, s$1, a] = de$1(ke$1(t$1.lab, e$1.lab, r$1));
							return new Me$1(n$2, i$1, s$1, a, !1);
						}
					}
				}
			}
			Me$1.black = new Me$1(0, 0, 0, 1), Me$1.white = new Me$1(1, 1, 1, 1), Me$1.transparent = new Me$1(0, 0, 0, 0), Me$1.red = new Me$1(1, 0, 0, 1);
			class Ie$1 {
				constructor(t$1, e$1, r$1) {
					this.sensitivity = t$1 ? e$1 ? "variant" : "case" : e$1 ? "accent" : "base", this.locale = r$1, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(t$1, e$1) {
					return this.collator.compare(t$1, e$1);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			const ze$1 = [
				"bottom",
				"center",
				"top"
			];
			class Pe$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.text = t$1, this.image = e$1, this.scale = r$1, this.fontStack = n$1, this.textColor = i$1, this.verticalAlign = s$1;
				}
			}
			class Ce {
				constructor(t$1) {
					this.sections = t$1;
				}
				static fromString(t$1) {
					return new Ce([new Pe$1(t$1, null, null, null, null, null)]);
				}
				isEmpty() {
					return 0 === this.sections.length || !this.sections.some(((t$1) => 0 !== t$1.text.length || t$1.image && 0 !== t$1.image.name.length));
				}
				static factory(t$1) {
					return t$1 instanceof Ce ? t$1 : Ce.fromString(t$1);
				}
				toString() {
					return 0 === this.sections.length ? "" : this.sections.map(((t$1) => t$1.text)).join("");
				}
			}
			class Ee {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Ee) return t$1;
					if ("number" == typeof t$1) return new Ee([
						t$1,
						t$1,
						t$1,
						t$1
					]);
					if (Array.isArray(t$1) && !(t$1.length < 1 || t$1.length > 4)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						switch (t$1.length) {
							case 1:
								t$1 = [
									t$1[0],
									t$1[0],
									t$1[0],
									t$1[0]
								];
								break;
							case 2:
								t$1 = [
									t$1[0],
									t$1[1],
									t$1[0],
									t$1[1]
								];
								break;
							case 3: t$1 = [
								t$1[0],
								t$1[1],
								t$1[2],
								t$1[1]
							];
						}
						return new Ee(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Ee(ke$1(t$1.values, e$1.values, r$1));
				}
			}
			class Be$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Be$1) return t$1;
					if ("number" == typeof t$1) return new Be$1([t$1]);
					if (Array.isArray(t$1)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						return new Be$1(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Be$1(ke$1(t$1.values, e$1.values, r$1));
				}
			}
			class Ve$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Ve$1) return t$1;
					if ("string" == typeof t$1) {
						const e$2 = Me$1.parse(t$1);
						if (!e$2) return;
						return new Ve$1([e$2]);
					}
					if (!Array.isArray(t$1)) return;
					const e$1 = [];
					for (const r$1 of t$1) {
						if ("string" != typeof r$1) return;
						const t$2 = Me$1.parse(r$1);
						if (!t$2) return;
						e$1.push(t$2);
					}
					return new Ve$1(e$1);
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					const i$1 = [];
					if (t$1.values.length != e$1.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t$1.values.length} vs. ${e$1.values.length}), cannot interpolate.`);
					for (let s$1 = 0; s$1 < t$1.values.length; s$1++) i$1.push(Me$1.interpolate(t$1.values[s$1], e$1.values[s$1], r$1, n$1));
					return new Ve$1(i$1);
				}
			}
			class Te$1 extends Error {
				constructor(t$1) {
					super(t$1), this.name = "RuntimeError";
				}
				toJSON() {
					return this.message;
				}
			}
			const Fe$1 = new Set([
				"center",
				"left",
				"right",
				"top",
				"bottom",
				"top-left",
				"top-right",
				"bottom-left",
				"bottom-right"
			]);
			class $e$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof $e$1) return t$1;
					if (Array.isArray(t$1) && !(t$1.length < 1) && t$1.length % 2 == 0) {
						for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
							const r$1 = t$1[e$1], n$1 = t$1[e$1 + 1];
							if ("string" != typeof r$1 || !Fe$1.has(r$1)) return;
							if (!Array.isArray(n$1) || 2 !== n$1.length || "number" != typeof n$1[0] || "number" != typeof n$1[1]) return;
						}
						return new $e$1(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					const n$1 = t$1.values, i$1 = e$1.values;
					if (n$1.length !== i$1.length) throw new Te$1(`Cannot interpolate values of different length. from: ${t$1.toString()}, to: ${e$1.toString()}`);
					const s$1 = [];
					for (let t$2 = 0; t$2 < n$1.length; t$2 += 2) {
						if (n$1[t$2] !== i$1[t$2]) throw new Te$1(`Cannot interpolate values containing mismatched anchors. from[${t$2}]: ${n$1[t$2]}, to[${t$2}]: ${i$1[t$2]}`);
						s$1.push(n$1[t$2]);
						const [e$2, a] = n$1[t$2 + 1], [o$1, l$1] = i$1[t$2 + 1];
						s$1.push([Ae$1(e$2, o$1, r$1), Ae$1(a, l$1, r$1)]);
					}
					return new $e$1(s$1);
				}
			}
			class Le {
				constructor(t$1) {
					this.name = t$1.name, this.available = t$1.available;
				}
				toString() {
					return this.name;
				}
				static fromString(t$1) {
					return t$1 ? new Le({
						name: t$1,
						available: !1
					}) : null;
				}
			}
			class Oe$1 {
				constructor(t$1, e$1, r$1) {
					this.from = t$1, this.to = e$1, this.transition = r$1;
				}
				static interpolate(t$1, e$1, r$1) {
					return new Oe$1(t$1, e$1, r$1);
				}
				static parse(t$1) {
					return t$1 instanceof Oe$1 ? t$1 : Array.isArray(t$1) && 3 === t$1.length && "string" == typeof t$1[0] && "string" == typeof t$1[1] && "number" == typeof t$1[2] ? new Oe$1(t$1[0], t$1[1], t$1[2]) : "object" == typeof t$1 && "string" == typeof t$1.from && "string" == typeof t$1.to && "number" == typeof t$1.transition ? new Oe$1(t$1.from, t$1.to, t$1.transition) : "string" == typeof t$1 ? new Oe$1(t$1, t$1, 1) : void 0;
				}
			}
			function De$1(t$1, e$1, r$1, n$1) {
				return "number" == typeof t$1 && t$1 >= 0 && t$1 <= 255 && "number" == typeof e$1 && e$1 >= 0 && e$1 <= 255 && "number" == typeof r$1 && r$1 >= 0 && r$1 <= 255 ? void 0 === n$1 || "number" == typeof n$1 && n$1 >= 0 && n$1 <= 1 ? null : `Invalid rgba value [${[
					t$1,
					e$1,
					r$1,
					n$1
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n$1 ? [
					t$1,
					e$1,
					r$1,
					n$1
				] : [
					t$1,
					e$1,
					r$1
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function Re$1(t$1) {
				if (null === t$1 || "string" == typeof t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || t$1 instanceof Oe$1 || t$1 instanceof Me$1 || t$1 instanceof Ie$1 || t$1 instanceof Ce || t$1 instanceof Ee || t$1 instanceof Be$1 || t$1 instanceof Ve$1 || t$1 instanceof $e$1 || t$1 instanceof Le) return !0;
				if (Array.isArray(t$1)) {
					for (const e$1 of t$1) if (!Re$1(e$1)) return !1;
					return !0;
				}
				if ("object" == typeof t$1) {
					for (const e$1 in t$1) if (!Re$1(t$1[e$1])) return !1;
					return !0;
				}
				return !1;
			}
			function Ue$1(t$1) {
				if (null === t$1) return Tt$1;
				if ("string" == typeof t$1) return $t;
				if ("boolean" == typeof t$1) return Lt$1;
				if ("number" == typeof t$1) return Ft;
				if (t$1 instanceof Me$1) return Ot;
				if (t$1 instanceof Oe$1) return Dt;
				if (t$1 instanceof Ie$1) return jt;
				if (t$1 instanceof Ce) return Nt;
				if (t$1 instanceof Ee) return qt$1;
				if (t$1 instanceof Be$1) return Xt$1;
				if (t$1 instanceof Ve$1) return Gt$1;
				if (t$1 instanceof $e$1) return Yt$1;
				if (t$1 instanceof Le) return Zt$1;
				if (Array.isArray(t$1)) {
					const e$1 = t$1.length;
					let r$1;
					for (const e$2 of t$1) {
						const t$2 = Ue$1(e$2);
						if (r$1) {
							if (r$1 === t$2) continue;
							r$1 = Ut$1;
							break;
						}
						r$1 = t$2;
					}
					return Ht$1(r$1 || Ut$1, e$1);
				}
				return Rt$1;
			}
			function je$1(t$1) {
				const e$1 = typeof t$1;
				return null === t$1 ? "" : "string" === e$1 || "number" === e$1 || "boolean" === e$1 ? String(t$1) : t$1 instanceof Me$1 || t$1 instanceof Oe$1 || t$1 instanceof Ce || t$1 instanceof Ee || t$1 instanceof Be$1 || t$1 instanceof Ve$1 || t$1 instanceof $e$1 || t$1 instanceof Le ? t$1.toString() : JSON.stringify(t$1);
			}
			class Ne$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.value = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'literal' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (!Re$1(t$1[1])) return e$1.error("invalid value");
					const r$1 = t$1[1];
					let n$1 = Ue$1(r$1);
					const i$1 = e$1.expectedType;
					return "array" !== n$1.kind || 0 !== n$1.N || !i$1 || "array" !== i$1.kind || "number" == typeof i$1.N && 0 !== i$1.N || (n$1 = i$1), new Ne$1(n$1, r$1);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			const qe$1 = {
				string: $t,
				number: Ft,
				boolean: Lt$1,
				object: Rt$1
			};
			class Ge$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1, n$1 = 1;
					const i$1 = t$1[0];
					if ("array" === i$1) {
						let i$2, s$2;
						if (t$1.length > 2) {
							const r$2 = t$1[1];
							if ("string" != typeof r$2 || !(r$2 in qe$1) || "object" === r$2) return e$1.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							i$2 = qe$1[r$2], n$1++;
						} else i$2 = Ut$1;
						if (t$1.length > 3) {
							if (null !== t$1[2] && ("number" != typeof t$1[2] || t$1[2] < 0 || t$1[2] !== Math.floor(t$1[2]))) return e$1.error("The length argument to \"array\" must be a positive integer literal", 2);
							s$2 = t$1[2], n$1++;
						}
						r$1 = Ht$1(i$2, s$2);
					} else {
						if (!qe$1[i$1]) throw new Error(`Types doesn't contain name = ${i$1}`);
						r$1 = qe$1[i$1];
					}
					const s$1 = [];
					for (; n$1 < t$1.length; n$1++) {
						const r$2 = e$1.parse(t$1[n$1], n$1, Ut$1);
						if (!r$2) return null;
						s$1.push(r$2);
					}
					return new Ge$1(r$1, s$1);
				}
				evaluate(t$1) {
					for (let e$1 = 0; e$1 < this.args.length; e$1++) {
						const r$1 = this.args[e$1].evaluate(t$1);
						if (!Wt$1(this.type, Ue$1(r$1))) return r$1;
						if (e$1 === this.args.length - 1) throw new Te$1(`Expected value to be of type ${Kt$1(this.type)}, but found ${Kt$1(Ue$1(r$1))} instead.`);
					}
					throw new Error();
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Xe$1 = {
				"to-boolean": Lt$1,
				"to-color": Ot,
				"to-number": Ft,
				"to-string": $t
			};
			class Ze$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[0];
					if (!Xe$1[r$1]) throw new Error(`Can't parse ${r$1} as it is not part of the known types`);
					if (("to-boolean" === r$1 || "to-string" === r$1) && 2 !== t$1.length) return e$1.error("Expected one argument.");
					const n$1 = Xe$1[r$1], i$1 = [];
					for (let r$2 = 1; r$2 < t$1.length; r$2++) {
						const n$2 = e$1.parse(t$1[r$2], r$2, Ut$1);
						if (!n$2) return null;
						i$1.push(n$2);
					}
					return new Ze$1(n$1, i$1);
				}
				evaluate(t$1) {
					switch (this.type.kind) {
						case "boolean": return Boolean(this.args[0].evaluate(t$1));
						case "color": {
							let e$1, r$1;
							for (const n$1 of this.args) {
								if (e$1 = n$1.evaluate(t$1), r$1 = null, e$1 instanceof Me$1) return e$1;
								if ("string" == typeof e$1) {
									const r$2 = t$1.parseColor(e$1);
									if (r$2) return r$2;
								} else if (Array.isArray(e$1) && (r$1 = e$1.length < 3 || e$1.length > 4 ? `Invalid rgba value ${JSON.stringify(e$1)}: expected an array containing either three or four numeric values.` : De$1(e$1[0], e$1[1], e$1[2], e$1[3]), !r$1)) return new Me$1(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]);
							}
							throw new Te$1(r$1 || `Could not parse color from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "padding": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Ee.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Te$1(`Could not parse padding from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "numberArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Be$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Te$1(`Could not parse numberArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "colorArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Ve$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Te$1(`Could not parse colorArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "variableAnchorOffsetCollection": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = $e$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Te$1(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "number": {
							let e$1 = null;
							for (const r$1 of this.args) {
								if (e$1 = r$1.evaluate(t$1), null === e$1) return 0;
								const n$1 = Number(e$1);
								if (!isNaN(n$1)) return n$1;
							}
							throw new Te$1(`Could not convert ${JSON.stringify(e$1)} to number.`);
						}
						case "formatted": return Ce.fromString(je$1(this.args[0].evaluate(t$1)));
						case "resolvedImage": return Le.fromString(je$1(this.args[0].evaluate(t$1)));
						case "projectionDefinition": return this.args[0].evaluate(t$1);
						default: return je$1(this.args[0].evaluate(t$1));
					}
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Ye$1 = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class He$1 {
				constructor() {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
				}
				id() {
					return this.feature && "id" in this.feature ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? "number" == typeof this.feature.type ? Ye$1[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				parseColor(t$1) {
					let e$1 = this._parseColorCache.get(t$1);
					return e$1 || (e$1 = Me$1.parse(t$1), this._parseColorCache.set(t$1, e$1)), e$1;
				}
			}
			class Ke$1 {
				constructor(t$1, e$1, r$1 = [], n$1, i$1 = new Vt$1(), s$1 = []) {
					this.registry = t$1, this.path = r$1, this.key = r$1.map(((t$2) => `[${t$2}]`)).join(""), this.scope = i$1, this.errors = s$1, this.expectedType = n$1, this._isConstant = e$1;
				}
				parse(t$1, e$1, r$1, n$1, i$1 = {}) {
					return e$1 ? this.concat(e$1, r$1, n$1)._parse(t$1, i$1) : this._parse(t$1, i$1);
				}
				_parse(t$1, e$1) {
					function r$1(t$2, e$2, r$2) {
						return "assert" === r$2 ? new Ge$1(e$2, [t$2]) : "coerce" === r$2 ? new Ze$1(e$2, [t$2]) : t$2;
					}
					if (null !== t$1 && "string" != typeof t$1 && "boolean" != typeof t$1 && "number" != typeof t$1 || (t$1 = ["literal", t$1]), Array.isArray(t$1)) {
						if (0 === t$1.length) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						const n$1 = t$1[0];
						if ("string" != typeof n$1) return this.error(`Expression name must be a string, but found ${typeof n$1} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
						const i$1 = this.registry[n$1];
						if (i$1) {
							let n$2 = i$1.parse(t$1, this);
							if (!n$2) return null;
							if (this.expectedType) {
								const t$2 = this.expectedType, i$2 = n$2.type;
								if ("string" !== t$2.kind && "number" !== t$2.kind && "boolean" !== t$2.kind && "object" !== t$2.kind && "array" !== t$2.kind || "value" !== i$2.kind) {
									if ("projectionDefinition" === t$2.kind && ["string", "array"].includes(i$2.kind) || [
										"color",
										"formatted",
										"resolvedImage"
									].includes(t$2.kind) && ["value", "string"].includes(i$2.kind) || ["padding", "numberArray"].includes(t$2.kind) && [
										"value",
										"number",
										"array"
									].includes(i$2.kind) || "colorArray" === t$2.kind && [
										"value",
										"string",
										"array"
									].includes(i$2.kind) || "variableAnchorOffsetCollection" === t$2.kind && ["value", "array"].includes(i$2.kind)) n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "coerce");
									else if (this.checkSubtype(t$2, i$2)) return null;
								} else n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "assert");
							}
							if (!(n$2 instanceof Ne$1) && "resolvedImage" !== n$2.type.kind && this._isConstant(n$2)) {
								const t$2 = new He$1();
								try {
									n$2 = new Ne$1(n$2.type, n$2.evaluate(t$2));
								} catch (t$3) {
									return this.error(t$3.message), null;
								}
							}
							return n$2;
						}
						return this.error(`Unknown expression "${n$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					}
					return this.error(void 0 === t$1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t$1 ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof t$1} instead.`);
				}
				concat(t$1, e$1, r$1) {
					const n$1 = "number" == typeof t$1 ? this.path.concat(t$1) : this.path, i$1 = r$1 ? this.scope.concat(r$1) : this.scope;
					return new Ke$1(this.registry, this._isConstant, n$1, e$1 || null, i$1, this.errors);
				}
				error(t$1, ...e$1) {
					const r$1 = `${this.key}${e$1.map(((t$2) => `[${t$2}]`)).join("")}`;
					this.errors.push(new Bt$1(r$1, t$1));
				}
				checkSubtype(t$1, e$1) {
					const r$1 = Wt$1(t$1, e$1);
					return r$1 && this.error(r$1), r$1;
				}
			}
			class Je$1 {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.bindings = [].concat(t$1), this.result = e$1;
				}
				evaluate(t$1) {
					return this.result.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const e$1 of this.bindings) t$1(e$1[1]);
					t$1(this.result);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = [];
					for (let n$2 = 1; n$2 < t$1.length - 1; n$2 += 2) {
						const i$1 = t$1[n$2];
						if ("string" != typeof i$1) return e$1.error(`Expected string, but found ${typeof i$1} instead.`, n$2);
						if (/[^a-zA-Z0-9_]/.test(i$1)) return e$1.error("Variable names must contain only alphanumeric characters or '_'.", n$2);
						const s$1 = e$1.parse(t$1[n$2 + 1], n$2 + 1);
						if (!s$1) return null;
						r$1.push([i$1, s$1]);
					}
					const n$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, e$1.expectedType, r$1);
					return n$1 ? new Je$1(r$1, n$1) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
			}
			class We$1 {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.name = t$1, this.boundExpression = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length || "string" != typeof t$1[1]) return e$1.error("'var' expression requires exactly one string literal argument.");
					const r$1 = t$1[1];
					return e$1.scope.has(r$1) ? new We$1(r$1, e$1.scope.get(r$1)) : e$1.error(`Unknown variable "${r$1}". Make sure "${r$1}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(t$1) {
					return this.boundExpression.evaluate(t$1);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			class Qe$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ft), n$1 = e$1.parse(t$1[2], 2, Ht$1(e$1.expectedType || Ut$1));
					return r$1 && n$1 ? new Qe$1(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Te$1(`Array index out of bounds: ${e$1} < 0.`);
					if (e$1 >= r$1.length) throw new Te$1(`Array index out of bounds: ${e$1} > ${r$1.length - 1}.`);
					if (e$1 !== Math.floor(e$1)) throw new Te$1(`Array index must be an integer, but found ${e$1} instead.`);
					return r$1[e$1];
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class tr$1 {
				constructor(t$1, e$1) {
					this.type = Lt$1, this.needle = t$1, this.haystack = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ut$1);
					return r$1 && n$1 ? Qt$1(r$1.type, [
						Lt$1,
						$t,
						Ft,
						Tt$1,
						Ut$1
					]) ? new tr$1(r$1, n$1) : e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Kt$1(r$1.type)} instead`) : null;
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!r$1) return !1;
					if (!te$1(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Te$1(`Expected first argument to be of type boolean, string, number or null, but found ${Kt$1(Ue$1(e$1))} instead.`);
					if (!te$1(r$1, ["string", "array"])) throw new Te$1(`Expected second argument to be of type array or string, but found ${Kt$1(Ue$1(r$1))} instead.`);
					return r$1.indexOf(e$1) >= 0;
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack);
				}
				outputDefined() {
					return !0;
				}
			}
			class er$1 {
				constructor(t$1, e$1, r$1) {
					this.type = Ft, this.needle = t$1, this.haystack = e$1, this.fromIndex = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 3 or 4 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ut$1);
					if (!r$1 || !n$1) return null;
					if (!Qt$1(r$1.type, [
						Lt$1,
						$t,
						Ft,
						Tt$1,
						Ut$1
					])) return e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Kt$1(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ft);
						return i$1 ? new er$1(r$1, n$1, i$1) : null;
					}
					return new er$1(r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!te$1(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Te$1(`Expected first argument to be of type boolean, string, number or null, but found ${Kt$1(Ue$1(e$1))} instead.`);
					let n$1;
					if (this.fromIndex && (n$1 = this.fromIndex.evaluate(t$1)), te$1(r$1, ["string"])) {
						const t$2 = r$1.indexOf(e$1, n$1);
						return -1 === t$2 ? -1 : [...r$1.slice(0, t$2)].length;
					}
					if (te$1(r$1, ["array"])) return r$1.indexOf(e$1, n$1);
					throw new Te$1(`Expected second argument to be of type array or string, but found ${Kt$1(Ue$1(r$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack), this.fromIndex && t$1(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			class rr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.inputType = t$1, this.type = e$1, this.input = r$1, this.cases = n$1, this.outputs = i$1, this.otherwise = s$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 5) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 1) return e$1.error("Expected an even number of arguments.");
					let r$1, n$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (n$1 = e$1.expectedType);
					const i$1 = {}, s$1 = [];
					for (let a$1 = 2; a$1 < t$1.length - 1; a$1 += 2) {
						let o$2 = t$1[a$1];
						const l$1 = t$1[a$1 + 1];
						Array.isArray(o$2) || (o$2 = [o$2]);
						const u$1 = e$1.concat(a$1);
						if (0 === o$2.length) return u$1.error("Expected at least one branch label.");
						for (const t$2 of o$2) {
							if ("number" != typeof t$2 && "string" != typeof t$2) return u$1.error("Branch labels must be numbers or strings.");
							if ("number" == typeof t$2 && Math.abs(t$2) > Number.MAX_SAFE_INTEGER) return u$1.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
							if ("number" == typeof t$2 && Math.floor(t$2) !== t$2) return u$1.error("Numeric branch labels must be integer values.");
							if (r$1) {
								if (u$1.checkSubtype(r$1, Ue$1(t$2))) return null;
							} else r$1 = Ue$1(t$2);
							if (void 0 !== i$1[String(t$2)]) return u$1.error("Branch labels must be unique.");
							i$1[String(t$2)] = s$1.length;
						}
						const c$1 = e$1.parse(l$1, a$1, n$1);
						if (!c$1) return null;
						n$1 = n$1 || c$1.type, s$1.push(c$1);
					}
					const a = e$1.parse(t$1[1], 1, Ut$1);
					if (!a) return null;
					const o$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, n$1);
					return o$1 ? "value" !== a.type.kind && e$1.concat(1).checkSubtype(r$1, a.type) ? null : new rr$1(r$1, n$1, a, i$1, s$1, o$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					return (Ue$1(e$1) === this.inputType && this.outputs[this.cases[e$1]] || this.otherwise).evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input), this.outputs.forEach(t$1), t$1(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class nr$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.branches = e$1, this.otherwise = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 0) return e$1.error("Expected an odd number of arguments.");
					let r$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (r$1 = e$1.expectedType);
					const n$1 = [];
					for (let i$2 = 1; i$2 < t$1.length - 1; i$2 += 2) {
						const s$1 = e$1.parse(t$1[i$2], i$2, Lt$1);
						if (!s$1) return null;
						const a = e$1.parse(t$1[i$2 + 1], i$2 + 1, r$1);
						if (!a) return null;
						n$1.push([s$1, a]), r$1 = r$1 || a.type;
					}
					const i$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, r$1);
					if (!i$1) return null;
					if (!r$1) throw new Error("Can't infer output type");
					return new nr$1(r$1, n$1, i$1);
				}
				evaluate(t$1) {
					for (const [e$1, r$1] of this.branches) if (e$1.evaluate(t$1)) return r$1.evaluate(t$1);
					return this.otherwise.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const [e$1, r$1] of this.branches) t$1(e$1), t$1(r$1);
					t$1(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([t$1, e$1]) => e$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class ir$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.type = t$1, this.input = e$1, this.beginIndex = r$1, this.endIndex = n$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 3 or 4 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ft);
					if (!r$1 || !n$1) return null;
					if (!Qt$1(r$1.type, [
						Ht$1(Ut$1),
						$t,
						Ut$1
					])) return e$1.error(`Expected first argument to be of type array or string, but found ${Kt$1(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ft);
						return i$1 ? new ir$1(r$1.type, r$1, n$1, i$1) : null;
					}
					return new ir$1(r$1.type, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = this.beginIndex.evaluate(t$1);
					let n$1;
					if (this.endIndex && (n$1 = this.endIndex.evaluate(t$1)), te$1(e$1, ["string"])) return [...e$1].slice(r$1, n$1).join("");
					if (te$1(e$1, ["array"])) return e$1.slice(r$1, n$1);
					throw new Te$1(`Expected first argument to be of type array or string, but found ${Kt$1(Ue$1(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input), t$1(this.beginIndex), this.endIndex && t$1(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			function sr$1(t$1, e$1) {
				const r$1 = t$1.length - 1;
				let n$1, i$1, s$1 = 0, a = r$1, o$1 = 0;
				for (; s$1 <= a;) if (o$1 = Math.floor((s$1 + a) / 2), n$1 = t$1[o$1], i$1 = t$1[o$1 + 1], n$1 <= e$1) {
					if (o$1 === r$1 || e$1 < i$1) return o$1;
					s$1 = o$1 + 1;
				} else {
					if (!(n$1 > e$1)) throw new Te$1("Input is not a number.");
					a = o$1 - 1;
				}
				return 0;
			}
			class ar$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.input = e$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of r$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static parse(t$1, e$1) {
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ft);
					if (!r$1) return null;
					const n$1 = [];
					let i$1 = null;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (i$1 = e$1.expectedType);
					for (let r$2 = 1; r$2 < t$1.length; r$2 += 2) {
						const s$1 = 1 === r$2 ? -Infinity : t$1[r$2], a = t$1[r$2 + 1], o$1 = r$2, l$1 = r$2 + 1;
						if ("number" != typeof s$1) return e$1.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", o$1);
						if (n$1.length && n$1[n$1.length - 1][0] >= s$1) return e$1.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", o$1);
						const u$1 = e$1.parse(a, l$1, i$1);
						if (!u$1) return null;
						i$1 = i$1 || u$1.type, n$1.push([s$1, u$1]);
					}
					return new ar$1(i$1, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					return n$1 >= e$1[i$1 - 1] ? r$1[i$1 - 1].evaluate(t$1) : r$1[sr$1(e$1, n$1)].evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function or$1(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var lr$1, ur$1, hr$1 = or$1(function() {
				if (ur$1) return lr$1;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return ur$1 = 1, lr$1 = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a) + a;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, lr$1;
			}());
			class pr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = t$1, this.operator = e$1, this.interpolation = r$1, this.input = n$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of i$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static interpolationFactor(t$1, e$1, r$1, n$1) {
					let i$1 = 0;
					if ("exponential" === t$1.name) i$1 = fr$1(e$1, t$1.base, r$1, n$1);
					else if ("linear" === t$1.name) i$1 = fr$1(e$1, 1, r$1, n$1);
					else if ("cubic-bezier" === t$1.name) {
						const s$1 = t$1.controlPoints;
						i$1 = new hr$1(s$1[0], s$1[1], s$1[2], s$1[3]).solve(fr$1(e$1, 1, r$1, n$1));
					}
					return i$1;
				}
				static parse(t$1, e$1) {
					let [r$1, n$1, i$1, ...s$1] = t$1;
					if (!Array.isArray(n$1) || 0 === n$1.length) return e$1.error("Expected an interpolation type expression.", 1);
					if ("linear" === n$1[0]) n$1 = { name: "linear" };
					else if ("exponential" === n$1[0]) {
						const t$2 = n$1[1];
						if ("number" != typeof t$2) return e$1.error("Exponential interpolation requires a numeric base.", 1, 1);
						n$1 = {
							name: "exponential",
							base: t$2
						};
					} else {
						if ("cubic-bezier" !== n$1[0]) return e$1.error(`Unknown interpolation type ${String(n$1[0])}`, 1, 0);
						{
							const t$2 = n$1.slice(1);
							if (4 !== t$2.length || t$2.some(((t$3) => "number" != typeof t$3 || t$3 < 0 || t$3 > 1))) return e$1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							n$1 = {
								name: "cubic-bezier",
								controlPoints: t$2
							};
						}
					}
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					if (i$1 = e$1.parse(i$1, 2, Ft), !i$1) return null;
					const a = [];
					let o$1 = null;
					"interpolate-hcl" !== r$1 && "interpolate-lab" !== r$1 || e$1.expectedType == Gt$1 ? e$1.expectedType && "value" !== e$1.expectedType.kind && (o$1 = e$1.expectedType) : o$1 = Ot;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 2) {
						const r$2 = s$1[t$2], n$2 = s$1[t$2 + 1], i$2 = t$2 + 3, l$1 = t$2 + 4;
						if ("number" != typeof r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", i$2);
						if (a.length && a[a.length - 1][0] >= r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", i$2);
						const u$1 = e$1.parse(n$2, l$1, o$1);
						if (!u$1) return null;
						o$1 = o$1 || u$1.type, a.push([r$2, u$1]);
					}
					return ee(o$1, Ft) || ee(o$1, Dt) || ee(o$1, Ot) || ee(o$1, qt$1) || ee(o$1, Xt$1) || ee(o$1, Gt$1) || ee(o$1, Yt$1) || ee(o$1, Ht$1(Ft)) ? new pr$1(o$1, r$1, n$1, i$1, a) : e$1.error(`Type ${Kt$1(o$1)} is not interpolatable.`);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					if (n$1 >= e$1[i$1 - 1]) return r$1[i$1 - 1].evaluate(t$1);
					const s$1 = sr$1(e$1, n$1), a = pr$1.interpolationFactor(this.interpolation, n$1, e$1[s$1], e$1[s$1 + 1]), o$1 = r$1[s$1].evaluate(t$1), l$1 = r$1[s$1 + 1].evaluate(t$1);
					switch (this.operator) {
						case "interpolate": switch (this.type.kind) {
							case "number": return Ae$1(o$1, l$1, a);
							case "color": return Me$1.interpolate(o$1, l$1, a);
							case "padding": return Ee.interpolate(o$1, l$1, a);
							case "colorArray": return Ve$1.interpolate(o$1, l$1, a);
							case "numberArray": return Be$1.interpolate(o$1, l$1, a);
							case "variableAnchorOffsetCollection": return $e$1.interpolate(o$1, l$1, a);
							case "array": return ke$1(o$1, l$1, a);
							case "projectionDefinition": return Oe$1.interpolate(o$1, l$1, a);
						}
						case "interpolate-hcl": switch (this.type.kind) {
							case "color": return Me$1.interpolate(o$1, l$1, a, "hcl");
							case "colorArray": return Ve$1.interpolate(o$1, l$1, a, "hcl");
						}
						case "interpolate-lab": switch (this.type.kind) {
							case "color": return Me$1.interpolate(o$1, l$1, a, "lab");
							case "colorArray": return Ve$1.interpolate(o$1, l$1, a, "lab");
						}
					}
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function fr$1(t$1, e$1, r$1, n$1) {
				const i$1 = n$1 - r$1, s$1 = t$1 - r$1;
				return 0 === i$1 ? 0 : 1 === e$1 ? s$1 / i$1 : (Math.pow(e$1, s$1) - 1) / (Math.pow(e$1, i$1) - 1);
			}
			const dr$1 = {
				color: Me$1.interpolate,
				number: Ae$1,
				padding: Ee.interpolate,
				numberArray: Be$1.interpolate,
				colorArray: Ve$1.interpolate,
				variableAnchorOffsetCollection: $e$1.interpolate,
				array: ke$1
			};
			class yr$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1 = null;
					const n$1 = e$1.expectedType;
					n$1 && "value" !== n$1.kind && (r$1 = n$1);
					const i$1 = [];
					for (const n$2 of t$1.slice(1)) {
						const t$2 = e$1.parse(n$2, 1 + i$1.length, r$1, void 0, { typeAnnotation: "omit" });
						if (!t$2) return null;
						r$1 = r$1 || t$2.type, i$1.push(t$2);
					}
					if (!r$1) throw new Error("No output type");
					return new yr$1(n$1 && i$1.some(((t$2) => Wt$1(n$1, t$2.type))) ? Ut$1 : r$1, i$1);
				}
				evaluate(t$1) {
					let e$1, r$1 = null, n$1 = 0;
					for (const i$1 of this.args) if (n$1++, r$1 = i$1.evaluate(t$1), r$1 && r$1 instanceof Le && !r$1.available && (e$1 || (e$1 = r$1.name), r$1 = null, n$1 === this.args.length && (r$1 = e$1)), null !== r$1) break;
					return r$1;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			function mr$1(t$1, e$1) {
				return "==" === t$1 || "!=" === t$1 ? "boolean" === e$1.kind || "string" === e$1.kind || "number" === e$1.kind || "null" === e$1.kind || "value" === e$1.kind : "string" === e$1.kind || "number" === e$1.kind || "value" === e$1.kind;
			}
			function gr$1(t$1, e$1, r$1, n$1) {
				return 0 === n$1.compare(e$1, r$1);
			}
			function xr$1(t$1, e$1, r$1) {
				const n$1 = "==" !== t$1 && "!=" !== t$1;
				return class i$1 {
					constructor(t$2, e$2, r$2) {
						this.type = Lt$1, this.lhs = t$2, this.rhs = e$2, this.collator = r$2, this.hasUntypedArgument = "value" === t$2.type.kind || "value" === e$2.type.kind;
					}
					static parse(t$2, e$2) {
						if (3 !== t$2.length && 4 !== t$2.length) return e$2.error("Expected two or three arguments.");
						const r$2 = t$2[0];
						let s$1 = e$2.parse(t$2[1], 1, Ut$1);
						if (!s$1) return null;
						if (!mr$1(r$2, s$1.type)) return e$2.concat(1).error(`"${r$2}" comparisons are not supported for type '${Kt$1(s$1.type)}'.`);
						let a = e$2.parse(t$2[2], 2, Ut$1);
						if (!a) return null;
						if (!mr$1(r$2, a.type)) return e$2.concat(2).error(`"${r$2}" comparisons are not supported for type '${Kt$1(a.type)}'.`);
						if (s$1.type.kind !== a.type.kind && "value" !== s$1.type.kind && "value" !== a.type.kind) return e$2.error(`Cannot compare types '${Kt$1(s$1.type)}' and '${Kt$1(a.type)}'.`);
						n$1 && ("value" === s$1.type.kind && "value" !== a.type.kind ? s$1 = new Ge$1(a.type, [s$1]) : "value" !== s$1.type.kind && "value" === a.type.kind && (a = new Ge$1(s$1.type, [a])));
						let o$1 = null;
						if (4 === t$2.length) {
							if ("string" !== s$1.type.kind && "string" !== a.type.kind && "value" !== s$1.type.kind && "value" !== a.type.kind) return e$2.error("Cannot use collator to compare non-string types.");
							if (o$1 = e$2.parse(t$2[3], 3, jt), !o$1) return null;
						}
						return new i$1(s$1, a, o$1);
					}
					evaluate(i$2) {
						const s$1 = this.lhs.evaluate(i$2), a = this.rhs.evaluate(i$2);
						if (n$1 && this.hasUntypedArgument) {
							const e$2 = Ue$1(s$1), r$2 = Ue$1(a);
							if (e$2.kind !== r$2.kind || "string" !== e$2.kind && "number" !== e$2.kind) throw new Te$1(`Expected arguments for "${t$1}" to be (string, string) or (number, number), but found (${e$2.kind}, ${r$2.kind}) instead.`);
						}
						if (this.collator && !n$1 && this.hasUntypedArgument) {
							const t$2 = Ue$1(s$1), r$2 = Ue$1(a);
							if ("string" !== t$2.kind || "string" !== r$2.kind) return e$1(i$2, s$1, a);
						}
						return this.collator ? r$1(i$2, s$1, a, this.collator.evaluate(i$2)) : e$1(i$2, s$1, a);
					}
					eachChild(t$2) {
						t$2(this.lhs), t$2(this.rhs), this.collator && t$2(this.collator);
					}
					outputDefined() {
						return !0;
					}
				};
			}
			const vr$1 = xr$1("==", (function(t$1, e$1, r$1) {
				return e$1 === r$1;
			}), gr$1), br$1 = xr$1("!=", (function(t$1, e$1, r$1) {
				return e$1 !== r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return !gr$1(0, e$1, r$1, n$1);
			})), wr$1 = xr$1("<", (function(t$1, e$1, r$1) {
				return e$1 < r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) < 0;
			})), _r$1 = xr$1(">", (function(t$1, e$1, r$1) {
				return e$1 > r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) > 0;
			})), Sr$1 = xr$1("<=", (function(t$1, e$1, r$1) {
				return e$1 <= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) <= 0;
			})), Ar$1 = xr$1(">=", (function(t$1, e$1, r$1) {
				return e$1 >= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) >= 0;
			}));
			class kr$1 {
				constructor(t$1, e$1, r$1) {
					this.type = jt, this.locale = r$1, this.caseSensitive = t$1, this.diacriticSensitive = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected one argument.");
					const r$1 = t$1[1];
					if ("object" != typeof r$1 || Array.isArray(r$1)) return e$1.error("Collator options argument must be an object.");
					const n$1 = e$1.parse(void 0 !== r$1["case-sensitive"] && r$1["case-sensitive"], 1, Lt$1);
					if (!n$1) return null;
					const i$1 = e$1.parse(void 0 !== r$1["diacritic-sensitive"] && r$1["diacritic-sensitive"], 1, Lt$1);
					if (!i$1) return null;
					let s$1 = null;
					return r$1.locale && (s$1 = e$1.parse(r$1.locale, 1, $t), !s$1) ? null : new kr$1(n$1, i$1, s$1);
				}
				evaluate(t$1) {
					return new Ie$1(this.caseSensitive.evaluate(t$1), this.diacriticSensitive.evaluate(t$1), this.locale ? this.locale.evaluate(t$1) : null);
				}
				eachChild(t$1) {
					t$1(this.caseSensitive), t$1(this.diacriticSensitive), this.locale && t$1(this.locale);
				}
				outputDefined() {
					return !1;
				}
			}
			class Mr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = $t, this.number = t$1, this.locale = e$1, this.currency = r$1, this.minFractionDigits = n$1, this.maxFractionDigits = i$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ft);
					if (!r$1) return null;
					const n$1 = t$1[2];
					if ("object" != typeof n$1 || Array.isArray(n$1)) return e$1.error("NumberFormat options argument must be an object.");
					let i$1 = null;
					if (n$1.locale && (i$1 = e$1.parse(n$1.locale, 1, $t), !i$1)) return null;
					let s$1 = null;
					if (n$1.currency && (s$1 = e$1.parse(n$1.currency, 1, $t), !s$1)) return null;
					let a = null;
					if (n$1["min-fraction-digits"] && (a = e$1.parse(n$1["min-fraction-digits"], 1, Ft), !a)) return null;
					let o$1 = null;
					return n$1["max-fraction-digits"] && (o$1 = e$1.parse(n$1["max-fraction-digits"], 1, Ft), !o$1) ? null : new Mr$1(r$1, i$1, s$1, a, o$1);
				}
				evaluate(t$1) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t$1) : [], {
						style: this.currency ? "currency" : "decimal",
						currency: this.currency ? this.currency.evaluate(t$1) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t$1) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t$1) : void 0
					}).format(this.number.evaluate(t$1));
				}
				eachChild(t$1) {
					t$1(this.number), this.locale && t$1(this.locale), this.currency && t$1(this.currency), this.minFractionDigits && t$1(this.minFractionDigits), this.maxFractionDigits && t$1(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
			}
			class Ir$1 {
				constructor(t$1) {
					this.type = Nt, this.sections = t$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[1];
					if (!Array.isArray(r$1) && "object" == typeof r$1) return e$1.error("First argument must be an image or text section.");
					const n$1 = [];
					let i$1 = !1;
					for (let r$2 = 1; r$2 <= t$1.length - 1; ++r$2) {
						const s$1 = t$1[r$2];
						if (i$1 && "object" == typeof s$1 && !Array.isArray(s$1)) {
							i$1 = !1;
							let t$2 = null;
							if (s$1["font-scale"] && (t$2 = e$1.parse(s$1["font-scale"], 1, Ft), !t$2)) return null;
							let r$3 = null;
							if (s$1["text-font"] && (r$3 = e$1.parse(s$1["text-font"], 1, Ht$1($t)), !r$3)) return null;
							let a = null;
							if (s$1["text-color"] && (a = e$1.parse(s$1["text-color"], 1, Ot), !a)) return null;
							let o$1 = null;
							if (s$1["vertical-align"]) {
								if ("string" == typeof s$1["vertical-align"] && !ze$1.includes(s$1["vertical-align"])) return e$1.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s$1["vertical-align"]}' instead.`);
								if (o$1 = e$1.parse(s$1["vertical-align"], 1, $t), !o$1) return null;
							}
							const l$1 = n$1[n$1.length - 1];
							l$1.scale = t$2, l$1.font = r$3, l$1.textColor = a, l$1.verticalAlign = o$1;
						} else {
							const s$2 = e$1.parse(t$1[r$2], 1, Ut$1);
							if (!s$2) return null;
							const a = s$2.type.kind;
							if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e$1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							i$1 = !0, n$1.push({
								content: s$2,
								scale: null,
								font: null,
								textColor: null,
								verticalAlign: null
							});
						}
					}
					return new Ir$1(n$1);
				}
				evaluate(t$1) {
					return new Ce(this.sections.map(((e$1) => {
						const r$1 = e$1.content.evaluate(t$1);
						return Ue$1(r$1) === Zt$1 ? new Pe$1("", r$1, null, null, null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null) : new Pe$1(je$1(r$1), null, e$1.scale ? e$1.scale.evaluate(t$1) : null, e$1.font ? e$1.font.evaluate(t$1).join(",") : null, e$1.textColor ? e$1.textColor.evaluate(t$1) : null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null);
					})));
				}
				eachChild(t$1) {
					for (const e$1 of this.sections) t$1(e$1.content), e$1.scale && t$1(e$1.scale), e$1.font && t$1(e$1.font), e$1.textColor && t$1(e$1.textColor), e$1.verticalAlign && t$1(e$1.verticalAlign);
				}
				outputDefined() {
					return !1;
				}
			}
			class zr$1 {
				constructor(t$1) {
					this.type = Zt$1, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, $t);
					return r$1 ? new zr$1(r$1) : e$1.error("No image name provided.");
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = Le.fromString(e$1);
					return r$1 && t$1.availableImages && (r$1.available = t$1.availableImages.indexOf(e$1) > -1), r$1;
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class Pr$1 {
				constructor(t$1) {
					this.type = Ft, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1);
					return r$1 ? "array" !== r$1.type.kind && "string" !== r$1.type.kind && "value" !== r$1.type.kind ? e$1.error(`Expected argument of type string or array, but found ${Kt$1(r$1.type)} instead.`) : new Pr$1(r$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					if ("string" == typeof e$1) return [...e$1].length;
					if (Array.isArray(e$1)) return e$1.length;
					throw new Te$1(`Expected value to be of type string or array, but found ${Kt$1(Ue$1(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			const Cr = 8192;
			function Er(t$1, e$1) {
				const r$1 = (180 + t$1[0]) / 360, n$1 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1[1] * Math.PI / 360))) / 360, i$1 = Math.pow(2, e$1.z);
				return [Math.round(r$1 * i$1 * Cr), Math.round(n$1 * i$1 * Cr)];
			}
			function Br$1(t$1, e$1) {
				const r$1 = Math.pow(2, e$1.z);
				return [(i$1 = (t$1[0] / Cr + e$1.x) / r$1, 360 * i$1 - 180), (n$1 = (t$1[1] / Cr + e$1.y) / r$1, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n$1) * Math.PI / 180)) - 90)];
				var n$1, i$1;
			}
			function Vr$1(t$1, e$1) {
				t$1[0] = Math.min(t$1[0], e$1[0]), t$1[1] = Math.min(t$1[1], e$1[1]), t$1[2] = Math.max(t$1[2], e$1[0]), t$1[3] = Math.max(t$1[3], e$1[1]);
			}
			function Tr$1(t$1, e$1) {
				return !(t$1[0] <= e$1[0] || t$1[2] >= e$1[2] || t$1[1] <= e$1[1] || t$1[3] >= e$1[3]);
			}
			function Fr$1(t$1, e$1, r$1) {
				const n$1 = t$1[0] - e$1[0], i$1 = t$1[1] - e$1[1], s$1 = t$1[0] - r$1[0], a = t$1[1] - r$1[1];
				return n$1 * a - s$1 * i$1 == 0 && n$1 * s$1 <= 0 && i$1 * a <= 0;
			}
			function $r$1(t$1, e$1, r$1, n$1) {
				return 0 != (i$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]])[0] * (s$1 = [e$1[0] - t$1[0], e$1[1] - t$1[1]])[1] - i$1[1] * s$1[0] && !(!jr$1(t$1, e$1, r$1, n$1) || !jr$1(r$1, n$1, t$1, e$1));
				var i$1, s$1;
			}
			function Lr$1(t$1, e$1, r$1) {
				for (const n$1 of r$1) for (let r$2 = 0; r$2 < n$1.length - 1; ++r$2) if ($r$1(t$1, e$1, n$1[r$2], n$1[r$2 + 1])) return !0;
				return !1;
			}
			function Or$1(t$1, e$1, r$1 = !1) {
				let n$1 = !1;
				for (const o$1 of e$1) for (let e$2 = 0; e$2 < o$1.length - 1; e$2++) {
					if (Fr$1(t$1, o$1[e$2], o$1[e$2 + 1])) return r$1;
					(s$1 = o$1[e$2])[1] > (i$1 = t$1)[1] != (a = o$1[e$2 + 1])[1] > i$1[1] && i$1[0] < (a[0] - s$1[0]) * (i$1[1] - s$1[1]) / (a[1] - s$1[1]) + s$1[0] && (n$1 = !n$1);
				}
				var i$1, s$1, a;
				return n$1;
			}
			function Dr$1(t$1, e$1) {
				for (const r$1 of e$1) if (Or$1(t$1, r$1)) return !0;
				return !1;
			}
			function Rr$1(t$1, e$1) {
				for (const r$1 of t$1) if (!Or$1(r$1, e$1)) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; ++r$1) if (Lr$1(t$1[r$1], t$1[r$1 + 1], e$1)) return !1;
				return !0;
			}
			function Ur$1(t$1, e$1) {
				for (const r$1 of e$1) if (Rr$1(t$1, r$1)) return !0;
				return !1;
			}
			function jr$1(t$1, e$1, r$1, n$1) {
				const i$1 = n$1[0] - r$1[0], s$1 = n$1[1] - r$1[1], a = (t$1[0] - r$1[0]) * s$1 - i$1 * (t$1[1] - r$1[1]), o$1 = (e$1[0] - r$1[0]) * s$1 - i$1 * (e$1[1] - r$1[1]);
				return a > 0 && o$1 < 0 || a < 0 && o$1 > 0;
			}
			function Nr$1(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = [];
					for (let n$2 = 0; n$2 < t$1[i$1].length; n$2++) {
						const a = Er(t$1[i$1][n$2], r$1);
						Vr$1(e$1, a), s$1.push(a);
					}
					n$1.push(s$1);
				}
				return n$1;
			}
			function qr$1(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = Nr$1(t$1[i$1], e$1, r$1);
					n$1.push(s$1);
				}
				return n$1;
			}
			function Gr$1(t$1, e$1, r$1, n$1) {
				if (t$1[0] < r$1[0] || t$1[0] > r$1[2]) {
					const e$2 = .5 * n$1;
					let i$1 = t$1[0] - r$1[0] > e$2 ? -n$1 : r$1[0] - t$1[0] > e$2 ? n$1 : 0;
					0 === i$1 && (i$1 = t$1[0] - r$1[2] > e$2 ? -n$1 : r$1[2] - t$1[0] > e$2 ? n$1 : 0), t$1[0] += i$1;
				}
				Vr$1(e$1, t$1);
			}
			function Xr$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Cr, s$1 = [n$1.x * Cr, n$1.y * Cr], a = [];
				for (const n$2 of t$1) for (const t$2 of n$2) {
					const n$3 = [t$2.x + s$1[0], t$2.y + s$1[1]];
					Gr$1(n$3, e$1, r$1, i$1), a.push(n$3);
				}
				return a;
			}
			function Zr$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Cr, s$1 = [n$1.x * Cr, n$1.y * Cr], a = [];
				for (const r$2 of t$1) {
					const t$2 = [];
					for (const n$2 of r$2) {
						const r$3 = [n$2.x + s$1[0], n$2.y + s$1[1]];
						Vr$1(e$1, r$3), t$2.push(r$3);
					}
					a.push(t$2);
				}
				if (e$1[2] - e$1[0] <= i$1 / 2) {
					(o$1 = e$1)[0] = o$1[1] = Infinity, o$1[2] = o$1[3] = -Infinity;
					for (const t$2 of a) for (const n$2 of t$2) Gr$1(n$2, e$1, r$1, i$1);
				}
				var o$1;
				return a;
			}
			class Yr$1 {
				constructor(t$1, e$1) {
					this.type = Lt$1, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'within' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (Re$1(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) {
							const t$2 = [];
							for (const r$1 of e$2.features) {
								const { type: e$3, coordinates: n$1 } = r$1.geometry;
								"Polygon" === e$3 && t$2.push(n$1), "MultiPolygon" === e$3 && t$2.push(...n$1);
							}
							if (t$2.length) return new Yr$1(e$2, {
								type: "MultiPolygon",
								coordinates: t$2
							});
						} else if ("Feature" === e$2.type) {
							const t$2 = e$2.geometry.type;
							if ("Polygon" === t$2 || "MultiPolygon" === t$2) return new Yr$1(e$2, e$2.geometry);
						} else if ("Polygon" === e$2.type || "MultiPolygon" === e$2.type) return new Yr$1(e$2, e$2);
					}
					return e$1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = Nr$1(e$1.coordinates, n$1, i$1), a = Xr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Tr$1(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Or$1(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = qr$1(e$1.coordinates, n$1, i$1), a = Xr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Tr$1(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Dr$1(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = Nr$1(e$1.coordinates, n$1, i$1), a = Zr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Tr$1(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Rr$1(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = qr$1(e$1.coordinates, n$1, i$1), a = Zr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Tr$1(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Ur$1(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let Hr$1 = class {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			};
			function Kr$1(t$1, e$1, r$1 = 0, n$1 = t$1.length - 1, i$1 = Wr$1) {
				for (; n$1 > r$1;) {
					if (n$1 - r$1 > 600) {
						const s$2 = n$1 - r$1 + 1, a$1 = e$1 - r$1 + 1, o$2 = Math.log(s$2), l$1 = .5 * Math.exp(2 * o$2 / 3), u$1 = .5 * Math.sqrt(o$2 * l$1 * (s$2 - l$1) / s$2) * (a$1 - s$2 / 2 < 0 ? -1 : 1);
						Kr$1(t$1, e$1, Math.max(r$1, Math.floor(e$1 - a$1 * l$1 / s$2 + u$1)), Math.min(n$1, Math.floor(e$1 + (s$2 - a$1) * l$1 / s$2 + u$1)), i$1);
					}
					const s$1 = t$1[e$1];
					let a = r$1, o$1 = n$1;
					for (Jr$1(t$1, r$1, e$1), i$1(t$1[n$1], s$1) > 0 && Jr$1(t$1, r$1, n$1); a < o$1;) {
						for (Jr$1(t$1, a, o$1), a++, o$1--; i$1(t$1[a], s$1) < 0;) a++;
						for (; i$1(t$1[o$1], s$1) > 0;) o$1--;
					}
					0 === i$1(t$1[r$1], s$1) ? Jr$1(t$1, r$1, o$1) : (o$1++, Jr$1(t$1, o$1, n$1)), o$1 <= e$1 && (r$1 = o$1 + 1), e$1 <= o$1 && (n$1 = o$1 - 1);
				}
			}
			function Jr$1(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Wr$1(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function Qr$1(t$1, e$1) {
				if (t$1.length <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (const e$2 of t$1) {
					const t$2 = en$1(e$2);
					0 !== t$2 && (e$2.area = Math.abs(t$2), void 0 === i$1 && (i$1 = t$2 < 0), i$1 === t$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [e$2]) : n$1.push(e$2));
				}
				if (n$1 && r$1.push(n$1), e$1 > 1) for (let t$2 = 0; t$2 < r$1.length; t$2++) r$1[t$2].length <= e$1 || (Kr$1(r$1[t$2], e$1, 1, r$1[t$2].length - 1, tn$1), r$1[t$2] = r$1[t$2].slice(0, e$1));
				return r$1;
			}
			function tn$1(t$1, e$1) {
				return e$1.area - t$1.area;
			}
			function en$1(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a = s$1 - 1; i$1 < s$1; a = i$1++) r$1 = t$1[i$1], n$1 = t$1[a], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			const rn$1 = 1 / 298.257223563, nn$1 = rn$1 * (2 - rn$1), sn$1 = Math.PI / 180;
			class an$1 {
				constructor(t$1) {
					const e$1 = 6378.137 * sn$1 * 1e3, r$1 = Math.cos(t$1 * sn$1), n$1 = 1 / (1 - nn$1 * (1 - r$1 * r$1)), i$1 = Math.sqrt(n$1);
					this.kx = e$1 * i$1 * r$1, this.ky = e$1 * i$1 * n$1 * (1 - nn$1);
				}
				distance(t$1, e$1) {
					const r$1 = this.wrap(t$1[0] - e$1[0]) * this.kx, n$1 = (t$1[1] - e$1[1]) * this.ky;
					return Math.sqrt(r$1 * r$1 + n$1 * n$1);
				}
				pointOnLine(t$1, e$1) {
					let r$1, n$1, i$1, s$1, a = Infinity;
					for (let o$1 = 0; o$1 < t$1.length - 1; o$1++) {
						let l$1 = t$1[o$1][0], u$1 = t$1[o$1][1], c$1 = this.wrap(t$1[o$1 + 1][0] - l$1) * this.kx, h$1 = (t$1[o$1 + 1][1] - u$1) * this.ky, p$1 = 0;
						0 === c$1 && 0 === h$1 || (p$1 = (this.wrap(e$1[0] - l$1) * this.kx * c$1 + (e$1[1] - u$1) * this.ky * h$1) / (c$1 * c$1 + h$1 * h$1), p$1 > 1 ? (l$1 = t$1[o$1 + 1][0], u$1 = t$1[o$1 + 1][1]) : p$1 > 0 && (l$1 += c$1 / this.kx * p$1, u$1 += h$1 / this.ky * p$1)), c$1 = this.wrap(e$1[0] - l$1) * this.kx, h$1 = (e$1[1] - u$1) * this.ky;
						const f$1 = c$1 * c$1 + h$1 * h$1;
						f$1 < a && (a = f$1, r$1 = l$1, n$1 = u$1, i$1 = o$1, s$1 = p$1);
					}
					return {
						point: [r$1, n$1],
						index: i$1,
						t: Math.max(0, Math.min(1, s$1))
					};
				}
				wrap(t$1) {
					for (; t$1 < -180;) t$1 += 360;
					for (; t$1 > 180;) t$1 -= 360;
					return t$1;
				}
			}
			function on$1(t$1, e$1) {
				return e$1[0] - t$1[0];
			}
			function ln$1(t$1) {
				return t$1[1] - t$1[0] + 1;
			}
			function un$1(t$1, e$1) {
				return t$1[1] >= t$1[0] && t$1[1] < e$1;
			}
			function cn$1(t$1, e$1) {
				if (t$1[0] > t$1[1]) return [null, null];
				const r$1 = ln$1(t$1);
				if (e$1) {
					if (2 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2);
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2, t$1[1]]];
				}
				if (1 === r$1) return [t$1, null];
				const n$1 = Math.floor(r$1 / 2) - 1;
				return [[t$1[0], t$1[0] + n$1], [t$1[0] + n$1 + 1, t$1[1]]];
			}
			function hn$1(t$1, e$1) {
				if (!un$1(e$1, t$1.length)) return [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				const r$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let n$1 = e$1[0]; n$1 <= e$1[1]; ++n$1) Vr$1(r$1, t$1[n$1]);
				return r$1;
			}
			function pn$1(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (const r$1 of t$1) for (const t$2 of r$1) Vr$1(e$1, t$2);
				return e$1;
			}
			function fn$1(t$1) {
				return t$1[0] !== -Infinity && t$1[1] !== -Infinity && t$1[2] !== Infinity && t$1[3] !== Infinity;
			}
			function dn$1(t$1, e$1, r$1) {
				if (!fn$1(t$1) || !fn$1(e$1)) return NaN;
				let n$1 = 0, i$1 = 0;
				return t$1[2] < e$1[0] && (n$1 = e$1[0] - t$1[2]), t$1[0] > e$1[2] && (n$1 = t$1[0] - e$1[2]), t$1[1] > e$1[3] && (i$1 = t$1[1] - e$1[3]), t$1[3] < e$1[1] && (i$1 = e$1[1] - t$1[3]), r$1.distance([0, 0], [n$1, i$1]);
			}
			function yn$1(t$1, e$1, r$1) {
				const n$1 = r$1.pointOnLine(e$1, t$1);
				return r$1.distance(t$1, n$1.point);
			}
			function mn$1(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.min(yn$1(t$1, [r$1, n$1], i$1), yn$1(e$1, [r$1, n$1], i$1)), a = Math.min(yn$1(r$1, [t$1, e$1], i$1), yn$1(n$1, [t$1, e$1], i$1));
				return Math.min(s$1, a);
			}
			function gn$1(t$1, e$1, r$1, n$1, i$1) {
				if (!un$1(e$1, t$1.length) || !un$1(n$1, r$1.length)) return Infinity;
				let s$1 = Infinity;
				for (let a = e$1[0]; a < e$1[1]; ++a) {
					const e$2 = t$1[a], o$1 = t$1[a + 1];
					for (let t$2 = n$1[0]; t$2 < n$1[1]; ++t$2) {
						const n$2 = r$1[t$2], a$1 = r$1[t$2 + 1];
						if ($r$1(e$2, o$1, n$2, a$1)) return 0;
						s$1 = Math.min(s$1, mn$1(e$2, o$1, n$2, a$1, i$1));
					}
				}
				return s$1;
			}
			function xn$1(t$1, e$1, r$1, n$1, i$1) {
				if (!un$1(e$1, t$1.length) || !un$1(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let a = e$1[0]; a <= e$1[1]; ++a) for (let e$2 = n$1[0]; e$2 <= n$1[1]; ++e$2) if (s$1 = Math.min(s$1, i$1.distance(t$1[a], r$1[e$2])), 0 === s$1) return s$1;
				return s$1;
			}
			function vn$1(t$1, e$1, r$1) {
				if (Or$1(t$1, e$1, !0)) return 0;
				let n$1 = Infinity;
				for (const i$1 of e$1) {
					const e$2 = i$1[0], s$1 = i$1[i$1.length - 1];
					if (e$2 !== s$1 && (n$1 = Math.min(n$1, yn$1(t$1, [s$1, e$2], r$1)), 0 === n$1)) return n$1;
					const a = r$1.pointOnLine(i$1, t$1);
					if (n$1 = Math.min(n$1, r$1.distance(t$1, a.point)), 0 === n$1) return n$1;
				}
				return n$1;
			}
			function bn$1(t$1, e$1, r$1, n$1) {
				if (!un$1(e$1, t$1.length)) return NaN;
				for (let n$2 = e$1[0]; n$2 <= e$1[1]; ++n$2) if (Or$1(t$1[n$2], r$1, !0)) return 0;
				let i$1 = Infinity;
				for (let s$1 = e$1[0]; s$1 < e$1[1]; ++s$1) {
					const e$2 = t$1[s$1], a = t$1[s$1 + 1];
					for (const t$2 of r$1) for (let r$2 = 0, s$2 = t$2.length, o$1 = s$2 - 1; r$2 < s$2; o$1 = r$2++) {
						const s$3 = t$2[o$1], l$1 = t$2[r$2];
						if ($r$1(e$2, a, s$3, l$1)) return 0;
						i$1 = Math.min(i$1, mn$1(e$2, a, s$3, l$1, n$1));
					}
				}
				return i$1;
			}
			function wn$1(t$1, e$1) {
				for (const r$1 of t$1) for (const t$2 of r$1) if (Or$1(t$2, e$1, !0)) return !0;
				return !1;
			}
			function _n$1(t$1, e$1, r$1, n$1 = Infinity) {
				const i$1 = pn$1(t$1), s$1 = pn$1(e$1);
				if (n$1 !== Infinity && dn$1(i$1, s$1, r$1) >= n$1) return n$1;
				if (Tr$1(i$1, s$1)) {
					if (wn$1(t$1, e$1)) return 0;
				} else if (wn$1(e$1, t$1)) return 0;
				let a = Infinity;
				for (const n$2 of t$1) for (let t$2 = 0, i$2 = n$2.length, s$2 = i$2 - 1; t$2 < i$2; s$2 = t$2++) {
					const i$3 = n$2[s$2], o$1 = n$2[t$2];
					for (const t$3 of e$1) for (let e$2 = 0, n$3 = t$3.length, s$3 = n$3 - 1; e$2 < n$3; s$3 = e$2++) {
						const n$4 = t$3[s$3], l$1 = t$3[e$2];
						if ($r$1(i$3, o$1, n$4, l$1)) return 0;
						a = Math.min(a, mn$1(i$3, o$1, n$4, l$1, r$1));
					}
				}
				return a;
			}
			function Sn$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!s$1) return;
				const a = dn$1(hn$1(n$1, s$1), i$1, r$1);
				a < e$1 && t$1.push([
					a,
					s$1,
					[0, 0]
				]);
			}
			function An$1(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (!s$1 || !a) return;
				const o$1 = dn$1(hn$1(n$1, s$1), hn$1(i$1, a), r$1);
				o$1 < e$1 && t$1.push([
					o$1,
					s$1,
					a
				]);
			}
			function kn$1(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = Math.min(n$1.distance(t$1[0], r$1[0][0]), i$1);
				if (0 === s$1) return s$1;
				const a = new Hr$1([[
					0,
					[0, t$1.length - 1],
					[0, 0]
				]], on$1), o$1 = pn$1(r$1);
				for (; a.length > 0;) {
					const i$2 = a.pop();
					if (i$2[0] >= s$1) continue;
					const l$1 = i$2[1], u$1 = e$1 ? 50 : 100;
					if (ln$1(l$1) <= u$1) {
						if (!un$1(l$1, t$1.length)) return NaN;
						if (e$1) {
							const e$2 = bn$1(t$1, l$1, r$1, n$1);
							if (isNaN(e$2) || 0 === e$2) return e$2;
							s$1 = Math.min(s$1, e$2);
						} else for (let e$2 = l$1[0]; e$2 <= l$1[1]; ++e$2) {
							const i$3 = vn$1(t$1[e$2], r$1, n$1);
							if (s$1 = Math.min(s$1, i$3), 0 === s$1) return 0;
						}
					} else {
						const r$2 = cn$1(l$1, e$1);
						Sn$1(a, s$1, n$1, t$1, o$1, r$2[0]), Sn$1(a, s$1, n$1, t$1, o$1, r$2[1]);
					}
				}
				return s$1;
			}
			function Mn$1(t$1, e$1, r$1, n$1, i$1, s$1 = Infinity) {
				let a = Math.min(s$1, i$1.distance(t$1[0], r$1[0]));
				if (0 === a) return a;
				const o$1 = new Hr$1([[
					0,
					[0, t$1.length - 1],
					[0, r$1.length - 1]
				]], on$1);
				for (; o$1.length > 0;) {
					const s$2 = o$1.pop();
					if (s$2[0] >= a) continue;
					const l$1 = s$2[1], u$1 = s$2[2], c$1 = e$1 ? 50 : 100, h$1 = n$1 ? 50 : 100;
					if (ln$1(l$1) <= c$1 && ln$1(u$1) <= h$1) {
						if (!un$1(l$1, t$1.length) && un$1(u$1, r$1.length)) return NaN;
						let s$3;
						if (e$1 && n$1) s$3 = gn$1(t$1, l$1, r$1, u$1, i$1), a = Math.min(a, s$3);
						else if (e$1 && !n$1) {
							const e$2 = t$1.slice(l$1[0], l$1[1] + 1);
							for (let t$2 = u$1[0]; t$2 <= u$1[1]; ++t$2) if (s$3 = yn$1(r$1[t$2], e$2, i$1), a = Math.min(a, s$3), 0 === a) return a;
						} else if (!e$1 && n$1) {
							const e$2 = r$1.slice(u$1[0], u$1[1] + 1);
							for (let r$2 = l$1[0]; r$2 <= l$1[1]; ++r$2) if (s$3 = yn$1(t$1[r$2], e$2, i$1), a = Math.min(a, s$3), 0 === a) return a;
						} else s$3 = xn$1(t$1, l$1, r$1, u$1, i$1), a = Math.min(a, s$3);
					} else {
						const s$3 = cn$1(l$1, e$1), c$2 = cn$1(u$1, n$1);
						An$1(o$1, a, i$1, t$1, r$1, s$3[0], c$2[0]), An$1(o$1, a, i$1, t$1, r$1, s$3[0], c$2[1]), An$1(o$1, a, i$1, t$1, r$1, s$3[1], c$2[0]), An$1(o$1, a, i$1, t$1, r$1, s$3[1], c$2[1]);
					}
				}
				return a;
			}
			function In$1(t$1) {
				return "MultiPolygon" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Polygon",
					coordinates: t$2
				}))) : "MultiLineString" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "LineString",
					coordinates: t$2
				}))) : "MultiPoint" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Point",
					coordinates: t$2
				}))) : [t$1];
			}
			class zn$1 {
				constructor(t$1, e$1) {
					this.type = Ft, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'distance' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (Re$1(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) return new zn$1(e$2, e$2.features.map(((t$2) => In$1(t$2.geometry))).flat());
						if ("Feature" === e$2.type) return new zn$1(e$2, In$1(e$2.geometry));
						if ("type" in e$2 && "coordinates" in e$2) return new zn$1(e$2, In$1(e$2));
					}
					return e$1.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Br$1([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an$1(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Mn$1(n$1, !1, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Mn$1(n$1, !1, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, kn$1(n$1, !1, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Br$1([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an$1(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Mn$1(n$1, !0, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Mn$1(n$1, !0, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, kn$1(n$1, !0, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("Polygon" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry();
							if (0 === r$1.length || 0 === r$1[0].length) return NaN;
							const n$1 = Qr$1(r$1, 0).map(((e$2) => e$2.map(((e$3) => e$3.map(((e$4) => Br$1([e$4.x, e$4.y], t$2.canonical))))))), i$1 = new an$1(n$1[0][0][0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) for (const e$2 of n$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, kn$1([t$3.coordinates], !1, e$2, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, kn$1(t$3.coordinates, !0, e$2, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, _n$1(e$2, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
					}
					return NaN;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			class Pn$1 {
				constructor(t$1) {
					this.type = Ut$1, this.key = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = t$1[1];
					return null == r$1 ? e$1.error("Global state property must be defined.") : "string" != typeof r$1 ? e$1.error(`Global state property must be string, but found ${typeof t$1[1]} instead.`) : new Pn$1(r$1);
				}
				evaluate(t$1) {
					var e$1;
					const r$1 = null === (e$1 = t$1.globals) || void 0 === e$1 ? void 0 : e$1.globalState;
					return r$1 && 0 !== Object.keys(r$1).length ? xe$1(r$1, this.key) : null;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			const Cn$1 = {
				"==": vr$1,
				"!=": br$1,
				">": _r$1,
				"<": wr$1,
				">=": Ar$1,
				"<=": Sr$1,
				array: Ge$1,
				at: Qe$1,
				boolean: Ge$1,
				case: nr$1,
				coalesce: yr$1,
				collator: kr$1,
				format: Ir$1,
				image: zr$1,
				in: tr$1,
				"index-of": er$1,
				interpolate: pr$1,
				"interpolate-hcl": pr$1,
				"interpolate-lab": pr$1,
				length: Pr$1,
				let: Je$1,
				literal: Ne$1,
				match: rr$1,
				number: Ge$1,
				"number-format": Mr$1,
				object: Ge$1,
				slice: ir$1,
				step: ar$1,
				string: Ge$1,
				"to-boolean": Ze$1,
				"to-color": Ze$1,
				"to-number": Ze$1,
				"to-string": Ze$1,
				var: We$1,
				within: Yr$1,
				distance: zn$1,
				"global-state": Pn$1
			};
			class En$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.name = t$1, this.type = e$1, this._evaluate = r$1, this.args = n$1;
				}
				evaluate(t$1) {
					return this._evaluate(t$1, this.args);
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return !1;
				}
				static parse(t$1, e$1) {
					const r$1 = t$1[0], n$1 = En$1.definitions[r$1];
					if (!n$1) return e$1.error(`Unknown expression "${r$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					const i$1 = Array.isArray(n$1) ? n$1[0] : n$1.type, s$1 = Array.isArray(n$1) ? [[n$1[1], n$1[2]]] : n$1.overloads, a = s$1.filter((([e$2]) => !Array.isArray(e$2) || e$2.length === t$1.length - 1));
					let o$1 = null;
					for (const [n$2, s$2] of a) {
						o$1 = new Ke$1(e$1.registry, $n$1, e$1.path, null, e$1.scope);
						const a$1 = [];
						let l$1 = !1;
						for (let e$2 = 1; e$2 < t$1.length; e$2++) {
							const r$2 = t$1[e$2], i$2 = Array.isArray(n$2) ? n$2[e$2 - 1] : n$2.type, s$3 = o$1.parse(r$2, 1 + a$1.length, i$2);
							if (!s$3) {
								l$1 = !0;
								break;
							}
							a$1.push(s$3);
						}
						if (!l$1) if (Array.isArray(n$2) && n$2.length !== a$1.length) o$1.error(`Expected ${n$2.length} arguments, but found ${a$1.length} instead.`);
						else {
							for (let t$2 = 0; t$2 < a$1.length; t$2++) {
								const e$2 = Array.isArray(n$2) ? n$2[t$2] : n$2.type, r$2 = a$1[t$2];
								o$1.concat(t$2 + 1).checkSubtype(e$2, r$2.type);
							}
							if (0 === o$1.errors.length) return new En$1(r$1, i$1, s$2, a$1);
						}
					}
					if (1 === a.length) e$1.errors.push(...o$1.errors);
					else {
						const r$2 = (a.length ? a : s$1).map((([t$2]) => {
							return e$2 = t$2, Array.isArray(e$2) ? `(${e$2.map(Kt$1).join(", ")})` : `(${Kt$1(e$2.type)}...)`;
							var e$2;
						})).join(" | "), n$2 = [];
						for (let r$3 = 1; r$3 < t$1.length; r$3++) {
							const i$2 = e$1.parse(t$1[r$3], 1 + n$2.length);
							if (!i$2) return null;
							n$2.push(Kt$1(i$2.type));
						}
						e$1.error(`Expected arguments of type ${r$2}, but found (${n$2.join(", ")}) instead.`);
					}
					return null;
				}
				static register(t$1, e$1) {
					En$1.definitions = e$1;
					for (const r$1 in e$1) t$1[r$1] = En$1;
				}
			}
			function Bn(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, a = De$1(e$1, r$1, n$1, s$1);
				if (a) throw new Te$1(a);
				return new Me$1(e$1 / 255, r$1 / 255, n$1 / 255, s$1, !1);
			}
			function Vn(t$1, e$1) {
				return t$1 in e$1;
			}
			function Tn$1(t$1, e$1) {
				const r$1 = e$1[t$1];
				return void 0 === r$1 ? null : r$1;
			}
			function Fn$1(t$1) {
				return { type: t$1 };
			}
			function $n$1(t$1) {
				if (t$1 instanceof We$1) return $n$1(t$1.boundExpression);
				if (t$1 instanceof En$1 && "error" === t$1.name) return !1;
				if (t$1 instanceof kr$1) return !1;
				if (t$1 instanceof Yr$1) return !1;
				if (t$1 instanceof zn$1) return !1;
				if (t$1 instanceof Pn$1) return !1;
				const e$1 = t$1 instanceof Ze$1 || t$1 instanceof Ge$1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 = e$1 ? r$1 && $n$1(t$2) : r$1 && t$2 instanceof Ne$1;
				})), !!r$1 && Ln$1(t$1) && Dn(t$1, [
					"zoom",
					"heatmap-density",
					"elevation",
					"line-progress",
					"accumulated",
					"is-supported-script"
				]);
			}
			function Ln$1(t$1) {
				if (t$1 instanceof En$1) {
					if ("get" === t$1.name && 1 === t$1.args.length) return !1;
					if ("feature-state" === t$1.name) return !1;
					if ("has" === t$1.name && 1 === t$1.args.length) return !1;
					if ("properties" === t$1.name || "geometry-type" === t$1.name || "id" === t$1.name) return !1;
					if (/^filter-/.test(t$1.name)) return !1;
				}
				if (t$1 instanceof Yr$1) return !1;
				if (t$1 instanceof zn$1) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !Ln$1(t$2) && (e$1 = !1);
				})), e$1;
			}
			function On$1(t$1) {
				if (t$1 instanceof En$1 && "feature-state" === t$1.name) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !On$1(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Dn(t$1, e$1) {
				if (t$1 instanceof En$1 && e$1.indexOf(t$1.name) >= 0) return !1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 && !Dn(t$2, e$1) && (r$1 = !1);
				})), r$1;
			}
			function Rn$1(t$1) {
				return {
					result: "success",
					value: t$1
				};
			}
			function Un(t$1) {
				return {
					result: "error",
					value: t$1
				};
			}
			function jn(t$1) {
				return "data-driven" === t$1["property-type"] || "cross-faded-data-driven" === t$1["property-type"];
			}
			function Nn$1(t$1) {
				return !!t$1.expression && t$1.expression.parameters.indexOf("zoom") > -1;
			}
			function qn(t$1) {
				return !!t$1.expression && t$1.expression.interpolated;
			}
			function Gn(t$1) {
				return t$1 instanceof Number ? "number" : t$1 instanceof String ? "string" : t$1 instanceof Boolean ? "boolean" : Array.isArray(t$1) ? "array" : null === t$1 ? "null" : typeof t$1;
			}
			function Xn(t$1) {
				return "object" == typeof t$1 && null !== t$1 && !Array.isArray(t$1) && Ue$1(t$1) === Rt$1;
			}
			function Zn(t$1) {
				return t$1;
			}
			function Yn$1(t$1, e$1) {
				const r$1 = t$1.stops && "object" == typeof t$1.stops[0][0], n$1 = r$1 || !(r$1 || void 0 !== t$1.property), i$1 = t$1.type || (qn(e$1) ? "exponential" : "interval"), s$1 = function(t$2) {
					switch (t$2.type) {
						case "color": return Me$1.parse;
						case "padding": return Ee.parse;
						case "numberArray": return Be$1.parse;
						case "colorArray": return Ve$1.parse;
						default: return null;
					}
				}(e$1);
				if (s$1 && ((t$1 = Et$1({}, t$1)).stops && (t$1.stops = t$1.stops.map(((t$2) => [t$2[0], s$1(t$2[1])]))), t$1.default = s$1(t$1.default ? t$1.default : e$1.default)), t$1.colorSpace && "rgb" !== (a = t$1.colorSpace) && "hcl" !== a && "lab" !== a) throw new Error(`Unknown color space: "${t$1.colorSpace}"`);
				var a;
				const o$1 = function(t$2) {
					switch (t$2) {
						case "exponential": return Wn$1;
						case "interval": return Jn$1;
						case "categorical": return Kn;
						case "identity": return Qn$1;
						default: throw new Error(`Unknown function type "${t$2}"`);
					}
				}(i$1);
				let l$1, u$1;
				if ("categorical" === i$1) {
					l$1 = Object.create(null);
					for (const e$2 of t$1.stops) l$1[e$2[0]] = e$2[1];
					u$1 = typeof t$1.stops[0][0];
				}
				if (r$1) {
					const r$2 = {}, n$2 = [];
					for (let e$2 = 0; e$2 < t$1.stops.length; e$2++) {
						const i$3 = t$1.stops[e$2], s$3 = i$3[0].zoom;
						void 0 === r$2[s$3] && (r$2[s$3] = {
							zoom: s$3,
							type: t$1.type,
							property: t$1.property,
							default: t$1.default,
							stops: []
						}, n$2.push(s$3)), r$2[s$3].stops.push([i$3[0].value, i$3[1]]);
					}
					const i$2 = [];
					for (const t$2 of n$2) i$2.push([r$2[t$2].zoom, Yn$1(r$2[t$2], e$1)]);
					const s$2 = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: s$2,
						interpolationFactor: pr$1.interpolationFactor.bind(void 0, s$2),
						zoomStops: i$2.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }, n$3) => Wn$1({
							stops: i$2,
							base: t$1.base
						}, e$1, r$3).evaluate(r$3, n$3)
					};
				}
				if (n$1) {
					const r$2 = "exponential" === i$1 ? {
						name: "exponential",
						base: void 0 !== t$1.base ? t$1.base : 1
					} : null;
					return {
						kind: "camera",
						interpolationType: r$2,
						interpolationFactor: pr$1.interpolationFactor.bind(void 0, r$2),
						zoomStops: t$1.stops.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }) => o$1(t$1, e$1, r$3, l$1, u$1)
					};
				}
				return {
					kind: "source",
					evaluate(r$2, n$2) {
						const i$2 = n$2 && n$2.properties ? n$2.properties[t$1.property] : void 0;
						return void 0 === i$2 ? Hn$1(t$1.default, e$1.default) : o$1(t$1, e$1, i$2, l$1, u$1);
					}
				};
			}
			function Hn$1(t$1, e$1, r$1) {
				return void 0 !== t$1 ? t$1 : void 0 !== e$1 ? e$1 : void 0 !== r$1 ? r$1 : void 0;
			}
			function Kn(t$1, e$1, r$1, n$1, i$1) {
				return Hn$1(typeof r$1 === i$1 ? n$1[r$1] : void 0, t$1.default, e$1.default);
			}
			function Jn$1(t$1, e$1, r$1) {
				if ("number" !== Gn(r$1)) return Hn$1(t$1.default, e$1.default);
				const n$1 = t$1.stops.length;
				if (1 === n$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[n$1 - 1][0]) return t$1.stops[n$1 - 1][1];
				const i$1 = sr$1(t$1.stops.map(((t$2) => t$2[0])), r$1);
				return t$1.stops[i$1][1];
			}
			function Wn$1(t$1, e$1, r$1) {
				const n$1 = void 0 !== t$1.base ? t$1.base : 1;
				if ("number" !== Gn(r$1)) return Hn$1(t$1.default, e$1.default);
				const i$1 = t$1.stops.length;
				if (1 === i$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[i$1 - 1][0]) return t$1.stops[i$1 - 1][1];
				const s$1 = sr$1(t$1.stops.map(((t$2) => t$2[0])), r$1), a = function(t$2, e$2, r$2, n$2) {
					const i$2 = n$2 - r$2, s$2 = t$2 - r$2;
					return 0 === i$2 ? 0 : 1 === e$2 ? s$2 / i$2 : (Math.pow(e$2, s$2) - 1) / (Math.pow(e$2, i$2) - 1);
				}(r$1, n$1, t$1.stops[s$1][0], t$1.stops[s$1 + 1][0]), o$1 = t$1.stops[s$1][1], l$1 = t$1.stops[s$1 + 1][1], u$1 = dr$1[e$1.type] || Zn;
				return "function" == typeof o$1.evaluate ? { evaluate(...e$2) {
					const r$2 = o$1.evaluate.apply(void 0, e$2), n$2 = l$1.evaluate.apply(void 0, e$2);
					if (void 0 !== r$2 && void 0 !== n$2) return u$1(r$2, n$2, a, t$1.colorSpace);
				} } : u$1(o$1, l$1, a, t$1.colorSpace);
			}
			function Qn$1(t$1, e$1, r$1) {
				switch (e$1.type) {
					case "color":
						r$1 = Me$1.parse(r$1);
						break;
					case "formatted":
						r$1 = Ce.fromString(r$1.toString());
						break;
					case "resolvedImage":
						r$1 = Le.fromString(r$1.toString());
						break;
					case "padding":
						r$1 = Ee.parse(r$1);
						break;
					case "colorArray":
						r$1 = Ve$1.parse(r$1);
						break;
					case "numberArray":
						r$1 = Be$1.parse(r$1);
						break;
					default: Gn(r$1) === e$1.type || "enum" === e$1.type && e$1.values[r$1] || (r$1 = void 0);
				}
				return Hn$1(r$1, t$1.default, e$1.default);
			}
			En$1.register(Cn$1, {
				error: [
					{ kind: "error" },
					[$t],
					(t$1, [e$1]) => {
						throw new Te$1(e$1.evaluate(t$1));
					}
				],
				typeof: [
					$t,
					[Ut$1],
					(t$1, [e$1]) => Kt$1(Ue$1(e$1.evaluate(t$1)))
				],
				"to-rgba": [
					Ht$1(Ft, 4),
					[Ot],
					(t$1, [e$1]) => {
						const [r$1, n$1, i$1, s$1] = e$1.evaluate(t$1).rgb;
						return [
							255 * r$1,
							255 * n$1,
							255 * i$1,
							s$1
						];
					}
				],
				rgb: [
					Ot,
					[
						Ft,
						Ft,
						Ft
					],
					Bn
				],
				rgba: [
					Ot,
					[
						Ft,
						Ft,
						Ft,
						Ft
					],
					Bn
				],
				has: {
					type: Lt$1,
					overloads: [[[$t], (t$1, [e$1]) => Vn(e$1.evaluate(t$1), t$1.properties())], [[$t, Rt$1], (t$1, [e$1, r$1]) => Vn(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				get: {
					type: Ut$1,
					overloads: [[[$t], (t$1, [e$1]) => Tn$1(e$1.evaluate(t$1), t$1.properties())], [[$t, Rt$1], (t$1, [e$1, r$1]) => Tn$1(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				"feature-state": [
					Ut$1,
					[$t],
					(t$1, [e$1]) => Tn$1(e$1.evaluate(t$1), t$1.featureState || {})
				],
				properties: [
					Rt$1,
					[],
					(t$1) => t$1.properties()
				],
				"geometry-type": [
					$t,
					[],
					(t$1) => t$1.geometryType()
				],
				id: [
					Ut$1,
					[],
					(t$1) => t$1.id()
				],
				zoom: [
					Ft,
					[],
					(t$1) => t$1.globals.zoom
				],
				"heatmap-density": [
					Ft,
					[],
					(t$1) => t$1.globals.heatmapDensity || 0
				],
				elevation: [
					Ft,
					[],
					(t$1) => t$1.globals.elevation || 0
				],
				"line-progress": [
					Ft,
					[],
					(t$1) => t$1.globals.lineProgress || 0
				],
				accumulated: [
					Ut$1,
					[],
					(t$1) => void 0 === t$1.globals.accumulated ? null : t$1.globals.accumulated
				],
				"+": [
					Ft,
					Fn$1(Ft),
					(t$1, e$1) => {
						let r$1 = 0;
						for (const n$1 of e$1) r$1 += n$1.evaluate(t$1);
						return r$1;
					}
				],
				"*": [
					Ft,
					Fn$1(Ft),
					(t$1, e$1) => {
						let r$1 = 1;
						for (const n$1 of e$1) r$1 *= n$1.evaluate(t$1);
						return r$1;
					}
				],
				"-": {
					type: Ft,
					overloads: [[[Ft, Ft], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) - r$1.evaluate(t$1)], [[Ft], (t$1, [e$1]) => -e$1.evaluate(t$1)]]
				},
				"/": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) / r$1.evaluate(t$1)
				],
				"%": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) % r$1.evaluate(t$1)
				],
				ln2: [
					Ft,
					[],
					() => Math.LN2
				],
				pi: [
					Ft,
					[],
					() => Math.PI
				],
				e: [
					Ft,
					[],
					() => Math.E
				],
				"^": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => Math.pow(e$1.evaluate(t$1), r$1.evaluate(t$1))
				],
				sqrt: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.sqrt(e$1.evaluate(t$1))
				],
				log10: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN10
				],
				ln: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1))
				],
				log2: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN2
				],
				sin: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.sin(e$1.evaluate(t$1))
				],
				cos: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.cos(e$1.evaluate(t$1))
				],
				tan: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.tan(e$1.evaluate(t$1))
				],
				asin: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.asin(e$1.evaluate(t$1))
				],
				acos: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.acos(e$1.evaluate(t$1))
				],
				atan: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.atan(e$1.evaluate(t$1))
				],
				min: [
					Ft,
					Fn$1(Ft),
					(t$1, e$1) => Math.min(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				max: [
					Ft,
					Fn$1(Ft),
					(t$1, e$1) => Math.max(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				abs: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.abs(e$1.evaluate(t$1))
				],
				round: [
					Ft,
					[Ft],
					(t$1, [e$1]) => {
						const r$1 = e$1.evaluate(t$1);
						return r$1 < 0 ? -Math.round(-r$1) : Math.round(r$1);
					}
				],
				floor: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.floor(e$1.evaluate(t$1))
				],
				ceil: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.ceil(e$1.evaluate(t$1))
				],
				"filter-==": [
					Lt$1,
					[$t, Ut$1],
					(t$1, [e$1, r$1]) => t$1.properties()[e$1.value] === r$1.value
				],
				"filter-id-==": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => t$1.id() === e$1.value
				],
				"filter-type-==": [
					Lt$1,
					[$t],
					(t$1, [e$1]) => t$1.geometryType() === e$1.value
				],
				"filter-<": [
					Lt$1,
					[$t, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 < i$1;
					}
				],
				"filter-id-<": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 < n$1;
					}
				],
				"filter->": [
					Lt$1,
					[$t, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 > i$1;
					}
				],
				"filter-id->": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 > n$1;
					}
				],
				"filter-<=": [
					Lt$1,
					[$t, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 <= i$1;
					}
				],
				"filter-id-<=": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 <= n$1;
					}
				],
				"filter->=": [
					Lt$1,
					[$t, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 >= i$1;
					}
				],
				"filter-id->=": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 >= n$1;
					}
				],
				"filter-has": [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => e$1.value in t$1.properties()
				],
				"filter-has-id": [
					Lt$1,
					[],
					(t$1) => null !== t$1.id() && void 0 !== t$1.id()
				],
				"filter-type-in": [
					Lt$1,
					[Ht$1($t)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.geometryType()) >= 0
				],
				"filter-id-in": [
					Lt$1,
					[Ht$1(Ut$1)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.id()) >= 0
				],
				"filter-in-small": [
					Lt$1,
					[$t, Ht$1(Ut$1)],
					(t$1, [e$1, r$1]) => r$1.value.indexOf(t$1.properties()[e$1.value]) >= 0
				],
				"filter-in-large": [
					Lt$1,
					[$t, Ht$1(Ut$1)],
					(t$1, [e$1, r$1]) => function(t$2, e$2, r$2, n$1) {
						for (; r$2 <= n$1;) {
							const i$1 = r$2 + n$1 >> 1;
							if (e$2[i$1] === t$2) return !0;
							e$2[i$1] > t$2 ? n$1 = i$1 - 1 : r$2 = i$1 + 1;
						}
						return !1;
					}(t$1.properties()[e$1.value], r$1.value, 0, r$1.value.length - 1)
				],
				all: {
					type: Lt$1,
					overloads: [[[Lt$1, Lt$1], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) && r$1.evaluate(t$1)], [Fn$1(Lt$1), (t$1, e$1) => {
						for (const r$1 of e$1) if (!r$1.evaluate(t$1)) return !1;
						return !0;
					}]]
				},
				any: {
					type: Lt$1,
					overloads: [[[Lt$1, Lt$1], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) || r$1.evaluate(t$1)], [Fn$1(Lt$1), (t$1, e$1) => {
						for (const r$1 of e$1) if (r$1.evaluate(t$1)) return !0;
						return !1;
					}]]
				},
				"!": [
					Lt$1,
					[Lt$1],
					(t$1, [e$1]) => !e$1.evaluate(t$1)
				],
				"is-supported-script": [
					Lt$1,
					[$t],
					(t$1, [e$1]) => {
						const r$1 = t$1.globals && t$1.globals.isSupportedScript;
						return !r$1 || r$1(e$1.evaluate(t$1));
					}
				],
				upcase: [
					$t,
					[$t],
					(t$1, [e$1]) => e$1.evaluate(t$1).toUpperCase()
				],
				downcase: [
					$t,
					[$t],
					(t$1, [e$1]) => e$1.evaluate(t$1).toLowerCase()
				],
				concat: [
					$t,
					Fn$1(Ut$1),
					(t$1, e$1) => e$1.map(((e$2) => je$1(e$2.evaluate(t$1)))).join("")
				],
				"resolved-locale": [
					$t,
					[jt],
					(t$1, [e$1]) => e$1.evaluate(t$1).resolvedLocale()
				]
			});
			class ti$1 {
				constructor(t$1, e$1) {
					this.expression = t$1, this._warningHistory = {}, this._evaluator = new He$1(), this._defaultValue = e$1 ? function(t$2) {
						if ("color" === t$2.type && Xn(t$2.default)) return new Me$1(0, 0, 0, 0);
						switch (t$2.type) {
							case "color": return Me$1.parse(t$2.default) || null;
							case "padding": return Ee.parse(t$2.default) || null;
							case "numberArray": return Be$1.parse(t$2.default) || null;
							case "colorArray": return Ve$1.parse(t$2.default) || null;
							case "variableAnchorOffsetCollection": return $e$1.parse(t$2.default) || null;
							case "projectionDefinition": return Oe$1.parse(t$2.default) || null;
							default: return void 0 === t$2.default ? null : t$2.default;
						}
					}(e$1) : null, this._enumValues = e$1 && "enum" === e$1.type ? e$1.values : null;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._evaluator.globals = t$1, this._evaluator.feature = e$1, this._evaluator.featureState = r$1, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1, this.expression.evaluate(this._evaluator);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					this._evaluator.globals = t$1, this._evaluator.feature = e$1 || null, this._evaluator.featureState = r$1 || null, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1 || null;
					try {
						const t$2 = this.expression.evaluate(this._evaluator);
						if (null == t$2 || "number" == typeof t$2 && t$2 != t$2) return this._defaultValue;
						if (this._enumValues && !(t$2 in this._enumValues)) throw new Te$1(`Expected value to be one of ${Object.keys(this._enumValues).map(((t$3) => JSON.stringify(t$3))).join(", ")}, but found ${JSON.stringify(t$2)} instead.`);
						return t$2;
					} catch (t$2) {
						return this._warningHistory[t$2.message] || (this._warningHistory[t$2.message] = !0, "undefined" != typeof console && console.warn(t$2.message)), this._defaultValue;
					}
				}
			}
			function ei$1(t$1) {
				return Array.isArray(t$1) && t$1.length > 0 && "string" == typeof t$1[0] && t$1[0] in Cn$1;
			}
			function ri$1(t$1, e$1) {
				const r$1 = new Ke$1(Cn$1, $n$1, [], e$1 ? function(t$2) {
					const e$2 = {
						color: Ot,
						string: $t,
						number: Ft,
						enum: $t,
						boolean: Lt$1,
						formatted: Nt,
						padding: qt$1,
						numberArray: Xt$1,
						colorArray: Gt$1,
						projectionDefinition: Dt,
						resolvedImage: Zt$1,
						variableAnchorOffsetCollection: Yt$1
					};
					return "array" === t$2.type ? Ht$1(e$2[t$2.value] || Ut$1, t$2.length) : e$2[t$2.type];
				}(e$1) : void 0), n$1 = r$1.parse(t$1, void 0, void 0, void 0, e$1 && "string" === e$1.type ? { typeAnnotation: "coerce" } : void 0);
				return n$1 ? Rn$1(new ti$1(n$1, e$1)) : Un(r$1.errors);
			}
			class ni$1 {
				constructor(t$1, e$1) {
					this.kind = t$1, this._styleExpression = e$1, this.isStateDependent = "constant" !== t$1 && !On$1(e$1.expression), this.globalStateRefs = li$1(e$1.expression);
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
			}
			class ii$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.kind = t$1, this.zoomStops = r$1, this._styleExpression = e$1, this.isStateDependent = "camera" !== t$1 && !On$1(e$1.expression), this.globalStateRefs = li$1(e$1.expression), this.interpolationType = n$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				interpolationFactor(t$1, e$1, r$1) {
					return this.interpolationType ? pr$1.interpolationFactor(this.interpolationType, t$1, e$1, r$1) : 0;
				}
			}
			function si$1(t$1, e$1) {
				const r$1 = ri$1(t$1, e$1);
				if ("error" === r$1.result) return r$1;
				const n$1 = r$1.value.expression, i$1 = Ln$1(n$1);
				if (!i$1 && !jn(e$1)) return Un([new Bt$1("", "data expressions not supported")]);
				const s$1 = Dn(n$1, ["zoom"]);
				if (!s$1 && !Nn$1(e$1)) return Un([new Bt$1("", "zoom expressions not supported")]);
				const a = oi$1(n$1);
				return a || s$1 ? a instanceof Bt$1 ? Un([a]) : a instanceof pr$1 && !qn(e$1) ? Un([new Bt$1("", "\"interpolate\" expressions cannot be used with this property")]) : Rn$1(a ? new ii$1(i$1 ? "camera" : "composite", r$1.value, a.labels, a instanceof pr$1 ? a.interpolation : void 0) : new ni$1(i$1 ? "constant" : "source", r$1.value)) : Un([new Bt$1("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
			}
			class ai$1 {
				constructor(t$1, e$1) {
					this._parameters = t$1, this._specification = e$1, Et$1(this, Yn$1(this._parameters, this._specification));
				}
				static deserialize(t$1) {
					return new ai$1(t$1._parameters, t$1._specification);
				}
				static serialize(t$1) {
					return {
						_parameters: t$1._parameters,
						_specification: t$1._specification
					};
				}
			}
			function oi$1(t$1) {
				let e$1 = null;
				if (t$1 instanceof Je$1) e$1 = oi$1(t$1.result);
				else if (t$1 instanceof yr$1) {
					for (const r$1 of t$1.args) if (e$1 = oi$1(r$1), e$1) break;
				} else (t$1 instanceof ar$1 || t$1 instanceof pr$1) && t$1.input instanceof En$1 && "zoom" === t$1.input.name && (e$1 = t$1);
				return e$1 instanceof Bt$1 || t$1.eachChild(((t$2) => {
					const r$1 = oi$1(t$2);
					r$1 instanceof Bt$1 ? e$1 = r$1 : !e$1 && r$1 ? e$1 = new Bt$1("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e$1 && r$1 && e$1 !== r$1 && (e$1 = new Bt$1("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), e$1;
			}
			function li$1(t$1, e$1 = /* @__PURE__ */ new Set()) {
				return t$1 instanceof Pn$1 && e$1.add(t$1.key), t$1.eachChild(((t$2) => {
					li$1(t$2, e$1);
				})), e$1;
			}
			function ui$1(t$1) {
				if (!0 === t$1 || !1 === t$1) return !0;
				if (!Array.isArray(t$1) || 0 === t$1.length) return !1;
				switch (t$1[0]) {
					case "has": return t$1.length >= 2 && "$id" !== t$1[1] && "$type" !== t$1[1];
					case "in": return t$1.length >= 3 && ("string" != typeof t$1[1] || Array.isArray(t$1[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return 3 !== t$1.length || Array.isArray(t$1[1]) || Array.isArray(t$1[2]);
					case "any":
					case "all":
						for (const e$1 of t$1.slice(1)) if (!ui$1(e$1) && "boolean" != typeof e$1) return !1;
						return !0;
					default: return !0;
				}
			}
			const ci$1 = {
				type: "boolean",
				default: !1,
				transition: !1,
				"property-type": "data-driven",
				expression: {
					interpolated: !1,
					parameters: ["zoom", "feature"]
				}
			};
			function hi$1(t$1) {
				if (null == t$1) return {
					filter: () => !0,
					needGeometry: !1,
					getGlobalStateRefs: () => /* @__PURE__ */ new Set()
				};
				ui$1(t$1) || (t$1 = di$1(t$1));
				const e$1 = ri$1(t$1, ci$1);
				if ("error" === e$1.result) throw new Error(e$1.value.map(((t$2) => `${t$2.key}: ${t$2.message}`)).join(", "));
				return {
					filter: (t$2, r$1, n$1) => e$1.value.evaluate(t$2, r$1, {}, n$1),
					needGeometry: fi$1(t$1),
					getGlobalStateRefs: () => li$1(e$1.value.expression)
				};
			}
			function pi$1(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function fi$1(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("within" === t$1[0] || "distance" === t$1[0]) return !0;
				for (let e$1 = 1; e$1 < t$1.length; e$1++) if (fi$1(t$1[e$1])) return !0;
				return !1;
			}
			function di$1(t$1) {
				if (!t$1) return !0;
				const e$1 = t$1[0];
				return t$1.length <= 1 ? "any" !== e$1 : "==" === e$1 ? yi$1(t$1[1], t$1[2], "==") : "!=" === e$1 ? xi$1(yi$1(t$1[1], t$1[2], "==")) : "<" === e$1 || ">" === e$1 || "<=" === e$1 || ">=" === e$1 ? yi$1(t$1[1], t$1[2], e$1) : "any" === e$1 ? (r$1 = t$1.slice(1), ["any"].concat(r$1.map(di$1))) : "all" === e$1 ? ["all"].concat(t$1.slice(1).map(di$1)) : "none" === e$1 ? ["all"].concat(t$1.slice(1).map(di$1).map(xi$1)) : "in" === e$1 ? mi$1(t$1[1], t$1.slice(2)) : "!in" === e$1 ? xi$1(mi$1(t$1[1], t$1.slice(2))) : "has" === e$1 ? gi$1(t$1[1]) : "!has" !== e$1 || xi$1(gi$1(t$1[1]));
				var r$1;
			}
			function yi$1(t$1, e$1, r$1) {
				switch (t$1) {
					case "$type": return [`filter-type-${r$1}`, e$1];
					case "$id": return [`filter-id-${r$1}`, e$1];
					default: return [
						`filter-${r$1}`,
						t$1,
						e$1
					];
				}
			}
			function mi$1(t$1, e$1) {
				if (0 === e$1.length) return !1;
				switch (t$1) {
					case "$type": return ["filter-type-in", ["literal", e$1]];
					case "$id": return ["filter-id-in", ["literal", e$1]];
					default: return e$1.length > 200 && !e$1.some(((t$2) => typeof t$2 != typeof e$1[0])) ? [
						"filter-in-large",
						t$1,
						["literal", e$1.sort(pi$1)]
					] : [
						"filter-in-small",
						t$1,
						["literal", e$1]
					];
				}
			}
			function gi$1(t$1) {
				switch (t$1) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", t$1];
				}
			}
			function xi$1(t$1) {
				return ["!", t$1];
			}
			function vi$1(t$1) {
				const e$1 = typeof t$1;
				if ("number" === e$1 || "boolean" === e$1 || "string" === e$1 || null == t$1) return JSON.stringify(t$1);
				if (Array.isArray(t$1)) {
					let e$2 = "[";
					for (const r$2 of t$1) e$2 += `${vi$1(r$2)},`;
					return `${e$2}]`;
				}
				const r$1 = Object.keys(t$1).sort();
				let n$1 = "{";
				for (let e$2 = 0; e$2 < r$1.length; e$2++) n$1 += `${JSON.stringify(r$1[e$2])}:${vi$1(t$1[r$1[e$2]])},`;
				return `${n$1}}`;
			}
			function bi$1(t$1) {
				let e$1 = "";
				for (const r$1 of vt$1) e$1 += `/${vi$1(t$1[r$1])}`;
				return e$1;
			}
			function wi(t$1) {
				const e$1 = t$1.value;
				return e$1 ? [new Ct$1(t$1.key, e$1, "constants have been deprecated as of v8")] : [];
			}
			function _i(t$1) {
				return t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean ? t$1.valueOf() : t$1;
			}
			function Si$1(t$1) {
				if (Array.isArray(t$1)) return t$1.map(Si$1);
				if (t$1 instanceof Object && !(t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean)) {
					const e$1 = {};
					for (const r$1 in t$1) e$1[r$1] = Si$1(t$1[r$1]);
					return e$1;
				}
				return _i(t$1);
			}
			function Ai(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec || {}, i$1 = t$1.objectElementValidators || {}, s$1 = t$1.style, a = t$1.styleSpec, o$1 = t$1.validateSpec;
				let l$1 = [];
				const u$1 = Gn(r$1);
				if ("object" !== u$1) return [new Ct$1(e$1, r$1, `object expected, ${u$1} found`)];
				for (const t$2 in r$1) {
					const u$2 = t$2.split(".")[0], c$1 = xe$1(n$1, u$2) || n$1["*"];
					let h$1;
					if (xe$1(i$1, u$2)) h$1 = i$1[u$2];
					else if (xe$1(n$1, u$2)) h$1 = o$1;
					else if (i$1["*"]) h$1 = i$1["*"];
					else {
						if (!n$1["*"]) {
							l$1.push(new Ct$1(e$1, r$1[t$2], `unknown property "${t$2}"`));
							continue;
						}
						h$1 = o$1;
					}
					l$1 = l$1.concat(h$1({
						key: (e$1 ? `${e$1}.` : e$1) + t$2,
						value: r$1[t$2],
						valueSpec: c$1,
						style: s$1,
						styleSpec: a,
						object: r$1,
						objectKey: t$2,
						validateSpec: o$1
					}, r$1));
				}
				for (const t$2 in n$1) i$1[t$2] || n$1[t$2].required && void 0 === n$1[t$2].default && void 0 === r$1[t$2] && l$1.push(new Ct$1(e$1, r$1, `missing required property "${t$2}"`));
				return l$1;
			}
			function ki(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.style, i$1 = t$1.styleSpec, s$1 = t$1.key, a = t$1.arrayElementValidator || t$1.validateSpec;
				if ("array" !== Gn(e$1)) return [new Ct$1(s$1, e$1, `array expected, ${Gn(e$1)} found`)];
				if (r$1.length && e$1.length !== r$1.length) return [new Ct$1(s$1, e$1, `array length ${r$1.length} expected, length ${e$1.length} found`)];
				if (r$1["min-length"] && e$1.length < r$1["min-length"]) return [new Ct$1(s$1, e$1, `array length at least ${r$1["min-length"]} expected, length ${e$1.length} found`)];
				let o$1 = {
					type: r$1.value,
					values: r$1.values
				};
				i$1.$version < 7 && (o$1.function = r$1.function), "object" === Gn(r$1.value) && (o$1 = r$1.value);
				let l$1 = [];
				for (let r$2 = 0; r$2 < e$1.length; r$2++) l$1 = l$1.concat(a({
					array: e$1,
					arrayIndex: r$2,
					value: e$1[r$2],
					valueSpec: o$1,
					validateSpec: t$1.validateSpec,
					style: n$1,
					styleSpec: i$1,
					key: `${s$1}[${r$2}]`
				}));
				return l$1;
			}
			function Mi$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec;
				let i$1 = Gn(r$1);
				return "number" === i$1 && r$1 != r$1 && (i$1 = "NaN"), "number" !== i$1 ? [new Ct$1(e$1, r$1, `number expected, ${i$1} found`)] : "minimum" in n$1 && r$1 < n$1.minimum ? [new Ct$1(e$1, r$1, `${r$1} is less than the minimum value ${n$1.minimum}`)] : "maximum" in n$1 && r$1 > n$1.maximum ? [new Ct$1(e$1, r$1, `${r$1} is greater than the maximum value ${n$1.maximum}`)] : [];
			}
			function Ii(t$1) {
				const e$1 = t$1.valueSpec, r$1 = _i(t$1.value.type);
				let n$1, i$1, s$1, a = {};
				const o$1 = "categorical" !== r$1 && void 0 === t$1.value.property, l$1 = !o$1, u$1 = "array" === Gn(t$1.value.stops) && "array" === Gn(t$1.value.stops[0]) && "object" === Gn(t$1.value.stops[0][0]), c$1 = Ai({
					key: t$1.key,
					value: t$1.value,
					valueSpec: t$1.styleSpec.function,
					validateSpec: t$1.validateSpec,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						stops: function(t$2) {
							if ("identity" === r$1) return [new Ct$1(t$2.key, t$2.value, "identity function may not have a \"stops\" property")];
							let e$2 = [];
							const n$2 = t$2.value;
							return e$2 = e$2.concat(ki({
								key: t$2.key,
								value: n$2,
								valueSpec: t$2.valueSpec,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: h$1
							})), "array" === Gn(n$2) && 0 === n$2.length && e$2.push(new Ct$1(t$2.key, n$2, "array must have at least one stop")), e$2;
						},
						default: function(t$2) {
							return t$2.validateSpec({
								key: t$2.key,
								value: t$2.value,
								valueSpec: e$1,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec
							});
						}
					}
				});
				return "identity" === r$1 && o$1 && c$1.push(new Ct$1(t$1.key, t$1.value, "missing required property \"property\"")), "identity" === r$1 || t$1.value.stops || c$1.push(new Ct$1(t$1.key, t$1.value, "missing required property \"stops\"")), "exponential" === r$1 && t$1.valueSpec.expression && !qn(t$1.valueSpec) && c$1.push(new Ct$1(t$1.key, t$1.value, "exponential functions not supported")), t$1.styleSpec.$version >= 8 && (l$1 && !jn(t$1.valueSpec) ? c$1.push(new Ct$1(t$1.key, t$1.value, "property functions not supported")) : o$1 && !Nn$1(t$1.valueSpec) && c$1.push(new Ct$1(t$1.key, t$1.value, "zoom functions not supported"))), "categorical" !== r$1 && !u$1 || void 0 !== t$1.value.property || c$1.push(new Ct$1(t$1.key, t$1.value, "\"property\" property is required")), c$1;
				function h$1(t$2) {
					let r$2 = [];
					const n$2 = t$2.value, o$2 = t$2.key;
					if ("array" !== Gn(n$2)) return [new Ct$1(o$2, n$2, `array expected, ${Gn(n$2)} found`)];
					if (2 !== n$2.length) return [new Ct$1(o$2, n$2, `array length 2 expected, length ${n$2.length} found`)];
					if (u$1) {
						if ("object" !== Gn(n$2[0])) return [new Ct$1(o$2, n$2, `object expected, ${Gn(n$2[0])} found`)];
						if (void 0 === n$2[0].zoom) return [new Ct$1(o$2, n$2, "object stop key must have zoom")];
						if (void 0 === n$2[0].value) return [new Ct$1(o$2, n$2, "object stop key must have value")];
						if (s$1 && s$1 > _i(n$2[0].zoom)) return [new Ct$1(o$2, n$2[0].zoom, "stop zoom values must appear in ascending order")];
						_i(n$2[0].zoom) !== s$1 && (s$1 = _i(n$2[0].zoom), i$1 = void 0, a = {}), r$2 = r$2.concat(Ai({
							key: `${o$2}[0]`,
							value: n$2[0],
							valueSpec: { zoom: {} },
							validateSpec: t$2.validateSpec,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							objectElementValidators: {
								zoom: Mi$1,
								value: p$1
							}
						}));
					} else r$2 = r$2.concat(p$1({
						key: `${o$2}[0]`,
						value: n$2[0],
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}, n$2));
					return ei$1(Si$1(n$2[1])) ? r$2.concat([new Ct$1(`${o$2}[1]`, n$2[1], "expressions are not allowed in function stops.")]) : r$2.concat(t$2.validateSpec({
						key: `${o$2}[1]`,
						value: n$2[1],
						valueSpec: e$1,
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}));
				}
				function p$1(t$2, s$2) {
					const o$2 = Gn(t$2.value), l$2 = _i(t$2.value), u$2 = null !== t$2.value ? t$2.value : s$2;
					if (n$1) {
						if (o$2 !== n$1) return [new Ct$1(t$2.key, u$2, `${o$2} stop domain type must match previous stop domain type ${n$1}`)];
					} else n$1 = o$2;
					if ("number" !== o$2 && "string" !== o$2 && "boolean" !== o$2) return [new Ct$1(t$2.key, u$2, "stop domain value must be a number, string, or boolean")];
					if ("number" !== o$2 && "categorical" !== r$1) {
						let n$2 = `number expected, ${o$2} found`;
						return jn(e$1) && void 0 === r$1 && (n$2 += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new Ct$1(t$2.key, u$2, n$2)];
					}
					return "categorical" !== r$1 || "number" !== o$2 || isFinite(l$2) && Math.floor(l$2) === l$2 ? "categorical" !== r$1 && "number" === o$2 && void 0 !== i$1 && l$2 < i$1 ? [new Ct$1(t$2.key, u$2, "stop domain values must appear in ascending order")] : (i$1 = l$2, "categorical" === r$1 && l$2 in a ? [new Ct$1(t$2.key, u$2, "stop domain values must be unique")] : (a[l$2] = !0, [])) : [new Ct$1(t$2.key, u$2, `integer expected, found ${l$2}`)];
				}
			}
			function zi$1(t$1) {
				const e$1 = ("property" === t$1.expressionContext ? si$1 : ri$1)(Si$1(t$1.value), t$1.valueSpec);
				if ("error" === e$1.result) return e$1.value.map(((e$2) => new Ct$1(`${t$1.key}${e$2.key}`, t$1.value, e$2.message)));
				const r$1 = e$1.value.expression || e$1.value._styleExpression.expression;
				if ("property" === t$1.expressionContext && "text-font" === t$1.propertyKey && !r$1.outputDefined()) return [new Ct$1(t$1.key, t$1.value, `Invalid data expression for "${t$1.propertyKey}". Output values must be contained as literals within the expression.`)];
				if ("property" === t$1.expressionContext && "layout" === t$1.propertyType && !On$1(r$1)) return [new Ct$1(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if ("filter" === t$1.expressionContext && !On$1(r$1)) return [new Ct$1(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with filters.")];
				if (t$1.expressionContext && 0 === t$1.expressionContext.indexOf("cluster")) {
					if (!Dn(r$1, ["zoom", "feature-state"])) return [new Ct$1(t$1.key, t$1.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if ("cluster-initial" === t$1.expressionContext && !Ln$1(r$1)) return [new Ct$1(t$1.key, t$1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function Pi$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = Gn(r$1);
				return "string" !== n$1 ? [new Ct$1(e$1, r$1, `color expected, ${n$1} found`)] : Me$1.parse(String(r$1)) ? [] : [new Ct$1(e$1, r$1, `color expected, "${r$1}" found`)];
			}
			function Ci(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec, i$1 = [];
				return Array.isArray(n$1.values) ? -1 === n$1.values.indexOf(_i(r$1)) && i$1.push(new Ct$1(e$1, r$1, `expected one of [${n$1.values.join(", ")}], ${JSON.stringify(r$1)} found`)) : -1 === Object.keys(n$1.values).indexOf(_i(r$1)) && i$1.push(new Ct$1(e$1, r$1, `expected one of [${Object.keys(n$1.values).join(", ")}], ${JSON.stringify(r$1)} found`)), i$1;
			}
			function Ei(t$1) {
				return ui$1(Si$1(t$1.value)) ? zi$1(Et$1({}, t$1, {
					expressionContext: "filter",
					valueSpec: { value: "boolean" }
				})) : Bi$1(t$1);
			}
			function Bi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key;
				if ("array" !== Gn(e$1)) return [new Ct$1(r$1, e$1, `array expected, ${Gn(e$1)} found`)];
				const n$1 = t$1.styleSpec;
				let i$1, s$1 = [];
				if (e$1.length < 1) return [new Ct$1(r$1, e$1, "filter array must have at least 1 element")];
				switch (s$1 = s$1.concat(Ci({
					key: `${r$1}[0]`,
					value: e$1[0],
					valueSpec: n$1.filter_operator,
					style: t$1.style,
					styleSpec: t$1.styleSpec
				})), _i(e$1[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=": e$1.length >= 2 && "$type" === _i(e$1[1]) && s$1.push(new Ct$1(r$1, e$1, `"$type" cannot be use with operator "${e$1[0]}"`));
					case "==":
					case "!=": 3 !== e$1.length && s$1.push(new Ct$1(r$1, e$1, `filter array for operator "${e$1[0]}" must have 3 elements`));
					case "in":
					case "!in":
						e$1.length >= 2 && (i$1 = Gn(e$1[1]), "string" !== i$1 && s$1.push(new Ct$1(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`)));
						for (let a = 2; a < e$1.length; a++) i$1 = Gn(e$1[a]), "$type" === _i(e$1[1]) ? s$1 = s$1.concat(Ci({
							key: `${r$1}[${a}]`,
							value: e$1[a],
							valueSpec: n$1.geometry_type,
							style: t$1.style,
							styleSpec: t$1.styleSpec
						})) : "string" !== i$1 && "number" !== i$1 && "boolean" !== i$1 && s$1.push(new Ct$1(`${r$1}[${a}]`, e$1[a], `string, number, or boolean expected, ${i$1} found`));
						break;
					case "any":
					case "all":
					case "none":
						for (let n$2 = 1; n$2 < e$1.length; n$2++) s$1 = s$1.concat(Bi$1({
							key: `${r$1}[${n$2}]`,
							value: e$1[n$2],
							style: t$1.style,
							styleSpec: t$1.styleSpec
						}));
						break;
					case "has":
					case "!has": i$1 = Gn(e$1[1]), 2 !== e$1.length ? s$1.push(new Ct$1(r$1, e$1, `filter array for "${e$1[0]}" operator must have 2 elements`)) : "string" !== i$1 && s$1.push(new Ct$1(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`));
				}
				return s$1;
			}
			function Vi$1(t$1, e$1) {
				const r$1 = t$1.key, n$1 = t$1.validateSpec, i$1 = t$1.style, s$1 = t$1.styleSpec, a = t$1.value, o$1 = t$1.objectKey, l$1 = s$1[`${e$1}_${t$1.layerType}`];
				if (!l$1) return [];
				const u$1 = o$1.match(/^(.*)-transition$/);
				if ("paint" === e$1 && u$1 && l$1[u$1[1]] && l$1[u$1[1]].transition) return n$1({
					key: r$1,
					value: a,
					valueSpec: s$1.transition,
					style: i$1,
					styleSpec: s$1
				});
				const c$1 = t$1.valueSpec || l$1[o$1];
				if (!c$1) return [new Ct$1(r$1, a, `unknown property "${o$1}"`)];
				let h$1;
				if ("string" === Gn(a) && jn(c$1) && !c$1.tokens && (h$1 = /^{([^}]+)}$/.exec(a))) return [new Ct$1(r$1, a, `"${o$1}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h$1[1])} }\`.`)];
				const p$1 = [];
				return "symbol" === t$1.layerType && ("text-field" === o$1 && i$1 && !i$1.glyphs && p$1.push(new Ct$1(r$1, a, "use of \"text-field\" requires a style \"glyphs\" property")), "text-font" === o$1 && Xn(Si$1(a)) && "identity" === _i(a.type) && p$1.push(new Ct$1(r$1, a, "\"text-font\" does not support identity functions"))), p$1.concat(n$1({
					key: t$1.key,
					value: a,
					valueSpec: c$1,
					style: i$1,
					styleSpec: s$1,
					expressionContext: "property",
					propertyType: e$1,
					propertyKey: o$1
				}));
			}
			function Ti(t$1) {
				return Vi$1(t$1, "paint");
			}
			function Fi$1(t$1) {
				return Vi$1(t$1, "layout");
			}
			function $i$1(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key, i$1 = t$1.style, s$1 = t$1.styleSpec;
				if ("object" !== Gn(r$1)) return [new Ct$1(n$1, r$1, `object expected, ${Gn(r$1)} found`)];
				r$1.type || r$1.ref || e$1.push(new Ct$1(n$1, r$1, "either \"type\" or \"ref\" is required"));
				let a = _i(r$1.type);
				const o$1 = _i(r$1.ref);
				if (r$1.id) {
					const s$2 = _i(r$1.id);
					for (let a$1 = 0; a$1 < t$1.arrayIndex; a$1++) {
						const t$2 = i$1.layers[a$1];
						_i(t$2.id) === s$2 && e$1.push(new Ct$1(n$1, r$1.id, `duplicate layer id "${r$1.id}", previously used at line ${t$2.id.__line__}`));
					}
				}
				if ("ref" in r$1) {
					let t$2;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((t$3) => {
						t$3 in r$1 && e$1.push(new Ct$1(n$1, r$1[t$3], `"${t$3}" is prohibited for ref layers`));
					})), i$1.layers.forEach(((e$2) => {
						_i(e$2.id) === o$1 && (t$2 = e$2);
					})), t$2 ? t$2.ref ? e$1.push(new Ct$1(n$1, r$1.ref, "ref cannot reference another ref layer")) : a = _i(t$2.type) : e$1.push(new Ct$1(n$1, r$1.ref, `ref layer "${o$1}" not found`));
				} else if ("background" !== a) if (r$1.source) {
					const t$2 = i$1.sources && i$1.sources[r$1.source], s$2 = t$2 && _i(t$2.type);
					t$2 ? "vector" === s$2 && "raster" === a ? e$1.push(new Ct$1(n$1, r$1.source, `layer "${r$1.id}" requires a raster source`)) : "raster-dem" !== s$2 && "hillshade" === a || "raster-dem" !== s$2 && "color-relief" === a ? e$1.push(new Ct$1(n$1, r$1.source, `layer "${r$1.id}" requires a raster-dem source`)) : "raster" === s$2 && "raster" !== a ? e$1.push(new Ct$1(n$1, r$1.source, `layer "${r$1.id}" requires a vector source`)) : "vector" !== s$2 || r$1["source-layer"] ? "raster-dem" === s$2 && "hillshade" !== a && "color-relief" !== a ? e$1.push(new Ct$1(n$1, r$1.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== a || !r$1.paint || !r$1.paint["line-gradient"] || "geojson" === s$2 && t$2.lineMetrics || e$1.push(new Ct$1(n$1, r$1, `layer "${r$1.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e$1.push(new Ct$1(n$1, r$1, `layer "${r$1.id}" must specify a "source-layer"`)) : e$1.push(new Ct$1(n$1, r$1.source, `source "${r$1.source}" not found`));
				} else e$1.push(new Ct$1(n$1, r$1, "missing required property \"source\""));
				return e$1 = e$1.concat(Ai({
					key: n$1,
					value: r$1,
					valueSpec: s$1.layer,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					validateSpec: t$1.validateSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => t$1.validateSpec({
							key: `${n$1}.type`,
							value: r$1.type,
							valueSpec: s$1.layer.type,
							style: t$1.style,
							styleSpec: t$1.styleSpec,
							validateSpec: t$1.validateSpec,
							object: r$1,
							objectKey: "type"
						}),
						filter: Ei,
						layout: (t$2) => Ai({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Fi$1(Et$1({ layerType: a }, t$3)) }
						}),
						paint: (t$2) => Ai({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Ti(Et$1({ layerType: a }, t$3)) }
						})
					}
				})), e$1;
			}
			function Li$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Gn(e$1);
				return "string" !== n$1 ? [new Ct$1(r$1, e$1, `string expected, ${n$1} found`)] : [];
			}
			const Oi$1 = { promoteId: function({ key: t$1, value: e$1 }) {
				if ("string" === Gn(e$1)) return Li$1({
					key: t$1,
					value: e$1
				});
				{
					const r$1 = [];
					for (const n$1 in e$1) r$1.push(...Li$1({
						key: `${t$1}.${n$1}`,
						value: e$1[n$1]
					}));
					return r$1;
				}
			} };
			function Di$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = t$1.styleSpec, i$1 = t$1.style, s$1 = t$1.validateSpec;
				if (!e$1.type) return [new Ct$1(r$1, e$1, "\"type\" is required")];
				const a = _i(e$1.type);
				let o$1;
				switch (a) {
					case "vector":
					case "raster": return o$1 = Ai({
						key: r$1,
						value: e$1,
						valueSpec: n$1[`source_${a.replace("-", "_")}`],
						style: t$1.style,
						styleSpec: n$1,
						objectElementValidators: Oi$1,
						validateSpec: s$1
					}), o$1;
					case "raster-dem": return o$1 = function(t$2) {
						var e$2;
						const r$2 = null !== (e$2 = t$2.sourceName) && void 0 !== e$2 ? e$2 : "", n$2 = t$2.value, i$2 = t$2.styleSpec, s$2 = i$2.source_raster_dem, a$1 = t$2.style;
						let o$2 = [];
						const l$1 = Gn(n$2);
						if (void 0 === n$2) return o$2;
						if ("object" !== l$1) return o$2.push(new Ct$1("source_raster_dem", n$2, `object expected, ${l$1} found`)), o$2;
						const u$1 = "custom" === _i(n$2.encoding), c$1 = [
							"redFactor",
							"greenFactor",
							"blueFactor",
							"baseShift"
						], h$1 = t$2.value.encoding ? `"${t$2.value.encoding}"` : "Default";
						for (const e$3 in n$2) !u$1 && c$1.includes(e$3) ? o$2.push(new Ct$1(e$3, n$2[e$3], `In "${r$2}": "${e$3}" is only valid when "encoding" is set to "custom". ${h$1} encoding found`)) : s$2[e$3] ? o$2 = o$2.concat(t$2.validateSpec({
							key: e$3,
							value: n$2[e$3],
							valueSpec: s$2[e$3],
							validateSpec: t$2.validateSpec,
							style: a$1,
							styleSpec: i$2
						})) : o$2.push(new Ct$1(e$3, n$2[e$3], `unknown property "${e$3}"`));
						return o$2;
					}({
						sourceName: r$1,
						value: e$1,
						style: t$1.style,
						styleSpec: n$1,
						validateSpec: s$1
					}), o$1;
					case "geojson":
						if (o$1 = Ai({
							key: r$1,
							value: e$1,
							valueSpec: n$1.source_geojson,
							style: i$1,
							styleSpec: n$1,
							validateSpec: s$1,
							objectElementValidators: Oi$1
						}), e$1.cluster) for (const t$2 in e$1.clusterProperties) {
							const [n$2, i$2] = e$1.clusterProperties[t$2], s$2 = "string" == typeof n$2 ? [
								n$2,
								["accumulated"],
								["get", t$2]
							] : n$2;
							o$1.push(...zi$1({
								key: `${r$1}.${t$2}.map`,
								value: i$2,
								expressionContext: "cluster-map"
							})), o$1.push(...zi$1({
								key: `${r$1}.${t$2}.reduce`,
								value: s$2,
								expressionContext: "cluster-reduce"
							}));
						}
						return o$1;
					case "video": return Ai({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_video,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "image": return Ai({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_image,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "canvas": return [new Ct$1(r$1, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return Ci({
						key: `${r$1}.type`,
						value: e$1.type,
						valueSpec: { values: [
							"vector",
							"raster",
							"raster-dem",
							"geojson",
							"video",
							"image"
						] }
					});
				}
			}
			function Ri$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.light, i$1 = t$1.style;
				let s$1 = [];
				const a = Gn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a) return s$1 = s$1.concat([new Ct$1("light", e$1, `object expected, ${a} found`)]), s$1;
				for (const a$1 in e$1) {
					const o$1 = a$1.match(/^(.*)-transition$/);
					s$1 = s$1.concat(o$1 && n$1[o$1[1]] && n$1[o$1[1]].transition ? t$1.validateSpec({
						key: a$1,
						value: e$1[a$1],
						valueSpec: r$1.transition,
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : n$1[a$1] ? t$1.validateSpec({
						key: a$1,
						value: e$1[a$1],
						valueSpec: n$1[a$1],
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : [new Ct$1(a$1, e$1[a$1], `unknown property "${a$1}"`)]);
				}
				return s$1;
			}
			function Ui$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.sky, i$1 = t$1.style, s$1 = Gn(e$1);
				if (void 0 === e$1) return [];
				if ("object" !== s$1) return [new Ct$1("sky", e$1, `object expected, ${s$1} found`)];
				let a = [];
				for (const s$2 in e$1) a = a.concat(n$1[s$2] ? t$1.validateSpec({
					key: s$2,
					value: e$1[s$2],
					valueSpec: n$1[s$2],
					style: i$1,
					styleSpec: r$1
				}) : [new Ct$1(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
				return a;
			}
			function ji$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.terrain, i$1 = t$1.style;
				let s$1 = [];
				const a = Gn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a) return s$1 = s$1.concat([new Ct$1("terrain", e$1, `object expected, ${a} found`)]), s$1;
				for (const a$1 in e$1) s$1 = s$1.concat(n$1[a$1] ? t$1.validateSpec({
					key: a$1,
					value: e$1[a$1],
					valueSpec: n$1[a$1],
					validateSpec: t$1.validateSpec,
					style: i$1,
					styleSpec: r$1
				}) : [new Ct$1(a$1, e$1[a$1], `unknown property "${a$1}"`)]);
				return s$1;
			}
			function Ni$1(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key;
				if (Array.isArray(r$1)) {
					const i$1 = [], s$1 = [];
					for (const a in r$1) r$1[a].id && i$1.includes(r$1[a].id) && e$1.push(new Ct$1(n$1, r$1, `all the sprites' ids must be unique, but ${r$1[a].id} is duplicated`)), i$1.push(r$1[a].id), r$1[a].url && s$1.includes(r$1[a].url) && e$1.push(new Ct$1(n$1, r$1, `all the sprites' URLs must be unique, but ${r$1[a].url} is duplicated`)), s$1.push(r$1[a].url), e$1 = e$1.concat(Ai({
						key: `${n$1}[${a}]`,
						value: r$1[a],
						valueSpec: {
							id: {
								type: "string",
								required: !0
							},
							url: {
								type: "string",
								required: !0
							}
						},
						validateSpec: t$1.validateSpec
					}));
					return e$1;
				}
				return Li$1({
					key: n$1,
					value: r$1
				});
			}
			function qi$1(t$1) {
				return e$1 = t$1.value, Boolean(e$1) && e$1.constructor === Object ? [] : [new Ct$1(t$1.key, t$1.value, `object expected, ${Gn(t$1.value)} found`)];
				var e$1;
			}
			const Gi$1 = {
				"*": () => [],
				array: ki,
				boolean: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.key, n$1 = Gn(e$1);
					return "boolean" !== n$1 ? [new Ct$1(r$1, e$1, `boolean expected, ${n$1} found`)] : [];
				},
				number: Mi$1,
				color: Pi$1,
				constants: wi,
				enum: Ci,
				filter: Ei,
				function: Ii,
				layer: $i$1,
				object: Ai,
				source: Di$1,
				light: Ri$1,
				sky: Ui$1,
				terrain: ji$1,
				projection: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.projection, i$1 = t$1.style, s$1 = Gn(e$1);
					if (void 0 === e$1) return [];
					if ("object" !== s$1) return [new Ct$1("projection", e$1, `object expected, ${s$1} found`)];
					let a = [];
					for (const s$2 in e$1) a = a.concat(n$1[s$2] ? t$1.validateSpec({
						key: s$2,
						value: e$1[s$2],
						valueSpec: n$1[s$2],
						style: i$1,
						styleSpec: r$1
					}) : [new Ct$1(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
					return a;
				},
				projectionDefinition: function(t$1) {
					const e$1 = t$1.key;
					let r$1 = t$1.value;
					r$1 = r$1 instanceof String ? r$1.valueOf() : r$1;
					const n$1 = Gn(r$1);
					return "array" !== n$1 || function(t$2) {
						return Array.isArray(t$2) && 3 === t$2.length && "string" == typeof t$2[0] && "string" == typeof t$2[1] && "number" == typeof t$2[2];
					}(r$1) || function(t$2) {
						return !![
							"interpolate",
							"step",
							"literal"
						].includes(t$2[0]);
					}(r$1) ? ["array", "string"].includes(n$1) ? [] : [new Ct$1(e$1, r$1, `projection expected, invalid type "${n$1}" found`)] : [new Ct$1(e$1, r$1, `projection expected, invalid array ${JSON.stringify(r$1)} found`)];
				},
				string: Li$1,
				formatted: function(t$1) {
					return 0 === Li$1(t$1).length ? [] : zi$1(t$1);
				},
				resolvedImage: function(t$1) {
					return 0 === Li$1(t$1).length ? [] : zi$1(t$1);
				},
				padding: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						if (r$1.length < 1 || r$1.length > 4) return [new Ct$1(e$1, r$1, `padding requires 1 to 4 values; ${r$1.length} values found`)];
						const n$1 = { type: "number" };
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Mi$1({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				numberArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						const n$1 = { type: "number" };
						if (r$1.length < 1) return [new Ct$1(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Mi$1({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				colorArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						if (r$1.length < 1) return [new Ct$1(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let t$2 = [];
						for (let n$1 = 0; n$1 < r$1.length; n$1++) t$2 = t$2.concat(Pi$1({
							key: `${e$1}[${n$1}]`,
							value: r$1[n$1]
						}));
						return t$2;
					}
					return Pi$1({
						key: e$1,
						value: r$1
					});
				},
				variableAnchorOffsetCollection: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value, n$1 = Gn(r$1), i$1 = t$1.styleSpec;
					if ("array" !== n$1 || r$1.length < 1 || r$1.length % 2 != 0) return [new Ct$1(e$1, r$1, "variableAnchorOffsetCollection requires a non-empty array of even length")];
					let s$1 = [];
					for (let n$2 = 0; n$2 < r$1.length; n$2 += 2) s$1 = s$1.concat(Ci({
						key: `${e$1}[${n$2}]`,
						value: r$1[n$2],
						valueSpec: i$1.layout_symbol["text-anchor"]
					})), s$1 = s$1.concat(ki({
						key: `${e$1}[${n$2 + 1}]`,
						value: r$1[n$2 + 1],
						valueSpec: {
							length: 2,
							value: "number"
						},
						validateSpec: t$1.validateSpec,
						style: t$1.style,
						styleSpec: i$1
					}));
					return s$1;
				},
				sprite: Ni$1,
				state: qi$1
			};
			function Xi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.styleSpec;
				return t$1.validateSpec = Xi$1, r$1.expression && Xn(_i(e$1)) ? Ii(t$1) : r$1.expression && ei$1(Si$1(e$1)) ? zi$1(t$1) : r$1.type && Gi$1[r$1.type] ? Gi$1[r$1.type](t$1) : Ai(Et$1({}, t$1, { valueSpec: r$1.type ? n$1[r$1.type] : r$1 }));
			}
			function Zi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Li$1(t$1);
				return n$1.length || (-1 === e$1.indexOf("{fontstack}") && n$1.push(new Ct$1(r$1, e$1, "\"glyphs\" url must include a \"{fontstack}\" token")), -1 === e$1.indexOf("{range}") && n$1.push(new Ct$1(r$1, e$1, "\"glyphs\" url must include a \"{range}\" token"))), n$1;
			}
			function Yi$1(t$1, e$1 = xt$1) {
				let r$1 = [];
				return r$1 = r$1.concat(Xi$1({
					key: "",
					value: t$1,
					valueSpec: e$1.$root,
					styleSpec: e$1,
					style: t$1,
					validateSpec: Xi$1,
					objectElementValidators: {
						glyphs: Zi$1,
						"*": () => []
					}
				})), t$1.constants && (r$1 = r$1.concat(wi({
					key: "constants",
					value: t$1.constants
				}))), Ki$1(r$1);
			}
			function Hi$1(t$1) {
				return function(e$1) {
					return t$1({
						...e$1,
						validateSpec: Xi$1
					});
				};
			}
			function Ki$1(t$1) {
				return [].concat(t$1).sort(((t$2, e$1) => t$2.line - e$1.line));
			}
			function Ji$1(t$1) {
				return function(...e$1) {
					return Ki$1(t$1.apply(this, e$1));
				};
			}
			Yi$1.source = Ji$1(Hi$1(Di$1)), Yi$1.sprite = Ji$1(Hi$1(Ni$1)), Yi$1.glyphs = Ji$1(Hi$1(Zi$1)), Yi$1.light = Ji$1(Hi$1(Ri$1)), Yi$1.sky = Ji$1(Hi$1(Ui$1)), Yi$1.terrain = Ji$1(Hi$1(ji$1)), Yi$1.state = Ji$1(Hi$1(qi$1)), Yi$1.layer = Ji$1(Hi$1($i$1)), Yi$1.filter = Ji$1(Hi$1(Ei)), Yi$1.paintProperty = Ji$1(Hi$1(Ti)), Yi$1.layoutProperty = Ji$1(Hi$1(Fi$1));
			const Wi$1 = Yi$1, Qi$1 = Wi$1.light, ts$1 = Wi$1.sky, es$1 = Wi$1.paintProperty, rs$1 = Wi$1.layoutProperty;
			function ns$1(t$1, e$1) {
				let r$1 = !1;
				if (e$1 && e$1.length) for (const n$1 of e$1) t$1.fire(new mt$1(new Error(n$1.message))), r$1 = !0;
				return r$1;
			}
			class is$1 {
				constructor(t$1, e$1, r$1) {
					const n$1 = this.cells = [];
					if (t$1 instanceof ArrayBuffer) {
						this.arrayBuffer = t$1;
						const i$2 = new Int32Array(this.arrayBuffer);
						t$1 = i$2[0], this.d = (e$1 = i$2[1]) + 2 * (r$1 = i$2[2]);
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) {
							const e$2 = i$2[3 + t$2], r$2 = i$2[3 + t$2 + 1];
							n$1.push(e$2 === r$2 ? null : i$2.subarray(e$2, r$2));
						}
						const s$1 = i$2[3 + n$1.length + 1];
						this.keys = i$2.subarray(i$2[3 + n$1.length], s$1), this.bboxes = i$2.subarray(s$1), this.insert = this._insertReadonly;
					} else {
						this.d = e$1 + 2 * r$1;
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) n$1.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = e$1, this.extent = t$1, this.padding = r$1, this.scale = e$1 / t$1, this.uid = 0;
					const i$1 = r$1 / e$1 * t$1;
					this.min = -i$1, this.max = t$1 + i$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1) {
					this._forEachCell(e$1, r$1, n$1, i$1, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t$1), this.bboxes.push(e$1), this.bboxes.push(r$1), this.bboxes.push(n$1), this.bboxes.push(i$1);
				}
				_insertReadonly() {
					throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
				}
				_insertCell(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.cells[i$1].push(s$1);
				}
				query(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.min, a = this.max;
					if (t$1 <= s$1 && e$1 <= s$1 && a <= r$1 && a <= n$1 && !i$1) return Array.prototype.slice.call(this.keys);
					{
						const s$2 = [];
						return this._forEachCell(t$1, e$1, r$1, n$1, this._queryCell, s$2, {}, i$1), s$2;
					}
				}
				_queryCell(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = this.cells[i$1];
					if (null !== l$1) {
						const i$2 = this.keys, u$1 = this.bboxes;
						for (let c$1 = 0; c$1 < l$1.length; c$1++) {
							const h$1 = l$1[c$1];
							if (void 0 === a[h$1]) {
								const l$2 = 4 * h$1;
								(o$1 ? o$1(u$1[l$2 + 0], u$1[l$2 + 1], u$1[l$2 + 2], u$1[l$2 + 3]) : t$1 <= u$1[l$2 + 2] && e$1 <= u$1[l$2 + 3] && r$1 >= u$1[l$2 + 0] && n$1 >= u$1[l$2 + 1]) ? (a[h$1] = !0, s$1.push(i$2[h$1])) : a[h$1] = !1;
							}
						}
					}
				}
				_forEachCell(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = this._convertToCellCoord(t$1), u$1 = this._convertToCellCoord(e$1), c$1 = this._convertToCellCoord(r$1), h$1 = this._convertToCellCoord(n$1);
					for (let p$1 = l$1; p$1 <= c$1; p$1++) for (let l$2 = u$1; l$2 <= h$1; l$2++) {
						const u$2 = this.d * l$2 + p$1;
						if ((!o$1 || o$1(this._convertFromCellCoord(p$1), this._convertFromCellCoord(l$2), this._convertFromCellCoord(p$1 + 1), this._convertFromCellCoord(l$2 + 1))) && i$1.call(this, t$1, e$1, r$1, n$1, u$2, s$1, a, o$1)) return;
					}
				}
				_convertFromCellCoord(t$1) {
					return (t$1 - this.padding) / this.scale;
				}
				_convertToCellCoord(t$1) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(t$1 * this.scale) + this.padding));
				}
				toArrayBuffer() {
					if (this.arrayBuffer) return this.arrayBuffer;
					const t$1 = this.cells, e$1 = 3 + this.cells.length + 1 + 1;
					let r$1 = 0;
					for (let t$2 = 0; t$2 < this.cells.length; t$2++) r$1 += this.cells[t$2].length;
					const n$1 = new Int32Array(e$1 + r$1 + this.keys.length + this.bboxes.length);
					n$1[0] = this.extent, n$1[1] = this.n, n$1[2] = this.padding;
					let i$1 = e$1;
					for (let e$2 = 0; e$2 < t$1.length; e$2++) {
						const r$2 = t$1[e$2];
						n$1[3 + e$2] = i$1, n$1.set(r$2, i$1), i$1 += r$2.length;
					}
					return n$1[3 + t$1.length] = i$1, n$1.set(this.keys, i$1), i$1 += this.keys.length, n$1[3 + t$1.length + 1] = i$1, n$1.set(this.bboxes, i$1), i$1 += this.bboxes.length, n$1.buffer;
				}
				static serialize(t$1, e$1) {
					const r$1 = t$1.toArrayBuffer();
					return e$1 && e$1.push(r$1), { buffer: r$1 };
				}
				static deserialize(t$1) {
					return new is$1(t$1.buffer);
				}
			}
			const ss$1 = {};
			function as$1(t$1, e$1, r$1 = {}) {
				if (ss$1[t$1]) throw new Error(`${t$1} is already registered.`);
				Object.defineProperty(e$1, "_classRegistryKey", {
					value: t$1,
					writeable: !1
				}), ss$1[t$1] = {
					klass: e$1,
					omit: r$1.omit || [],
					shallow: r$1.shallow || []
				};
			}
			as$1("Object", Object), as$1("Set", Set), as$1("TransferableGridIndex", is$1), as$1("Color", Me$1), as$1("Error", Error), as$1("AJAXError", ut$1), as$1("ResolvedImage", Le), as$1("StylePropertyFunction", ai$1), as$1("StyleExpression", ti$1, { omit: ["_evaluator"] }), as$1("ZoomDependentExpression", ii$1), as$1("ZoomConstantExpression", ni$1), as$1("CompoundExpression", En$1, { omit: ["_evaluate"] });
			for (const t$1 in Cn$1) Cn$1[t$1]._classRegistryKey || as$1(`Expression_${t$1}`, Cn$1[t$1]);
			function os$1(t$1) {
				return t$1 && "undefined" != typeof ArrayBuffer && (t$1 instanceof ArrayBuffer || t$1.constructor && "ArrayBuffer" === t$1.constructor.name);
			}
			function ls$1(t$1) {
				return t$1.$name || t$1.constructor._classRegistryKey;
			}
			function us$1(t$1) {
				return !function(t$2) {
					if (null === t$2 || "object" != typeof t$2) return !1;
					const e$1 = ls$1(t$2);
					return !(!e$1 || "Object" === e$1);
				}(t$1) && (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp || t$1 instanceof Blob || t$1 instanceof Error || os$1(t$1) || Y$1(t$1) || ArrayBuffer.isView(t$1) || t$1 instanceof ImageData);
			}
			function cs$1(t$1, e$1) {
				if (us$1(t$1)) return (os$1(t$1) || Y$1(t$1)) && e$1 && e$1.push(t$1), ArrayBuffer.isView(t$1) && e$1 && e$1.push(t$1.buffer), t$1 instanceof ImageData && e$1 && e$1.push(t$1.data.buffer), t$1;
				if (Array.isArray(t$1)) {
					const r$2 = [];
					for (const n$2 of t$1) r$2.push(cs$1(n$2, e$1));
					return r$2;
				}
				if ("object" != typeof t$1) throw new Error("can't serialize object of type " + typeof t$1);
				const r$1 = ls$1(t$1);
				if (!r$1) throw new Error(`can't serialize object of unregistered class ${t$1.constructor.name}`);
				if (!ss$1[r$1]) throw new Error(`${r$1} is not registered.`);
				const { klass: n$1 } = ss$1[r$1], i$1 = n$1.serialize ? n$1.serialize(t$1, e$1) : {};
				if (n$1.serialize) {
					if (e$1 && i$1 === e$1[e$1.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
				} else {
					for (const n$2 in t$1) {
						if (!t$1.hasOwnProperty(n$2)) continue;
						if (ss$1[r$1].omit.indexOf(n$2) >= 0) continue;
						const s$1 = t$1[n$2];
						i$1[n$2] = ss$1[r$1].shallow.indexOf(n$2) >= 0 ? s$1 : cs$1(s$1, e$1);
					}
					t$1 instanceof Error && (i$1.message = t$1.message);
				}
				if (i$1.$name) throw new Error("$name property is reserved for worker serialization logic.");
				return "Object" !== r$1 && (i$1.$name = r$1), i$1;
			}
			function hs$1(t$1) {
				if (us$1(t$1)) return t$1;
				if (Array.isArray(t$1)) return t$1.map(hs$1);
				if ("object" != typeof t$1) throw new Error("can't deserialize object of type " + typeof t$1);
				const e$1 = ls$1(t$1) || "Object";
				if (!ss$1[e$1]) throw new Error(`can't deserialize unregistered class ${e$1}`);
				const { klass: r$1 } = ss$1[e$1];
				if (!r$1) throw new Error(`can't deserialize unregistered class ${e$1}`);
				if (r$1.deserialize) return r$1.deserialize(t$1);
				const n$1 = Object.create(r$1.prototype);
				for (const r$2 of Object.keys(t$1)) {
					if ("$name" === r$2) continue;
					const i$1 = t$1[r$2];
					n$1[r$2] = ss$1[e$1].shallow.indexOf(r$2) >= 0 ? i$1 : hs$1(i$1);
				}
				return n$1;
			}
			class ps$1 {
				constructor() {
					this.first = !0;
				}
				update(t$1, e$1) {
					const r$1 = Math.floor(t$1);
					return this.first ? (this.first = !1, this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = 0, this.lastZoom = t$1, this.lastFloorZoom = r$1, !0) : (this.lastFloorZoom > r$1 ? (this.lastIntegerZoom = r$1 + 1, this.lastIntegerZoomTime = e$1) : this.lastFloorZoom < r$1 && (this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = e$1), t$1 !== this.lastZoom && (this.lastZoom = t$1, this.lastFloorZoom = r$1, !0));
				}
			}
			const fs$1 = {
				"Latin-1 Supplement": (t$1) => t$1 >= 128 && t$1 <= 255,
				"Hangul Jamo": (t$1) => t$1 >= 4352 && t$1 <= 4607,
				Khmer: (t$1) => t$1 >= 6016 && t$1 <= 6143,
				"General Punctuation": (t$1) => t$1 >= 8192 && t$1 <= 8303,
				"Letterlike Symbols": (t$1) => t$1 >= 8448 && t$1 <= 8527,
				"Number Forms": (t$1) => t$1 >= 8528 && t$1 <= 8591,
				"Miscellaneous Technical": (t$1) => t$1 >= 8960 && t$1 <= 9215,
				"Control Pictures": (t$1) => t$1 >= 9216 && t$1 <= 9279,
				"Optical Character Recognition": (t$1) => t$1 >= 9280 && t$1 <= 9311,
				"Enclosed Alphanumerics": (t$1) => t$1 >= 9312 && t$1 <= 9471,
				"Geometric Shapes": (t$1) => t$1 >= 9632 && t$1 <= 9727,
				"Miscellaneous Symbols": (t$1) => t$1 >= 9728 && t$1 <= 9983,
				"Miscellaneous Symbols and Arrows": (t$1) => t$1 >= 11008 && t$1 <= 11263,
				"Ideographic Description Characters": (t$1) => t$1 >= 12272 && t$1 <= 12287,
				"CJK Symbols and Punctuation": (t$1) => t$1 >= 12288 && t$1 <= 12351,
				Hiragana: (t$1) => t$1 >= 12352 && t$1 <= 12447,
				Katakana: (t$1) => t$1 >= 12448 && t$1 <= 12543,
				Kanbun: (t$1) => t$1 >= 12688 && t$1 <= 12703,
				"CJK Strokes": (t$1) => t$1 >= 12736 && t$1 <= 12783,
				"Enclosed CJK Letters and Months": (t$1) => t$1 >= 12800 && t$1 <= 13055,
				"CJK Compatibility": (t$1) => t$1 >= 13056 && t$1 <= 13311,
				"Yijing Hexagram Symbols": (t$1) => t$1 >= 19904 && t$1 <= 19967,
				"CJK Unified Ideographs": (t$1) => t$1 >= 19968 && t$1 <= 40959,
				"Hangul Syllables": (t$1) => t$1 >= 44032 && t$1 <= 55215,
				"Private Use Area": (t$1) => t$1 >= 57344 && t$1 <= 63743,
				"Vertical Forms": (t$1) => t$1 >= 65040 && t$1 <= 65055,
				"CJK Compatibility Forms": (t$1) => t$1 >= 65072 && t$1 <= 65103,
				"Small Form Variants": (t$1) => t$1 >= 65104 && t$1 <= 65135,
				"Halfwidth and Fullwidth Forms": (t$1) => t$1 >= 65280 && t$1 <= 65519
			};
			function ds$1(t$1) {
				for (const e$1 of t$1) if (bs$1(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			function ys$1(t$1) {
				for (const e$1 of t$1) if (!xs$1(e$1.charCodeAt(0))) return !1;
				return !0;
			}
			function ms$1(t$1) {
				const e$1 = t$1.map(((t$2) => {
					try {
						return new RegExp(`\\p{sc=${t$2}}`, "u").source;
					} catch (t$3) {
						return null;
					}
				})).filter(((t$2) => t$2));
				return new RegExp(e$1.join("|"), "u");
			}
			const gs$1 = ms$1([
				"Arab",
				"Dupl",
				"Mong",
				"Ougr",
				"Syrc"
			]);
			function xs$1(t$1) {
				return !gs$1.test(String.fromCodePoint(t$1));
			}
			const vs$1 = ms$1([
				"Bopo",
				"Hani",
				"Hira",
				"Kana",
				"Kits",
				"Nshu",
				"Tang",
				"Yiii"
			]);
			function bs$1(t$1) {
				return !(746 !== t$1 && 747 !== t$1 && (t$1 < 4352 || !(fs$1["CJK Compatibility Forms"](t$1) && !(t$1 >= 65097 && t$1 <= 65103) || fs$1["CJK Compatibility"](t$1) || fs$1["CJK Strokes"](t$1) || !(!fs$1["CJK Symbols and Punctuation"](t$1) || t$1 >= 12296 && t$1 <= 12305 || t$1 >= 12308 && t$1 <= 12319 || 12336 === t$1) || fs$1["Enclosed CJK Letters and Months"](t$1) || fs$1["Ideographic Description Characters"](t$1) || fs$1.Kanbun(t$1) || fs$1.Katakana(t$1) && 12540 !== t$1 || !(!fs$1["Halfwidth and Fullwidth Forms"](t$1) || 65288 === t$1 || 65289 === t$1 || 65293 === t$1 || t$1 >= 65306 && t$1 <= 65310 || 65339 === t$1 || 65341 === t$1 || 65343 === t$1 || t$1 >= 65371 && t$1 <= 65503 || 65507 === t$1 || t$1 >= 65512 && t$1 <= 65519) || !(!fs$1["Small Form Variants"](t$1) || t$1 >= 65112 && t$1 <= 65118 || t$1 >= 65123 && t$1 <= 65126) || fs$1["Vertical Forms"](t$1) || fs$1["Yijing Hexagram Symbols"](t$1) || /\p{sc=Cans}/u.test(String.fromCodePoint(t$1)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t$1)) || vs$1.test(String.fromCodePoint(t$1)))));
			}
			function ws$1(t$1) {
				return !(bs$1(t$1) || function(t$2) {
					return !!(fs$1["Latin-1 Supplement"](t$2) && (167 === t$2 || 169 === t$2 || 174 === t$2 || 177 === t$2 || 188 === t$2 || 189 === t$2 || 190 === t$2 || 215 === t$2 || 247 === t$2) || fs$1["General Punctuation"](t$2) && (8214 === t$2 || 8224 === t$2 || 8225 === t$2 || 8240 === t$2 || 8241 === t$2 || 8251 === t$2 || 8252 === t$2 || 8258 === t$2 || 8263 === t$2 || 8264 === t$2 || 8265 === t$2 || 8273 === t$2) || fs$1["Letterlike Symbols"](t$2) || fs$1["Number Forms"](t$2) || fs$1["Miscellaneous Technical"](t$2) && (t$2 >= 8960 && t$2 <= 8967 || t$2 >= 8972 && t$2 <= 8991 || t$2 >= 8996 && t$2 <= 9e3 || 9003 === t$2 || t$2 >= 9085 && t$2 <= 9114 || t$2 >= 9150 && t$2 <= 9165 || 9167 === t$2 || t$2 >= 9169 && t$2 <= 9179 || t$2 >= 9186 && t$2 <= 9215) || fs$1["Control Pictures"](t$2) && 9251 !== t$2 || fs$1["Optical Character Recognition"](t$2) || fs$1["Enclosed Alphanumerics"](t$2) || fs$1["Geometric Shapes"](t$2) || fs$1["Miscellaneous Symbols"](t$2) && !(t$2 >= 9754 && t$2 <= 9759) || fs$1["Miscellaneous Symbols and Arrows"](t$2) && (t$2 >= 11026 && t$2 <= 11055 || t$2 >= 11088 && t$2 <= 11097 || t$2 >= 11192 && t$2 <= 11243) || fs$1["CJK Symbols and Punctuation"](t$2) || fs$1.Katakana(t$2) || fs$1["Private Use Area"](t$2) || fs$1["CJK Compatibility Forms"](t$2) || fs$1["Small Form Variants"](t$2) || fs$1["Halfwidth and Fullwidth Forms"](t$2) || 8734 === t$2 || 8756 === t$2 || 8757 === t$2 || t$2 >= 9984 && t$2 <= 10087 || t$2 >= 10102 && t$2 <= 10131 || 65532 === t$2 || 65533 === t$2);
				}(t$1));
			}
			const _s$1 = ms$1([
				"Adlm",
				"Arab",
				"Armi",
				"Avst",
				"Chrs",
				"Cprt",
				"Egyp",
				"Elym",
				"Gara",
				"Hatr",
				"Hebr",
				"Hung",
				"Khar",
				"Lydi",
				"Mand",
				"Mani",
				"Mend",
				"Merc",
				"Mero",
				"Narb",
				"Nbat",
				"Nkoo",
				"Orkh",
				"Palm",
				"Phli",
				"Phlp",
				"Phnx",
				"Prti",
				"Rohg",
				"Samr",
				"Sarb",
				"Sogo",
				"Syrc",
				"Thaa",
				"Todr",
				"Yezi"
			]);
			function Ss$1(t$1) {
				return _s$1.test(String.fromCodePoint(t$1));
			}
			function As$1(t$1, e$1) {
				return !(!e$1 && Ss$1(t$1) || t$1 >= 2304 && t$1 <= 3583 || t$1 >= 3840 && t$1 <= 4255 || fs$1.Khmer(t$1));
			}
			function ks$1(t$1) {
				for (const e$1 of t$1) if (Ss$1(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			const Ms$1 = new class {
				constructor() {
					this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {};
				}
				setState(t$1) {
					this.pluginStatus = t$1.pluginStatus, this.pluginURL = t$1.pluginURL;
				}
				getState() {
					return {
						pluginStatus: this.pluginStatus,
						pluginURL: this.pluginURL
					};
				}
				setMethods(t$1) {
					if (Ms$1.isParsed()) throw new Error("RTL text plugin already registered.");
					this.applyArabicShaping = t$1.applyArabicShaping, this.processBidirectionalText = t$1.processBidirectionalText, this.processStyledBidirectionalText = t$1.processStyledBidirectionalText, this.loadScriptResolve();
				}
				isParsed() {
					return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
				}
				getRTLTextPluginStatus() {
					return this.pluginStatus;
				}
				syncState(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if (this.isParsed()) return this.getState();
						if ("loading" !== t$1.pluginStatus) return this.setState(t$1), t$1;
						const e$1 = t$1.pluginURL, n$1 = new Promise(((t$2) => {
							this.loadScriptResolve = t$2;
						}));
						r$1(e$1);
						const i$1 = new Promise(((t$2) => setTimeout((() => t$2()), this.TIMEOUT)));
						if (yield Promise.race([n$1, i$1]), this.isParsed()) {
							const t$2 = {
								pluginStatus: "loaded",
								pluginURL: e$1
							};
							return this.setState(t$2), t$2;
						}
						throw this.setState({
							pluginStatus: "error",
							pluginURL: ""
						}), /* @__PURE__ */ new Error(`RTL Text Plugin failed to import scripts from ${e$1}`);
					}));
				}
			}();
			class Is$1 {
				constructor(t$1, e$1) {
					this.zoom = t$1, e$1 ? (this.now = e$1.now || 0, this.fadeDuration = e$1.fadeDuration || 0, this.zoomHistory = e$1.zoomHistory || new ps$1(), this.transition = e$1.transition || {}, this.globalState = e$1.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ps$1(), this.transition = {}, this.globalState = {});
				}
				isSupportedScript(t$1) {
					return function(t$2, e$1) {
						for (const r$1 of t$2) if (!As$1(r$1.charCodeAt(0), e$1)) return !1;
						return !0;
					}(t$1, "loaded" === Ms$1.getRTLTextPluginStatus());
				}
				crossFadingFactor() {
					return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
				}
				getCrossfadeParameters() {
					const t$1 = this.zoom, e$1 = t$1 - Math.floor(t$1), r$1 = this.crossFadingFactor();
					return t$1 > this.zoomHistory.lastIntegerZoom ? {
						fromScale: 2,
						toScale: 1,
						t: e$1 + (1 - e$1) * r$1
					} : {
						fromScale: .5,
						toScale: 1,
						t: 1 - (1 - r$1) * e$1
					};
				}
			}
			class zs$1 {
				constructor(t$1, e$1) {
					this.property = t$1, this.value = e$1, this.expression = function(t$2, e$2) {
						if (Xn(t$2)) return new ai$1(t$2, e$2);
						if (ei$1(t$2)) {
							const r$1 = si$1(t$2, e$2);
							if ("error" === r$1.result) throw new Error(r$1.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
							return r$1.value;
						}
						{
							let r$1 = t$2;
							return "color" === e$2.type && "string" == typeof t$2 ? r$1 = Me$1.parse(t$2) : "padding" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "numberArray" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "colorArray" !== e$2.type || "string" != typeof t$2 && !Array.isArray(t$2) ? "variableAnchorOffsetCollection" === e$2.type && Array.isArray(t$2) ? r$1 = $e$1.parse(t$2) : "projectionDefinition" === e$2.type && "string" == typeof t$2 && (r$1 = Oe$1.parse(t$2)) : r$1 = Ve$1.parse(t$2) : r$1 = Be$1.parse(t$2) : r$1 = Ee.parse(t$2), {
								globalStateRefs: /* @__PURE__ */ new Set(),
								kind: "constant",
								evaluate: () => r$1
							};
						}
					}(void 0 === e$1 ? t$1.specification.default : e$1, t$1.specification);
				}
				isDataDriven() {
					return "source" === this.expression.kind || "composite" === this.expression.kind;
				}
				getGlobalStateRefs() {
					return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					return this.property.possiblyEvaluate(this, t$1, e$1, r$1);
				}
			}
			class Ps$1 {
				constructor(t$1) {
					this.property = t$1, this.value = new zs$1(t$1, void 0);
				}
				transitioned(t$1, e$1) {
					return new Es$1(this.property, this.value, e$1, O$1({}, t$1.transition, this.transition), t$1.now);
				}
				untransitioned() {
					return new Es$1(this.property, this.value, null, {}, 0);
				}
			}
			class Cs$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitionablePropertyValues);
				}
				getValue(t$1) {
					return j$1(this._values[t$1].value.value);
				}
				setValue(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Ps$1(this._values[t$1].property)), this._values[t$1].value = new zs$1(this._values[t$1].property, null === e$1 ? void 0 : j$1(e$1));
				}
				getTransition(t$1) {
					return j$1(this._values[t$1].transition);
				}
				setTransition(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Ps$1(this._values[t$1].property)), this._values[t$1].transition = j$1(e$1) || void 0;
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
						const n$1 = this.getTransition(e$1);
						void 0 !== n$1 && (t$1[`${e$1}-transition`] = n$1);
					}
					return t$1;
				}
				transitioned(t$1, e$1) {
					const r$1 = new Bs$1(this._properties);
					for (const n$1 of Object.keys(this._values)) r$1._values[n$1] = this._values[n$1].transitioned(t$1, e$1._values[n$1]);
					return r$1;
				}
				untransitioned() {
					const t$1 = new Bs$1(this._properties);
					for (const e$1 of Object.keys(this._values)) t$1._values[e$1] = this._values[e$1].untransitioned();
					return t$1;
				}
			}
			class Es$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.property = t$1, this.value = e$1, this.begin = i$1 + n$1.delay || 0, this.end = this.begin + n$1.duration || 0, t$1.specification.transition && (n$1.delay || n$1.duration) && (this.prior = r$1);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = t$1.now || 0, i$1 = this.value.possiblyEvaluate(t$1, e$1, r$1), s$1 = this.prior;
					if (s$1) {
						if (n$1 > this.end) return this.prior = null, i$1;
						if (this.value.isDataDriven()) return this.prior = null, i$1;
						if (n$1 < this.begin) return s$1.possiblyEvaluate(t$1, e$1, r$1);
						{
							const a = (n$1 - this.begin) / (this.end - this.begin);
							return this.property.interpolate(s$1.possiblyEvaluate(t$1, e$1, r$1), i$1, V(a));
						}
					}
					return i$1;
				}
			}
			class Bs$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new Fs$1(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
				hasTransition() {
					for (const t$1 of Object.keys(this._values)) if (this._values[t$1].prior) return !0;
					return !1;
				}
			}
			class Vs$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPropertyValues);
				}
				hasValue(t$1) {
					return void 0 !== this._values[t$1].value;
				}
				getValue(t$1) {
					return j$1(this._values[t$1].value);
				}
				setValue(t$1, e$1) {
					this._values[t$1] = new zs$1(this._values[t$1].property, null === e$1 ? void 0 : j$1(e$1));
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
					}
					return t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new Fs$1(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
			}
			class Ts$1 {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.parameters = r$1;
				}
				isConstant() {
					return "constant" === this.value.kind;
				}
				constantOr(t$1) {
					return "constant" === this.value.kind ? this.value.value : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return this.property.evaluate(this.value, this.parameters, t$1, e$1, r$1, n$1);
				}
			}
			class Fs$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPossiblyEvaluatedValues);
				}
				get(t$1) {
					return this._values[t$1];
				}
			}
			class $s$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					if (t$1.isDataDriven()) throw new Error("Value should not be data driven");
					return t$1.expression.evaluate(e$1);
				}
				interpolate(t$1, e$1, r$1) {
					const n$1 = dr$1[this.specification.type];
					return n$1 ? n$1(t$1, e$1, r$1) : t$1;
				}
			}
			class Ls$1 {
				constructor(t$1, e$1) {
					this.specification = t$1, this.overrides = e$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return new Ts$1(this, "constant" === t$1.expression.kind || "camera" === t$1.expression.kind ? {
						kind: "constant",
						value: t$1.expression.evaluate(e$1, null, {}, r$1, n$1)
					} : t$1.expression, e$1);
				}
				interpolate(t$1, e$1, r$1) {
					if ("constant" !== t$1.value.kind || "constant" !== e$1.value.kind) return t$1;
					if (void 0 === t$1.value.value || void 0 === e$1.value.value) return new Ts$1(this, {
						kind: "constant",
						value: void 0
					}, t$1.parameters);
					const n$1 = dr$1[this.specification.type];
					if (n$1) {
						const i$1 = n$1(t$1.value.value, e$1.value.value, r$1);
						return new Ts$1(this, {
							kind: "constant",
							value: i$1
						}, t$1.parameters);
					}
					return t$1;
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return "constant" === t$1.kind ? t$1.value : t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
				}
			}
			class Os$1 extends Ls$1 {
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 === t$1.value) return new Ts$1(this, {
						kind: "constant",
						value: void 0
					}, e$1);
					if ("constant" === t$1.expression.kind) {
						const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1), s$1 = "resolvedImage" === t$1.property.specification.type && "string" != typeof i$1 ? i$1.name : i$1, a = this._calculate(s$1, s$1, s$1, e$1);
						return new Ts$1(this, {
							kind: "constant",
							value: a
						}, e$1);
					}
					if ("camera" === t$1.expression.kind) {
						const r$2 = this._calculate(t$1.expression.evaluate({ zoom: e$1.zoom - 1 }), t$1.expression.evaluate({ zoom: e$1.zoom }), t$1.expression.evaluate({ zoom: e$1.zoom + 1 }), e$1);
						return new Ts$1(this, {
							kind: "constant",
							value: r$2
						}, e$1);
					}
					return new Ts$1(this, t$1.expression, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					if ("source" === t$1.kind) {
						const a = t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
						return this._calculate(a, a, a, e$1);
					}
					return "composite" === t$1.kind ? this._calculate(t$1.evaluate({ zoom: Math.floor(e$1.zoom) - 1 }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) + 1 }, r$1, n$1), e$1) : t$1.value;
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Ds$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 !== t$1.value) {
						if ("constant" === t$1.expression.kind) {
							const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
							return this._calculate(i$1, i$1, i$1, e$1);
						}
						return this._calculate(t$1.expression.evaluate(new Is$1(Math.floor(e$1.zoom - 1), e$1)), t$1.expression.evaluate(new Is$1(Math.floor(e$1.zoom), e$1)), t$1.expression.evaluate(new Is$1(Math.floor(e$1.zoom + 1), e$1)), e$1);
					}
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Rs$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return !!t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
				}
				interpolate() {
					return !1;
				}
			}
			class Us$1 {
				constructor(t$1) {
					this.properties = t$1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
					for (const e$1 in t$1) {
						const r$1 = t$1[e$1];
						r$1.specification.overridable && this.overridableProperties.push(e$1);
						const n$1 = this.defaultPropertyValues[e$1] = new zs$1(r$1, void 0), i$1 = this.defaultTransitionablePropertyValues[e$1] = new Ps$1(r$1);
						this.defaultTransitioningPropertyValues[e$1] = i$1.untransitioned(), this.defaultPossiblyEvaluatedValues[e$1] = n$1.possiblyEvaluate({});
					}
				}
			}
			as$1("DataDrivenProperty", Ls$1), as$1("DataConstantProperty", $s$1), as$1("CrossFadedDataDrivenProperty", Os$1), as$1("CrossFadedProperty", Ds$1), as$1("ColorRampProperty", Rs$1);
			const js$1 = "-transition";
			class Ns$1 extends gt$1 {
				constructor(t$1, e$1) {
					if (super(), this.id = t$1.id, this.type = t$1.type, this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						getGlobalStateRefs: () => /* @__PURE__ */ new Set()
					}, "custom" !== t$1.type && (this.metadata = t$1.metadata, this.minzoom = t$1.minzoom, this.maxzoom = t$1.maxzoom, "background" !== t$1.type && (this.source = t$1.source, this.sourceLayer = t$1["source-layer"], this.filter = t$1.filter, this._featureFilter = hi$1(t$1.filter)), e$1.layout && (this._unevaluatedLayout = new Vs$1(e$1.layout)), e$1.paint)) {
						this._transitionablePaint = new Cs$1(e$1.paint);
						for (const e$2 in t$1.paint) this.setPaintProperty(e$2, t$1.paint[e$2], { validate: !1 });
						for (const e$2 in t$1.layout) this.setLayoutProperty(e$2, t$1.layout[e$2], { validate: !1 });
						this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Fs$1(e$1.paint);
					}
				}
				setFilter(t$1) {
					this.filter = t$1, this._featureFilter = hi$1(t$1);
				}
				getCrossfadeParameters() {
					return this._crossfadeParameters;
				}
				getLayoutProperty(t$1) {
					return "visibility" === t$1 ? this.visibility : this._unevaluatedLayout.getValue(t$1);
				}
				getLayoutAffectingGlobalStateRefs() {
					const t$1 = /* @__PURE__ */ new Set();
					if (this._unevaluatedLayout) for (const e$1 in this._unevaluatedLayout._values) {
						const r$1 = this._unevaluatedLayout._values[e$1];
						for (const e$2 of r$1.getGlobalStateRefs()) t$1.add(e$2);
					}
					for (const e$1 of this._featureFilter.getGlobalStateRefs()) t$1.add(e$1);
					return t$1;
				}
				setLayoutProperty(t$1, e$1, r$1 = {}) {
					null != e$1 && this._validate(rs$1, `layers.${this.id}.layout.${t$1}`, t$1, e$1, r$1) || ("visibility" !== t$1 ? this._unevaluatedLayout.setValue(t$1, e$1) : this.visibility = e$1);
				}
				getPaintProperty(t$1) {
					return t$1.endsWith(js$1) ? this._transitionablePaint.getTransition(t$1.slice(0, -11)) : this._transitionablePaint.getValue(t$1);
				}
				setPaintProperty(t$1, e$1, r$1 = {}) {
					if (null != e$1 && this._validate(es$1, `layers.${this.id}.paint.${t$1}`, t$1, e$1, r$1)) return !1;
					if (t$1.endsWith(js$1)) return this._transitionablePaint.setTransition(t$1.slice(0, -11), e$1 || void 0), !1;
					{
						const r$2 = this._transitionablePaint._values[t$1], n$1 = "cross-faded-data-driven" === r$2.property.specification["property-type"], i$1 = r$2.value.isDataDriven(), s$1 = r$2.value;
						this._transitionablePaint.setValue(t$1, e$1), this._handleSpecialPaintPropertyUpdate(t$1);
						const a = this._transitionablePaint._values[t$1].value;
						return a.isDataDriven() || i$1 || n$1 || this._handleOverridablePaintPropertyUpdate(t$1, s$1, a);
					}
				}
				_handleSpecialPaintPropertyUpdate(t$1) {}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !1;
				}
				isHidden(t$1) {
					return !!(this.minzoom && t$1 < this.minzoom) || !!(this.maxzoom && t$1 >= this.maxzoom) || "none" === this.visibility;
				}
				updateTransitions(t$1) {
					this._transitioningPaint = this._transitionablePaint.transitioned(t$1, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculate(t$1, e$1) {
					t$1.getCrossfadeParameters && (this._crossfadeParameters = t$1.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1)), this.paint = this._transitioningPaint.possiblyEvaluate(t$1, void 0, e$1);
				}
				serialize() {
					const t$1 = {
						id: this.id,
						type: this.type,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return this.visibility && (t$1.layout = t$1.layout || {}, t$1.layout.visibility = this.visibility), U$1(t$1, ((t$2, e$1) => !(void 0 === t$2 || "layout" === e$1 && !Object.keys(t$2).length || "paint" === e$1 && !Object.keys(t$2).length)));
				}
				_validate(t$1, e$1, r$1, n$1, i$1 = {}) {
					return (!i$1 || !1 !== i$1.validate) && ns$1(this, t$1.call(Wi$1, {
						key: e$1,
						layerType: this.type,
						objectKey: r$1,
						value: n$1,
						styleSpec: xt$1,
						style: {
							glyphs: !0,
							sprite: !0
						}
					}));
				}
				is3D() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				resize() {}
				isStateDependent() {
					for (const t$1 in this.paint._values) {
						const e$1 = this.paint.get(t$1);
						if (e$1 instanceof Ts$1 && jn(e$1.property.specification) && ("source" === e$1.value.kind || "composite" === e$1.value.kind) && e$1.value.isStateDependent) return !0;
					}
					return !1;
				}
			}
			const qs$1 = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class Gs$1 {
				constructor(t$1, e$1) {
					this._structArray = t$1, this._pos1 = e$1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			class Xs$1 {
				constructor() {
					this.isTransferred = !1, this.capacity = -1, this.resize(0);
				}
				static serialize(t$1, e$1) {
					return t$1._trim(), e$1 && (t$1.isTransferred = !0, e$1.push(t$1.arrayBuffer)), {
						length: t$1.length,
						arrayBuffer: t$1.arrayBuffer
					};
				}
				static deserialize(t$1) {
					const e$1 = Object.create(this.prototype);
					return e$1.arrayBuffer = t$1.arrayBuffer, e$1.length = t$1.length, e$1.capacity = t$1.arrayBuffer.byteLength / e$1.bytesPerElement, e$1._refreshViews(), e$1;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(t$1) {
					this.reserve(t$1), this.length = t$1;
				}
				reserve(t$1) {
					if (t$1 > this.capacity) {
						this.capacity = Math.max(t$1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						const e$1 = this.uint8;
						this._refreshViews(), e$1 && this.uint8.set(e$1);
					}
				}
				_refreshViews() {
					throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
				}
			}
			function Zs$1(t$1, e$1 = 1) {
				let r$1 = 0, n$1 = 0;
				return {
					members: t$1.map(((t$2) => {
						const i$1 = qs$1[t$2.type].BYTES_PER_ELEMENT, s$1 = r$1 = Ys$1(r$1, Math.max(e$1, i$1)), a = t$2.components || 1;
						return n$1 = Math.max(n$1, i$1), r$1 += i$1 * a, {
							name: t$2.name,
							type: t$2.type,
							components: a,
							offset: s$1
						};
					})),
					size: Ys$1(r$1, Math.max(n$1, e$1)),
					alignment: e$1
				};
			}
			function Ys$1(t$1, e$1) {
				return Math.ceil(t$1 / e$1) * e$1;
			}
			class Hs$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.int16[n$1 + 0] = e$1, this.int16[n$1 + 1] = r$1, t$1;
				}
			}
			Hs$1.prototype.bytesPerElement = 4, as$1("StructArrayLayout2i4", Hs$1);
			class Ks$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			Ks$1.prototype.bytesPerElement = 6, as$1("StructArrayLayout3i6", Ks$1);
			class Js$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.int16[s$1 + 0] = e$1, this.int16[s$1 + 1] = r$1, this.int16[s$1 + 2] = n$1, this.int16[s$1 + 3] = i$1, t$1;
				}
			}
			Js$1.prototype.bytesPerElement = 8, as$1("StructArrayLayout4i8", Js$1);
			class Ws$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a, t$1;
				}
			}
			Ws$1.prototype.bytesPerElement = 12, as$1("StructArrayLayout2i4i12", Ws$1);
			class Qs$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 4 * t$1, l$1 = 8 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.uint8[l$1 + 4] = n$1, this.uint8[l$1 + 5] = i$1, this.uint8[l$1 + 6] = s$1, this.uint8[l$1 + 7] = a, t$1;
				}
			}
			Qs$1.prototype.bytesPerElement = 8, as$1("StructArrayLayout2i4ub8", Qs$1);
			class ta$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.float32[n$1 + 0] = e$1, this.float32[n$1 + 1] = r$1, t$1;
				}
			}
			ta$1.prototype.bytesPerElement = 8, as$1("StructArrayLayout2f8", ta$1);
			class ea$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = this.length;
					return this.resize(c$1 + 1), this.emplace(c$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					const h$1 = 10 * t$1;
					return this.uint16[h$1 + 0] = e$1, this.uint16[h$1 + 1] = r$1, this.uint16[h$1 + 2] = n$1, this.uint16[h$1 + 3] = i$1, this.uint16[h$1 + 4] = s$1, this.uint16[h$1 + 5] = a, this.uint16[h$1 + 6] = o$1, this.uint16[h$1 + 7] = l$1, this.uint16[h$1 + 8] = u$1, this.uint16[h$1 + 9] = c$1, t$1;
				}
			}
			ea$1.prototype.bytesPerElement = 20, as$1("StructArrayLayout10ui20", ea$1);
			class ra$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1) {
					const p$1 = this.length;
					return this.resize(p$1 + 1), this.emplace(p$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = 12 * t$1;
					return this.int16[f$1 + 0] = e$1, this.int16[f$1 + 1] = r$1, this.int16[f$1 + 2] = n$1, this.int16[f$1 + 3] = i$1, this.uint16[f$1 + 4] = s$1, this.uint16[f$1 + 5] = a, this.uint16[f$1 + 6] = o$1, this.uint16[f$1 + 7] = l$1, this.int16[f$1 + 8] = u$1, this.int16[f$1 + 9] = c$1, this.int16[f$1 + 10] = h$1, this.int16[f$1 + 11] = p$1, t$1;
				}
			}
			ra$1.prototype.bytesPerElement = 24, as$1("StructArrayLayout4i4ui4i24", ra$1);
			class na$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.float32[i$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			na$1.prototype.bytesPerElement = 12, as$1("StructArrayLayout3f12", na$1);
			class ia$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ia$1.prototype.bytesPerElement = 4, as$1("StructArrayLayout1ul4", ia$1);
			class sa$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
					const u$1 = this.length;
					return this.resize(u$1 + 1), this.emplace(u$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = 10 * t$1, h$1 = 5 * t$1;
					return this.int16[c$1 + 0] = e$1, this.int16[c$1 + 1] = r$1, this.int16[c$1 + 2] = n$1, this.int16[c$1 + 3] = i$1, this.int16[c$1 + 4] = s$1, this.int16[c$1 + 5] = a, this.uint32[h$1 + 3] = o$1, this.uint16[c$1 + 8] = l$1, this.uint16[c$1 + 9] = u$1, t$1;
				}
			}
			sa$1.prototype.bytesPerElement = 20, as$1("StructArrayLayout6i1ul2ui20", sa$1);
			class aa$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a, t$1;
				}
			}
			aa$1.prototype.bytesPerElement = 12, as$1("StructArrayLayout2i2i2i12", aa$1);
			class oa$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = 4 * t$1, o$1 = 8 * t$1;
					return this.float32[a + 0] = e$1, this.float32[a + 1] = r$1, this.float32[a + 2] = n$1, this.int16[o$1 + 6] = i$1, this.int16[o$1 + 7] = s$1, t$1;
				}
			}
			oa$1.prototype.bytesPerElement = 16, as$1("StructArrayLayout2f1f2i16", oa$1);
			class la$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 16 * t$1, l$1 = 4 * t$1, u$1 = 8 * t$1;
					return this.uint8[o$1 + 0] = e$1, this.uint8[o$1 + 1] = r$1, this.float32[l$1 + 1] = n$1, this.float32[l$1 + 2] = i$1, this.int16[u$1 + 6] = s$1, this.int16[u$1 + 7] = a, t$1;
				}
			}
			la$1.prototype.bytesPerElement = 16, as$1("StructArrayLayout2ub2f2i16", la$1);
			class ua$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[i$1 + 0] = e$1, this.uint16[i$1 + 1] = r$1, this.uint16[i$1 + 2] = n$1, t$1;
				}
			}
			ua$1.prototype.bytesPerElement = 6, as$1("StructArrayLayout3ui6", ua$1);
			class ca$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1) {
					const g$2 = this.length;
					return this.resize(g$2 + 1), this.emplace(g$2, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2) {
					const x$1 = 24 * t$1, v$1 = 12 * t$1, b$2 = 48 * t$1;
					return this.int16[x$1 + 0] = e$1, this.int16[x$1 + 1] = r$1, this.uint16[x$1 + 2] = n$1, this.uint16[x$1 + 3] = i$1, this.uint32[v$1 + 2] = s$1, this.uint32[v$1 + 3] = a, this.uint32[v$1 + 4] = o$1, this.uint16[x$1 + 10] = l$1, this.uint16[x$1 + 11] = u$1, this.uint16[x$1 + 12] = c$1, this.float32[v$1 + 7] = h$1, this.float32[v$1 + 8] = p$1, this.uint8[b$2 + 36] = f$1, this.uint8[b$2 + 37] = d$1, this.uint8[b$2 + 38] = y$1, this.uint32[v$1 + 10] = m$1, this.int16[x$1 + 22] = g$2, t$1;
				}
			}
			ca$1.prototype.bytesPerElement = 48, as$1("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ca$1);
			class ha$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$2, w$1, _$2, S$2, A$1, k$2, M$2, I$2) {
					const z$2 = this.length;
					return this.resize(z$2 + 1), this.emplace(z$2, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$2, w$1, _$2, S$2, A$1, k$2, M$2, I$2);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$2, w$1, _$2, S$2, A$1, k$2, M$2, I$2, z$2) {
					const P$2 = 32 * t$1, C$1 = 16 * t$1;
					return this.int16[P$2 + 0] = e$1, this.int16[P$2 + 1] = r$1, this.int16[P$2 + 2] = n$1, this.int16[P$2 + 3] = i$1, this.int16[P$2 + 4] = s$1, this.int16[P$2 + 5] = a, this.int16[P$2 + 6] = o$1, this.int16[P$2 + 7] = l$1, this.uint16[P$2 + 8] = u$1, this.uint16[P$2 + 9] = c$1, this.uint16[P$2 + 10] = h$1, this.uint16[P$2 + 11] = p$1, this.uint16[P$2 + 12] = f$1, this.uint16[P$2 + 13] = d$1, this.uint16[P$2 + 14] = y$1, this.uint16[P$2 + 15] = m$1, this.uint16[P$2 + 16] = g$2, this.uint16[P$2 + 17] = x$1, this.uint16[P$2 + 18] = v$1, this.uint16[P$2 + 19] = b$2, this.uint16[P$2 + 20] = w$1, this.uint16[P$2 + 21] = _$2, this.uint16[P$2 + 22] = S$2, this.uint32[C$1 + 12] = A$1, this.float32[C$1 + 13] = k$2, this.float32[C$1 + 14] = M$2, this.uint16[P$2 + 30] = I$2, this.uint16[P$2 + 31] = z$2, t$1;
				}
			}
			ha$1.prototype.bytesPerElement = 64, as$1("StructArrayLayout8i15ui1ul2f2ui64", ha$1);
			class pa$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.float32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			pa$1.prototype.bytesPerElement = 4, as$1("StructArrayLayout1f4", pa$1);
			class fa$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[6 * t$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			fa$1.prototype.bytesPerElement = 12, as$1("StructArrayLayout1ui2f12", fa$1);
			class da$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1;
					return this.uint32[2 * t$1 + 0] = e$1, this.uint16[i$1 + 2] = r$1, this.uint16[i$1 + 3] = n$1, t$1;
				}
			}
			da$1.prototype.bytesPerElement = 8, as$1("StructArrayLayout1ul2ui8", da$1);
			class ya$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.uint16[n$1 + 0] = e$1, this.uint16[n$1 + 1] = r$1, t$1;
				}
			}
			ya$1.prototype.bytesPerElement = 4, as$1("StructArrayLayout2ui4", ya$1);
			class ma$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ma$1.prototype.bytesPerElement = 2, as$1("StructArrayLayout1ui2", ma$1);
			class ga$1 extends Xs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.float32[s$1 + 0] = e$1, this.float32[s$1 + 1] = r$1, this.float32[s$1 + 2] = n$1, this.float32[s$1 + 3] = i$1, t$1;
				}
			}
			ga$1.prototype.bytesPerElement = 16, as$1("StructArrayLayout4f16", ga$1);
			class xa$1 extends Gs$1 {
				get anchorPointX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorPointY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get x1() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get y1() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get x2() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get y2() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get anchorPoint() {
					return new r(this.anchorPointX, this.anchorPointY);
				}
			}
			xa$1.prototype.size = 20;
			class va$1 extends sa$1 {
				get(t$1) {
					return new xa$1(this, t$1);
				}
			}
			as$1("CollisionBoxArray", va$1);
			class ba$1 extends Gs$1 {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 2];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 4];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 7];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 8];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 36];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 37];
				}
				set placedOrientation(t$1) {
					this._structArray.uint8[this._pos1 + 37] = t$1;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 38];
				}
				set hidden(t$1) {
					this._structArray.uint8[this._pos1 + 38] = t$1;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 10];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 10] = t$1;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 22];
				}
			}
			ba$1.prototype.size = 48;
			class wa$1 extends ca$1 {
				get(t$1) {
					return new ba$1(this, t$1);
				}
			}
			as$1("PlacedSymbolArray", wa$1);
			class _a$1 extends Gs$1 {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 12];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 12] = t$1;
				}
				get textBoxScale() {
					return this._structArray.float32[this._pos4 + 13];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 14];
				}
				get textAnchorOffsetStartIndex() {
					return this._structArray.uint16[this._pos2 + 30];
				}
				get textAnchorOffsetEndIndex() {
					return this._structArray.uint16[this._pos2 + 31];
				}
			}
			_a$1.prototype.size = 64;
			class Sa$1 extends ha$1 {
				get(t$1) {
					return new _a$1(this, t$1);
				}
			}
			as$1("SymbolInstanceArray", Sa$1);
			class Aa$1 extends pa$1 {
				getoffsetX(t$1) {
					return this.float32[1 * t$1 + 0];
				}
			}
			as$1("GlyphOffsetArray", Aa$1);
			class ka$1 extends Ks$1 {
				getx(t$1) {
					return this.int16[3 * t$1 + 0];
				}
				gety(t$1) {
					return this.int16[3 * t$1 + 1];
				}
				gettileUnitDistanceFromAnchor(t$1) {
					return this.int16[3 * t$1 + 2];
				}
			}
			as$1("SymbolLineVertexArray", ka$1);
			class Ma$1 extends Gs$1 {
				get textAnchor() {
					return this._structArray.uint16[this._pos2 + 0];
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 2];
				}
			}
			Ma$1.prototype.size = 12;
			class Ia$1 extends fa$1 {
				get(t$1) {
					return new Ma$1(this, t$1);
				}
			}
			as$1("TextAnchorOffsetArray", Ia$1);
			class za$1 extends Gs$1 {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
			}
			za$1.prototype.size = 8;
			class Pa$1 extends da$1 {
				get(t$1) {
					return new za$1(this, t$1);
				}
			}
			as$1("FeatureIndexArray", Pa$1);
			class Ca$1 extends Hs$1 {}
			class Ea$1 extends Hs$1 {}
			class Ba$1 extends Hs$1 {}
			class Va$1 extends Ws$1 {}
			class Ta$1 extends Qs$1 {}
			class Fa$1 extends ta$1 {}
			class $a$1 extends ea$1 {}
			class La$1 extends ra$1 {}
			class Oa$1 extends na$1 {}
			class Da$1 extends ia$1 {}
			class Ra$1 extends aa$1 {}
			class Ua$1 extends la$1 {}
			class ja$1 extends ua$1 {}
			class Na$1 extends ya$1 {}
			const { members: Ga$1 } = Zs$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			class Xa$1 {
				constructor(t$1 = []) {
					this._forceNewSegmentOnNextPrepare = !1, this.segments = t$1;
				}
				prepareSegment(t$1, e$1, r$1, n$1) {
					const i$1 = this.segments[this.segments.length - 1];
					return t$1 > Xa$1.MAX_VERTEX_ARRAY_LENGTH && q$1(`Max vertices per segment is ${Xa$1.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t$1}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Xa$1.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i$1 || i$1.vertexLength + t$1 > Xa$1.MAX_VERTEX_ARRAY_LENGTH || i$1.sortKey !== n$1 ? this.createNewSegment(e$1, r$1, n$1) : i$1;
				}
				createNewSegment(t$1, e$1, r$1) {
					const n$1 = {
						vertexOffset: t$1.length,
						primitiveOffset: e$1.length,
						vertexLength: 0,
						primitiveLength: 0,
						vaos: {}
					};
					return void 0 !== r$1 && (n$1.sortKey = r$1), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(n$1), n$1;
				}
				getOrCreateLatestSegment(t$1, e$1, r$1) {
					return this.prepareSegment(0, t$1, e$1, r$1);
				}
				forceNewSegmentOnNextPrepare() {
					this._forceNewSegmentOnNextPrepare = !0;
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (const t$1 of this.segments) for (const e$1 in t$1.vaos) t$1.vaos[e$1].destroy();
				}
				static simpleSegment(t$1, e$1, r$1, n$1) {
					return new Xa$1([{
						vertexOffset: t$1,
						primitiveOffset: e$1,
						vertexLength: r$1,
						primitiveLength: n$1,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function Za$1(t$1, e$1) {
				return 256 * (t$1 = $$1(Math.floor(t$1), 0, 255)) + $$1(Math.floor(e$1), 0, 255);
			}
			Xa$1.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, as$1("SegmentVector", Xa$1);
			const Ya$1 = Zs$1([
				{
					name: "a_pattern_from",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pattern_to",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_from",
					components: 1,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_to",
					components: 1,
					type: "Uint16"
				}
			]);
			var Ha$1, Ka$1, Ja$1, Wa$1 = { exports: {} }, Qa$1 = { exports: {} }, to$1 = { exports: {} }, ro$1 = n(function() {
				if (Ja$1) return Wa$1.exports;
				Ja$1 = 1;
				var t$1 = (Ha$1 || (Ha$1 = 1, Qa$1.exports = function(t$2, e$2) {
					var r$1, n$1, i$1, s$1, a, o$1, l$1, u$1;
					for (n$1 = t$2.length - (r$1 = 3 & t$2.length), i$1 = e$2, a = 3432918353, o$1 = 461845907, u$1 = 0; u$1 < n$1;) l$1 = 255 & t$2.charCodeAt(u$1) | (255 & t$2.charCodeAt(++u$1)) << 8 | (255 & t$2.charCodeAt(++u$1)) << 16 | (255 & t$2.charCodeAt(++u$1)) << 24, ++u$1, i$1 = 27492 + (65535 & (s$1 = 5 * (65535 & (i$1 = (i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & l$1) * a + (((l$1 >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295) << 13 | i$1 >>> 19)) + ((5 * (i$1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s$1 >>> 16) & 65535) << 16);
					switch (l$1 = 0, r$1) {
						case 3: l$1 ^= (255 & t$2.charCodeAt(u$1 + 2)) << 16;
						case 2: l$1 ^= (255 & t$2.charCodeAt(u$1 + 1)) << 8;
						case 1: i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & (l$1 ^= 255 & t$2.charCodeAt(u$1))) * a + (((l$1 >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295;
					}
					return i$1 ^= t$2.length, i$1 = 2246822507 * (65535 & (i$1 ^= i$1 >>> 16)) + ((2246822507 * (i$1 >>> 16) & 65535) << 16) & 4294967295, i$1 = 3266489909 * (65535 & (i$1 ^= i$1 >>> 13)) + ((3266489909 * (i$1 >>> 16) & 65535) << 16) & 4294967295, (i$1 ^= i$1 >>> 16) >>> 0;
				}), Qa$1.exports), e$1 = (Ka$1 || (Ka$1 = 1, to$1.exports = function(t$2, e$2) {
					for (var r$1, n$1 = t$2.length, i$1 = e$2 ^ n$1, s$1 = 0; n$1 >= 4;) r$1 = 1540483477 * (65535 & (r$1 = 255 & t$2.charCodeAt(s$1) | (255 & t$2.charCodeAt(++s$1)) << 8 | (255 & t$2.charCodeAt(++s$1)) << 16 | (255 & t$2.charCodeAt(++s$1)) << 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16), i$1 = 1540483477 * (65535 & i$1) + ((1540483477 * (i$1 >>> 16) & 65535) << 16) ^ (r$1 = 1540483477 * (65535 & (r$1 ^= r$1 >>> 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16)), n$1 -= 4, ++s$1;
					switch (n$1) {
						case 3: i$1 ^= (255 & t$2.charCodeAt(s$1 + 2)) << 16;
						case 2: i$1 ^= (255 & t$2.charCodeAt(s$1 + 1)) << 8;
						case 1: i$1 = 1540483477 * (65535 & (i$1 ^= 255 & t$2.charCodeAt(s$1))) + ((1540483477 * (i$1 >>> 16) & 65535) << 16);
					}
					return i$1 = 1540483477 * (65535 & (i$1 ^= i$1 >>> 13)) + ((1540483477 * (i$1 >>> 16) & 65535) << 16), (i$1 ^= i$1 >>> 15) >>> 0;
				}), to$1.exports);
				return Wa$1.exports = t$1, Wa$1.exports.murmur3 = t$1, Wa$1.exports.murmur2 = e$1, Wa$1.exports;
			}());
			class no$1 {
				constructor() {
					this.ids = [], this.positions = [], this.indexed = !1;
				}
				add(t$1, e$1, r$1, n$1) {
					this.ids.push(io$1(t$1)), this.positions.push(e$1, r$1, n$1);
				}
				getPositions(t$1) {
					if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
					const e$1 = io$1(t$1);
					let r$1 = 0, n$1 = this.ids.length - 1;
					for (; r$1 < n$1;) {
						const t$2 = r$1 + n$1 >> 1;
						this.ids[t$2] >= e$1 ? n$1 = t$2 : r$1 = t$2 + 1;
					}
					const i$1 = [];
					for (; this.ids[r$1] === e$1;) i$1.push({
						index: this.positions[3 * r$1],
						start: this.positions[3 * r$1 + 1],
						end: this.positions[3 * r$1 + 2]
					}), r$1++;
					return i$1;
				}
				static serialize(t$1, e$1) {
					const r$1 = new Float64Array(t$1.ids), n$1 = new Uint32Array(t$1.positions);
					return so$1(r$1, n$1, 0, r$1.length - 1), e$1 && e$1.push(r$1.buffer, n$1.buffer), {
						ids: r$1,
						positions: n$1
					};
				}
				static deserialize(t$1) {
					const e$1 = new no$1();
					return e$1.ids = t$1.ids, e$1.positions = t$1.positions, e$1.indexed = !0, e$1;
				}
			}
			function io$1(t$1) {
				const e$1 = +t$1;
				return !isNaN(e$1) && e$1 <= Number.MAX_SAFE_INTEGER ? e$1 : ro$1(String(t$1));
			}
			function so$1(t$1, e$1, r$1, n$1) {
				for (; r$1 < n$1;) {
					const i$1 = t$1[r$1 + n$1 >> 1];
					let s$1 = r$1 - 1, a = n$1 + 1;
					for (;;) {
						do
							s$1++;
						while (t$1[s$1] < i$1);
						do
							a--;
						while (t$1[a] > i$1);
						if (s$1 >= a) break;
						ao$1(t$1, s$1, a), ao$1(e$1, 3 * s$1, 3 * a), ao$1(e$1, 3 * s$1 + 1, 3 * a + 1), ao$1(e$1, 3 * s$1 + 2, 3 * a + 2);
					}
					a - r$1 < n$1 - a ? (so$1(t$1, e$1, r$1, a), r$1 = a + 1) : (so$1(t$1, e$1, a + 1, n$1), n$1 = a);
				}
			}
			function ao$1(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			as$1("FeaturePositionMap", no$1);
			class oo$1 {
				constructor(t$1, e$1) {
					this.gl = t$1.gl, this.location = e$1;
				}
			}
			class lo$1 extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1f(this.location, t$1));
				}
			}
			class uo$1 extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] && t$1[3] === this.current[3] || (this.current = t$1, this.gl.uniform4f(this.location, t$1[0], t$1[1], t$1[2], t$1[3]));
				}
			}
			class co$1 extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = Me$1.transparent;
				}
				set(t$1) {
					t$1.r === this.current.r && t$1.g === this.current.g && t$1.b === this.current.b && t$1.a === this.current.a || (this.current = t$1, this.gl.uniform4f(this.location, t$1.r, t$1.g, t$1.b, t$1.a));
				}
			}
			const ho$1 = new Float32Array(16);
			function po$1(t$1) {
				return [Za$1(255 * t$1.r, 255 * t$1.g), Za$1(255 * t$1.b, 255 * t$1.a)];
			}
			class fo {
				constructor(t$1, e$1, r$1) {
					this.value = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.type = r$1;
				}
				setUniform(t$1, e$1, r$1) {
					t$1.set(r$1.constantOr(this.value));
				}
				getBinding(t$1, e$1, r$1) {
					return "color" === this.type ? new co$1(t$1, e$1) : new lo$1(t$1, e$1);
				}
			}
			class yo$1 {
				constructor(t$1, e$1) {
					this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
				}
				setConstantPatternPositions(t$1, e$1) {
					this.pixelRatioFrom = e$1.pixelRatio, this.pixelRatioTo = t$1.pixelRatio, this.patternFrom = e$1.tlbr, this.patternTo = t$1.tlbr;
				}
				setUniform(t$1, e$1, r$1, n$1) {
					const i$1 = "u_pattern_to" === n$1 ? this.patternTo : "u_pattern_from" === n$1 ? this.patternFrom : "u_pixel_ratio_to" === n$1 ? this.pixelRatioTo : "u_pixel_ratio_from" === n$1 ? this.pixelRatioFrom : null;
					i$1 && t$1.set(i$1);
				}
				getBinding(t$1, e$1, r$1) {
					return "u_pattern" === r$1.substr(0, 9) ? new uo$1(t$1, e$1) : new lo$1(t$1, e$1);
				}
			}
			class mo$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.expression = t$1, this.type = r$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new n$1();
				}
				populatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.paintVertexArray.length, a = this.expression.evaluate(new Is$1(0), e$1, {}, n$1, [], i$1);
					this.paintVertexArray.resize(t$1), this._setPaintValue(s$1, t$1, a);
				}
				updatePaintArray(t$1, e$1, r$1, n$1) {
					const i$1 = this.expression.evaluate({ zoom: 0 }, r$1, n$1);
					this._setPaintValue(t$1, e$1, i$1);
				}
				_setPaintValue(t$1, e$1, r$1) {
					if ("color" === this.type) {
						const n$1 = po$1(r$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, n$1[0], n$1[1]);
					} else {
						for (let n$1 = t$1; n$1 < e$1; n$1++) this.paintVertexArray.emplace(n$1, r$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class go$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}_t`)), this.type = r$1, this.useIntegerZoom = n$1, this.zoom = i$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new s$1();
				}
				populatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new Is$1(this.zoom), e$1, {}, n$1, [], i$1), a = this.expression.evaluate(new Is$1(this.zoom + 1), e$1, {}, n$1, [], i$1), o$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValue(o$1, t$1, s$1, a);
				}
				updatePaintArray(t$1, e$1, r$1, n$1) {
					const i$1 = this.expression.evaluate({ zoom: this.zoom }, r$1, n$1), s$1 = this.expression.evaluate({ zoom: this.zoom + 1 }, r$1, n$1);
					this._setPaintValue(t$1, e$1, i$1, s$1);
				}
				_setPaintValue(t$1, e$1, r$1, n$1) {
					if ("color" === this.type) {
						const i$1 = po$1(r$1), s$1 = po$1(n$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, i$1[0], i$1[1], s$1[0], s$1[1]);
					} else {
						for (let i$1 = t$1; i$1 < e$1; i$1++) this.paintVertexArray.emplace(i$1, r$1, n$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1), Math.abs(n$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(t$1, e$1) {
					const r$1 = this.useIntegerZoom ? Math.floor(e$1.zoom) : e$1.zoom, n$1 = $$1(this.expression.interpolationFactor(r$1, this.zoom, this.zoom + 1), 0, 1);
					t$1.set(n$1);
				}
				getBinding(t$1, e$1, r$1) {
					return new lo$1(t$1, e$1);
				}
			}
			class xo$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.type = e$1, this.useIntegerZoom = r$1, this.zoom = n$1, this.layerId = s$1, this.zoomInPaintVertexArray = new i$1(), this.zoomOutPaintVertexArray = new i$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.zoomInPaintVertexArray.length;
					this.zoomInPaintVertexArray.resize(t$1), this.zoomOutPaintVertexArray.resize(t$1), this._setPaintValues(n$1, t$1, e$1.patterns && e$1.patterns[this.layerId], r$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					this._setPaintValues(t$1, e$1, r$1.patterns && r$1.patterns[this.layerId], i$1);
				}
				_setPaintValues(t$1, e$1, r$1, n$1) {
					if (!n$1 || !r$1) return;
					const { min: i$1, mid: s$1, max: a } = r$1, o$1 = n$1[i$1], l$1 = n$1[s$1], u$1 = n$1[a];
					if (o$1 && l$1 && u$1) for (let r$2 = t$1; r$2 < e$1; r$2++) this.zoomInPaintVertexArray.emplace(r$2, l$1.tl[0], l$1.tl[1], l$1.br[0], l$1.br[1], o$1.tl[0], o$1.tl[1], o$1.br[0], o$1.br[1], l$1.pixelRatio, o$1.pixelRatio), this.zoomOutPaintVertexArray.emplace(r$2, l$1.tl[0], l$1.tl[1], l$1.br[0], l$1.br[1], u$1.tl[0], u$1.tl[1], u$1.br[0], u$1.br[1], l$1.pixelRatio, u$1.pixelRatio);
				}
				upload(t$1) {
					this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t$1.createVertexBuffer(this.zoomInPaintVertexArray, Ya$1.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t$1.createVertexBuffer(this.zoomOutPaintVertexArray, Ya$1.members, this.expression.isStateDependent));
				}
				destroy() {
					this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
				}
			}
			class vo$1 {
				constructor(t$1, e$1, r$1) {
					this.binders = {}, this._buffers = [];
					const n$1 = [];
					for (const i$1 in t$1.paint._values) {
						if (!r$1(i$1)) continue;
						const s$1 = t$1.paint.get(i$1);
						if (!(s$1 instanceof Ts$1 && jn(s$1.property.specification))) continue;
						const a = wo$1(i$1, t$1.type), o$1 = s$1.value, l$1 = s$1.property.specification.type, u$1 = s$1.property.useIntegerZoom, c$1 = s$1.property.specification["property-type"], h$1 = "cross-faded" === c$1 || "cross-faded-data-driven" === c$1;
						if ("constant" === o$1.kind) this.binders[i$1] = h$1 ? new yo$1(o$1.value, a) : new fo(o$1.value, a, l$1), n$1.push(`/u_${i$1}`);
						else if ("source" === o$1.kind || h$1) {
							const r$2 = _o$1(i$1, l$1, "source");
							this.binders[i$1] = h$1 ? new xo$1(o$1, l$1, u$1, e$1, r$2, t$1.id) : new mo$1(o$1, a, l$1, r$2), n$1.push(`/a_${i$1}`);
						} else {
							const t$2 = _o$1(i$1, l$1, "composite");
							this.binders[i$1] = new go$1(o$1, a, l$1, u$1, e$1, t$2), n$1.push(`/z_${i$1}`);
						}
					}
					this.cacheKey = n$1.sort().join("");
				}
				getMaxValue(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof mo$1 || e$1 instanceof go$1 ? e$1.maxValue : 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					for (const s$1 in this.binders) {
						const a = this.binders[s$1];
						(a instanceof mo$1 || a instanceof go$1 || a instanceof xo$1) && a.populatePaintArray(t$1, e$1, r$1, n$1, i$1);
					}
				}
				setConstantPatternPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof yo$1 && n$1.setConstantPatternPositions(t$1, e$1);
					}
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = !1;
					for (const a in t$1) {
						const o$1 = e$1.getPositions(a);
						for (const e$2 of o$1) {
							const o$2 = r$1.feature(e$2.index);
							for (const r$2 in this.binders) {
								const l$1 = this.binders[r$2];
								if ((l$1 instanceof mo$1 || l$1 instanceof go$1 || l$1 instanceof xo$1) && !0 === l$1.expression.isStateDependent) l$1.expression = n$1.paint.get(r$2).value, l$1.updatePaintArray(e$2.start, e$2.end, o$2, t$1[a], i$1), s$1 = !0;
							}
						}
					}
					return s$1;
				}
				defines() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof fo || r$1 instanceof yo$1) && t$1.push(...r$1.uniformNames.map(((t$2) => `#define HAS_UNIFORM_${t$2}`)));
					}
					return t$1;
				}
				getBinderAttributes() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof mo$1 || r$1 instanceof go$1) for (let e$2 = 0; e$2 < r$1.paintVertexAttributes.length; e$2++) t$1.push(r$1.paintVertexAttributes[e$2].name);
						else if (r$1 instanceof xo$1) for (let e$2 = 0; e$2 < Ya$1.members.length; e$2++) t$1.push(Ya$1.members[e$2].name);
					}
					return t$1;
				}
				getBinderUniforms() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof fo || r$1 instanceof yo$1 || r$1 instanceof go$1) for (const e$2 of r$1.uniformNames) t$1.push(e$2);
					}
					return t$1;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(t$1, e$1) {
					const r$1 = [];
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						if (i$1 instanceof fo || i$1 instanceof yo$1 || i$1 instanceof go$1) {
							for (const s$1 of i$1.uniformNames) if (e$1[s$1]) {
								const a = i$1.getBinding(t$1, e$1[s$1], s$1);
								r$1.push({
									name: s$1,
									property: n$1,
									binding: a
								});
							}
						}
					}
					return r$1;
				}
				setUniforms(t$1, e$1, r$1, n$1) {
					for (const { name: t$2, property: i$1, binding: s$1 } of e$1) this.binders[i$1].setUniform(s$1, n$1, r$1.get(i$1), t$2);
				}
				updatePaintBuffers(t$1) {
					this._buffers = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (t$1 && r$1 instanceof xo$1) {
							const e$2 = 2 === t$1.fromScale ? r$1.zoomInPaintVertexBuffer : r$1.zoomOutPaintVertexBuffer;
							e$2 && this._buffers.push(e$2);
						} else (r$1 instanceof mo$1 || r$1 instanceof go$1) && r$1.paintVertexBuffer && this._buffers.push(r$1.paintVertexBuffer);
					}
				}
				upload(t$1) {
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof mo$1 || r$1 instanceof go$1 || r$1 instanceof xo$1) && r$1.upload(t$1);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof mo$1 || e$1 instanceof go$1 || e$1 instanceof xo$1) && e$1.destroy();
					}
				}
			}
			class bo$1 {
				constructor(t$1, e$1, r$1 = () => !0) {
					this.programConfigurations = {};
					for (const n$1 of t$1) this.programConfigurations[n$1.id] = new vo$1(n$1, e$1, r$1);
					this.needsUpload = !1, this._featureMap = new no$1(), this._bufferOffset = 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const r$2 in this.programConfigurations) this.programConfigurations[r$2].populatePaintArrays(t$1, e$1, n$1, i$1, s$1);
					void 0 !== e$1.id && this._featureMap.add(e$1.id, r$1, this._bufferOffset, t$1), this._bufferOffset = t$1, this.needsUpload = !0;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const i$1 of r$1) this.needsUpload = this.programConfigurations[i$1.id].updatePaintArrays(t$1, this._featureMap, e$1, i$1, n$1) || this.needsUpload;
				}
				get(t$1) {
					return this.programConfigurations[t$1];
				}
				upload(t$1) {
					if (this.needsUpload) {
						for (const e$1 in this.programConfigurations) this.programConfigurations[e$1].upload(t$1);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (const t$1 in this.programConfigurations) this.programConfigurations[t$1].destroy();
				}
			}
			function wo$1(t$1, e$1) {
				return {
					"text-opacity": ["opacity"],
					"icon-opacity": ["opacity"],
					"text-color": ["fill_color"],
					"icon-color": ["fill_color"],
					"text-halo-color": ["halo_color"],
					"icon-halo-color": ["halo_color"],
					"text-halo-blur": ["halo_blur"],
					"icon-halo-blur": ["halo_blur"],
					"text-halo-width": ["halo_width"],
					"icon-halo-width": ["halo_width"],
					"line-gap-width": ["gapwidth"],
					"line-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-extrusion-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					]
				}[t$1] || [t$1.replace(`${e$1}-`, "").replace(/-/g, "_")];
			}
			function _o$1(t$1, e$1, r$1) {
				const n$1 = {
					color: {
						source: ta$1,
						composite: ga$1
					},
					number: {
						source: pa$1,
						composite: ta$1
					}
				}, i$1 = function(t$2) {
					return {
						"line-pattern": {
							source: $a$1,
							composite: $a$1
						},
						"fill-pattern": {
							source: $a$1,
							composite: $a$1
						},
						"fill-extrusion-pattern": {
							source: $a$1,
							composite: $a$1
						}
					}[t$2];
				}(t$1);
				return i$1 && i$1[r$1] || n$1[e$1][r$1];
			}
			as$1("ConstantBinder", fo), as$1("CrossFadedConstantBinder", yo$1), as$1("SourceExpressionBinder", mo$1), as$1("CrossFadedCompositeBinder", xo$1), as$1("CompositeExpressionBinder", go$1), as$1("ProgramConfiguration", vo$1, { omit: ["_buffers"] }), as$1("ProgramConfigurationSet", bo$1);
			const So$1 = Math.pow(2, 14) - 1, Ao$1 = -So$1 - 1;
			function ko$1(t$1) {
				const e$1 = P$1 / t$1.extent, r$1 = t$1.loadGeometry();
				for (let t$2 = 0; t$2 < r$1.length; t$2++) {
					const n$1 = r$1[t$2];
					for (let t$3 = 0; t$3 < n$1.length; t$3++) {
						const r$2 = n$1[t$3], i$1 = Math.round(r$2.x * e$1), s$1 = Math.round(r$2.y * e$1);
						r$2.x = $$1(i$1, Ao$1, So$1), r$2.y = $$1(s$1, Ao$1, So$1), (i$1 < r$2.x || i$1 > r$2.x + 1 || s$1 < r$2.y || s$1 > r$2.y + 1) && q$1("Geometry exceeds allowed extent, reduce your vector tile buffer size");
					}
				}
				return r$1;
			}
			function Mo$1(t$1, e$1) {
				return {
					type: t$1.type,
					id: t$1.id,
					properties: t$1.properties,
					geometry: e$1 ? ko$1(t$1) : []
				};
			}
			const Io$1 = -32768;
			function zo$1(t$1, e$1, r$1, n$1, i$1) {
				t$1.emplaceBack(Io$1 + 8 * e$1 + n$1, Io$1 + 8 * r$1 + i$1);
			}
			class Po$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.globalState = t$1.globalState, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasPattern = !1, this.layoutVertexArray = new Ea$1(), this.indexArray = new ja$1(), this.segments = new Xa$1(), this.programConfigurations = new bo$1(t$1.layers, t$1.zoom), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					const n$1 = this.layers[0], i$1 = [];
					let s$1 = null, a = !1, o$1 = "heatmap" === n$1.type;
					if ("circle" === n$1.type) {
						const t$2 = n$1;
						s$1 = t$2.layout.get("circle-sort-key"), a = !s$1.isConstant(), o$1 = o$1 || "map" === t$2.paint.get("circle-pitch-alignment");
					}
					const l$1 = o$1 ? e$1.subdivisionGranularity.circle : 1;
					for (const { feature: e$2, id: n$2, index: o$2, sourceLayerIndex: l$2 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Mo$1(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Is$1(this.zoom, { globalState: this.globalState }), u$1, r$1)) continue;
						const c$1 = a ? s$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: n$2,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$2,
							index: o$2,
							geometry: t$2 ? u$1.geometry : ko$1(e$2),
							patterns: {},
							sortKey: c$1
						};
						i$1.push(h$1);
					}
					a && i$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of i$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a$1 } = n$2, o$2 = t$1[s$2].feature;
						this.addFeature(n$2, i$2, s$2, r$1, l$1), e$1.featureIndex.insert(o$2, i$2, s$2, a$1, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, r$1);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Ga$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1 = 1) {
					let s$1;
					switch (i$1) {
						case 1:
							s$1 = [0, 7];
							break;
						case 3:
							s$1 = [
								0,
								2,
								5,
								7
							];
							break;
						case 5:
							s$1 = [
								0,
								1,
								3,
								4,
								6,
								7
							];
							break;
						case 7:
							s$1 = [
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7
							];
							break;
						default: throw new Error(`Invalid circle bucket granularity: ${i$1}; valid values are 1, 3, 5, 7.`);
					}
					const a = s$1.length;
					for (const r$2 of e$1) for (const e$2 of r$2) {
						const r$3 = e$2.x, n$2 = e$2.y;
						if (r$3 < 0 || r$3 >= P$1 || n$2 < 0 || n$2 >= P$1) continue;
						const i$2 = this.segments.prepareSegment(a * a, this.layoutVertexArray, this.indexArray, t$1.sortKey), o$1 = i$2.vertexLength;
						for (let t$2 = 0; t$2 < a; t$2++) for (let e$3 = 0; e$3 < a; e$3++) zo$1(this.layoutVertexArray, r$3, n$2, s$1[e$3], s$1[t$2]);
						for (let t$2 = 0; t$2 < a - 1; t$2++) for (let e$3 = 0; e$3 < a - 1; e$3++) {
							const r$4 = o$1 + t$2 * a + e$3, n$3 = o$1 + (t$2 + 1) * a + e$3;
							this.indexArray.emplaceBack(r$4, n$3 + 1, r$4 + 1), this.indexArray.emplaceBack(r$4, n$3, n$3 + 1);
						}
						i$2.vertexLength += a * a, i$2.primitiveLength += (a - 1) * (a - 1) * 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {}, n$1);
				}
			}
			function Co$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Do$1(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Do$1(t$1, e$1[r$1])) return !0;
				return !!To$1(t$1, e$1);
			}
			function Eo$1(t$1, e$1, r$1) {
				return !!Do$1(t$1, e$1) || !!$o$1(e$1, t$1, r$1);
			}
			function Bo$1(t$1, e$1) {
				if (1 === t$1.length) return Oo$1(e$1, t$1[0]);
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (Do$1(t$1, n$1[e$2])) return !0;
				}
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Oo$1(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (To$1(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function Vo$1(t$1, e$1, r$1) {
				if (t$1.length > 1) {
					if (To$1(t$1, e$1)) return !0;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if ($o$1(e$1[n$1], t$1, r$1)) return !0;
				}
				for (let n$1 = 0; n$1 < t$1.length; n$1++) if ($o$1(t$1[n$1], e$1, r$1)) return !0;
				return !1;
			}
			function To$1(t$1, e$1) {
				if (0 === t$1.length || 0 === e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const n$1 = t$1[r$1], i$1 = t$1[r$1 + 1];
					for (let t$2 = 0; t$2 < e$1.length - 1; t$2++) if (Fo$1(n$1, i$1, e$1[t$2], e$1[t$2 + 1])) return !0;
				}
				return !1;
			}
			function Fo$1(t$1, e$1, r$1, n$1) {
				return G$1(t$1, r$1, n$1) !== G$1(e$1, r$1, n$1) && G$1(t$1, e$1, r$1) !== G$1(t$1, e$1, n$1);
			}
			function $o$1(t$1, e$1, r$1) {
				const n$1 = r$1 * r$1;
				if (1 === e$1.length) return t$1.distSqr(e$1[0]) < n$1;
				for (let r$2 = 1; r$2 < e$1.length; r$2++) if (Lo$1(t$1, e$1[r$2 - 1], e$1[r$2]) < n$1) return !0;
				return !1;
			}
			function Lo$1(t$1, e$1, r$1) {
				const n$1 = e$1.distSqr(r$1);
				if (0 === n$1) return t$1.distSqr(e$1);
				const i$1 = ((t$1.x - e$1.x) * (r$1.x - e$1.x) + (t$1.y - e$1.y) * (r$1.y - e$1.y)) / n$1;
				return t$1.distSqr(i$1 < 0 ? e$1 : i$1 > 1 ? r$1 : r$1.sub(e$1)._mult(i$1)._add(e$1));
			}
			function Oo$1(t$1, e$1) {
				let r$1, n$1, i$1, s$1 = !1;
				for (let a = 0; a < t$1.length; a++) {
					r$1 = t$1[a];
					for (let t$2 = 0, a$1 = r$1.length - 1; t$2 < r$1.length; a$1 = t$2++) n$1 = r$1[t$2], i$1 = r$1[a$1], n$1.y > e$1.y != i$1.y > e$1.y && e$1.x < (i$1.x - n$1.x) * (e$1.y - n$1.y) / (i$1.y - n$1.y) + n$1.x && (s$1 = !s$1);
				}
				return s$1;
			}
			function Do$1(t$1, e$1) {
				let r$1 = !1;
				for (let n$1 = 0, i$1 = t$1.length - 1; n$1 < t$1.length; i$1 = n$1++) {
					const s$1 = t$1[n$1], a = t$1[i$1];
					s$1.y > e$1.y != a.y > e$1.y && e$1.x < (a.x - s$1.x) * (e$1.y - s$1.y) / (a.y - s$1.y) + s$1.x && (r$1 = !r$1);
				}
				return r$1;
			}
			function Ro$1(t$1, e$1, r$1) {
				const n$1 = r$1[0], i$1 = r$1[2];
				if (t$1.x < n$1.x && e$1.x < n$1.x || t$1.x > i$1.x && e$1.x > i$1.x || t$1.y < n$1.y && e$1.y < n$1.y || t$1.y > i$1.y && e$1.y > i$1.y) return !1;
				const s$1 = G$1(t$1, e$1, r$1[0]);
				return s$1 !== G$1(t$1, e$1, r$1[1]) || s$1 !== G$1(t$1, e$1, r$1[2]) || s$1 !== G$1(t$1, e$1, r$1[3]);
			}
			function Uo$1(t$1, e$1, r$1) {
				const n$1 = e$1.paint.get(t$1).value;
				return "constant" === n$1.kind ? n$1.value : r$1.programConfigurations.get(e$1.id).getMaxValue(t$1);
			}
			function jo$1(t$1) {
				return Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]);
			}
			function No$1(t$1, e$1, n$1, i$1, s$1) {
				if (!e$1[0] && !e$1[1]) return t$1;
				const a = r.convert(e$1)._mult(s$1);
				"viewport" === n$1 && a._rotate(-i$1);
				const o$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2++) o$1.push(t$1[e$2].sub(a));
				return o$1;
			}
			let qo$1, Go$1;
			as$1("CircleBucket", Po$1, { omit: ["layers"] });
			var Xo$1 = {
				get paint() {
					return Go$1 = Go$1 || new Us$1({
						"circle-radius": new Ls$1(xt$1.paint_circle["circle-radius"]),
						"circle-color": new Ls$1(xt$1.paint_circle["circle-color"]),
						"circle-blur": new Ls$1(xt$1.paint_circle["circle-blur"]),
						"circle-opacity": new Ls$1(xt$1.paint_circle["circle-opacity"]),
						"circle-translate": new $s$1(xt$1.paint_circle["circle-translate"]),
						"circle-translate-anchor": new $s$1(xt$1.paint_circle["circle-translate-anchor"]),
						"circle-pitch-scale": new $s$1(xt$1.paint_circle["circle-pitch-scale"]),
						"circle-pitch-alignment": new $s$1(xt$1.paint_circle["circle-pitch-alignment"]),
						"circle-stroke-width": new Ls$1(xt$1.paint_circle["circle-stroke-width"]),
						"circle-stroke-color": new Ls$1(xt$1.paint_circle["circle-stroke-color"]),
						"circle-stroke-opacity": new Ls$1(xt$1.paint_circle["circle-stroke-opacity"])
					});
				},
				get layout() {
					return qo$1 = qo$1 || new Us$1({ "circle-sort-key": new Ls$1(xt$1.layout_circle["circle-sort-key"]) });
				}
			};
			class Zo$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, Xo$1);
				}
				createBucket(t$1) {
					return new Po$1(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1;
					return Uo$1("circle-radius", this, e$1) + Uo$1("circle-stroke-width", this, e$1) + jo$1(this.paint.get("circle-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: a, getElevation: o$1 }) {
					const l$1 = No$1(t$1, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i$1.bearingInRadians, s$1), u$1 = this.paint.get("circle-radius").evaluate(e$1, r$1) + this.paint.get("circle-stroke-width").evaluate(e$1, r$1), c$1 = "map" === this.paint.get("circle-pitch-alignment"), h$1 = c$1 ? l$1 : function(t$2, e$2, r$2, n$2) {
						return t$2.map(((t$3) => Yo$1(t$3, e$2, r$2, n$2)));
					}(l$1, i$1, a, o$1), p$1 = c$1 ? u$1 * s$1 : u$1;
					for (const t$2 of n$1) for (const e$2 of t$2) {
						const t$3 = c$1 ? e$2 : Yo$1(e$2, i$1, a, o$1);
						let r$2 = p$1;
						const n$2 = i$1.projectTileCoordinates(e$2.x, e$2.y, a, o$1).signedDistanceFromCamera;
						if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r$2 *= n$2 / i$1.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r$2 *= i$1.cameraToCenterDistance / n$2), Eo$1(h$1, t$3, r$2)) return !0;
					}
					return !1;
				}
			}
			function Yo$1(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.projectTileCoordinates(t$1.x, t$1.y, n$1, i$1).point;
				return new r((.5 * s$1.x + .5) * e$1.width, (.5 * -s$1.y + .5) * e$1.height);
			}
			class Ho extends Po$1 {}
			let Ko$1;
			as$1("HeatmapBucket", Ho, { omit: ["layers"] });
			var Jo$1 = { get paint() {
				return Ko$1 = Ko$1 || new Us$1({
					"heatmap-radius": new Ls$1(xt$1.paint_heatmap["heatmap-radius"]),
					"heatmap-weight": new Ls$1(xt$1.paint_heatmap["heatmap-weight"]),
					"heatmap-intensity": new $s$1(xt$1.paint_heatmap["heatmap-intensity"]),
					"heatmap-color": new Rs$1(xt$1.paint_heatmap["heatmap-color"]),
					"heatmap-opacity": new $s$1(xt$1.paint_heatmap["heatmap-opacity"])
				});
			} };
			function Wo$1(t$1, { width: e$1, height: r$1 }, n$1, i$1) {
				if (i$1) {
					if (i$1 instanceof Uint8ClampedArray) i$1 = new Uint8Array(i$1.buffer);
					else if (i$1.length !== e$1 * r$1 * n$1) throw new RangeError(`mismatched image size. expected: ${i$1.length} but got: ${e$1 * r$1 * n$1}`);
				} else i$1 = new Uint8Array(e$1 * r$1 * n$1);
				return t$1.width = e$1, t$1.height = r$1, t$1.data = i$1, t$1;
			}
			function Qo$1(t$1, { width: e$1, height: r$1 }, n$1) {
				if (e$1 === t$1.width && r$1 === t$1.height) return;
				const i$1 = Wo$1({}, {
					width: e$1,
					height: r$1
				}, n$1);
				tl$1(t$1, i$1, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(t$1.width, e$1),
					height: Math.min(t$1.height, r$1)
				}, n$1), t$1.width = e$1, t$1.height = r$1, t$1.data = i$1.data;
			}
			function tl$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (0 === i$1.width || 0 === i$1.height) return e$1;
				if (i$1.width > t$1.width || i$1.height > t$1.height || r$1.x > t$1.width - i$1.width || r$1.y > t$1.height - i$1.height) throw new RangeError("out of range source coordinates for image copy");
				if (i$1.width > e$1.width || i$1.height > e$1.height || n$1.x > e$1.width - i$1.width || n$1.y > e$1.height - i$1.height) throw new RangeError("out of range destination coordinates for image copy");
				const a = t$1.data, o$1 = e$1.data;
				if (a === o$1) throw new Error("srcData equals dstData, so image is already copied");
				for (let l$1 = 0; l$1 < i$1.height; l$1++) {
					const u$1 = ((r$1.y + l$1) * t$1.width + r$1.x) * s$1, c$1 = ((n$1.y + l$1) * e$1.width + n$1.x) * s$1;
					for (let t$2 = 0; t$2 < i$1.width * s$1; t$2++) o$1[c$1 + t$2] = a[u$1 + t$2];
				}
				return e$1;
			}
			class el$1 {
				constructor(t$1, e$1) {
					Wo$1(this, t$1, 1, e$1);
				}
				resize(t$1) {
					Qo$1(this, t$1, 1);
				}
				clone() {
					return new el$1({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					tl$1(t$1, e$1, r$1, n$1, i$1, 1);
				}
			}
			class rl$1 {
				constructor(t$1, e$1) {
					Wo$1(this, t$1, 4, e$1);
				}
				resize(t$1) {
					Qo$1(this, t$1, 4);
				}
				replace(t$1, e$1) {
					e$1 ? this.data.set(t$1) : this.data = t$1 instanceof Uint8ClampedArray ? new Uint8Array(t$1.buffer) : t$1;
				}
				clone() {
					return new rl$1({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					tl$1(t$1, e$1, r$1, n$1, i$1, 4);
				}
				setPixel(t$1, e$1, r$1) {
					const n$1 = 4 * (t$1 * this.width + e$1);
					this.data[n$1 + 0] = Math.round(255 * r$1.r / r$1.a), this.data[n$1 + 1] = Math.round(255 * r$1.g / r$1.a), this.data[n$1 + 2] = Math.round(255 * r$1.b / r$1.a), this.data[n$1 + 3] = Math.round(255 * r$1.a);
				}
			}
			function nl(t$1) {
				const e$1 = {}, r$1 = t$1.resolution || 256, n$1 = t$1.clips ? t$1.clips.length : 1, i$1 = t$1.image || new rl$1({
					width: r$1,
					height: n$1
				});
				if (Math.log(r$1) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r$1}`);
				const s$1 = (n$2, s$2, a) => {
					e$1[t$1.evaluationKey] = a;
					const o$1 = t$1.expression.evaluate(e$1);
					i$1.setPixel(n$2 / 4 / r$1, s$2 / 4, o$1);
				};
				if (t$1.clips) for (let e$2 = 0, i$2 = 0; e$2 < n$1; ++e$2, i$2 += 4 * r$1) for (let n$2 = 0, a = 0; n$2 < r$1; n$2++, a += 4) {
					const o$1 = n$2 / (r$1 - 1), { start: l$1, end: u$1 } = t$1.clips[e$2];
					s$1(i$2, a, l$1 * (1 - o$1) + u$1 * o$1);
				}
				else for (let t$2 = 0, e$2 = 0; t$2 < r$1; t$2++, e$2 += 4) s$1(0, e$2, t$2 / (r$1 - 1));
				return i$1;
			}
			as$1("AlphaImage", el$1), as$1("RGBAImage", rl$1);
			const il$1 = "big-fb";
			class sl$1 extends Ns$1 {
				createBucket(t$1) {
					return new Ho(t$1);
				}
				constructor(t$1) {
					super(t$1, Jo$1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"heatmap-color" === t$1 && this._updateColorRamp();
				}
				_updateColorRamp() {
					this.colorRamp = nl({
						expression: this._transitionablePaint._values["heatmap-color"].value.expression,
						evaluationKey: "heatmapDensity",
						image: this.colorRamp
					}), this.colorRampTexture = null;
				}
				resize() {
					this.heatmapFbos.has(il$1) && this.heatmapFbos.delete(il$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					return !1;
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
				}
			}
			let al$1;
			var ol$1 = { get paint() {
				return al$1 = al$1 || new Us$1({
					"hillshade-illumination-direction": new $s$1(xt$1.paint_hillshade["hillshade-illumination-direction"]),
					"hillshade-illumination-altitude": new $s$1(xt$1.paint_hillshade["hillshade-illumination-altitude"]),
					"hillshade-illumination-anchor": new $s$1(xt$1.paint_hillshade["hillshade-illumination-anchor"]),
					"hillshade-exaggeration": new $s$1(xt$1.paint_hillshade["hillshade-exaggeration"]),
					"hillshade-shadow-color": new $s$1(xt$1.paint_hillshade["hillshade-shadow-color"]),
					"hillshade-highlight-color": new $s$1(xt$1.paint_hillshade["hillshade-highlight-color"]),
					"hillshade-accent-color": new $s$1(xt$1.paint_hillshade["hillshade-accent-color"]),
					"hillshade-method": new $s$1(xt$1.paint_hillshade["hillshade-method"])
				});
			} };
			class ll$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, ol$1), this.recalculate({
						zoom: 0,
						zoomHistory: {}
					}, void 0);
				}
				getIlluminationProperties() {
					let t$1 = this.paint.get("hillshade-illumination-direction").values, e$1 = this.paint.get("hillshade-illumination-altitude").values, r$1 = this.paint.get("hillshade-highlight-color").values, n$1 = this.paint.get("hillshade-shadow-color").values;
					const i$1 = Math.max(t$1.length, e$1.length, r$1.length, n$1.length);
					t$1 = t$1.concat(Array(i$1 - t$1.length).fill(t$1.at(-1))), e$1 = e$1.concat(Array(i$1 - e$1.length).fill(e$1.at(-1))), r$1 = r$1.concat(Array(i$1 - r$1.length).fill(r$1.at(-1))), n$1 = n$1.concat(Array(i$1 - n$1.length).fill(n$1.at(-1)));
					const s$1 = e$1.map(tt$1);
					return {
						directionRadians: t$1.map(tt$1),
						altitudeRadians: s$1,
						shadowColor: n$1,
						highlightColor: r$1
					};
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
				}
			}
			let ul$1;
			var cl$1 = { get paint() {
				return ul$1 = ul$1 || new Us$1({
					"color-relief-opacity": new $s$1(xt$1["paint_color-relief"]["color-relief-opacity"]),
					"color-relief-color": new Rs$1(xt$1["paint_color-relief"]["color-relief-color"])
				});
			} };
			class hl$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = r$1, this.texture = t$1.gl.createTexture(), this.update(e$1, n$1);
				}
				update(t$1, e$1, r$1) {
					const { width: n$1, height: i$1 } = t$1, s$1 = !(this.size && this.size[0] === n$1 && this.size[1] === i$1 || r$1), { context: a } = this, { gl: o$1 } = a;
					if (this.useMipmap = Boolean(e$1 && e$1.useMipmap), o$1.bindTexture(o$1.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o$1.RGBA && (!e$1 || !1 !== e$1.premultiply)), s$1) this.size = [n$1, i$1], t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Y$1(t$1) ? o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, this.format, o$1.UNSIGNED_BYTE, t$1) : o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, n$1, i$1, 0, this.format, o$1.UNSIGNED_BYTE, t$1.data);
					else {
						const { x: e$2, y: s$2 } = r$1 || {
							x: 0,
							y: 0
						};
						t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Y$1(t$1) ? o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1) : o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, n$1, i$1, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1.data);
					}
					this.useMipmap && this.isSizePowerOfTwo() && o$1.generateMipmap(o$1.TEXTURE_2D), a.pixelStoreUnpackFlipY.setDefault(), a.pixelStoreUnpack.setDefault(), a.pixelStoreUnpackPremultiplyAlpha.setDefault();
				}
				bind(t$1, e$1, r$1) {
					const { context: n$1 } = this, { gl: i$1 } = n$1;
					i$1.bindTexture(i$1.TEXTURE_2D, this.texture), r$1 !== i$1.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r$1 = i$1.LINEAR), t$1 !== this.filter && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MAG_FILTER, t$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MIN_FILTER, r$1 || t$1), this.filter = t$1), e$1 !== this.wrap && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_S, e$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_T, e$1), this.wrap = e$1);
				}
				isSizePowerOfTwo() {
					return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}
			class pl$1 {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = 1, s$1 = 1, a = 0) {
					if (this.uid = t$1, e$1.height !== e$1.width) throw new RangeError("DEM tiles must be square");
					if (r$1 && ![
						"mapbox",
						"terrarium",
						"custom"
					].includes(r$1)) return void q$1(`"${r$1}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
					this.stride = e$1.height;
					const o$1 = this.dim = e$1.height - 2;
					switch (this.data = new Uint32Array(e$1.data.buffer), r$1) {
						case "terrarium":
							this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
							break;
						case "custom":
							this.redFactor = n$1, this.greenFactor = i$1, this.blueFactor = s$1, this.baseShift = a;
							break;
						default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
					}
					for (let t$2 = 0; t$2 < o$1; t$2++) this.data[this._idx(-1, t$2)] = this.data[this._idx(0, t$2)], this.data[this._idx(o$1, t$2)] = this.data[this._idx(o$1 - 1, t$2)], this.data[this._idx(t$2, -1)] = this.data[this._idx(t$2, 0)], this.data[this._idx(t$2, o$1)] = this.data[this._idx(t$2, o$1 - 1)];
					this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o$1, -1)] = this.data[this._idx(o$1 - 1, 0)], this.data[this._idx(-1, o$1)] = this.data[this._idx(0, o$1 - 1)], this.data[this._idx(o$1, o$1)] = this.data[this._idx(o$1 - 1, o$1 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
					for (let t$2 = 0; t$2 < o$1; t$2++) for (let e$2 = 0; e$2 < o$1; e$2++) {
						const r$2 = this.get(t$2, e$2);
						r$2 > this.max && (this.max = r$2), r$2 < this.min && (this.min = r$2);
					}
				}
				get(t$1, e$1) {
					const r$1 = new Uint8Array(this.data.buffer), n$1 = 4 * this._idx(t$1, e$1);
					return this.unpack(r$1[n$1], r$1[n$1 + 1], r$1[n$1 + 2]);
				}
				getUnpackVector() {
					return [
						this.redFactor,
						this.greenFactor,
						this.blueFactor,
						this.baseShift
					];
				}
				_idx(t$1, e$1) {
					if (t$1 < -1 || t$1 >= this.dim + 1 || e$1 < -1 || e$1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
					return (e$1 + 1) * this.stride + (t$1 + 1);
				}
				unpack(t$1, e$1, r$1) {
					return t$1 * this.redFactor + e$1 * this.greenFactor + r$1 * this.blueFactor - this.baseShift;
				}
				pack(t$1) {
					return fl$1(t$1, this.getUnpackVector());
				}
				getPixels() {
					return new rl$1({
						width: this.stride,
						height: this.stride
					}, new Uint8Array(this.data.buffer));
				}
				backfillBorder(t$1, e$1, r$1) {
					if (this.dim !== t$1.dim) throw new Error("dem dimension mismatch");
					let n$1 = e$1 * this.dim, i$1 = e$1 * this.dim + this.dim, s$1 = r$1 * this.dim, a = r$1 * this.dim + this.dim;
					switch (e$1) {
						case -1:
							n$1 = i$1 - 1;
							break;
						case 1: i$1 = n$1 + 1;
					}
					switch (r$1) {
						case -1:
							s$1 = a - 1;
							break;
						case 1: a = s$1 + 1;
					}
					const o$1 = -e$1 * this.dim, l$1 = -r$1 * this.dim;
					for (let e$2 = s$1; e$2 < a; e$2++) for (let r$2 = n$1; r$2 < i$1; r$2++) this.data[this._idx(r$2, e$2)] = t$1.data[this._idx(r$2 + o$1, e$2 + l$1)];
				}
			}
			function fl$1(t$1, e$1) {
				const r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a = Math.min(r$1, n$1, i$1), o$1 = Math.round((t$1 + s$1) / a);
				return {
					r: Math.floor(o$1 * a / r$1) % 256,
					g: Math.floor(o$1 * a / n$1) % 256,
					b: Math.floor(o$1 * a / i$1) % 256
				};
			}
			as$1("DEMData", pl$1);
			class dl$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, cl$1);
				}
				_createColorRamp(t$1) {
					const e$1 = {
						elevationStops: [],
						colorStops: []
					}, r$1 = this._transitionablePaint._values["color-relief-color"].value.expression;
					if (r$1 instanceof ni$1 && r$1._styleExpression.expression instanceof pr$1) {
						this.colorRampExpression = r$1;
						const t$2 = r$1._styleExpression.expression;
						e$1.elevationStops = t$2.labels, e$1.colorStops = [];
						for (const r$2 of e$1.elevationStops) e$1.colorStops.push(t$2.evaluate({ globals: { elevation: r$2 } }));
					}
					if (e$1.elevationStops.length < 1 && (e$1.elevationStops = [0], e$1.colorStops = [Me$1.transparent]), e$1.elevationStops.length < 2 && (e$1.elevationStops.push(e$1.elevationStops[0] + 1), e$1.colorStops.push(e$1.colorStops[0])), e$1.elevationStops.length <= t$1) return e$1;
					const n$1 = {
						elevationStops: [],
						colorStops: []
					}, i$1 = (e$1.elevationStops.length - 1) / (t$1 - 1);
					for (let t$2 = 0; t$2 < e$1.elevationStops.length - .5; t$2 += i$1) n$1.elevationStops.push(e$1.elevationStops[Math.round(t$2)]), n$1.colorStops.push(e$1.colorStops[Math.round(t$2)]);
					return q$1(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), n$1;
				}
				_colorRampChanged() {
					return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
				}
				getColorRampTextures(t$1, e$1, r$1) {
					if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
					const n$1 = this._createColorRamp(e$1), i$1 = new rl$1({
						width: n$1.colorStops.length,
						height: 1
					}), s$1 = new rl$1({
						width: n$1.colorStops.length,
						height: 1
					});
					for (let t$2 = 0; t$2 < n$1.elevationStops.length; t$2++) {
						const e$2 = fl$1(n$1.elevationStops[t$2], r$1);
						s$1.setPixel(0, t$2, new Me$1(e$2.r / 255, e$2.g / 255, e$2.b / 255, 1)), i$1.setPixel(0, t$2, n$1.colorStops[t$2]);
					}
					return this.colorRampTextures = {
						elevationTexture: new hl$1(t$1, s$1, t$1.gl.RGBA),
						colorTexture: new hl$1(t$1, i$1, t$1.gl.RGBA)
					}, this.colorRampTextures;
				}
				hasOffscreenPass() {
					return "none" !== this.visibility && !!this.colorRampTextures;
				}
			}
			const { members: ml$1 } = Zs$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			function gl$1(t$1, e$1, r$1) {
				const n$1 = r$1.patternDependencies;
				let i$1 = !1;
				for (const r$2 of e$1) {
					const e$2 = r$2.paint.get(`${t$1}-pattern`);
					e$2.isConstant() || (i$1 = !0);
					const s$1 = e$2.constantOr(null);
					s$1 && (i$1 = !0, n$1[s$1.to] = !0, n$1[s$1.from] = !0);
				}
				return i$1;
			}
			function xl$1(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = i$1.patternDependencies;
				for (const a of e$1) {
					const e$2 = a.paint.get(`${t$1}-pattern`).value;
					if ("constant" !== e$2.kind) {
						let t$2 = e$2.evaluate({ zoom: n$1 - 1 }, r$1, {}, i$1.availableImages), o$1 = e$2.evaluate({ zoom: n$1 }, r$1, {}, i$1.availableImages), l$1 = e$2.evaluate({ zoom: n$1 + 1 }, r$1, {}, i$1.availableImages);
						t$2 = t$2 && t$2.name ? t$2.name : t$2, o$1 = o$1 && o$1.name ? o$1.name : o$1, l$1 = l$1 && l$1.name ? l$1.name : l$1, s$1[t$2] = !0, s$1[o$1] = !0, s$1[l$1] = !0, r$1.patterns[a.id] = {
							min: t$2,
							mid: o$1,
							max: l$1
						};
					}
				}
				return r$1;
			}
			function vl$1(t$1, e$1, r$1, n$1, i$1) {
				let s$1;
				if (i$1 === function(t$2, e$2, r$2, n$2) {
					let i$2 = 0;
					for (let s$2 = e$2, a = r$2 - n$2; s$2 < r$2; s$2 += n$2) i$2 += (t$2[a] - t$2[s$2]) * (t$2[s$2 + 1] + t$2[a + 1]), a = s$2;
					return i$2;
				}(t$1, e$1, r$1, n$1) > 0) for (let i$2 = e$1; i$2 < r$1; i$2 += n$1) s$1 = Ul$1(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				else for (let i$2 = r$1 - n$1; i$2 >= e$1; i$2 -= n$1) s$1 = Ul$1(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				return s$1 && Fl$1(s$1, s$1.next) && (jl$1(s$1), s$1 = s$1.next), s$1;
			}
			function bl$1(t$1, e$1) {
				if (!t$1) return t$1;
				e$1 || (e$1 = t$1);
				let r$1, n$1 = t$1;
				do
					if (r$1 = !1, n$1.steiner || !Fl$1(n$1, n$1.next) && 0 !== Tl$1(n$1.prev, n$1, n$1.next)) n$1 = n$1.next;
					else {
						if (jl$1(n$1), n$1 = e$1 = n$1.prev, n$1 === n$1.next) break;
						r$1 = !0;
					}
				while (r$1 || n$1 !== e$1);
				return e$1;
			}
			function wl$1(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (!t$1) return;
				!a && s$1 && function(t$2, e$2, r$2, n$2) {
					let i$2 = t$2;
					do
						0 === i$2.z && (i$2.z = Pl$1(i$2.x, i$2.y, e$2, r$2, n$2)), i$2.prevZ = i$2.prev, i$2.nextZ = i$2.next, i$2 = i$2.next;
					while (i$2 !== t$2);
					i$2.prevZ.nextZ = null, i$2.prevZ = null, function(t$3) {
						let e$3, r$3 = 1;
						do {
							let n$3, i$3 = t$3;
							t$3 = null;
							let s$2 = null;
							for (e$3 = 0; i$3;) {
								e$3++;
								let a$1 = i$3, o$2 = 0;
								for (let t$4 = 0; t$4 < r$3 && (o$2++, a$1 = a$1.nextZ, a$1); t$4++);
								let l$1 = r$3;
								for (; o$2 > 0 || l$1 > 0 && a$1;) 0 !== o$2 && (0 === l$1 || !a$1 || i$3.z <= a$1.z) ? (n$3 = i$3, i$3 = i$3.nextZ, o$2--) : (n$3 = a$1, a$1 = a$1.nextZ, l$1--), s$2 ? s$2.nextZ = n$3 : t$3 = n$3, n$3.prevZ = s$2, s$2 = n$3;
								i$3 = a$1;
							}
							s$2.nextZ = null, r$3 *= 2;
						} while (e$3 > 1);
					}(i$2);
				}(t$1, n$1, i$1, s$1);
				let o$1 = t$1;
				for (; t$1.prev !== t$1.next;) {
					const l$1 = t$1.prev, u$1 = t$1.next;
					if (s$1 ? Sl$1(t$1, n$1, i$1, s$1) : _l$1(t$1)) e$1.push(l$1.i, t$1.i, u$1.i), jl$1(t$1), t$1 = u$1.next, o$1 = u$1.next;
					else if ((t$1 = u$1) === o$1) {
						a ? 1 === a ? wl$1(t$1 = Al$1(bl$1(t$1), e$1), e$1, r$1, n$1, i$1, s$1, 2) : 2 === a && kl$1(t$1, e$1, r$1, n$1, i$1, s$1) : wl$1(bl$1(t$1), e$1, r$1, n$1, i$1, s$1, 1);
						break;
					}
				}
			}
			function _l$1(t$1) {
				const e$1 = t$1.prev, r$1 = t$1, n$1 = t$1.next;
				if (Tl$1(e$1, r$1, n$1) >= 0) return !1;
				const i$1 = e$1.x, s$1 = r$1.x, a = n$1.x, o$1 = e$1.y, l$1 = r$1.y, u$1 = n$1.y, c$1 = Math.min(i$1, s$1, a), h$1 = Math.min(o$1, l$1, u$1), p$1 = Math.max(i$1, s$1, a), f$1 = Math.max(o$1, l$1, u$1);
				let d$1 = n$1.next;
				for (; d$1 !== e$1;) {
					if (d$1.x >= c$1 && d$1.x <= p$1 && d$1.y >= h$1 && d$1.y <= f$1 && Bl$1(i$1, o$1, s$1, l$1, a, u$1, d$1.x, d$1.y) && Tl$1(d$1.prev, d$1, d$1.next) >= 0) return !1;
					d$1 = d$1.next;
				}
				return !0;
			}
			function Sl$1(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.prev, s$1 = t$1, a = t$1.next;
				if (Tl$1(i$1, s$1, a) >= 0) return !1;
				const o$1 = i$1.x, l$1 = s$1.x, u$1 = a.x, c$1 = i$1.y, h$1 = s$1.y, p$1 = a.y, f$1 = Math.min(o$1, l$1, u$1), d$1 = Math.min(c$1, h$1, p$1), y$1 = Math.max(o$1, l$1, u$1), m$1 = Math.max(c$1, h$1, p$1), g$2 = Pl$1(f$1, d$1, e$1, r$1, n$1), x$1 = Pl$1(y$1, m$1, e$1, r$1, n$1);
				let v$1 = t$1.prevZ, b$2 = t$1.nextZ;
				for (; v$1 && v$1.z >= g$2 && b$2 && b$2.z <= x$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a && Bl$1(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Tl$1(v$1.prev, v$1, v$1.next) >= 0) return !1;
					if (v$1 = v$1.prevZ, b$2.x >= f$1 && b$2.x <= y$1 && b$2.y >= d$1 && b$2.y <= m$1 && b$2 !== i$1 && b$2 !== a && Bl$1(o$1, c$1, l$1, h$1, u$1, p$1, b$2.x, b$2.y) && Tl$1(b$2.prev, b$2, b$2.next) >= 0) return !1;
					b$2 = b$2.nextZ;
				}
				for (; v$1 && v$1.z >= g$2;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a && Bl$1(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Tl$1(v$1.prev, v$1, v$1.next) >= 0) return !1;
					v$1 = v$1.prevZ;
				}
				for (; b$2 && b$2.z <= x$1;) {
					if (b$2.x >= f$1 && b$2.x <= y$1 && b$2.y >= d$1 && b$2.y <= m$1 && b$2 !== i$1 && b$2 !== a && Bl$1(o$1, c$1, l$1, h$1, u$1, p$1, b$2.x, b$2.y) && Tl$1(b$2.prev, b$2, b$2.next) >= 0) return !1;
					b$2 = b$2.nextZ;
				}
				return !0;
			}
			function Al$1(t$1, e$1) {
				let r$1 = t$1;
				do {
					const n$1 = r$1.prev, i$1 = r$1.next.next;
					!Fl$1(n$1, i$1) && $l$1(n$1, r$1, r$1.next, i$1) && Dl$1(n$1, i$1) && Dl$1(i$1, n$1) && (e$1.push(n$1.i, r$1.i, i$1.i), jl$1(r$1), jl$1(r$1.next), r$1 = t$1 = i$1), r$1 = r$1.next;
				} while (r$1 !== t$1);
				return bl$1(r$1);
			}
			function kl$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a = t$1;
				do {
					let t$2 = a.next.next;
					for (; t$2 !== a.prev;) {
						if (a.i !== t$2.i && Vl$1(a, t$2)) {
							let o$1 = Rl$1(a, t$2);
							a = bl$1(a, a.next), o$1 = bl$1(o$1, o$1.next), wl$1(a, e$1, r$1, n$1, i$1, s$1, 0), wl$1(o$1, e$1, r$1, n$1, i$1, s$1, 0);
							return;
						}
						t$2 = t$2.next;
					}
					a = a.next;
				} while (a !== t$1);
			}
			function Ml$1(t$1, e$1) {
				let r$1 = t$1.x - e$1.x;
				return 0 === r$1 && (r$1 = t$1.y - e$1.y, 0 === r$1) && (r$1 = (t$1.next.y - t$1.y) / (t$1.next.x - t$1.x) - (e$1.next.y - e$1.y) / (e$1.next.x - e$1.x)), r$1;
			}
			function Il$1(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					let r$2 = e$2;
					const n$2 = t$2.x, i$1 = t$2.y;
					let s$1, a = -Infinity;
					if (Fl$1(t$2, r$2)) return r$2;
					do {
						if (Fl$1(t$2, r$2.next)) return r$2.next;
						if (i$1 <= r$2.y && i$1 >= r$2.next.y && r$2.next.y !== r$2.y) {
							const t$3 = r$2.x + (i$1 - r$2.y) * (r$2.next.x - r$2.x) / (r$2.next.y - r$2.y);
							if (t$3 <= n$2 && t$3 > a && (a = t$3, s$1 = r$2.x < r$2.next.x ? r$2 : r$2.next, t$3 === n$2)) return s$1;
						}
						r$2 = r$2.next;
					} while (r$2 !== e$2);
					if (!s$1) return null;
					const o$1 = s$1, l$1 = s$1.x, u$1 = s$1.y;
					let c$1 = Infinity;
					r$2 = s$1;
					do {
						if (n$2 >= r$2.x && r$2.x >= l$1 && n$2 !== r$2.x && El$1(i$1 < u$1 ? n$2 : a, i$1, l$1, u$1, i$1 < u$1 ? a : n$2, i$1, r$2.x, r$2.y)) {
							const e$3 = Math.abs(i$1 - r$2.y) / (n$2 - r$2.x);
							Dl$1(r$2, t$2) && (e$3 < c$1 || e$3 === c$1 && (r$2.x > s$1.x || r$2.x === s$1.x && zl$1(s$1, r$2))) && (s$1 = r$2, c$1 = e$3);
						}
						r$2 = r$2.next;
					} while (r$2 !== o$1);
					return s$1;
				}(t$1, e$1);
				if (!r$1) return e$1;
				const n$1 = Rl$1(r$1, t$1);
				return bl$1(n$1, n$1.next), bl$1(r$1, r$1.next);
			}
			function zl$1(t$1, e$1) {
				return Tl$1(t$1.prev, t$1, e$1.prev) < 0 && Tl$1(e$1.next, t$1, t$1.next) < 0;
			}
			function Pl$1(t$1, e$1, r$1, n$1, i$1) {
				return (t$1 = 1431655765 & ((t$1 = 858993459 & ((t$1 = 252645135 & ((t$1 = 16711935 & ((t$1 = (t$1 - r$1) * i$1 | 0) | t$1 << 8)) | t$1 << 4)) | t$1 << 2)) | t$1 << 1)) | (e$1 = 1431655765 & ((e$1 = 858993459 & ((e$1 = 252645135 & ((e$1 = 16711935 & ((e$1 = (e$1 - n$1) * i$1 | 0) | e$1 << 8)) | e$1 << 4)) | e$1 << 2)) | e$1 << 1)) << 1;
			}
			function Cl$1(t$1) {
				let e$1 = t$1, r$1 = t$1;
				do
					(e$1.x < r$1.x || e$1.x === r$1.x && e$1.y < r$1.y) && (r$1 = e$1), e$1 = e$1.next;
				while (e$1 !== t$1);
				return r$1;
			}
			function El$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				return (i$1 - a) * (e$1 - o$1) >= (t$1 - a) * (s$1 - o$1) && (t$1 - a) * (n$1 - o$1) >= (r$1 - a) * (e$1 - o$1) && (r$1 - a) * (s$1 - o$1) >= (i$1 - a) * (n$1 - o$1);
			}
			function Bl$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				return !(t$1 === a && e$1 === o$1) && El$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1);
			}
			function Vl$1(t$1, e$1) {
				return t$1.next.i !== e$1.i && t$1.prev.i !== e$1.i && !function(t$2, e$2) {
					let r$1 = t$2;
					do {
						if (r$1.i !== t$2.i && r$1.next.i !== t$2.i && r$1.i !== e$2.i && r$1.next.i !== e$2.i && $l$1(r$1, r$1.next, t$2, e$2)) return !0;
						r$1 = r$1.next;
					} while (r$1 !== t$2);
					return !1;
				}(t$1, e$1) && (Dl$1(t$1, e$1) && Dl$1(e$1, t$1) && function(t$2, e$2) {
					let r$1 = t$2, n$1 = !1;
					const i$1 = (t$2.x + e$2.x) / 2, s$1 = (t$2.y + e$2.y) / 2;
					do
						r$1.y > s$1 != r$1.next.y > s$1 && r$1.next.y !== r$1.y && i$1 < (r$1.next.x - r$1.x) * (s$1 - r$1.y) / (r$1.next.y - r$1.y) + r$1.x && (n$1 = !n$1), r$1 = r$1.next;
					while (r$1 !== t$2);
					return n$1;
				}(t$1, e$1) && (Tl$1(t$1.prev, t$1, e$1.prev) || Tl$1(t$1, e$1.prev, e$1)) || Fl$1(t$1, e$1) && Tl$1(t$1.prev, t$1, t$1.next) > 0 && Tl$1(e$1.prev, e$1, e$1.next) > 0);
			}
			function Tl$1(t$1, e$1, r$1) {
				return (e$1.y - t$1.y) * (r$1.x - e$1.x) - (e$1.x - t$1.x) * (r$1.y - e$1.y);
			}
			function Fl$1(t$1, e$1) {
				return t$1.x === e$1.x && t$1.y === e$1.y;
			}
			function $l$1(t$1, e$1, r$1, n$1) {
				const i$1 = Ol$1(Tl$1(t$1, e$1, r$1)), s$1 = Ol$1(Tl$1(t$1, e$1, n$1)), a = Ol$1(Tl$1(r$1, n$1, t$1)), o$1 = Ol$1(Tl$1(r$1, n$1, e$1));
				return i$1 !== s$1 && a !== o$1 || !(0 !== i$1 || !Ll$1(t$1, r$1, e$1)) || !(0 !== s$1 || !Ll$1(t$1, n$1, e$1)) || !(0 !== a || !Ll$1(r$1, t$1, n$1)) || !(0 !== o$1 || !Ll$1(r$1, e$1, n$1));
			}
			function Ll$1(t$1, e$1, r$1) {
				return e$1.x <= Math.max(t$1.x, r$1.x) && e$1.x >= Math.min(t$1.x, r$1.x) && e$1.y <= Math.max(t$1.y, r$1.y) && e$1.y >= Math.min(t$1.y, r$1.y);
			}
			function Ol$1(t$1) {
				return t$1 > 0 ? 1 : t$1 < 0 ? -1 : 0;
			}
			function Dl$1(t$1, e$1) {
				return Tl$1(t$1.prev, t$1, t$1.next) < 0 ? Tl$1(t$1, e$1, t$1.next) >= 0 && Tl$1(t$1, t$1.prev, e$1) >= 0 : Tl$1(t$1, e$1, t$1.prev) < 0 || Tl$1(t$1, t$1.next, e$1) < 0;
			}
			function Rl$1(t$1, e$1) {
				const r$1 = Nl$1(t$1.i, t$1.x, t$1.y), n$1 = Nl$1(e$1.i, e$1.x, e$1.y), i$1 = t$1.next, s$1 = e$1.prev;
				return t$1.next = e$1, e$1.prev = t$1, r$1.next = i$1, i$1.prev = r$1, n$1.next = r$1, r$1.prev = n$1, s$1.next = n$1, n$1.prev = s$1, n$1;
			}
			function Ul$1(t$1, e$1, r$1, n$1) {
				const i$1 = Nl$1(t$1, e$1, r$1);
				return n$1 ? (i$1.next = n$1.next, i$1.prev = n$1, n$1.next.prev = i$1, n$1.next = i$1) : (i$1.prev = i$1, i$1.next = i$1), i$1;
			}
			function jl$1(t$1) {
				t$1.next.prev = t$1.prev, t$1.prev.next = t$1.next, t$1.prevZ && (t$1.prevZ.nextZ = t$1.nextZ), t$1.nextZ && (t$1.nextZ.prevZ = t$1.prevZ);
			}
			function Nl$1(t$1, e$1, r$1) {
				return {
					i: t$1,
					x: e$1,
					y: r$1,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			class ql$1 {
				constructor(t$1, e$1) {
					if (e$1 > t$1) throw new Error("Min granularity must not be greater than base granularity.");
					this._baseZoomGranularity = t$1, this._minGranularity = e$1;
				}
				getGranularityForZoomLevel(t$1) {
					return Math.max(Math.floor(this._baseZoomGranularity / (1 << t$1)), this._minGranularity, 1);
				}
			}
			class Gl$1 {
				constructor(t$1) {
					this.fill = t$1.fill, this.line = t$1.line, this.tile = t$1.tile, this.stencil = t$1.stencil, this.circle = t$1.circle;
				}
			}
			Gl$1.noSubdivision = new Gl$1({
				fill: new ql$1(0, 0),
				line: new ql$1(0, 0),
				tile: new ql$1(0, 0),
				stencil: new ql$1(0, 0),
				circle: 1
			}), as$1("SubdivisionGranularityExpression", ql$1), as$1("SubdivisionGranularitySetting", Gl$1);
			const Xl$1 = -32768, Zl$1 = 32767;
			class Yl$1 {
				constructor(t$1, e$1) {
					this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t$1, this._granularityCellSize = P$1 / t$1, this._canonical = e$1;
				}
				_getKey(t$1, e$1) {
					return (t$1 += 32768) << 16 | e$1 + 32768;
				}
				_vertexToIndex(t$1, e$1) {
					if (t$1 < -32768 || e$1 < -32768 || t$1 > 32767 || e$1 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
					const r$1 = 0 | Math.round(t$1), n$1 = 0 | Math.round(e$1), i$1 = this._getKey(r$1, n$1);
					if (this._vertexDictionary.has(i$1)) return this._vertexDictionary.get(i$1);
					const s$1 = this._vertexBuffer.length / 2;
					return this._vertexDictionary.set(i$1, s$1), this._vertexBuffer.push(r$1, n$1), s$1;
				}
				_subdivideTrianglesScanline(t$1) {
					if (this._granularity < 2) return function(t$2, e$2) {
						const r$2 = [];
						for (let n$1 = 0; n$1 < e$2.length; n$1 += 3) {
							const i$1 = e$2[n$1], s$1 = e$2[n$1 + 1], a = e$2[n$1 + 2], o$1 = t$2[2 * i$1], l$1 = t$2[2 * i$1 + 1];
							(t$2[2 * s$1] - o$1) * (t$2[2 * a + 1] - l$1) - (t$2[2 * s$1 + 1] - l$1) * (t$2[2 * a] - o$1) > 0 ? (r$2.push(i$1), r$2.push(a), r$2.push(s$1)) : (r$2.push(i$1), r$2.push(s$1), r$2.push(a));
						}
						return r$2;
					}(this._vertexBuffer, t$1);
					const e$1 = [], r$1 = t$1.length;
					for (let n$1 = 0; n$1 < r$1; n$1 += 3) {
						const r$2 = [
							t$1[n$1 + 0],
							t$1[n$1 + 1],
							t$1[n$1 + 2]
						], i$1 = [
							this._vertexBuffer[2 * t$1[n$1 + 0] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 0] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 1]
						];
						let s$1 = Infinity, a = Infinity, o$1 = -Infinity, l$1 = -Infinity;
						for (let t$2 = 0; t$2 < 3; t$2++) {
							const e$2 = i$1[2 * t$2], r$3 = i$1[2 * t$2 + 1];
							s$1 = Math.min(s$1, e$2), o$1 = Math.max(o$1, e$2), a = Math.min(a, r$3), l$1 = Math.max(l$1, r$3);
						}
						if (s$1 === o$1 || a === l$1) continue;
						const u$1 = Math.floor(s$1 / this._granularityCellSize), c$1 = Math.ceil(o$1 / this._granularityCellSize), h$1 = Math.floor(a / this._granularityCellSize), p$1 = Math.ceil(l$1 / this._granularityCellSize);
						if (u$1 !== c$1 || h$1 !== p$1) for (let t$2 = h$1; t$2 < p$1; t$2++) {
							const n$2 = this._scanlineGenerateVertexRingForCellRow(t$2, i$1, r$2);
							Jl$1(this._vertexBuffer, n$2, e$1);
						}
						else e$1.push(...r$2);
					}
					return e$1;
				}
				_scanlineGenerateVertexRingForCellRow(t$1, e$1, r$1) {
					const n$1 = t$1 * this._granularityCellSize, i$1 = n$1 + this._granularityCellSize, s$1 = [];
					for (let t$2 = 0; t$2 < 3; t$2++) {
						const a = e$1[2 * t$2], o$1 = e$1[2 * t$2 + 1], l$1 = e$1[2 * (t$2 + 1) % 6], u$1 = e$1[(2 * (t$2 + 1) + 1) % 6], c$1 = e$1[2 * (t$2 + 2) % 6], h$1 = e$1[(2 * (t$2 + 2) + 1) % 6], p$1 = l$1 - a, f$1 = u$1 - o$1, d$1 = 0 === p$1, y$1 = 0 === f$1, m$1 = (n$1 - o$1) / f$1, g$2 = (i$1 - o$1) / f$1, x$1 = Math.min(m$1, g$2), v$1 = Math.max(m$1, g$2);
						if (!y$1 && (x$1 >= 1 || v$1 <= 0) || y$1 && (o$1 < n$1 || o$1 > i$1)) {
							u$1 >= n$1 && u$1 <= i$1 && s$1.push(r$1[(t$2 + 1) % 3]);
							continue;
						}
						!y$1 && x$1 > 0 && s$1.push(this._vertexToIndex(a + p$1 * x$1, o$1 + f$1 * x$1));
						const b$2 = a + p$1 * Math.max(x$1, 0), w$1 = a + p$1 * Math.min(v$1, 1);
						d$1 || this._generateIntraEdgeVertices(s$1, a, o$1, l$1, u$1, b$2, w$1), !y$1 && v$1 < 1 && s$1.push(this._vertexToIndex(a + p$1 * v$1, o$1 + f$1 * v$1)), (y$1 || u$1 >= n$1 && u$1 <= i$1) && s$1.push(r$1[(t$2 + 1) % 3]), !y$1 && (u$1 <= n$1 || u$1 >= i$1) && this._generateInterEdgeVertices(s$1, a, o$1, l$1, u$1, c$1, h$1, w$1, n$1, i$1);
					}
					return s$1;
				}
				_generateIntraEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = n$1 - e$1, l$1 = i$1 - r$1, u$1 = 0 === l$1, c$1 = u$1 ? Math.min(e$1, n$1) : Math.min(s$1, a), h$1 = u$1 ? Math.max(e$1, n$1) : Math.max(s$1, a), p$1 = Math.floor(c$1 / this._granularityCellSize) + 1, f$1 = Math.ceil(h$1 / this._granularityCellSize) - 1;
					if (u$1 ? e$1 < n$1 : s$1 < a) for (let n$2 = p$1; n$2 <= f$1; n$2++) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
					else for (let n$2 = f$1; n$2 >= p$1; n$2--) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
				}
				_generateInterEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = i$1 - r$1, h$1 = s$1 - n$1, p$1 = a - i$1, f$1 = (l$1 - i$1) / p$1, d$1 = (u$1 - i$1) / p$1, y$1 = Math.min(f$1, d$1), m$1 = Math.max(f$1, d$1), g$2 = n$1 + h$1 * y$1;
					let x$1 = Math.floor(Math.min(g$2, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(g$2, o$1) / this._granularityCellSize) - 1, b$2 = o$1 < g$2;
					const w$1 = 0 === p$1;
					if (w$1 && (a === l$1 || a === u$1)) return;
					if (w$1 || y$1 >= 1 || m$1 <= 0) {
						const t$2 = r$1 - a, n$2 = s$1 + (e$1 - s$1) * Math.min((l$1 - a) / t$2, (u$1 - a) / t$2);
						x$1 = Math.floor(Math.min(n$2, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(n$2, o$1) / this._granularityCellSize) - 1, b$2 = o$1 < n$2;
					}
					const _$2 = c$1 > 0 ? u$1 : l$1;
					if (b$2) for (let e$2 = x$1; e$2 <= v$1; e$2++) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$2));
					else for (let e$2 = v$1; e$2 >= x$1; e$2--) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$2));
				}
				_generateOutline(t$1) {
					const e$1 = [];
					for (const r$1 of t$1) {
						const t$2 = Kl$1(r$1, this._granularity, !0), n$1 = this._pointArrayToIndices(t$2), i$1 = [];
						for (let t$3 = 1; t$3 < n$1.length; t$3++) i$1.push(n$1[t$3 - 1]), i$1.push(n$1[t$3]);
						e$1.push(i$1);
					}
					return e$1;
				}
				_handlePoles(t$1) {
					let e$1 = !1, r$1 = !1;
					this._canonical && (0 === this._canonical.y && (e$1 = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (r$1 = !0)), (e$1 || r$1) && this._fillPoles(t$1, e$1, r$1);
				}
				_ensureNoPoleVertices() {
					const t$1 = this._vertexBuffer;
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
						const r$1 = t$1[e$1 + 1];
						r$1 === Xl$1 && (t$1[e$1 + 1] = -32767), r$1 === Zl$1 && (t$1[e$1 + 1] = 32766);
					}
				}
				_generatePoleQuad(t$1, e$1, r$1, n$1, i$1, s$1) {
					n$1 > i$1 != (s$1 === Xl$1) ? (t$1.push(e$1), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(this._vertexToIndex(n$1, s$1))) : (t$1.push(r$1), t$1.push(e$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)));
				}
				_fillPoles(t$1, e$1, r$1) {
					const n$1 = this._vertexBuffer, i$1 = P$1, s$1 = t$1.length;
					for (let a = 2; a < s$1; a += 3) {
						const s$2 = t$1[a - 2], o$1 = t$1[a - 1], l$1 = t$1[a], u$1 = n$1[2 * s$2], c$1 = n$1[2 * s$2 + 1], h$1 = n$1[2 * o$1], p$1 = n$1[2 * o$1 + 1], f$1 = n$1[2 * l$1], d$1 = n$1[2 * l$1 + 1];
						e$1 && (0 === c$1 && 0 === p$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, Xl$1), 0 === p$1 && 0 === d$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, Xl$1), 0 === d$1 && 0 === c$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, Xl$1)), r$1 && (c$1 === i$1 && p$1 === i$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, Zl$1), p$1 === i$1 && d$1 === i$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, Zl$1), d$1 === i$1 && c$1 === i$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, Zl$1));
					}
				}
				_initializeVertices(t$1) {
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) this._vertexToIndex(t$1[e$1], t$1[e$1 + 1]);
				}
				subdividePolygonInternal(t$1, e$1) {
					if (this._used) throw new Error("Subdivision: multiple use not allowed.");
					this._used = !0;
					const { flattened: r$1, holeIndices: n$1 } = function(t$2) {
						const e$2 = [], r$2 = [];
						for (const n$2 of t$2) if (0 !== n$2.length) {
							n$2 !== t$2[0] && e$2.push(r$2.length / 2);
							for (let t$3 = 0; t$3 < n$2.length; t$3++) r$2.push(n$2[t$3].x), r$2.push(n$2[t$3].y);
						}
						return {
							flattened: r$2,
							holeIndices: e$2
						};
					}(t$1);
					let i$1;
					this._initializeVertices(r$1);
					try {
						const t$2 = function(t$3, e$3, r$2 = 2) {
							const n$2 = e$3 && e$3.length, i$2 = n$2 ? e$3[0] * r$2 : t$3.length;
							let s$2 = vl$1(t$3, 0, i$2, r$2, !0);
							const a = [];
							if (!s$2 || s$2.next === s$2.prev) return a;
							let o$1, l$1, u$1;
							if (n$2 && (s$2 = function(t$4, e$4, r$3, n$3) {
								const i$3 = [];
								for (let r$4 = 0, s$3 = e$4.length; r$4 < s$3; r$4++) {
									const a$1 = vl$1(t$4, e$4[r$4] * n$3, r$4 < s$3 - 1 ? e$4[r$4 + 1] * n$3 : t$4.length, n$3, !1);
									a$1 === a$1.next && (a$1.steiner = !0), i$3.push(Cl$1(a$1));
								}
								i$3.sort(Ml$1);
								for (let t$5 = 0; t$5 < i$3.length; t$5++) r$3 = Il$1(i$3[t$5], r$3);
								return r$3;
							}(t$3, e$3, s$2, r$2)), t$3.length > 80 * r$2) {
								o$1 = t$3[0], l$1 = t$3[1];
								let e$4 = o$1, n$3 = l$1;
								for (let s$3 = r$2; s$3 < i$2; s$3 += r$2) {
									const r$3 = t$3[s$3], i$3 = t$3[s$3 + 1];
									r$3 < o$1 && (o$1 = r$3), i$3 < l$1 && (l$1 = i$3), r$3 > e$4 && (e$4 = r$3), i$3 > n$3 && (n$3 = i$3);
								}
								u$1 = Math.max(e$4 - o$1, n$3 - l$1), u$1 = 0 !== u$1 ? 32767 / u$1 : 0;
							}
							return wl$1(s$2, a, r$2, o$1, l$1, u$1, 0), a;
						}(r$1, n$1), e$2 = this._convertIndices(r$1, t$2);
						i$1 = this._subdivideTrianglesScanline(e$2);
					} catch (t$2) {
						console.error(t$2);
					}
					let s$1 = [];
					return e$1 && (s$1 = this._generateOutline(t$1)), this._ensureNoPoleVertices(), this._handlePoles(i$1), {
						verticesFlattened: this._vertexBuffer,
						indicesTriangles: i$1,
						indicesLineList: s$1
					};
				}
				_convertIndices(t$1, e$1) {
					const r$1 = [];
					for (let n$1 = 0; n$1 < e$1.length; n$1++) r$1.push(this._vertexToIndex(t$1[2 * e$1[n$1]], t$1[2 * e$1[n$1] + 1]));
					return r$1;
				}
				_pointArrayToIndices(t$1) {
					const e$1 = [];
					for (let r$1 = 0; r$1 < t$1.length; r$1++) {
						const n$1 = t$1[r$1];
						e$1.push(this._vertexToIndex(n$1.x, n$1.y));
					}
					return e$1;
				}
			}
			function Hl$1(t$1, e$1, r$1, n$1 = !0) {
				return new Yl$1(r$1, e$1).subdividePolygonInternal(t$1, n$1);
			}
			function Kl$1(t$1, e$1, n$1 = !1) {
				if (!t$1 || t$1.length < 1) return [];
				if (t$1.length < 2) return [];
				const i$1 = t$1[0], s$1 = t$1[t$1.length - 1], a = n$1 && (i$1.x !== s$1.x || i$1.y !== s$1.y);
				if (e$1 < 2) return a ? [...t$1, t$1[0]] : [...t$1];
				const o$1 = Math.floor(P$1 / e$1), l$1 = [];
				l$1.push(new r(t$1[0].x, t$1[0].y));
				const u$1 = t$1.length, c$1 = a ? u$1 : u$1 - 1;
				for (let e$2 = 0; e$2 < c$1; e$2++) {
					const n$2 = t$1[e$2], i$2 = e$2 < u$1 - 1 ? t$1[e$2 + 1] : t$1[0], s$2 = n$2.x, a$1 = n$2.y, c$2 = i$2.x, h$1 = i$2.y, p$1 = s$2 !== c$2, f$1 = a$1 !== h$1;
					if (!p$1 && !f$1) continue;
					const d$1 = c$2 - s$2, y$1 = h$1 - a$1, m$1 = Math.abs(d$1), g$2 = Math.abs(y$1);
					let x$1 = s$2, v$1 = a$1;
					for (;;) {
						const t$2 = d$1 > 0 ? (Math.floor(x$1 / o$1) + 1) * o$1 : (Math.ceil(x$1 / o$1) - 1) * o$1, e$3 = y$1 > 0 ? (Math.floor(v$1 / o$1) + 1) * o$1 : (Math.ceil(v$1 / o$1) - 1) * o$1, n$3 = Math.abs(x$1 - t$2), i$3 = Math.abs(v$1 - e$3), s$3 = Math.abs(x$1 - c$2), a$2 = Math.abs(v$1 - h$1), u$2 = p$1 ? n$3 / m$1 : Number.POSITIVE_INFINITY, b$3 = f$1 ? i$3 / g$2 : Number.POSITIVE_INFINITY;
						if ((s$3 <= n$3 || !p$1) && (a$2 <= i$3 || !f$1)) break;
						if (u$2 < b$3 && p$1 || !f$1) {
							x$1 = t$2, v$1 += y$1 * u$2;
							const e$4 = new r(x$1, Math.round(v$1));
							l$1[l$1.length - 1].x === e$4.x && l$1[l$1.length - 1].y === e$4.y || l$1.push(e$4);
						} else {
							x$1 += d$1 * b$3, v$1 = e$3;
							const t$3 = new r(Math.round(x$1), v$1);
							l$1[l$1.length - 1].x === t$3.x && l$1[l$1.length - 1].y === t$3.y || l$1.push(t$3);
						}
					}
					const b$2 = new r(c$2, h$1);
					l$1[l$1.length - 1].x === b$2.x && l$1[l$1.length - 1].y === b$2.y || l$1.push(b$2);
				}
				return l$1;
			}
			function Jl$1(t$1, e$1, r$1) {
				if (0 === e$1.length) throw new Error("Subdivision vertex ring is empty.");
				let n$1 = 0, i$1 = t$1[2 * e$1[0]];
				for (let r$2 = 1; r$2 < e$1.length; r$2++) {
					const s$2 = t$1[2 * e$1[r$2]];
					s$2 < i$1 && (i$1 = s$2, n$1 = r$2);
				}
				const s$1 = e$1.length;
				let a = n$1, o$1 = (a + 1) % s$1;
				for (;;) {
					const n$2 = a - 1 >= 0 ? a - 1 : s$1 - 1, i$2 = (o$1 + 1) % s$1, l$1 = t$1[2 * e$1[n$2]], u$1 = t$1[2 * e$1[i$2]], c$1 = t$1[2 * e$1[a]], h$1 = t$1[2 * e$1[a] + 1], p$1 = t$1[2 * e$1[o$1] + 1];
					let f$1 = !1;
					if (l$1 < u$1) f$1 = !0;
					else if (l$1 > u$1) f$1 = !1;
					else {
						const r$2 = p$1 - h$1, s$2 = -(t$1[2 * e$1[o$1]] - c$1), a$1 = h$1 < p$1 ? 1 : -1;
						((l$1 - c$1) * r$2 + (t$1[2 * e$1[n$2] + 1] - h$1) * s$2) * a$1 > ((u$1 - c$1) * r$2 + (t$1[2 * e$1[i$2] + 1] - h$1) * s$2) * a$1 && (f$1 = !0);
					}
					if (f$1) {
						const t$2 = e$1[n$2], i$3 = e$1[a], l$2 = e$1[o$1];
						t$2 !== i$3 && t$2 !== l$2 && i$3 !== l$2 && r$1.push(l$2, i$3, t$2), a--, a < 0 && (a = s$1 - 1);
					} else {
						const t$2 = e$1[i$2], n$3 = e$1[a], l$2 = e$1[o$1];
						t$2 !== n$3 && t$2 !== l$2 && n$3 !== l$2 && r$1.push(l$2, n$3, t$2), o$1++, o$1 >= s$1 && (o$1 = 0);
					}
					if (n$2 === i$2) break;
				}
			}
			function Wl$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = i$1.length / 2, c$1 = a && o$1 && l$1;
				if (u$1 < Xa$1.MAX_VERTEX_ARRAY_LENGTH) {
					const h$1 = e$1.prepareSegment(u$1, r$1, n$1), p$1 = h$1.vertexLength;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) n$1.emplaceBack(p$1 + s$1[t$2], p$1 + s$1[t$2 + 1], p$1 + s$1[t$2 + 2]);
					let f$1, d$1;
					h$1.vertexLength += u$1, h$1.primitiveLength += s$1.length / 3, c$1 && (d$1 = a.prepareSegment(u$1, r$1, o$1), f$1 = d$1.vertexLength, d$1.vertexLength += u$1);
					for (let e$2 = 0; e$2 < i$1.length; e$2 += 2) t$1(i$1[e$2], i$1[e$2 + 1]);
					if (c$1) for (let t$2 = 0; t$2 < l$1.length; t$2++) {
						const e$2 = l$1[t$2];
						for (let t$3 = 1; t$3 < e$2.length; t$3 += 2) o$1.emplaceBack(f$1 + e$2[t$3 - 1], f$1 + e$2[t$3]);
						d$1.primitiveLength += e$2.length / 2;
					}
				} else (function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$1.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 2; h$1 < i$2.length; h$1 += 3) {
						const p$1 = i$2[h$1 - 2], f$1 = i$2[h$1 - 1], d$1 = i$2[h$1];
						let y$1 = a$1[p$1] < l$2, m$1 = a$1[f$1] < l$2, g$2 = a$1[d$1] < l$2;
						u$2.vertexLength + ((y$1 ? 1 : 0) + (m$1 ? 1 : 0) + (g$2 ? 1 : 0)) > Xa$1.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, y$1 = !0, m$1 = !0, g$2 = !0, c$2 = 0);
						const x$1 = Ql$1(a$1, n$2, s$2, o$2, p$1, y$1, u$2), v$1 = Ql$1(a$1, n$2, s$2, o$2, f$1, m$1, u$2), b$2 = Ql$1(a$1, n$2, s$2, o$2, d$1, g$2, u$2);
						r$2.emplaceBack(c$2 + x$1 - l$2, c$2 + v$1 - l$2, c$2 + b$2 - l$2), u$2.primitiveLength++;
					}
				})(e$1, r$1, n$1, i$1, s$1, t$1), c$1 && function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$1.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 0; h$1 < i$2.length; h$1++) {
						const p$1 = i$2[h$1];
						for (let f$1 = 1; f$1 < i$2[h$1].length; f$1 += 2) {
							const i$3 = p$1[f$1 - 1], h$2 = p$1[f$1];
							let d$1 = a$1[i$3] < l$2, y$1 = a$1[h$2] < l$2;
							u$2.vertexLength + ((d$1 ? 1 : 0) + (y$1 ? 1 : 0)) > Xa$1.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, d$1 = !0, y$1 = !0, c$2 = 0);
							const m$1 = Ql$1(a$1, n$2, s$2, o$2, i$3, d$1, u$2), g$2 = Ql$1(a$1, n$2, s$2, o$2, h$2, y$1, u$2);
							r$2.emplaceBack(c$2 + m$1 - l$2, c$2 + g$2 - l$2), u$2.primitiveLength++;
						}
					}
				}(a, r$1, o$1, i$1, l$1, t$1), e$1.forceNewSegmentOnNextPrepare(), a?.forceNewSegmentOnNextPrepare();
			}
			function Ql$1(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (s$1) {
					const s$2 = n$1.count;
					return r$1(e$1[2 * i$1], e$1[2 * i$1 + 1]), t$1[i$1] = n$1.count, n$1.count++, a.vertexLength++, s$2;
				}
				return t$1[i$1];
			}
			class tu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.globalState = t$1.globalState, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ba$1(), this.indexArray = new ja$1(), this.indexArray2 = new Na$1(), this.programConfigurations = new bo$1(t$1.layers, t$1.zoom), this.segments = new Xa$1(), this.segments2 = new Xa$1(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasPattern = gl$1("fill", this.layers, e$1);
					const n$1 = this.layers[0].layout.get("fill-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: a, id: o$1, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = Mo$1(a, t$2);
						if (!this.layers[0]._featureFilter.filter(new Is$1(this.zoom, { globalState: this.globalState }), c$1, r$1)) continue;
						const h$1 = i$1 ? n$1.evaluate(c$1, {}, r$1, e$1.availableImages) : void 0, p$1 = {
							id: o$1,
							properties: a.properties,
							type: a.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : ko$1(a),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a } = n$2;
						if (this.hasPattern) {
							const t$2 = xl$1("fill", this.layers, n$2, this.zoom, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.subdivisionGranularity);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, r$1);
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.patternFeatures) this.addFeature(n$1, n$1.geometry, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ml$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t$1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const t$2 of Qr$1(e$1, 500)) {
						const e$2 = Hl$1(t$2, n$1, s$1.fill.getGranularityForZoomLevel(n$1.z)), r$2 = this.layoutVertexArray;
						Wl$1(((t$3, e$3) => {
							r$2.emplaceBack(t$3, e$3);
						}), this.segments, this.layoutVertexArray, this.indexArray, e$2.verticesFlattened, e$2.indicesTriangles, this.segments2, this.indexArray2, e$2.indicesLineList);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, i$1, n$1);
				}
			}
			let eu$1, ru$1;
			as$1("FillBucket", tu$1, { omit: ["layers", "patternFeatures"] });
			var nu$1 = {
				get paint() {
					return ru$1 = ru$1 || new Us$1({
						"fill-antialias": new $s$1(xt$1.paint_fill["fill-antialias"]),
						"fill-opacity": new Ls$1(xt$1.paint_fill["fill-opacity"]),
						"fill-color": new Ls$1(xt$1.paint_fill["fill-color"]),
						"fill-outline-color": new Ls$1(xt$1.paint_fill["fill-outline-color"]),
						"fill-translate": new $s$1(xt$1.paint_fill["fill-translate"]),
						"fill-translate-anchor": new $s$1(xt$1.paint_fill["fill-translate-anchor"]),
						"fill-pattern": new Os$1(xt$1.paint_fill["fill-pattern"])
					});
				},
				get layout() {
					return eu$1 = eu$1 || new Us$1({ "fill-sort-key": new Ls$1(xt$1.layout_fill["fill-sort-key"]) });
				}
			};
			class iu$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, nu$1);
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1);
					const r$1 = this.paint._values["fill-outline-color"];
					"constant" === r$1.value.kind && void 0 === r$1.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
				}
				createBucket(t$1) {
					return new tu$1(t$1);
				}
				queryRadius() {
					return jo$1(this.paint.get("fill-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, geometry: e$1, transform: r$1, pixelsToTileUnits: n$1 }) {
					return Bo$1(No$1(t$1, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r$1.bearingInRadians, n$1), e$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			const su$1 = Zs$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_normal_ed",
				components: 4,
				type: "Int16"
			}], 4), au$1 = Zs$1([{
				name: "a_centroid",
				components: 2,
				type: "Int16"
			}], 4), { members: ou$1 } = su$1;
			class lu$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.properties = {}, this.extent = r$1, this.type = 0, this.id = void 0, this._pbf = t$1, this._geometry = -1, this._keys = n$1, this._values = i$1, t$1.readFields(uu$1, this, e$1);
				}
				loadGeometry() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos, n$1 = [];
					let i$1, s$1 = 1, a = 0, o$1 = 0, l$1 = 0;
					for (; t$1.pos < e$1;) {
						if (a <= 0) {
							const e$2 = t$1.readVarint();
							s$1 = 7 & e$2, a = e$2 >> 3;
						}
						if (a--, 1 === s$1 || 2 === s$1) o$1 += t$1.readSVarint(), l$1 += t$1.readSVarint(), 1 === s$1 && (i$1 && n$1.push(i$1), i$1 = []), i$1 && i$1.push(new r(o$1, l$1));
						else {
							if (7 !== s$1) throw new Error(`unknown command ${s$1}`);
							i$1 && i$1.push(i$1[0].clone());
						}
					}
					return i$1 && n$1.push(i$1), n$1;
				}
				bbox() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos;
					let r$1 = 1, n$1 = 0, i$1 = 0, s$1 = 0, a = Infinity, o$1 = -Infinity, l$1 = Infinity, u$1 = -Infinity;
					for (; t$1.pos < e$1;) {
						if (n$1 <= 0) {
							const e$2 = t$1.readVarint();
							r$1 = 7 & e$2, n$1 = e$2 >> 3;
						}
						if (n$1--, 1 === r$1 || 2 === r$1) i$1 += t$1.readSVarint(), s$1 += t$1.readSVarint(), i$1 < a && (a = i$1), i$1 > o$1 && (o$1 = i$1), s$1 < l$1 && (l$1 = s$1), s$1 > u$1 && (u$1 = s$1);
						else if (7 !== r$1) throw new Error(`unknown command ${r$1}`);
					}
					return [
						a,
						l$1,
						o$1,
						u$1
					];
				}
				toGeoJSON(t$1, e$1, r$1) {
					const n$1 = this.extent * Math.pow(2, r$1), i$1 = this.extent * t$1, s$1 = this.extent * e$1, a = this.loadGeometry();
					function o$1(t$2) {
						return [360 * (t$2.x + i$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$2.y + s$1) / n$1) * Math.PI)) - 90];
					}
					function l$1(t$2) {
						return t$2.map(o$1);
					}
					let u$1;
					if (1 === this.type) {
						const t$2 = [];
						for (const e$3 of a) t$2.push(e$3[0]);
						const e$2 = l$1(t$2);
						u$1 = 1 === t$2.length ? {
							type: "Point",
							coordinates: e$2[0]
						} : {
							type: "MultiPoint",
							coordinates: e$2
						};
					} else if (2 === this.type) {
						const t$2 = a.map(l$1);
						u$1 = 1 === t$2.length ? {
							type: "LineString",
							coordinates: t$2[0]
						} : {
							type: "MultiLineString",
							coordinates: t$2
						};
					} else {
						if (3 !== this.type) throw new Error("unknown feature type");
						{
							const t$2 = function(t$3) {
								const e$3 = t$3.length;
								if (e$3 <= 1) return [t$3];
								const r$2 = [];
								let n$2, i$2;
								for (let s$2 = 0; s$2 < e$3; s$2++) {
									const e$4 = cu$1(t$3[s$2]);
									0 !== e$4 && (void 0 === i$2 && (i$2 = e$4 < 0), i$2 === e$4 < 0 ? (n$2 && r$2.push(n$2), n$2 = [t$3[s$2]]) : n$2 && n$2.push(t$3[s$2]));
								}
								return n$2 && r$2.push(n$2), r$2;
							}(a), e$2 = [];
							for (const r$2 of t$2) e$2.push(r$2.map(l$1));
							u$1 = 1 === e$2.length ? {
								type: "Polygon",
								coordinates: e$2[0]
							} : {
								type: "MultiPolygon",
								coordinates: e$2
							};
						}
					}
					const c$1 = {
						type: "Feature",
						geometry: u$1,
						properties: this.properties
					};
					return null != this.id && (c$1.id = this.id), c$1;
				}
			}
			function uu$1(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? function(t$2, e$2) {
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = e$2._keys[t$2.readVarint()], n$1 = e$2._values[t$2.readVarint()];
						e$2.properties[r$3] = n$1;
					}
				}(r$1, e$1) : 3 === t$1 ? e$1.type = r$1.readVarint() : 4 === t$1 && (e$1._geometry = r$1.pos);
			}
			function cu$1(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a = s$1 - 1; i$1 < s$1; a = i$1++) r$1 = t$1[i$1], n$1 = t$1[a], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			lu$1.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class hu$1 {
				constructor(t$1, e$1) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t$1, this._keys = [], this._values = [], this._features = [], t$1.readFields(pu$1, this, e$1), this.length = this._features.length;
				}
				feature(t$1) {
					if (t$1 < 0 || t$1 >= this._features.length) throw new Error("feature index out of bounds");
					this._pbf.pos = this._features[t$1];
					const e$1 = this._pbf.readVarint() + this._pbf.pos;
					return new lu$1(this._pbf, e$1, this.extent, this._keys, this._values);
				}
			}
			function pu$1(t$1, e$1, r$1) {
				15 === t$1 ? e$1.version = r$1.readVarint() : 1 === t$1 ? e$1.name = r$1.readString() : 5 === t$1 ? e$1.extent = r$1.readVarint() : 2 === t$1 ? e$1._features.push(r$1.pos) : 3 === t$1 ? e$1._keys.push(r$1.readString()) : 4 === t$1 && e$1._values.push(function(t$2) {
					let e$2 = null;
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = t$2.readVarint() >> 3;
						e$2 = 1 === r$3 ? t$2.readString() : 2 === r$3 ? t$2.readFloat() : 3 === r$3 ? t$2.readDouble() : 4 === r$3 ? t$2.readVarint64() : 5 === r$3 ? t$2.readVarint() : 6 === r$3 ? t$2.readSVarint() : 7 === r$3 ? t$2.readBoolean() : null;
					}
					if (null == e$2) throw new Error("unknown feature value");
					return e$2;
				}(r$1));
			}
			class fu$1 {
				constructor(t$1, e$1) {
					this.layers = t$1.readFields(du$1, {}, e$1);
				}
			}
			function du$1(t$1, e$1, r$1) {
				if (3 === t$1) {
					const t$2 = new hu$1(r$1, r$1.readVarint() + r$1.pos);
					t$2.length && (e$1[t$2.name] = t$2);
				}
			}
			const yu$1 = Math.pow(2, 13);
			function mu$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				t$1.emplaceBack(e$1, r$1, 2 * Math.floor(n$1 * yu$1) + a, i$1 * yu$1 * 2, s$1 * yu$1 * 2, Math.round(o$1));
			}
			class gu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.globalState = t$1.globalState, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasPattern = !1, this.layoutVertexArray = new Va$1(), this.centroidVertexArray = new Ca$1(), this.indexArray = new ja$1(), this.programConfigurations = new bo$1(t$1.layers, t$1.zoom), this.segments = new Xa$1(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.features = [], this.hasPattern = gl$1("fill-extrusion", this.layers, e$1);
					for (const { feature: n$1, id: i$1, index: s$1, sourceLayerIndex: a } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, o$1 = Mo$1(n$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Is$1(this.zoom, { globalState: this.globalState }), o$1, r$1)) continue;
						const l$1 = {
							id: i$1,
							sourceLayerIndex: a,
							index: s$1,
							geometry: t$2 ? o$1.geometry : ko$1(n$1),
							properties: n$1.properties,
							type: n$1.type,
							patterns: {}
						};
						this.hasPattern ? this.features.push(xl$1("fill-extrusion", this.layers, l$1, this.zoom, e$1)) : this.addFeature(l$1, l$1.geometry, s$1, r$1, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(n$1, l$1.geometry, s$1, a, this.index, !0);
					}
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.features) {
						const { geometry: i$1 } = n$1;
						this.addFeature(n$1, i$1, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, r$1);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ou$1), this.centroidVertexBuffer = t$1.createVertexBuffer(this.centroidVertexArray, au$1.members, !0), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const r$2 of Qr$1(e$1, 500)) {
						const e$2 = {
							x: 0,
							y: 0,
							sampleCount: 0
						}, i$2 = this.layoutVertexArray.length;
						this.processPolygon(e$2, n$1, t$1, r$2, s$1);
						const a = this.layoutVertexArray.length - i$2, o$1 = Math.floor(e$2.x / e$2.sampleCount), l$1 = Math.floor(e$2.y / e$2.sampleCount);
						for (let t$2 = 0; t$2 < a; t$2++) this.centroidVertexArray.emplaceBack(o$1, l$1);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, i$1, n$1);
				}
				processPolygon(t$1, e$1, r$1, n$1, i$1) {
					if (n$1.length < 1) return;
					if (bu$1(n$1[0])) return;
					for (const e$2 of n$1) 0 !== e$2.length && xu$1(t$1, e$2);
					const s$1 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a = i$1.fill.getGranularityForZoomLevel(e$1.z), o$1 = "Polygon" === lu$1.types[r$1.type];
					for (const t$2 of n$1) {
						if (0 === t$2.length) continue;
						if (bu$1(t$2)) continue;
						const e$2 = Kl$1(t$2, a, o$1);
						this._generateSideFaces(e$2, s$1);
					}
					if (!o$1) return;
					const l$1 = Hl$1(n$1, e$1, a, !1), u$1 = this.layoutVertexArray;
					Wl$1(((t$2, e$2) => {
						mu$1(u$1, t$2, e$2, 0, 0, 1, 1, 0);
					}), this.segments, this.layoutVertexArray, this.indexArray, l$1.verticesFlattened, l$1.indicesTriangles);
				}
				_generateSideFaces(t$1, e$1) {
					let r$1 = 0;
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1], s$1 = t$1[n$1 - 1];
						if (vu$1(i$1, s$1)) continue;
						e$1.segment.vertexLength + 4 > Xa$1.MAX_VERTEX_ARRAY_LENGTH && (e$1.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
						const a = i$1.sub(s$1)._perp()._unit(), o$1 = s$1.dist(i$1);
						r$1 + o$1 > 32768 && (r$1 = 0), mu$1(this.layoutVertexArray, i$1.x, i$1.y, a.x, a.y, 0, 0, r$1), mu$1(this.layoutVertexArray, i$1.x, i$1.y, a.x, a.y, 0, 1, r$1), r$1 += o$1, mu$1(this.layoutVertexArray, s$1.x, s$1.y, a.x, a.y, 0, 0, r$1), mu$1(this.layoutVertexArray, s$1.x, s$1.y, a.x, a.y, 0, 1, r$1);
						const l$1 = e$1.segment.vertexLength;
						this.indexArray.emplaceBack(l$1, l$1 + 2, l$1 + 1), this.indexArray.emplaceBack(l$1 + 1, l$1 + 2, l$1 + 3), e$1.segment.vertexLength += 4, e$1.segment.primitiveLength += 2;
					}
				}
			}
			function xu$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					r$1 === e$1.length - 1 && e$1[0].x === n$1.x && e$1[0].y === n$1.y || (t$1.x += n$1.x, t$1.y += n$1.y, t$1.sampleCount++);
				}
			}
			function vu$1(t$1, e$1) {
				return t$1.x === e$1.x && (t$1.x < 0 || t$1.x > P$1) || t$1.y === e$1.y && (t$1.y < 0 || t$1.y > P$1);
			}
			function bu$1(t$1) {
				return t$1.every(((t$2) => t$2.x < 0)) || t$1.every(((t$2) => t$2.x > P$1)) || t$1.every(((t$2) => t$2.y < 0)) || t$1.every(((t$2) => t$2.y > P$1));
			}
			let wu$1;
			as$1("FillExtrusionBucket", gu$1, { omit: ["layers", "features"] });
			var _u$1 = { get paint() {
				return wu$1 = wu$1 || new Us$1({
					"fill-extrusion-opacity": new $s$1(xt$1["paint_fill-extrusion"]["fill-extrusion-opacity"]),
					"fill-extrusion-color": new Ls$1(xt$1["paint_fill-extrusion"]["fill-extrusion-color"]),
					"fill-extrusion-translate": new $s$1(xt$1["paint_fill-extrusion"]["fill-extrusion-translate"]),
					"fill-extrusion-translate-anchor": new $s$1(xt$1["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
					"fill-extrusion-pattern": new Os$1(xt$1["paint_fill-extrusion"]["fill-extrusion-pattern"]),
					"fill-extrusion-height": new Ls$1(xt$1["paint_fill-extrusion"]["fill-extrusion-height"]),
					"fill-extrusion-base": new Ls$1(xt$1["paint_fill-extrusion"]["fill-extrusion-base"]),
					"fill-extrusion-vertical-gradient": new $s$1(xt$1["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
				});
			} };
			class Su$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, _u$1);
				}
				createBucket(t$1) {
					return new gu$1(t$1);
				}
				queryRadius() {
					return jo$1(this.paint.get("fill-extrusion-translate"));
				}
				is3D() {
					return !0;
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a, pixelPosMatrix: o$1 }) {
					const l$1 = No$1(t$1, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s$1.bearingInRadians, a), u$1 = this.paint.get("fill-extrusion-height").evaluate(e$1, n$1), c$1 = this.paint.get("fill-extrusion-base").evaluate(e$1, n$1), h$1 = function(t$2, e$2) {
						const n$2 = [];
						for (const i$2 of t$2) {
							const t$3 = [
								i$2.x,
								i$2.y,
								0,
								1
							];
							A(t$3, t$3, e$2), n$2.push(new r(t$3[0] / t$3[3], t$3[1] / t$3[3]));
						}
						return n$2;
					}(l$1, o$1), p$1 = function(t$2, e$2, n$2, i$2) {
						const s$2 = [], a$1 = [], o$2 = i$2[8] * e$2, l$2 = i$2[9] * e$2, u$2 = i$2[10] * e$2, c$2 = i$2[11] * e$2, h$2 = i$2[8] * n$2, p$2 = i$2[9] * n$2, f$1 = i$2[10] * n$2, d$1 = i$2[11] * n$2;
						for (const e$3 of t$2) {
							const t$3 = [], n$3 = [];
							for (const s$3 of e$3) {
								const e$4 = s$3.x, a$2 = s$3.y, y$1 = i$2[0] * e$4 + i$2[4] * a$2 + i$2[12], m$1 = i$2[1] * e$4 + i$2[5] * a$2 + i$2[13], g$2 = i$2[2] * e$4 + i$2[6] * a$2 + i$2[14], x$1 = i$2[3] * e$4 + i$2[7] * a$2 + i$2[15], v$1 = g$2 + u$2, b$2 = x$1 + c$2, w$1 = y$1 + h$2, _$2 = m$1 + p$2, S$2 = g$2 + f$1, A$1 = x$1 + d$1, k$2 = new r((y$1 + o$2) / b$2, (m$1 + l$2) / b$2);
								k$2.z = v$1 / b$2, t$3.push(k$2);
								const M$2 = new r(w$1 / A$1, _$2 / A$1);
								M$2.z = S$2 / A$1, n$3.push(M$2);
							}
							s$2.push(t$3), a$1.push(n$3);
						}
						return [s$2, a$1];
					}(i$1, c$1, u$1, o$1);
					return function(t$2, e$2, r$1) {
						let n$2 = Infinity;
						Bo$1(r$1, e$2) && (n$2 = ku$1(r$1, e$2[0]));
						for (let i$2 = 0; i$2 < e$2.length; i$2++) {
							const s$2 = e$2[i$2], a$1 = t$2[i$2];
							for (let t$3 = 0; t$3 < s$2.length - 1; t$3++) {
								const e$3 = s$2[t$3], i$3 = [
									e$3,
									s$2[t$3 + 1],
									a$1[t$3 + 1],
									a$1[t$3],
									e$3
								];
								Co$1(r$1, i$3) && (n$2 = Math.min(n$2, ku$1(r$1, i$3)));
							}
						}
						return n$2 !== Infinity && n$2;
					}(p$1[0], p$1[1], h$1);
				}
			}
			function Au$1(t$1, e$1) {
				return t$1.x * e$1.x + t$1.y * e$1.y;
			}
			function ku$1(t$1, e$1) {
				if (1 === t$1.length) {
					let r$1 = 0;
					const n$1 = e$1[r$1++];
					let i$1;
					for (; !i$1 || n$1.equals(i$1);) if (i$1 = e$1[r$1++], !i$1) return Infinity;
					for (; r$1 < e$1.length; r$1++) {
						const s$1 = e$1[r$1], a = t$1[0], o$1 = i$1.sub(n$1), l$1 = s$1.sub(n$1), u$1 = a.sub(n$1), c$1 = Au$1(o$1, o$1), h$1 = Au$1(o$1, l$1), p$1 = Au$1(l$1, l$1), f$1 = Au$1(u$1, o$1), d$1 = Au$1(u$1, l$1), y$1 = c$1 * p$1 - h$1 * h$1, m$1 = (p$1 * f$1 - h$1 * d$1) / y$1, g$2 = (c$1 * d$1 - h$1 * f$1) / y$1, x$1 = n$1.z * (1 - m$1 - g$2) + i$1.z * m$1 + s$1.z * g$2;
						if (isFinite(x$1)) return x$1;
					}
					return Infinity;
				}
				{
					let t$2 = Infinity;
					for (const r$1 of e$1) t$2 = Math.min(t$2, r$1.z);
					return t$2;
				}
			}
			const { members: Iu$1 } = Zs$1([{
				name: "a_pos_normal",
				components: 2,
				type: "Int16"
			}, {
				name: "a_data",
				components: 4,
				type: "Uint8"
			}], 4), { members: Pu$1 } = Zs$1([{
				name: "a_uv_x",
				components: 1,
				type: "Float32"
			}, {
				name: "a_split_index",
				components: 1,
				type: "Float32"
			}]), Cu$1 = Math.cos(Math.PI / 180 * 37.5), Eu$1 = Math.pow(2, 14) / .5;
			class Bu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.globalState = t$1.globalState, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t$2) => {
						this.gradients[t$2.id] = {};
					})), this.layoutVertexArray = new Ta$1(), this.layoutVertexArray2 = new Fa$1(), this.indexArray = new ja$1(), this.programConfigurations = new bo$1(t$1.layers, t$1.zoom), this.segments = new Xa$1(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasPattern = gl$1("line", this.layers, e$1);
					const n$1 = this.layers[0].layout.get("line-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: e$2, id: a, index: o$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Mo$1(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Is$1(this.zoom, { globalState: this.globalState }), u$1, r$1)) continue;
						const c$1 = i$1 ? n$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: a,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$1,
							index: o$1,
							geometry: t$2 ? u$1.geometry : ko$1(e$2),
							patterns: {},
							sortKey: c$1
						};
						s$1.push(h$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a } = n$2;
						if (this.hasPattern) {
							const t$2 = xl$1("line", this.layers, n$2, this.zoom, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.subdivisionGranularity);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, r$1);
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.patternFeatures) this.addFeature(n$1, n$1.geometry, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t$1.createVertexBuffer(this.layoutVertexArray2, Pu$1)), this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Iu$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(t$1) {
					if (t$1.properties && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_end")) return {
						start: +t$1.properties.mapbox_clip_start,
						end: +t$1.properties.mapbox_clip_end
					};
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.layers[0].layout, o$1 = a.get("line-join").evaluate(t$1, {}), l$1 = a.get("line-cap"), u$1 = a.get("line-miter-limit"), c$1 = a.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(t$1);
					for (const r$2 of e$1) this.addLine(r$2, t$1, o$1, l$1, u$1, c$1, n$1, s$1);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, i$1, n$1);
				}
				addLine(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t$1 = Kl$1(t$1, a ? o$1.line.getGranularityForZoomLevel(a.z) : 1), this.lineClips) {
						this.lineClipsArray.push(this.lineClips);
						for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) this.totalDistance += t$1[e$2].dist(t$1[e$2 + 1]);
						this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
					}
					const l$1 = "Polygon" === lu$1.types[e$1.type];
					let u$1 = t$1.length;
					for (; u$1 >= 2 && t$1[u$1 - 1].equals(t$1[u$1 - 2]);) u$1--;
					let c$1 = 0;
					for (; c$1 < u$1 - 1 && t$1[c$1].equals(t$1[c$1 + 1]);) c$1++;
					if (u$1 < (l$1 ? 3 : 2)) return;
					"bevel" === r$1 && (i$1 = 1.05);
					const h$1 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p$1 = this.segments.prepareSegment(10 * u$1, this.layoutVertexArray, this.indexArray);
					let f$1, d$1, y$1, m$1, g$2;
					this.e1 = this.e2 = -1, l$1 && (f$1 = t$1[u$1 - 2], g$2 = t$1[c$1].sub(f$1)._unit()._perp());
					for (let e$2 = c$1; e$2 < u$1; e$2++) {
						if (y$1 = e$2 === u$1 - 1 ? l$1 ? t$1[c$1 + 1] : void 0 : t$1[e$2 + 1], y$1 && t$1[e$2].equals(y$1)) continue;
						g$2 && (m$1 = g$2), f$1 && (d$1 = f$1), f$1 = t$1[e$2], g$2 = y$1 ? y$1.sub(f$1)._unit()._perp() : m$1, m$1 = m$1 || g$2;
						let a$1 = m$1.add(g$2);
						0 === a$1.x && 0 === a$1.y || a$1._unit();
						const o$2 = m$1.x * g$2.x + m$1.y * g$2.y, x$1 = a$1.x * g$2.x + a$1.y * g$2.y, v$1 = 0 !== x$1 ? 1 / x$1 : Infinity, b$2 = 2 * Math.sqrt(2 - 2 * x$1), w$1 = x$1 < Cu$1 && d$1 && y$1, _$2 = m$1.x * g$2.y - m$1.y * g$2.x > 0;
						if (w$1 && e$2 > c$1) {
							const t$2 = f$1.dist(d$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.sub(f$1.sub(d$1)._mult(h$1 / t$2)._round());
								this.updateDistance(d$1, e$3), this.addCurrentVertex(e$3, m$1, 0, 0, p$1), d$1 = e$3;
							}
						}
						const S$2 = d$1 && y$1;
						let A$1 = S$2 ? r$1 : l$1 ? "butt" : n$1;
						if (S$2 && "round" === A$1 && (v$1 < s$1 ? A$1 = "miter" : v$1 <= 2 && (A$1 = "fakeround")), "miter" === A$1 && v$1 > i$1 && (A$1 = "bevel"), "bevel" === A$1 && (v$1 > 2 && (A$1 = "flipbevel"), v$1 < i$1 && (A$1 = "miter")), d$1 && this.updateDistance(d$1, f$1), "miter" === A$1) a$1._mult(v$1), this.addCurrentVertex(f$1, a$1, 0, 0, p$1);
						else if ("flipbevel" === A$1) {
							if (v$1 > 100) a$1 = g$2.mult(-1);
							else {
								const t$2 = v$1 * m$1.add(g$2).mag() / m$1.sub(g$2).mag();
								a$1._perp()._mult(t$2 * (_$2 ? -1 : 1));
							}
							this.addCurrentVertex(f$1, a$1, 0, 0, p$1), this.addCurrentVertex(f$1, a$1.mult(-1), 0, 0, p$1);
						} else if ("bevel" === A$1 || "fakeround" === A$1) {
							const t$2 = -Math.sqrt(v$1 * v$1 - 1), e$3 = _$2 ? t$2 : 0, r$2 = _$2 ? 0 : t$2;
							if (d$1 && this.addCurrentVertex(f$1, m$1, e$3, r$2, p$1), "fakeround" === A$1) {
								const t$3 = Math.round(180 * b$2 / Math.PI / 20);
								for (let e$4 = 1; e$4 < t$3; e$4++) {
									let r$3 = e$4 / t$3;
									if (.5 !== r$3) {
										const t$4 = r$3 - .5;
										r$3 += r$3 * t$4 * (r$3 - 1) * ((1.0904 + o$2 * (o$2 * (3.55645 - 1.43519 * o$2) - 3.2452)) * t$4 * t$4 + (.848013 + o$2 * (.215638 * o$2 - 1.06021)));
									}
									const n$2 = g$2.sub(m$1)._mult(r$3)._add(m$1)._unit()._mult(_$2 ? -1 : 1);
									this.addHalfVertex(f$1, n$2.x, n$2.y, !1, _$2, 0, p$1);
								}
							}
							y$1 && this.addCurrentVertex(f$1, g$2, -e$3, -r$2, p$1);
						} else if ("butt" === A$1) this.addCurrentVertex(f$1, a$1, 0, 0, p$1);
						else if ("square" === A$1) {
							const t$2 = d$1 ? 1 : -1;
							this.addCurrentVertex(f$1, a$1, t$2, t$2, p$1);
						} else "round" === A$1 && (d$1 && (this.addCurrentVertex(f$1, m$1, 0, 0, p$1), this.addCurrentVertex(f$1, m$1, 1, 1, p$1, !0)), y$1 && (this.addCurrentVertex(f$1, g$2, -1, -1, p$1, !0), this.addCurrentVertex(f$1, g$2, 0, 0, p$1)));
						if (w$1 && e$2 < u$1 - 1) {
							const t$2 = f$1.dist(y$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.add(y$1.sub(f$1)._mult(h$1 / t$2)._round());
								this.updateDistance(f$1, e$3), this.addCurrentVertex(e$3, g$2, 0, 0, p$1), f$1 = e$3;
							}
						}
					}
				}
				addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1 = !1) {
					const a = e$1.y * n$1 - e$1.x, o$1 = -e$1.y - e$1.x * n$1;
					this.addHalfVertex(t$1, e$1.x + e$1.y * r$1, e$1.y - e$1.x * r$1, s$1, !1, r$1, i$1), this.addHalfVertex(t$1, a, o$1, s$1, !0, -n$1, i$1), this.distance > Eu$1 / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1));
				}
				addHalfVertex({ x: t$1, y: e$1 }, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = .5 * (this.lineClips ? this.scaledDistance * (Eu$1 - 1) : this.scaledDistance);
					this.layoutVertexArray.emplaceBack((t$1 << 1) + (i$1 ? 1 : 0), (e$1 << 1) + (s$1 ? 1 : 0), Math.round(63 * r$1) + 128, Math.round(63 * n$1) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & l$1) << 2, l$1 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
					const u$1 = o$1.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u$1, this.e2), o$1.primitiveLength++), s$1 ? this.e2 = u$1 : this.e1 = u$1;
				}
				updateScaledDistance() {
					this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
				}
				updateDistance(t$1, e$1) {
					this.distance += t$1.dist(e$1), this.updateScaledDistance();
				}
			}
			let Vu$1, Tu$1;
			as$1("LineBucket", Bu$1, { omit: ["layers", "patternFeatures"] });
			var Fu$1 = {
				get paint() {
					return Tu$1 = Tu$1 || new Us$1({
						"line-opacity": new Ls$1(xt$1.paint_line["line-opacity"]),
						"line-color": new Ls$1(xt$1.paint_line["line-color"]),
						"line-translate": new $s$1(xt$1.paint_line["line-translate"]),
						"line-translate-anchor": new $s$1(xt$1.paint_line["line-translate-anchor"]),
						"line-width": new Ls$1(xt$1.paint_line["line-width"]),
						"line-gap-width": new Ls$1(xt$1.paint_line["line-gap-width"]),
						"line-offset": new Ls$1(xt$1.paint_line["line-offset"]),
						"line-blur": new Ls$1(xt$1.paint_line["line-blur"]),
						"line-dasharray": new Ds$1(xt$1.paint_line["line-dasharray"]),
						"line-pattern": new Os$1(xt$1.paint_line["line-pattern"]),
						"line-gradient": new Rs$1(xt$1.paint_line["line-gradient"])
					});
				},
				get layout() {
					return Vu$1 = Vu$1 || new Us$1({
						"line-cap": new $s$1(xt$1.layout_line["line-cap"]),
						"line-join": new Ls$1(xt$1.layout_line["line-join"]),
						"line-miter-limit": new $s$1(xt$1.layout_line["line-miter-limit"]),
						"line-round-limit": new $s$1(xt$1.layout_line["line-round-limit"]),
						"line-sort-key": new Ls$1(xt$1.layout_line["line-sort-key"])
					});
				}
			};
			class $u$1 extends Ls$1 {
				possiblyEvaluate(t$1, e$1) {
					return e$1 = new Is$1(Math.floor(e$1.zoom), {
						now: e$1.now,
						fadeDuration: e$1.fadeDuration,
						zoomHistory: e$1.zoomHistory,
						transition: e$1.transition
					}), super.possiblyEvaluate(t$1, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return e$1 = O$1({}, e$1, { zoom: Math.floor(e$1.zoom) }), super.evaluate(t$1, e$1, r$1, n$1);
				}
			}
			let Lu$1;
			class Ou$1 extends Ns$1 {
				constructor(t$1) {
					super(t$1, Fu$1), this.gradientVersion = 0, Lu$1 || (Lu$1 = new $u$1(Fu$1.paint.properties["line-width"].specification), Lu$1.useIntegerZoom = !0);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					if ("line-gradient" === t$1) {
						const t$2 = this.gradientExpression();
						this.stepInterpolant = !!function(t$3) {
							return void 0 !== t$3._styleExpression;
						}(t$2) && t$2._styleExpression.expression instanceof ar$1, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
					}
				}
				gradientExpression() {
					return this._transitionablePaint._values["line-gradient"].value.expression;
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1), this.paint._values["line-floorwidth"] = Lu$1.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t$1);
				}
				createBucket(t$1) {
					return new Bu$1(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1, r$1 = Du$1(Uo$1("line-width", this, e$1), Uo$1("line-gap-width", this, e$1)), n$1 = Uo$1("line-offset", this, e$1);
					return r$1 / 2 + Math.abs(n$1) + jo$1(this.paint.get("line-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a }) {
					const o$1 = No$1(t$1, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s$1.bearingInRadians, a), l$1 = a / 2 * Du$1(this.paint.get("line-width").evaluate(e$1, n$1), this.paint.get("line-gap-width").evaluate(e$1, n$1)), u$1 = this.paint.get("line-offset").evaluate(e$1, n$1);
					return u$1 && (i$1 = function(t$2, e$2) {
						const n$2 = [];
						for (let i$2 = 0; i$2 < t$2.length; i$2++) {
							const s$2 = t$2[i$2], a$1 = [];
							for (let t$3 = 0; t$3 < s$2.length; t$3++) {
								const n$3 = s$2[t$3 - 1], i$3 = s$2[t$3], o$2 = s$2[t$3 + 1], l$2 = 0 === t$3 ? new r(0, 0) : i$3.sub(n$3)._unit()._perp(), u$2 = t$3 === s$2.length - 1 ? new r(0, 0) : o$2.sub(i$3)._unit()._perp(), c$1 = l$2._add(u$2)._unit(), h$1 = c$1.x * u$2.x + c$1.y * u$2.y;
								0 !== h$1 && c$1._mult(1 / h$1), a$1.push(c$1._mult(e$2)._add(i$3));
							}
							n$2.push(a$1);
						}
						return n$2;
					}(i$1, u$1 * a)), function(t$2, e$2, r$1) {
						for (let n$2 = 0; n$2 < e$2.length; n$2++) {
							const i$2 = e$2[n$2];
							if (t$2.length >= 3) {
								for (let e$3 = 0; e$3 < i$2.length; e$3++) if (Do$1(t$2, i$2[e$3])) return !0;
							}
							if (Vo$1(t$2, i$2, r$1)) return !0;
						}
						return !1;
					}(o$1, i$1, l$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			function Du$1(t$1, e$1) {
				return e$1 > 0 ? e$1 + 2 * t$1 : t$1;
			}
			const Ru = Zs$1([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), Uu$1 = Zs$1([{
				name: "a_projected_pos",
				components: 3,
				type: "Float32"
			}], 4);
			Zs$1([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			const ju$1 = Zs$1([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_box_real",
					components: 2,
					type: "Int16"
				}
			]);
			Zs$1([
				{
					type: "Int16",
					name: "anchorPointX"
				},
				{
					type: "Int16",
					name: "anchorPointY"
				},
				{
					type: "Int16",
					name: "x1"
				},
				{
					type: "Int16",
					name: "y1"
				},
				{
					type: "Int16",
					name: "x2"
				},
				{
					type: "Int16",
					name: "y2"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			const Nu$1 = Zs$1([
				{
					name: "a_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), qu$1 = Zs$1([
				{
					name: "a_pos",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			function Gu$1(t$1, e$1, r$1) {
				return t$1.sections.forEach(((t$2) => {
					t$2.text = function(t$3, e$2, r$2) {
						const n$1 = e$2.layout.get("text-transform").evaluate(r$2, {});
						return "uppercase" === n$1 ? t$3 = t$3.toLocaleUpperCase() : "lowercase" === n$1 && (t$3 = t$3.toLocaleLowerCase()), Ms$1.applyArabicShaping && (t$3 = Ms$1.applyArabicShaping(t$3)), t$3;
					}(t$2.text, e$1, r$1);
				})), t$1;
			}
			Zs$1([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), Zs$1([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				}
			]), Zs$1([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					name: "textBoxScale"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetStartIndex"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetEndIndex"
				}
			]), Zs$1([{
				type: "Float32",
				name: "offsetX"
			}]), Zs$1([
				{
					type: "Int16",
					name: "x"
				},
				{
					type: "Int16",
					name: "y"
				},
				{
					type: "Int16",
					name: "tileUnitDistanceFromAnchor"
				}
			]), Zs$1([{
				type: "Uint16",
				name: "textAnchor"
			}, {
				type: "Float32",
				components: 2,
				name: "textOffset"
			}]);
			const Xu$1 = {
				"!": "",
				"#": "",
				$: "",
				"%": "",
				"&": "",
				"(": "",
				")": "",
				"*": "",
				"+": "",
				",": "",
				"-": "",
				".": "",
				"/": "",
				":": "",
				";": "",
				"<": "",
				"=": "",
				">": "",
				"?": "",
				"@": "",
				"[": "",
				"\\": "",
				"]": "",
				"^": "",
				_: "",
				"`": "",
				"{": "",
				"|": "",
				"}": "",
				"~": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": ""
			};
			var Zu$1 = 24;
			const Yu$1 = 4294967296, Hu$1 = 1 / Yu$1, Ku$1 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
			class Ju$1 {
				constructor(t$1 = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(t$1) ? t$1 : new Uint8Array(t$1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(t$1, e$1, r$1 = this.length) {
					for (; this.pos < r$1;) {
						const r$2 = this.readVarint(), n$1 = r$2 >> 3, i$1 = this.pos;
						this.type = 7 & r$2, t$1(n$1, e$1, this), this.pos === i$1 && this.skip(r$2);
					}
					return e$1;
				}
				readMessage(t$1, e$1) {
					return this.readFields(t$1, e$1, this.readVarint() + this.pos);
				}
				readFixed32() {
					const t$1 = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readSFixed32() {
					const t$1 = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Yu$1;
					return this.pos += 8, t$1;
				}
				readSFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Yu$1;
					return this.pos += 8, t$1;
				}
				readFloat() {
					const t$1 = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readDouble() {
					const t$1 = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, t$1;
				}
				readVarint(t$1) {
					const e$1 = this.buf;
					let r$1, n$1;
					return n$1 = e$1[this.pos++], r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
						const n$2 = r$2.buf;
						let i$1, s$1;
						if (s$1 = n$2[r$2.pos++], i$1 = (112 & s$1) >> 4, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 3, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 10, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 17, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 24, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (1 & s$1) << 31, s$1 < 128) return Wu$1(t$2, i$1, e$2);
						throw new Error("Expected varint not more than 10 bytes");
					}(r$1, t$1, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					const t$1 = this.readVarint();
					return t$1 % 2 == 1 ? (t$1 + 1) / -2 : t$1 / 2;
				}
				readBoolean() {
					return Boolean(this.readVarint());
				}
				readString() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.pos;
					return this.pos = t$1, t$1 - e$1 >= 12 && Ku$1 ? Ku$1.decode(this.buf.subarray(e$1, t$1)) : function(t$2, e$2, r$1) {
						let n$1 = "", i$1 = e$2;
						for (; i$1 < r$1;) {
							const e$3 = t$2[i$1];
							let s$1, a, o$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
							if (i$1 + u$1 > r$1) break;
							1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & a) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & a, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], o$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & a) && 128 == (192 & o$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & a) << 6 | 63 & o$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
						}
						return n$1;
					}(this.buf, e$1, t$1);
				}
				readBytes() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.buf.subarray(this.pos, t$1);
					return this.pos = t$1, e$1;
				}
				readPackedVarint(t$1 = [], e$1) {
					const r$1 = this.readPackedEnd();
					for (; this.pos < r$1;) t$1.push(this.readVarint(e$1));
					return t$1;
				}
				readPackedSVarint(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSVarint());
					return t$1;
				}
				readPackedBoolean(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readBoolean());
					return t$1;
				}
				readPackedFloat(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFloat());
					return t$1;
				}
				readPackedDouble(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readDouble());
					return t$1;
				}
				readPackedFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed32());
					return t$1;
				}
				readPackedSFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed32());
					return t$1;
				}
				readPackedFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed64());
					return t$1;
				}
				readPackedSFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed64());
					return t$1;
				}
				readPackedEnd() {
					return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(t$1) {
					const e$1 = 7 & t$1;
					if (0 === e$1) for (; this.buf[this.pos++] > 127;);
					else if (2 === e$1) this.pos = this.readVarint() + this.pos;
					else if (5 === e$1) this.pos += 4;
					else {
						if (1 !== e$1) throw new Error(`Unimplemented type: ${e$1}`);
						this.pos += 8;
					}
				}
				writeTag(t$1, e$1) {
					this.writeVarint(t$1 << 3 | e$1);
				}
				realloc(t$1) {
					let e$1 = this.length || 16;
					for (; e$1 < this.pos + t$1;) e$1 *= 2;
					if (e$1 !== this.length) {
						const t$2 = new Uint8Array(e$1);
						t$2.set(this.buf), this.buf = t$2, this.dataView = new DataView(t$2.buffer), this.length = e$1;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeSFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * Hu$1), !0), this.pos += 8;
				}
				writeSFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * Hu$1), !0), this.pos += 8;
				}
				writeVarint(t$1) {
					(t$1 = +t$1 || 0) > 268435455 || t$1 < 0 ? function(t$2, e$1) {
						let r$1, n$1;
						if (t$2 >= 0 ? (r$1 = t$2 % 4294967296 | 0, n$1 = t$2 / 4294967296 | 0) : (r$1 = ~(-t$2 % 4294967296), n$1 = ~(-t$2 / 4294967296), 4294967295 ^ r$1 ? r$1 = r$1 + 1 | 0 : (r$1 = 0, n$1 = n$1 + 1 | 0)), t$2 >= 0x10000000000000000 || t$2 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
						e$1.realloc(10), function(t$3, e$2, r$2) {
							r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, r$2.buf[r$2.pos] = 127 & (t$3 >>>= 7);
						}(r$1, 0, e$1), function(t$3, e$2) {
							const r$2 = (7 & t$3) << 4;
							e$2.buf[e$2.pos++] |= r$2 | ((t$3 >>>= 3) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3)))));
						}(n$1, e$1);
					}(t$1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t$1 | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = t$1 >>> 7 & 127))));
				}
				writeSVarint(t$1) {
					this.writeVarint(t$1 < 0 ? 2 * -t$1 - 1 : 2 * t$1);
				}
				writeBoolean(t$1) {
					this.writeVarint(+t$1);
				}
				writeString(t$1) {
					t$1 = String(t$1), this.realloc(4 * t$1.length), this.pos++;
					const e$1 = this.pos;
					this.pos = function(t$2, e$2, r$2) {
						for (let n$1, i$1, s$1 = 0; s$1 < e$2.length; s$1++) {
							if (n$1 = e$2.charCodeAt(s$1), n$1 > 55295 && n$1 < 57344) {
								if (!i$1) {
									n$1 > 56319 || s$1 + 1 === e$2.length ? (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189) : i$1 = n$1;
									continue;
								}
								if (n$1 < 56320) {
									t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = n$1;
									continue;
								}
								n$1 = i$1 - 55296 << 10 | n$1 - 56320 | 65536, i$1 = null;
							} else i$1 && (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = null);
							n$1 < 128 ? t$2[r$2++] = n$1 : (n$1 < 2048 ? t$2[r$2++] = n$1 >> 6 | 192 : (n$1 < 65536 ? t$2[r$2++] = n$1 >> 12 | 224 : (t$2[r$2++] = n$1 >> 18 | 240, t$2[r$2++] = n$1 >> 12 & 63 | 128), t$2[r$2++] = n$1 >> 6 & 63 | 128), t$2[r$2++] = 63 & n$1 | 128);
						}
						return r$2;
					}(this.buf, t$1, this.pos);
					const r$1 = this.pos - e$1;
					r$1 >= 128 && Qu$1(e$1, r$1, this), this.pos = e$1 - 1, this.writeVarint(r$1), this.pos += r$1;
				}
				writeFloat(t$1) {
					this.realloc(4), this.dataView.setFloat32(this.pos, t$1, !0), this.pos += 4;
				}
				writeDouble(t$1) {
					this.realloc(8), this.dataView.setFloat64(this.pos, t$1, !0), this.pos += 8;
				}
				writeBytes(t$1) {
					const e$1 = t$1.length;
					this.writeVarint(e$1), this.realloc(e$1);
					for (let r$1 = 0; r$1 < e$1; r$1++) this.buf[this.pos++] = t$1[r$1];
				}
				writeRawMessage(t$1, e$1) {
					this.pos++;
					const r$1 = this.pos;
					t$1(e$1, this);
					const n$1 = this.pos - r$1;
					n$1 >= 128 && Qu$1(r$1, n$1, this), this.pos = r$1 - 1, this.writeVarint(n$1), this.pos += n$1;
				}
				writeMessage(t$1, e$1, r$1) {
					this.writeTag(t$1, 2), this.writeRawMessage(e$1, r$1);
				}
				writePackedVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, tc$1, e$1);
				}
				writePackedSVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, ec$1, e$1);
				}
				writePackedBoolean(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, ic$1, e$1);
				}
				writePackedFloat(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, rc$1, e$1);
				}
				writePackedDouble(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, nc$1, e$1);
				}
				writePackedFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, sc$1, e$1);
				}
				writePackedSFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, ac$1, e$1);
				}
				writePackedFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, oc$1, e$1);
				}
				writePackedSFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, lc$1, e$1);
				}
				writeBytesField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeBytes(e$1);
				}
				writeFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFixed32(e$1);
				}
				writeSFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeSFixed32(e$1);
				}
				writeFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeFixed64(e$1);
				}
				writeSFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeSFixed64(e$1);
				}
				writeVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeVarint(e$1);
				}
				writeSVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeSVarint(e$1);
				}
				writeStringField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeString(e$1);
				}
				writeFloatField(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFloat(e$1);
				}
				writeDoubleField(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeDouble(e$1);
				}
				writeBooleanField(t$1, e$1) {
					this.writeVarintField(t$1, +e$1);
				}
			}
			function Wu$1(t$1, e$1, r$1) {
				return r$1 ? 4294967296 * e$1 + (t$1 >>> 0) : 4294967296 * (e$1 >>> 0) + (t$1 >>> 0);
			}
			function Qu$1(t$1, e$1, r$1) {
				const n$1 = e$1 <= 16383 ? 1 : e$1 <= 2097151 ? 2 : e$1 <= 268435455 ? 3 : Math.floor(Math.log(e$1) / (7 * Math.LN2));
				r$1.realloc(n$1);
				for (let e$2 = r$1.pos - 1; e$2 >= t$1; e$2--) r$1.buf[e$2 + n$1] = r$1.buf[e$2];
			}
			function tc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeVarint(t$1[r$1]);
			}
			function ec$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSVarint(t$1[r$1]);
			}
			function rc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFloat(t$1[r$1]);
			}
			function nc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeDouble(t$1[r$1]);
			}
			function ic$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeBoolean(t$1[r$1]);
			}
			function sc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed32(t$1[r$1]);
			}
			function ac$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed32(t$1[r$1]);
			}
			function oc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed64(t$1[r$1]);
			}
			function lc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed64(t$1[r$1]);
			}
			function uc$1(t$1, e$1, r$1) {
				1 === t$1 && r$1.readMessage(cc$1, e$1);
			}
			function cc$1(t$1, e$1, r$1) {
				if (3 === t$1) {
					const { id: t$2, bitmap: n$1, width: i$1, height: s$1, left: a, top: o$1, advance: l$1 } = r$1.readMessage(hc$1, {});
					e$1.push({
						id: t$2,
						bitmap: new el$1({
							width: i$1 + 6,
							height: s$1 + 6
						}, n$1),
						metrics: {
							width: i$1,
							height: s$1,
							left: a,
							top: o$1,
							advance: l$1
						}
					});
				}
			}
			function hc$1(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? e$1.bitmap = r$1.readBytes() : 3 === t$1 ? e$1.width = r$1.readVarint() : 4 === t$1 ? e$1.height = r$1.readVarint() : 5 === t$1 ? e$1.left = r$1.readSVarint() : 6 === t$1 ? e$1.top = r$1.readSVarint() : 7 === t$1 && (e$1.advance = r$1.readVarint());
			}
			function pc$1(t$1) {
				let e$1 = 0, r$1 = 0;
				for (const n$2 of t$1) e$1 += n$2.w * n$2.h, r$1 = Math.max(r$1, n$2.w);
				t$1.sort(((t$2, e$2) => e$2.h - t$2.h));
				const n$1 = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(e$1 / .95)), r$1),
					h: Infinity
				}];
				let i$1 = 0, s$1 = 0;
				for (const e$2 of t$1) for (let t$2 = n$1.length - 1; t$2 >= 0; t$2--) {
					const r$2 = n$1[t$2];
					if (!(e$2.w > r$2.w || e$2.h > r$2.h)) {
						if (e$2.x = r$2.x, e$2.y = r$2.y, s$1 = Math.max(s$1, e$2.y + e$2.h), i$1 = Math.max(i$1, e$2.x + e$2.w), e$2.w === r$2.w && e$2.h === r$2.h) {
							const e$3 = n$1.pop();
							e$3 && t$2 < n$1.length && (n$1[t$2] = e$3);
						} else e$2.h === r$2.h ? (r$2.x += e$2.w, r$2.w -= e$2.w) : e$2.w === r$2.w ? (r$2.y += e$2.h, r$2.h -= e$2.h) : (n$1.push({
							x: r$2.x + e$2.w,
							y: r$2.y,
							w: r$2.w - e$2.w,
							h: e$2.h
						}), r$2.y += e$2.h, r$2.h -= e$2.h);
						break;
					}
				}
				return {
					w: i$1,
					h: s$1,
					fill: e$1 / (i$1 * s$1) || 0
				};
			}
			class fc$1 {
				constructor(t$1, { pixelRatio: e$1, version: r$1, stretchX: n$1, stretchY: i$1, content: s$1, textFitWidth: a, textFitHeight: o$1 }) {
					this.paddedRect = t$1, this.pixelRatio = e$1, this.stretchX = n$1, this.stretchY = i$1, this.content = s$1, this.version = r$1, this.textFitWidth = a, this.textFitHeight = o$1;
				}
				get tl() {
					return [this.paddedRect.x + 1, this.paddedRect.y + 1];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
				}
				get tlbr() {
					return this.tl.concat(this.br);
				}
				get displaySize() {
					return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
				}
			}
			class dc$1 {
				constructor(t$1, e$1) {
					const r$1 = {}, n$1 = {};
					this.haveRenderCallbacks = [];
					const i$1 = [];
					this.addImages(t$1, r$1, i$1), this.addImages(e$1, n$1, i$1);
					const { w: s$1, h: a } = pc$1(i$1), o$1 = new rl$1({
						width: s$1 || 1,
						height: a || 1
					});
					for (const e$2 in t$1) {
						const n$2 = t$1[e$2], i$2 = r$1[e$2].paddedRect;
						rl$1.copy(n$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: i$2.x + 1,
							y: i$2.y + 1
						}, n$2.data);
					}
					for (const t$2 in e$1) {
						const r$2 = e$1[t$2], i$2 = n$1[t$2].paddedRect, s$2 = i$2.x + 1, a$1 = i$2.y + 1, l$1 = r$2.data.width, u$1 = r$2.data.height;
						rl$1.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$1
						}, r$2.data), rl$1.copy(r$2.data, o$1, {
							x: 0,
							y: u$1 - 1
						}, {
							x: s$2,
							y: a$1 - 1
						}, {
							width: l$1,
							height: 1
						}), rl$1.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$1 + u$1
						}, {
							width: l$1,
							height: 1
						}), rl$1.copy(r$2.data, o$1, {
							x: l$1 - 1,
							y: 0
						}, {
							x: s$2 - 1,
							y: a$1
						}, {
							width: 1,
							height: u$1
						}), rl$1.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2 + l$1,
							y: a$1
						}, {
							width: 1,
							height: u$1
						});
					}
					this.image = o$1, this.iconPositions = r$1, this.patternPositions = n$1;
				}
				addImages(t$1, e$1, r$1) {
					for (const n$1 in t$1) {
						const i$1 = t$1[n$1], s$1 = {
							x: 0,
							y: 0,
							w: i$1.data.width + 2,
							h: i$1.data.height + 2
						};
						r$1.push(s$1), e$1[n$1] = new fc$1(s$1, i$1), i$1.hasRenderCallback && this.haveRenderCallbacks.push(n$1);
					}
				}
				patchUpdatedImages(t$1, e$1) {
					t$1.dispatchRenderCallbacks(this.haveRenderCallbacks);
					for (const r$1 in t$1.updatedImages) this.patchUpdatedImage(this.iconPositions[r$1], t$1.getImage(r$1), e$1), this.patchUpdatedImage(this.patternPositions[r$1], t$1.getImage(r$1), e$1);
				}
				patchUpdatedImage(t$1, e$1, r$1) {
					if (!t$1 || !e$1) return;
					if (t$1.version === e$1.version) return;
					t$1.version = e$1.version;
					const [n$1, i$1] = t$1.tl;
					r$1.update(e$1.data, void 0, {
						x: n$1,
						y: i$1
					});
				}
			}
			var yc$1;
			as$1("ImagePosition", fc$1), as$1("ImageAtlas", dc$1), t.ao = void 0, (yc$1 = t.ao || (t.ao = {}))[yc$1.none = 0] = "none", yc$1[yc$1.horizontal = 1] = "horizontal", yc$1[yc$1.vertical = 2] = "vertical", yc$1[yc$1.horizontalOnly = 3] = "horizontalOnly";
			class mc$1 {
				constructor() {
					this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
				}
				static forText(t$1, e$1, r$1) {
					const n$1 = new mc$1();
					return n$1.scale = t$1 || 1, n$1.fontStack = e$1, n$1.verticalAlign = r$1 || "bottom", n$1;
				}
				static forImage(t$1, e$1) {
					const r$1 = new mc$1();
					return r$1.imageName = t$1, r$1.verticalAlign = e$1 || "bottom", r$1;
				}
			}
			class gc$1 {
				constructor() {
					this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
				}
				static fromFeature(t$1, e$1) {
					const r$1 = new gc$1();
					for (let n$1 = 0; n$1 < t$1.sections.length; n$1++) {
						const i$1 = t$1.sections[n$1];
						i$1.image ? r$1.addImageSection(i$1) : r$1.addTextSection(i$1, e$1);
					}
					return r$1;
				}
				length() {
					return this.text.length;
				}
				getSection(t$1) {
					return this.sections[this.sectionIndex[t$1]];
				}
				getSectionIndex(t$1) {
					return this.sectionIndex[t$1];
				}
				getCharCode(t$1) {
					return this.text.charCodeAt(t$1);
				}
				verticalizePunctuation() {
					this.text = function(t$1) {
						let e$1 = "";
						for (let r$1 = 0; r$1 < t$1.length; r$1++) {
							const n$1 = t$1.charCodeAt(r$1 + 1) || null, i$1 = t$1.charCodeAt(r$1 - 1) || null;
							e$1 += n$1 && ws$1(n$1) && !Xu$1[t$1[r$1 + 1]] || i$1 && ws$1(i$1) && !Xu$1[t$1[r$1 - 1]] || !Xu$1[t$1[r$1]] ? t$1[r$1] : Xu$1[t$1[r$1]];
						}
						return e$1;
					}(this.text);
				}
				trim() {
					let t$1 = 0;
					for (let e$2 = 0; e$2 < this.text.length && vc$1[this.text.charCodeAt(e$2)]; e$2++) t$1++;
					let e$1 = this.text.length;
					for (let r$1 = this.text.length - 1; r$1 >= 0 && r$1 >= t$1 && vc$1[this.text.charCodeAt(r$1)]; r$1--) e$1--;
					this.text = this.text.substring(t$1, e$1), this.sectionIndex = this.sectionIndex.slice(t$1, e$1);
				}
				substring(t$1, e$1) {
					const r$1 = new gc$1();
					return r$1.text = this.text.substring(t$1, e$1), r$1.sectionIndex = this.sectionIndex.slice(t$1, e$1), r$1.sections = this.sections, r$1;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((t$1, e$1) => Math.max(t$1, this.sections[e$1].scale)), 0);
				}
				getMaxImageSize(t$1) {
					let e$1 = 0, r$1 = 0;
					for (let n$1 = 0; n$1 < this.length(); n$1++) {
						const i$1 = this.getSection(n$1);
						if (i$1.imageName) {
							const n$2 = t$1[i$1.imageName];
							if (!n$2) continue;
							const s$1 = n$2.displaySize;
							e$1 = Math.max(e$1, s$1[0]), r$1 = Math.max(r$1, s$1[1]);
						}
					}
					return {
						maxImageWidth: e$1,
						maxImageHeight: r$1
					};
				}
				addTextSection(t$1, e$1) {
					this.text += t$1.text, this.sections.push(mc$1.forText(t$1.scale, t$1.fontStack || e$1, t$1.verticalAlign));
					const r$1 = this.sections.length - 1;
					for (let e$2 = 0; e$2 < t$1.text.length; ++e$2) this.sectionIndex.push(r$1);
				}
				addImageSection(t$1) {
					const e$1 = t$1.image ? t$1.image.name : "";
					if (0 === e$1.length) return void q$1("Can't add FormattedSection with an empty image.");
					const r$1 = this.getNextImageSectionCharCode();
					r$1 ? (this.text += String.fromCharCode(r$1), this.sections.push(mc$1.forImage(e$1, t$1.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : q$1("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
			}
			function xc$1(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = gc$1.fromFeature(e$1, s$1);
				let g$2;
				p$1 === t.ao.vertical && m$1.verticalizePunctuation();
				const { processBidirectionalText: x$1, processStyledBidirectionalText: v$1 } = Ms$1;
				if (x$1 && 1 === m$1.sections.length) {
					g$2 = [];
					const t$1 = x$1(m$1.toString(), Ic$1(m$1, c$1, a, r$1, i$1, d$1));
					for (const e$2 of t$1) {
						const t$2 = new gc$1();
						t$2.text = e$2, t$2.sections = m$1.sections;
						for (let r$2 = 0; r$2 < e$2.length; r$2++) t$2.sectionIndex.push(0);
						g$2.push(t$2);
					}
				} else if (v$1) {
					g$2 = [];
					const t$1 = v$1(m$1.text, m$1.sectionIndex, Ic$1(m$1, c$1, a, r$1, i$1, d$1));
					for (const e$2 of t$1) {
						const t$2 = new gc$1();
						t$2.text = e$2[0], t$2.sectionIndex = e$2[1], t$2.sections = m$1.sections, g$2.push(t$2);
					}
				} else g$2 = function(t$1, e$2) {
					const r$2 = [], n$2 = t$1.text;
					let i$2 = 0;
					for (const n$3 of e$2) r$2.push(t$1.substring(i$2, n$3)), i$2 = n$3;
					return i$2 < n$2.length && r$2.push(t$1.substring(i$2, n$2.length)), r$2;
				}(m$1, Ic$1(m$1, c$1, a, r$1, i$1, d$1));
				const b$2 = [], w$1 = {
					positionedLines: b$2,
					text: m$1.toString(),
					top: h$1[1],
					bottom: h$1[1],
					left: h$1[0],
					right: h$1[0],
					writingMode: p$1,
					iconsInText: !1,
					verticalizable: !1
				};
				return function(t$1, e$2, r$2, n$2, i$2, s$2, a$1, o$2, l$2, u$2, c$2, h$2) {
					let p$2 = 0, f$2 = 0, d$2 = 0, y$2 = 0;
					const m$2 = "right" === o$2 ? 1 : "left" === o$2 ? 0 : .5, g$3 = Zu$1 / h$2;
					let x$2 = 0;
					for (const a$2 of i$2) {
						a$2.trim();
						const i$3 = a$2.getMaxScale(), o$3 = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						t$1.positionedLines[x$2] = o$3;
						const h$3 = o$3.positionedGlyphs;
						let v$3 = 0;
						if (!a$2.length()) {
							f$2 += s$2, ++x$2;
							continue;
						}
						const b$4 = Pc$1(n$2, a$2, g$3);
						for (let s$3 = 0; s$3 < a$2.length(); s$3++) {
							const o$4 = a$2.getSection(s$3), d$3 = a$2.getSectionIndex(s$3), y$3 = a$2.getCharCode(s$3), m$3 = Ec$1(l$2, c$2, y$3);
							let x$3;
							if (o$4.imageName) {
								if (t$1.iconsInText = !0, o$4.scale = o$4.scale * g$3, x$3 = Vc$1(o$4, m$3, i$3, b$4, n$2), !x$3) continue;
								v$3 = Math.max(v$3, x$3.imageOffset);
							} else if (x$3 = Bc$1(o$4, y$3, m$3, b$4, e$2, r$2), !x$3) continue;
							const { rect: w$3, metrics: _$2, baselineOffset: S$2 } = x$3;
							h$3.push({
								glyph: y$3,
								imageName: o$4.imageName,
								x: p$2,
								y: f$2 + S$2 + -17,
								vertical: m$3,
								scale: o$4.scale,
								fontStack: o$4.fontStack,
								sectionIndex: d$3,
								metrics: _$2,
								rect: w$3
							}), m$3 ? (t$1.verticalizable = !0, p$2 += (o$4.imageName ? _$2.advance : Zu$1) * o$4.scale + u$2) : p$2 += _$2.advance * o$4.scale + u$2;
						}
						0 !== h$3.length && (d$2 = Math.max(p$2 - u$2, d$2), Tc$1(h$3, 0, h$3.length - 1, m$2)), p$2 = 0, o$3.lineOffset = Math.max(v$3, (i$3 - 1) * Zu$1);
						const w$2 = s$2 * i$3 + v$3;
						f$2 += w$2, y$2 = Math.max(w$2, y$2), ++x$2;
					}
					const { horizontalAlign: v$2, verticalAlign: b$3 } = zc$1(a$1);
					(function(t$2, e$3, r$3, n$3, i$3, s$3, a$2, o$3, l$3) {
						const u$3 = (e$3 - r$3) * i$3;
						let c$3 = 0;
						c$3 = s$3 !== a$2 ? -o$3 * n$3 - -17 : -n$3 * l$3 * a$2 + .5 * a$2;
						for (const e$4 of t$2) for (const t$3 of e$4.positionedGlyphs) t$3.x += u$3, t$3.y += c$3;
					})(t$1.positionedLines, m$2, v$2, b$3, d$2, y$2, s$2, f$2, i$2.length), t$1.top += -b$3 * f$2, t$1.bottom = t$1.top + f$2, t$1.left += -v$2 * d$2, t$1.right = t$1.left + d$2;
				}(w$1, r$1, n$1, i$1, g$2, o$1, l$1, u$1, p$1, c$1, f$1, y$1), !function(t$1) {
					for (const e$2 of t$1) if (0 !== e$2.positionedGlyphs.length) return !1;
					return !0;
				}(b$2) && w$1;
			}
			const vc$1 = {
				9: !0,
				10: !0,
				11: !0,
				12: !0,
				13: !0,
				32: !0
			}, bc$1 = {
				10: !0,
				32: !0,
				38: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			}, wc$1 = { 40: !0 };
			function _c$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (e$1.imageName) {
					const t$2 = n$1[e$1.imageName];
					return t$2 ? t$2.displaySize[0] * e$1.scale * Zu$1 / s$1 + i$1 : 0;
				}
				{
					const n$2 = r$1[e$1.fontStack], s$2 = n$2 && n$2[t$1];
					return s$2 ? s$2.metrics.advance * e$1.scale + i$1 : 0;
				}
			}
			function Sc$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(t$1 - e$1, 2);
				return n$1 ? t$1 < e$1 ? i$1 / 2 : 2 * i$1 : i$1 + Math.abs(r$1) * r$1;
			}
			function Ac$1(t$1, e$1, r$1) {
				let n$1 = 0;
				return 10 === t$1 && (n$1 -= 1e4), r$1 && (n$1 += 150), 40 !== t$1 && 65288 !== t$1 || (n$1 += 50), 41 !== e$1 && 65289 !== e$1 || (n$1 += 50), n$1;
			}
			function kc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a = null, o$1 = Sc$1(e$1, r$1, i$1, s$1);
				for (const t$2 of n$1) {
					const n$2 = Sc$1(e$1 - t$2.x, r$1, i$1, s$1) + t$2.badness;
					n$2 <= o$1 && (a = t$2, o$1 = n$2);
				}
				return {
					index: t$1,
					x: e$1,
					priorBreak: a,
					badness: o$1
				};
			}
			function Mc$1(t$1) {
				return t$1 ? Mc$1(t$1.priorBreak).concat(t$1.index) : [];
			}
			function Ic$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!t$1) return [];
				const a = [], o$1 = function(t$2, e$2, r$2, n$2, i$2, s$2) {
					let a$1 = 0;
					for (let r$3 = 0; r$3 < t$2.length(); r$3++) {
						const o$2 = t$2.getSection(r$3);
						a$1 += _c$1(t$2.getCharCode(r$3), o$2, n$2, i$2, e$2, s$2);
					}
					return a$1 / Math.max(1, Math.ceil(a$1 / r$2));
				}(t$1, e$1, r$1, n$1, i$1, s$1), l$1 = t$1.text.indexOf("") >= 0;
				let u$1 = 0;
				for (let r$2 = 0; r$2 < t$1.length(); r$2++) {
					const h$1 = t$1.getSection(r$2), p$1 = t$1.getCharCode(r$2);
					if (vc$1[p$1] || (u$1 += _c$1(p$1, h$1, n$1, i$1, e$1, s$1)), r$2 < t$1.length() - 1) {
						const e$2 = !((c$1 = p$1) < 11904) && (!!fs$1["CJK Compatibility Forms"](c$1) || !!fs$1["CJK Compatibility"](c$1) || !!fs$1["CJK Strokes"](c$1) || !!fs$1["CJK Symbols and Punctuation"](c$1) || !!fs$1["Enclosed CJK Letters and Months"](c$1) || !!fs$1["Halfwidth and Fullwidth Forms"](c$1) || !!fs$1["Ideographic Description Characters"](c$1) || !!fs$1["Vertical Forms"](c$1) || vs$1.test(String.fromCodePoint(c$1)));
						(bc$1[p$1] || e$2 || h$1.imageName || r$2 !== t$1.length() - 2 && wc$1[t$1.getCharCode(r$2 + 1)]) && a.push(kc$1(r$2 + 1, u$1, o$1, a, Ac$1(p$1, t$1.getCharCode(r$2 + 1), e$2 && l$1), !1));
					}
				}
				var c$1;
				return Mc$1(kc$1(t$1.length(), u$1, o$1, a, 0, !0));
			}
			function zc$1(t$1) {
				let e$1 = .5, r$1 = .5;
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right":
						e$1 = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": e$1 = 0;
				}
				switch (t$1) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						r$1 = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": r$1 = 0;
				}
				return {
					horizontalAlign: e$1,
					verticalAlign: r$1
				};
			}
			function Pc$1(t$1, e$1, r$1) {
				const n$1 = e$1.getMaxScale() * Zu$1, { maxImageWidth: i$1, maxImageHeight: s$1 } = e$1.getMaxImageSize(t$1), a = Math.max(n$1, s$1 * r$1);
				return {
					verticalLineContentWidth: Math.max(n$1, i$1 * r$1),
					horizontalLineContentHeight: a
				};
			}
			function Cc$1(t$1) {
				switch (t$1) {
					case "top": return 0;
					case "center": return .5;
					default: return 1;
				}
			}
			function Ec$1(e$1, r$1, n$1) {
				return !(e$1 === t.ao.horizontal || !r$1 && !bs$1(n$1) || r$1 && (vc$1[n$1] || (i$1 = n$1, /\p{sc=Arab}/u.test(String.fromCodePoint(i$1)))));
				var i$1;
			}
			function Bc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = s$1[t$1.fontStack], o$1 = function(t$2, e$2, r$2, n$2) {
					if (t$2 && t$2.rect) return t$2;
					const i$2 = e$2[r$2.fontStack], s$2 = i$2 && i$2[n$2];
					return s$2 ? {
						rect: null,
						metrics: s$2.metrics
					} : null;
				}(a && a[e$1], i$1, t$1, e$1);
				if (null === o$1) return null;
				let l$1;
				if (r$1) l$1 = n$1.verticalLineContentWidth - t$1.scale * Zu$1;
				else {
					const e$2 = Cc$1(t$1.verticalAlign);
					l$1 = (n$1.horizontalLineContentHeight - t$1.scale * Zu$1) * e$2;
				}
				return {
					rect: o$1.rect,
					metrics: o$1.metrics,
					baselineOffset: l$1
				};
			}
			function Vc$1(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = i$1[t$1.imageName];
				if (!s$1) return null;
				const a = s$1.paddedRect, o$1 = s$1.displaySize, l$1 = {
					width: o$1[0],
					height: o$1[1],
					left: 1,
					top: -3,
					advance: e$1 ? o$1[1] : o$1[0]
				};
				let u$1;
				if (e$1) u$1 = n$1.verticalLineContentWidth - o$1[1] * t$1.scale;
				else {
					const e$2 = Cc$1(t$1.verticalAlign);
					u$1 = (n$1.horizontalLineContentHeight - o$1[1] * t$1.scale) * e$2;
				}
				return {
					rect: a,
					metrics: l$1,
					baselineOffset: u$1,
					imageOffset: (e$1 ? o$1[0] : o$1[1]) * t$1.scale - Zu$1 * r$1
				};
			}
			function Tc$1(t$1, e$1, r$1, n$1) {
				if (0 === n$1) return;
				const i$1 = t$1[r$1], s$1 = (t$1[r$1].x + i$1.metrics.advance * i$1.scale) * n$1;
				for (let n$2 = e$1; n$2 <= r$1; n$2++) t$1[n$2].x -= s$1;
			}
			function Fc$1(t$1, e$1, r$1) {
				const { horizontalAlign: n$1, verticalAlign: i$1 } = zc$1(r$1), s$1 = e$1[0] - t$1.displaySize[0] * n$1, a = e$1[1] - t$1.displaySize[1] * i$1;
				return {
					image: t$1,
					top: a,
					bottom: a + t$1.displaySize[1],
					left: s$1,
					right: s$1 + t$1.displaySize[0]
				};
			}
			function $c$1(t$1) {
				var e$1, r$1;
				let n$1 = t$1.left, i$1 = t$1.top, s$1 = t$1.right - n$1, a = t$1.bottom - i$1;
				const o$1 = null !== (e$1 = t$1.image.textFitWidth) && void 0 !== e$1 ? e$1 : "stretchOrShrink", l$1 = null !== (r$1 = t$1.image.textFitHeight) && void 0 !== r$1 ? r$1 : "stretchOrShrink", u$1 = (t$1.image.content[2] - t$1.image.content[0]) / (t$1.image.content[3] - t$1.image.content[1]);
				if ("proportional" === l$1) {
					if ("stretchOnly" === o$1 && s$1 / a < u$1 || "proportional" === o$1) {
						const t$2 = Math.ceil(a * u$1);
						n$1 *= t$2 / s$1, s$1 = t$2;
					}
				} else if ("proportional" === o$1 && "stretchOnly" === l$1 && 0 !== u$1 && s$1 / a > u$1) {
					const t$2 = Math.ceil(s$1 / u$1);
					i$1 *= t$2 / a, a = t$2;
				}
				return {
					x1: n$1,
					y1: i$1,
					x2: n$1 + s$1,
					y2: i$1 + a
				};
			}
			function Lc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = t$1.image;
				let o$1;
				if (a.content) {
					const t$2 = a.content, e$2 = a.pixelRatio || 1;
					o$1 = [
						t$2[0] / e$2,
						t$2[1] / e$2,
						a.displaySize[0] - t$2[2] / e$2,
						a.displaySize[1] - t$2[3] / e$2
					];
				}
				const l$1 = e$1.left * s$1, u$1 = e$1.right * s$1;
				let c$1, h$1, p$1, f$1;
				"width" === r$1 || "both" === r$1 ? (f$1 = i$1[0] + l$1 - n$1[3], h$1 = i$1[0] + u$1 + n$1[1]) : (f$1 = i$1[0] + (l$1 + u$1 - a.displaySize[0]) / 2, h$1 = f$1 + a.displaySize[0]);
				const d$1 = e$1.top * s$1, y$1 = e$1.bottom * s$1;
				return "height" === r$1 || "both" === r$1 ? (c$1 = i$1[1] + d$1 - n$1[0], p$1 = i$1[1] + y$1 + n$1[2]) : (c$1 = i$1[1] + (d$1 + y$1 - a.displaySize[1]) / 2, p$1 = c$1 + a.displaySize[1]), {
					image: a,
					top: c$1,
					right: h$1,
					bottom: p$1,
					left: f$1,
					collisionPadding: o$1
				};
			}
			const Oc$1 = 128, Dc$1 = 32640;
			function Rc$1(t$1, e$1) {
				const { expression: r$1 } = e$1;
				if ("constant" === r$1.kind) return {
					kind: "constant",
					layoutSize: r$1.evaluate(new Is$1(t$1 + 1))
				};
				if ("source" === r$1.kind) return { kind: "source" };
				{
					const { zoomStops: e$2, interpolationType: n$1 } = r$1;
					let i$1 = 0;
					for (; i$1 < e$2.length && e$2[i$1] <= t$1;) i$1++;
					i$1 = Math.max(0, i$1 - 1);
					let s$1 = i$1;
					for (; s$1 < e$2.length && e$2[s$1] < t$1 + 1;) s$1++;
					s$1 = Math.min(e$2.length - 1, s$1);
					const a = e$2[i$1], o$1 = e$2[s$1];
					return "composite" === r$1.kind ? {
						kind: "composite",
						minZoom: a,
						maxZoom: o$1,
						interpolationType: n$1
					} : {
						kind: "camera",
						minZoom: a,
						maxZoom: o$1,
						minSize: r$1.evaluate(new Is$1(a)),
						maxSize: r$1.evaluate(new Is$1(o$1)),
						interpolationType: n$1
					};
				}
			}
			function Uc$1(t$1, e$1, r$1) {
				let n$1 = "never";
				const i$1 = t$1.get(e$1);
				return i$1 ? n$1 = i$1 : t$1.get(r$1) && (n$1 = "always"), n$1;
			}
			const jc$1 = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function Nc$1(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
				const f$1 = o$1 ? Math.min(Dc$1, Math.round(o$1[0])) : 0, d$1 = o$1 ? Math.min(Dc$1, Math.round(o$1[1])) : 0;
				t$1.emplaceBack(e$1, r$1, Math.round(32 * n$1), Math.round(32 * i$1), s$1, a, (f$1 << 1) + (l$1 ? 1 : 0), d$1, 16 * u$1, 16 * c$1, 256 * h$1, 256 * p$1);
			}
			function qc$1(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1);
			}
			function Gc$1(t$1) {
				for (const e$1 of t$1.sections) if (ks$1(e$1.text)) return !0;
				return !1;
			}
			class Xc$1 {
				constructor(t$1) {
					this.layoutVertexArray = new La$1(), this.indexArray = new ja$1(), this.programConfigurations = t$1, this.segments = new Xa$1(), this.dynamicLayoutVertexArray = new Oa$1(), this.opacityVertexArray = new Da$1(), this.hasVisibleVertices = !1, this.placedSymbolArray = new wa$1();
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
				}
				upload(t$1, e$1, r$1, n$1) {
					this.isEmpty() || (r$1 && (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Ru.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray, e$1), this.dynamicLayoutVertexBuffer = t$1.createVertexBuffer(this.dynamicLayoutVertexArray, Uu$1.members, !0), this.opacityVertexBuffer = t$1.createVertexBuffer(this.opacityVertexArray, jc$1, !0), this.opacityVertexBuffer.itemSize = 1), (r$1 || n$1) && this.programConfigurations.upload(t$1));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
				}
			}
			as$1("SymbolBuffers", Xc$1);
			class Zc$1 {
				constructor(t$1, e$1, r$1) {
					this.layoutVertexArray = new t$1(), this.layoutAttributes = e$1, this.indexArray = new r$1(), this.segments = new Xa$1(), this.collisionVertexArray = new Ua$1();
				}
				upload(t$1) {
					this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t$1.createVertexBuffer(this.collisionVertexArray, ju$1.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
				}
			}
			as$1("CollisionBuffers", Zc$1);
			class Yc {
				constructor(e$1) {
					this.collisionBoxArray = e$1.collisionBoxArray, this.zoom = e$1.zoom, this.globalState = e$1.globalState, this.overscaling = e$1.overscaling, this.layers = e$1.layers, this.layerIds = this.layers.map(((t$1) => t$1.id)), this.index = e$1.index, this.pixelRatio = e$1.pixelRatio, this.sourceLayerIndex = e$1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
					const r$1 = this.layers[0]._unevaluatedLayout._values;
					this.textSizeData = Rc$1(this.zoom, r$1["text-size"]), this.iconSizeData = Rc$1(this.zoom, r$1["icon-size"]);
					const n$1 = this.layers[0].layout, i$1 = n$1.get("symbol-sort-key"), s$1 = n$1.get("symbol-z-order");
					this.canOverlap = "never" !== Uc$1(n$1, "text-overlap", "text-allow-overlap") || "never" !== Uc$1(n$1, "icon-overlap", "icon-allow-overlap") || n$1.get("text-ignore-placement") || n$1.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s$1 && !i$1.isConstant(), this.sortFeaturesByY = ("viewport-y" === s$1 || "auto" === s$1 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n$1.get("symbol-placement") && (this.writingModes = n$1.get("text-writing-mode").map(((e$2) => t.ao[e$2]))), this.stateDependentLayerIds = this.layers.filter(((t$1) => t$1.isStateDependent())).map(((t$1) => t$1.id)), this.sourceID = e$1.sourceID;
				}
				createArrays() {
					this.text = new Xc$1(new bo$1(this.layers, this.zoom, ((t$1) => /^text/.test(t$1)))), this.icon = new Xc$1(new bo$1(this.layers, this.zoom, ((t$1) => /^icon/.test(t$1)))), this.glyphOffsetArray = new Aa$1(), this.lineVertexArray = new ka$1(), this.symbolInstances = new Sa$1(), this.textAnchorOffsets = new Ia$1();
				}
				calculateGlyphDependencies(t$1, e$1, r$1, n$1, i$1) {
					for (let s$1 = 0; s$1 < t$1.length; s$1++) if (e$1[t$1.charCodeAt(s$1)] = !0, (r$1 || n$1) && i$1) {
						const r$2 = Xu$1[t$1.charAt(s$1)];
						r$2 && (e$1[r$2.charCodeAt(0)] = !0);
					}
				}
				populate(e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = i$1.layout, a = s$1.get("text-font"), o$1 = s$1.get("text-field"), l$1 = s$1.get("icon-image"), u$1 = ("constant" !== o$1.value.kind || o$1.value.value instanceof Ce && !o$1.value.value.isEmpty() || o$1.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), c$1 = "constant" !== l$1.value.kind || !!l$1.value.value || Object.keys(l$1.parameters).length > 0, h$1 = s$1.get("symbol-sort-key");
					if (this.features = [], !u$1 && !c$1) return;
					const p$1 = r$1.iconDependencies, f$1 = r$1.glyphDependencies, d$1 = r$1.availableImages, y$1 = new Is$1(this.zoom, { globalState: this.globalState });
					for (const { feature: r$2, id: o$2, index: l$2, sourceLayerIndex: m$1 } of e$1) {
						const e$2 = i$1._featureFilter.needGeometry, g$2 = Mo$1(r$2, e$2);
						if (!i$1._featureFilter.filter(y$1, g$2, n$1)) continue;
						let x$1, v$1;
						if (e$2 || (g$2.geometry = ko$1(r$2)), u$1) {
							const t$1 = i$1.getValueAndResolveTokens("text-field", g$2, n$1, d$1), e$3 = Ce.factory(t$1), r$3 = this.hasRTLText = this.hasRTLText || Gc$1(e$3);
							(!r$3 || "unavailable" === Ms$1.getRTLTextPluginStatus() || r$3 && Ms$1.isParsed()) && (x$1 = Gu$1(e$3, i$1, g$2));
						}
						if (c$1) {
							const t$1 = i$1.getValueAndResolveTokens("icon-image", g$2, n$1, d$1);
							v$1 = t$1 instanceof Le ? t$1 : Le.fromString(t$1);
						}
						if (!x$1 && !v$1) continue;
						const b$2 = this.sortFeaturesByKey ? h$1.evaluate(g$2, {}, n$1) : void 0;
						if (this.features.push({
							id: o$2,
							text: x$1,
							icon: v$1,
							index: l$2,
							sourceLayerIndex: m$1,
							geometry: g$2.geometry,
							properties: r$2.properties,
							type: lu$1.types[r$2.type],
							sortKey: b$2
						}), v$1 && (p$1[v$1.name] = !0), x$1) {
							const e$3 = a.evaluate(g$2, {}, n$1).join(","), r$3 = "viewport" !== s$1.get("text-rotation-alignment") && "point" !== s$1.get("symbol-placement");
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ao.vertical) >= 0;
							for (const t$1 of x$1.sections) if (t$1.image) p$1[t$1.image.name] = !0;
							else {
								const n$2 = ds$1(x$1.toString()), i$2 = t$1.fontStack || e$3, s$2 = f$1[i$2] = f$1[i$2] || {};
								this.calculateGlyphDependencies(t$1.text, s$2, r$3, this.allowVerticalPlacement, n$2);
							}
						}
					}
					"line" === s$1.get("symbol-placement") && (this.features = function(t$1) {
						const e$2 = {}, r$2 = {}, n$2 = [];
						let i$2 = 0;
						function s$2(e$3) {
							n$2.push(t$1[e$3]), i$2++;
						}
						function a$1(t$2, e$3, i$3) {
							const s$3 = r$2[t$2];
							return delete r$2[t$2], r$2[e$3] = s$3, n$2[s$3].geometry[0].pop(), n$2[s$3].geometry[0] = n$2[s$3].geometry[0].concat(i$3[0]), s$3;
						}
						function o$2(t$2, r$3, i$3) {
							const s$3 = e$2[r$3];
							return delete e$2[r$3], e$2[t$2] = s$3, n$2[s$3].geometry[0].shift(), n$2[s$3].geometry[0] = i$3[0].concat(n$2[s$3].geometry[0]), s$3;
						}
						function l$2(t$2, e$3, r$3) {
							const n$3 = r$3 ? e$3[0][e$3[0].length - 1] : e$3[0][0];
							return `${t$2}:${n$3.x}:${n$3.y}`;
						}
						for (let u$2 = 0; u$2 < t$1.length; u$2++) {
							const c$2 = t$1[u$2], h$2 = c$2.geometry, p$2 = c$2.text ? c$2.text.toString() : null;
							if (!p$2) {
								s$2(u$2);
								continue;
							}
							const f$2 = l$2(p$2, h$2), d$2 = l$2(p$2, h$2, !0);
							if (f$2 in r$2 && d$2 in e$2 && r$2[f$2] !== e$2[d$2]) {
								const t$2 = o$2(f$2, d$2, h$2), i$3 = a$1(f$2, d$2, n$2[t$2].geometry);
								delete e$2[f$2], delete r$2[d$2], r$2[l$2(p$2, n$2[i$3].geometry, !0)] = i$3, n$2[t$2].geometry = null;
							} else f$2 in r$2 ? a$1(f$2, d$2, h$2) : d$2 in e$2 ? o$2(f$2, d$2, h$2) : (s$2(u$2), e$2[f$2] = i$2 - 1, r$2[d$2] = i$2 - 1);
						}
						return n$2.filter(((t$2) => t$2.geometry));
					}(this.features)), this.sortFeaturesByKey && this.features.sort(((t$1, e$2) => t$1.sortKey - e$2.sortKey));
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, r$1), this.icon.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, r$1));
				}
				isEmpty() {
					return 0 === this.symbolInstances.length && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(t$1) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t$1), this.iconCollisionBox.upload(t$1)), this.text.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(t$1, e$1) {
					const r$1 = this.lineVertexArray.length;
					if (void 0 !== t$1.segment) {
						let r$2 = t$1.dist(e$1[t$1.segment + 1]), n$1 = t$1.dist(e$1[t$1.segment]);
						const i$1 = {};
						for (let n$2 = t$1.segment + 1; n$2 < e$1.length; n$2++) i$1[n$2] = {
							x: e$1[n$2].x,
							y: e$1[n$2].y,
							tileUnitDistanceFromAnchor: r$2
						}, n$2 < e$1.length - 1 && (r$2 += e$1[n$2 + 1].dist(e$1[n$2]));
						for (let r$3 = t$1.segment || 0; r$3 >= 0; r$3--) i$1[r$3] = {
							x: e$1[r$3].x,
							y: e$1[r$3].y,
							tileUnitDistanceFromAnchor: n$1
						}, r$3 > 0 && (n$1 += e$1[r$3 - 1].dist(e$1[r$3]));
						for (let t$2 = 0; t$2 < e$1.length; t$2++) {
							const e$2 = i$1[t$2];
							this.lineVertexArray.emplaceBack(e$2.x, e$2.y, e$2.tileUnitDistanceFromAnchor);
						}
					}
					return {
						lineStartIndex: r$1,
						lineLength: this.lineVertexArray.length - r$1
					};
				}
				addSymbols(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = e$1.indexArray, d$1 = e$1.layoutVertexArray, y$1 = e$1.segments.prepareSegment(4 * r$1.length, d$1, f$1, this.canOverlap ? a.sortKey : void 0), m$1 = this.glyphOffsetArray.length, g$2 = y$1.vertexLength, x$1 = this.allowVerticalPlacement && o$1 === t.ao.vertical ? Math.PI / 2 : 0, v$1 = a.text && a.text.sections;
					for (let t$1 = 0; t$1 < r$1.length; t$1++) {
						const { tl: i$2, tr: s$2, bl: o$2, br: u$2, tex: c$2, pixelOffsetTL: h$2, pixelOffsetBR: m$2, minFontScaleX: g$3, minFontScaleY: b$2, glyphOffset: w$1, isSDF: _$2, sectionIndex: S$2 } = r$1[t$1], A$1 = y$1.vertexLength, k$2 = w$1[1];
						Nc$1(d$1, l$1.x, l$1.y, i$2.x, k$2 + i$2.y, c$2.x, c$2.y, n$1, _$2, h$2.x, h$2.y, g$3, b$2), Nc$1(d$1, l$1.x, l$1.y, s$2.x, k$2 + s$2.y, c$2.x + c$2.w, c$2.y, n$1, _$2, m$2.x, h$2.y, g$3, b$2), Nc$1(d$1, l$1.x, l$1.y, o$2.x, k$2 + o$2.y, c$2.x, c$2.y + c$2.h, n$1, _$2, h$2.x, m$2.y, g$3, b$2), Nc$1(d$1, l$1.x, l$1.y, u$2.x, k$2 + u$2.y, c$2.x + c$2.w, c$2.y + c$2.h, n$1, _$2, m$2.x, m$2.y, g$3, b$2), qc$1(e$1.dynamicLayoutVertexArray, l$1, x$1), f$1.emplaceBack(A$1, A$1 + 2, A$1 + 1), f$1.emplaceBack(A$1 + 1, A$1 + 2, A$1 + 3), y$1.vertexLength += 4, y$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w$1[0]), t$1 !== r$1.length - 1 && S$2 === r$1[t$1 + 1].sectionIndex || e$1.programConfigurations.populatePaintArrays(d$1.length, a, a.index, {}, p$1, v$1 && v$1[S$2]);
					}
					e$1.placedSymbolArray.emplaceBack(l$1.x, l$1.y, m$1, this.glyphOffsetArray.length - m$1, g$2, u$1, c$1, l$1.segment, n$1 ? n$1[0] : 0, n$1 ? n$1[1] : 0, i$1[0], i$1[1], o$1, 0, !1, 0, h$1);
				}
				_addCollisionDebugVertex(t$1, e$1, r$1, n$1, i$1, s$1) {
					return e$1.emplaceBack(0, 0), t$1.emplaceBack(r$1.x, r$1.y, n$1, i$1, Math.round(s$1.x), Math.round(s$1.y));
				}
				addCollisionDebugVertices(t$1, e$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = s$1.segments.prepareSegment(4, s$1.layoutVertexArray, s$1.indexArray), u$1 = l$1.vertexLength, c$1 = s$1.layoutVertexArray, h$1 = s$1.collisionVertexArray, p$1 = o$1.anchorX, f$1 = o$1.anchorY;
					this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(t$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(n$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(n$1, i$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(t$1, i$1)), l$1.vertexLength += 4;
					const d$1 = s$1.indexArray;
					d$1.emplaceBack(u$1, u$1 + 1), d$1.emplaceBack(u$1 + 1, u$1 + 2), d$1.emplaceBack(u$1 + 2, u$1 + 3), d$1.emplaceBack(u$1 + 3, u$1), l$1.primitiveLength += 4;
				}
				addDebugCollisionBoxes(t$1, e$1, r$1, n$1) {
					for (let i$1 = t$1; i$1 < e$1; i$1++) {
						const t$2 = this.collisionBoxArray.get(i$1);
						this.addCollisionDebugVertices(t$2.x1, t$2.y1, t$2.x2, t$2.y2, n$1 ? this.textCollisionBox : this.iconCollisionBox, t$2.anchorPoint, r$1);
					}
				}
				generateCollisionDebugBuffers() {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Zc$1(Ra$1, Nu$1.members, Na$1), this.iconCollisionBox = new Zc$1(Ra$1, Nu$1.members, Na$1);
					for (let t$1 = 0; t$1 < this.symbolInstances.length; t$1++) {
						const e$1 = this.symbolInstances.get(t$1);
						this.addDebugCollisionBoxes(e$1.textBoxStartIndex, e$1.textBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.verticalTextBoxStartIndex, e$1.verticalTextBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.iconBoxStartIndex, e$1.iconBoxEndIndex, e$1, !1), this.addDebugCollisionBoxes(e$1.verticalIconBoxStartIndex, e$1.verticalIconBoxEndIndex, e$1, !1);
					}
				}
				_deserializeCollisionBoxesForSymbol(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
					const u$1 = {};
					for (let n$2 = e$1; n$2 < r$1; n$2++) {
						const e$2 = t$1.get(n$2);
						u$1.textBox = {
							x1: e$2.x1,
							y1: e$2.y1,
							x2: e$2.x2,
							y2: e$2.y2,
							anchorPointX: e$2.anchorPointX,
							anchorPointY: e$2.anchorPointY
						}, u$1.textFeatureIndex = e$2.featureIndex;
						break;
					}
					for (let e$2 = n$1; e$2 < i$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalTextBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalTextFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = s$1; e$2 < a; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.iconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.iconFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = o$1; e$2 < l$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalIconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalIconFeatureIndex = r$2.featureIndex;
						break;
					}
					return u$1;
				}
				deserializeCollisionBoxes(t$1) {
					this.collisionArrays = [];
					for (let e$1 = 0; e$1 < this.symbolInstances.length; e$1++) {
						const r$1 = this.symbolInstances.get(e$1);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t$1, r$1.textBoxStartIndex, r$1.textBoxEndIndex, r$1.verticalTextBoxStartIndex, r$1.verticalTextBoxEndIndex, r$1.iconBoxStartIndex, r$1.iconBoxEndIndex, r$1.verticalIconBoxStartIndex, r$1.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				addIndicesForPlacedSymbol(t$1, e$1) {
					const r$1 = t$1.placedSymbolArray.get(e$1), n$1 = r$1.vertexStartIndex + 4 * r$1.numGlyphs;
					for (let e$2 = r$1.vertexStartIndex; e$2 < n$1; e$2 += 4) t$1.indexArray.emplaceBack(e$2, e$2 + 2, e$2 + 1), t$1.indexArray.emplaceBack(e$2 + 1, e$2 + 2, e$2 + 3);
				}
				getSortedSymbolIndexes(t$1) {
					if (this.sortedAngle === t$1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
					const e$1 = Math.sin(t$1), r$1 = Math.cos(t$1), n$1 = [], i$1 = [], s$1 = [];
					for (let t$2 = 0; t$2 < this.symbolInstances.length; ++t$2) {
						s$1.push(t$2);
						const a = this.symbolInstances.get(t$2);
						n$1.push(0 | Math.round(e$1 * a.anchorX + r$1 * a.anchorY)), i$1.push(a.featureIndex);
					}
					return s$1.sort(((t$2, e$2) => n$1[t$2] - n$1[e$2] || i$1[e$2] - i$1[t$2])), s$1;
				}
				addToSortKeyRanges(t$1, e$1) {
					const r$1 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					r$1 && r$1.sortKey === e$1 ? r$1.symbolInstanceEnd = t$1 + 1 : this.sortKeyRanges.push({
						sortKey: e$1,
						symbolInstanceStart: t$1,
						symbolInstanceEnd: t$1 + 1
					});
				}
				sortFeatures(t$1) {
					if (this.sortFeaturesByY && this.sortedAngle !== t$1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t$1), this.sortedAngle = t$1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (const t$2 of this.symbolInstanceIndexes) {
							const e$1 = this.symbolInstances.get(t$2);
							this.featureSortOrder.push(e$1.featureIndex), [
								e$1.rightJustifiedTextSymbolIndex,
								e$1.centerJustifiedTextSymbolIndex,
								e$1.leftJustifiedTextSymbolIndex
							].forEach(((t$3, e$2, r$1) => {
								t$3 >= 0 && r$1.indexOf(t$3) === e$2 && this.addIndicesForPlacedSymbol(this.text, t$3);
							})), e$1.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e$1.verticalPlacedTextSymbolIndex), e$1.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.placedIconSymbolIndex), e$1.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.verticalPlacedIconSymbolIndex);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
			}
			let Hc$1, Kc$1;
			as$1("SymbolBucket", Yc, { omit: [
				"layers",
				"collisionBoxArray",
				"features",
				"compareText"
			] }), Yc.MAX_GLYPHS = 65535, Yc.addDynamicAttributes = qc$1;
			var Jc = {
				get paint() {
					return Kc$1 = Kc$1 || new Us$1({
						"icon-opacity": new Ls$1(xt$1.paint_symbol["icon-opacity"]),
						"icon-color": new Ls$1(xt$1.paint_symbol["icon-color"]),
						"icon-halo-color": new Ls$1(xt$1.paint_symbol["icon-halo-color"]),
						"icon-halo-width": new Ls$1(xt$1.paint_symbol["icon-halo-width"]),
						"icon-halo-blur": new Ls$1(xt$1.paint_symbol["icon-halo-blur"]),
						"icon-translate": new $s$1(xt$1.paint_symbol["icon-translate"]),
						"icon-translate-anchor": new $s$1(xt$1.paint_symbol["icon-translate-anchor"]),
						"text-opacity": new Ls$1(xt$1.paint_symbol["text-opacity"]),
						"text-color": new Ls$1(xt$1.paint_symbol["text-color"], {
							runtimeType: Ot,
							getOverride: (t$1) => t$1.textColor,
							hasOverride: (t$1) => !!t$1.textColor
						}),
						"text-halo-color": new Ls$1(xt$1.paint_symbol["text-halo-color"]),
						"text-halo-width": new Ls$1(xt$1.paint_symbol["text-halo-width"]),
						"text-halo-blur": new Ls$1(xt$1.paint_symbol["text-halo-blur"]),
						"text-translate": new $s$1(xt$1.paint_symbol["text-translate"]),
						"text-translate-anchor": new $s$1(xt$1.paint_symbol["text-translate-anchor"])
					});
				},
				get layout() {
					return Hc$1 = Hc$1 || new Us$1({
						"symbol-placement": new $s$1(xt$1.layout_symbol["symbol-placement"]),
						"symbol-spacing": new $s$1(xt$1.layout_symbol["symbol-spacing"]),
						"symbol-avoid-edges": new $s$1(xt$1.layout_symbol["symbol-avoid-edges"]),
						"symbol-sort-key": new Ls$1(xt$1.layout_symbol["symbol-sort-key"]),
						"symbol-z-order": new $s$1(xt$1.layout_symbol["symbol-z-order"]),
						"icon-allow-overlap": new $s$1(xt$1.layout_symbol["icon-allow-overlap"]),
						"icon-overlap": new $s$1(xt$1.layout_symbol["icon-overlap"]),
						"icon-ignore-placement": new $s$1(xt$1.layout_symbol["icon-ignore-placement"]),
						"icon-optional": new $s$1(xt$1.layout_symbol["icon-optional"]),
						"icon-rotation-alignment": new $s$1(xt$1.layout_symbol["icon-rotation-alignment"]),
						"icon-size": new Ls$1(xt$1.layout_symbol["icon-size"]),
						"icon-text-fit": new $s$1(xt$1.layout_symbol["icon-text-fit"]),
						"icon-text-fit-padding": new $s$1(xt$1.layout_symbol["icon-text-fit-padding"]),
						"icon-image": new Ls$1(xt$1.layout_symbol["icon-image"]),
						"icon-rotate": new Ls$1(xt$1.layout_symbol["icon-rotate"]),
						"icon-padding": new Ls$1(xt$1.layout_symbol["icon-padding"]),
						"icon-keep-upright": new $s$1(xt$1.layout_symbol["icon-keep-upright"]),
						"icon-offset": new Ls$1(xt$1.layout_symbol["icon-offset"]),
						"icon-anchor": new Ls$1(xt$1.layout_symbol["icon-anchor"]),
						"icon-pitch-alignment": new $s$1(xt$1.layout_symbol["icon-pitch-alignment"]),
						"text-pitch-alignment": new $s$1(xt$1.layout_symbol["text-pitch-alignment"]),
						"text-rotation-alignment": new $s$1(xt$1.layout_symbol["text-rotation-alignment"]),
						"text-field": new Ls$1(xt$1.layout_symbol["text-field"]),
						"text-font": new Ls$1(xt$1.layout_symbol["text-font"]),
						"text-size": new Ls$1(xt$1.layout_symbol["text-size"]),
						"text-max-width": new Ls$1(xt$1.layout_symbol["text-max-width"]),
						"text-line-height": new $s$1(xt$1.layout_symbol["text-line-height"]),
						"text-letter-spacing": new Ls$1(xt$1.layout_symbol["text-letter-spacing"]),
						"text-justify": new Ls$1(xt$1.layout_symbol["text-justify"]),
						"text-radial-offset": new Ls$1(xt$1.layout_symbol["text-radial-offset"]),
						"text-variable-anchor": new $s$1(xt$1.layout_symbol["text-variable-anchor"]),
						"text-variable-anchor-offset": new Ls$1(xt$1.layout_symbol["text-variable-anchor-offset"]),
						"text-anchor": new Ls$1(xt$1.layout_symbol["text-anchor"]),
						"text-max-angle": new $s$1(xt$1.layout_symbol["text-max-angle"]),
						"text-writing-mode": new $s$1(xt$1.layout_symbol["text-writing-mode"]),
						"text-rotate": new Ls$1(xt$1.layout_symbol["text-rotate"]),
						"text-padding": new $s$1(xt$1.layout_symbol["text-padding"]),
						"text-keep-upright": new $s$1(xt$1.layout_symbol["text-keep-upright"]),
						"text-transform": new Ls$1(xt$1.layout_symbol["text-transform"]),
						"text-offset": new Ls$1(xt$1.layout_symbol["text-offset"]),
						"text-allow-overlap": new $s$1(xt$1.layout_symbol["text-allow-overlap"]),
						"text-overlap": new $s$1(xt$1.layout_symbol["text-overlap"]),
						"text-ignore-placement": new $s$1(xt$1.layout_symbol["text-ignore-placement"]),
						"text-optional": new $s$1(xt$1.layout_symbol["text-optional"])
					});
				}
			};
			class Wc {
				constructor(t$1) {
					if (void 0 === t$1.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
					this.type = t$1.property.overrides ? t$1.property.overrides.runtimeType : Tt$1, this.defaultValue = t$1;
				}
				evaluate(t$1) {
					if (t$1.formattedSection) {
						const e$1 = this.defaultValue.property.overrides;
						if (e$1 && e$1.hasOverride(t$1.formattedSection)) return e$1.getOverride(t$1.formattedSection);
					}
					return t$1.feature && t$1.featureState ? this.defaultValue.evaluate(t$1.feature, t$1.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(t$1) {
					this.defaultValue.isConstant() || t$1(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			as$1("FormatSectionOverride", Wc, { omit: ["defaultValue"] });
			class Qc extends Ns$1 {
				constructor(t$1) {
					super(t$1, Jc);
				}
				recalculate(t$1, e$1) {
					if (super.recalculate(t$1, e$1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
						const t$2 = this.layout.get("text-writing-mode");
						if (t$2) {
							const e$2 = [];
							for (const r$1 of t$2) e$2.indexOf(r$1) < 0 && e$2.push(r$1);
							this.layout._values["text-writing-mode"] = e$2;
						} else this.layout._values["text-writing-mode"] = ["horizontal"];
					}
					this._setPaintOverrides();
				}
				getValueAndResolveTokens(t$1, e$1, r$1, n$1) {
					const i$1 = this.layout.get(t$1).evaluate(e$1, {}, r$1, n$1), s$1 = this._unevaluatedLayout._values[t$1];
					return s$1.isDataDriven() || ei$1(s$1.value) || !i$1 ? i$1 : function(t$2, e$2) {
						return e$2.replace(/{([^{}]+)}/g, ((e$3, r$2) => t$2 && r$2 in t$2 ? String(t$2[r$2]) : ""));
					}(e$1.properties, i$1);
				}
				createBucket(t$1) {
					return new Yc(t$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					throw new Error("Should take a different path in FeatureIndex");
				}
				_setPaintOverrides() {
					for (const t$1 of Jc.paint.overridableProperties) {
						if (!Qc.hasPaintOverride(this.layout, t$1)) continue;
						const e$1 = this.paint.get(t$1), n$1 = new ti$1(new Wc(e$1), e$1.property.specification);
						let i$1 = null;
						i$1 = "constant" === e$1.value.kind || "source" === e$1.value.kind ? new ni$1("source", n$1) : new ii$1("composite", n$1, e$1.value.zoomStops), this.paint._values[t$1] = new Ts$1(e$1.property, i$1, e$1.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven()) && Qc.hasPaintOverride(this.layout, t$1);
				}
				static hasPaintOverride(t$1, e$1) {
					const r$1 = t$1.get("text-field"), n$1 = Jc.paint.properties[e$1];
					let i$1 = !1;
					const s$1 = (t$2) => {
						for (const e$2 of t$2) if (n$1.overrides && n$1.overrides.hasOverride(e$2)) return void (i$1 = !0);
					};
					if ("constant" === r$1.value.kind && r$1.value.value instanceof Ce) s$1(r$1.value.value.sections);
					else if ("source" === r$1.value.kind) {
						const t$2 = (e$3) => {
							i$1 || (e$3 instanceof Ne$1 && Ue$1(e$3.value) === Nt ? s$1(e$3.value.sections) : e$3 instanceof Ir$1 ? s$1(e$3.sections) : e$3.eachChild(t$2));
						}, e$2 = r$1.value;
						e$2._styleExpression && t$2(e$2._styleExpression.expression);
					}
					return i$1;
				}
			}
			let th;
			var eh = { get paint() {
				return th = th || new Us$1({
					"background-color": new $s$1(xt$1.paint_background["background-color"]),
					"background-pattern": new Ds$1(xt$1.paint_background["background-pattern"]),
					"background-opacity": new $s$1(xt$1.paint_background["background-opacity"])
				});
			} };
			class rh extends Ns$1 {
				constructor(t$1) {
					super(t$1, eh);
				}
			}
			let nh;
			var ih = { get paint() {
				return nh = nh || new Us$1({
					"raster-opacity": new $s$1(xt$1.paint_raster["raster-opacity"]),
					"raster-hue-rotate": new $s$1(xt$1.paint_raster["raster-hue-rotate"]),
					"raster-brightness-min": new $s$1(xt$1.paint_raster["raster-brightness-min"]),
					"raster-brightness-max": new $s$1(xt$1.paint_raster["raster-brightness-max"]),
					"raster-saturation": new $s$1(xt$1.paint_raster["raster-saturation"]),
					"raster-contrast": new $s$1(xt$1.paint_raster["raster-contrast"]),
					"raster-resampling": new $s$1(xt$1.paint_raster["raster-resampling"]),
					"raster-fade-duration": new $s$1(xt$1.paint_raster["raster-fade-duration"])
				});
			} };
			class sh extends Ns$1 {
				constructor(t$1) {
					super(t$1, ih);
				}
			}
			class ah extends Ns$1 {
				constructor(t$1) {
					super(t$1, {}), this.onAdd = (t$2) => {
						this.implementation.onAdd && this.implementation.onAdd(t$2, t$2.painter.context.gl);
					}, this.onRemove = (t$2) => {
						this.implementation.onRemove && this.implementation.onRemove(t$2, t$2.painter.context.gl);
					}, this.implementation = t$1;
				}
				is3D() {
					return "3d" === this.implementation.renderingMode;
				}
				hasOffscreenPass() {
					return void 0 !== this.implementation.prerender;
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {
					throw new Error("Custom layers cannot be serialized");
				}
			}
			class oh {
				constructor(t$1) {
					this._methodToThrottle = t$1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._methodToThrottle();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._methodToThrottle();
					}), 0));
				}
				remove() {
					delete this._channel, this._methodToThrottle = () => {};
				}
			}
			const lh = { once: !0 }, uh = 6371008.8;
			class ch {
				constructor(t$1, e$1) {
					if (isNaN(t$1) || isNaN(e$1)) throw new Error(`Invalid LngLat object: (${t$1}, ${e$1})`);
					if (this.lng = +t$1, this.lat = +e$1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new ch(L$1(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(t$1) {
					const e$1 = Math.PI / 180, r$1 = this.lat * e$1, n$1 = t$1.lat * e$1, i$1 = Math.sin(r$1) * Math.sin(n$1) + Math.cos(r$1) * Math.cos(n$1) * Math.cos((t$1.lng - this.lng) * e$1);
					return uh * Math.acos(Math.min(i$1, 1));
				}
				static convert(t$1) {
					if (t$1 instanceof ch) return t$1;
					if (Array.isArray(t$1) && (2 === t$1.length || 3 === t$1.length)) return new ch(Number(t$1[0]), Number(t$1[1]));
					if (!Array.isArray(t$1) && "object" == typeof t$1 && null !== t$1) return new ch(Number("lng" in t$1 ? t$1.lng : t$1.lon), Number(t$1.lat));
					throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			const hh = 2 * Math.PI * uh;
			function ph(t$1) {
				return hh * Math.cos(t$1 * Math.PI / 180);
			}
			function fh(t$1) {
				return (180 + t$1) / 360;
			}
			function dh(t$1) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1 * Math.PI / 360))) / 360;
			}
			function yh(t$1, e$1) {
				return t$1 / ph(e$1);
			}
			function mh(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function gh(t$1, e$1) {
				return t$1 * ph(mh(e$1));
			}
			class xh {
				constructor(t$1, e$1, r$1 = 0) {
					this.x = +t$1, this.y = +e$1, this.z = +r$1;
				}
				static fromLngLat(t$1, e$1 = 0) {
					const r$1 = ch.convert(t$1);
					return new xh(fh(r$1.lng), dh(r$1.lat), yh(e$1, r$1.lat));
				}
				toLngLat() {
					return new ch(360 * this.x - 180, mh(this.y));
				}
				toAltitude() {
					return gh(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / hh * (t$1 = mh(this.y), 1 / Math.cos(t$1 * Math.PI / 180));
					var t$1;
				}
			}
			function vh(t$1, e$1, r$1) {
				var n$1 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r$1);
				return [t$1 * n$1 - 2 * Math.PI * 6378137 / 2, e$1 * n$1 - 2 * Math.PI * 6378137 / 2];
			}
			class bh {
				constructor(t$1, e$1, r$1) {
					if (!function(t$2, e$2, r$2) {
						return !(t$2 < 0 || t$2 > 25 || r$2 < 0 || r$2 >= Math.pow(2, t$2) || e$2 < 0 || e$2 >= Math.pow(2, t$2));
					}(t$1, e$1, r$1)) throw new Error(`x=${e$1}, y=${r$1}, z=${t$1} outside of bounds. 0<=x<${Math.pow(2, t$1)}, 0<=y<${Math.pow(2, t$1)} 0<=z<=25 `);
					this.z = t$1, this.x = e$1, this.y = r$1, this.key = Sh(0, t$1, t$1, e$1, r$1);
				}
				equals(t$1) {
					return this.z === t$1.z && this.x === t$1.x && this.y === t$1.y;
				}
				url(t$1, e$1, r$1) {
					const n$1 = (s$1 = this.y, a = this.z, o$1 = vh(256 * (i$1 = this.x), 256 * (s$1 = Math.pow(2, a) - s$1 - 1), a), l$1 = vh(256 * (i$1 + 1), 256 * (s$1 + 1), a), o$1[0] + "," + o$1[1] + "," + l$1[0] + "," + l$1[1]);
					var i$1, s$1, a, o$1, l$1;
					const u$1 = function(t$2, e$2, r$2) {
						let n$2, i$2 = "";
						for (let s$2 = t$2; s$2 > 0; s$2--) n$2 = 1 << s$2 - 1, i$2 += (e$2 & n$2 ? 1 : 0) + (r$2 & n$2 ? 2 : 0);
						return i$2;
					}(this.z, this.x, this.y);
					return t$1[(this.x + this.y) % t$1.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r$1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e$1 > 1 ? "@2x" : "").replace(/{quadkey}/g, u$1).replace(/{bbox-epsg-3857}/g, n$1);
				}
				isChildOf(t$1) {
					const e$1 = this.z - t$1.z;
					return e$1 > 0 && t$1.x === this.x >> e$1 && t$1.y === this.y >> e$1;
				}
				getTilePoint(t$1) {
					const e$1 = Math.pow(2, this.z);
					return new r((t$1.x * e$1 - this.x) * P$1, (t$1.y * e$1 - this.y) * P$1);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class wh {
				constructor(t$1, e$1) {
					this.wrap = t$1, this.canonical = e$1, this.key = Sh(t$1, e$1.z, e$1.z, e$1.x, e$1.y);
				}
			}
			class _h {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					if (this.terrainRttPosMatrix32f = null, t$1 < r$1) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t$1}; z = ${r$1}`);
					this.overscaledZ = t$1, this.wrap = e$1, this.canonical = new bh(r$1, +n$1, +i$1), this.key = Sh(e$1, t$1, r$1, n$1, i$1);
				}
				clone() {
					return new _h(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				equals(t$1) {
					return this.overscaledZ === t$1.overscaledZ && this.wrap === t$1.wrap && this.canonical.equals(t$1.canonical);
				}
				scaledTo(t$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const e$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? new _h(t$1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new _h(t$1, this.wrap, t$1, this.canonical.x >> e$1, this.canonical.y >> e$1);
				}
				calculateScaledKey(t$1, e$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const r$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? Sh(this.wrap * +e$1, t$1, this.canonical.z, this.canonical.x, this.canonical.y) : Sh(this.wrap * +e$1, t$1, t$1, this.canonical.x >> r$1, this.canonical.y >> r$1);
				}
				isChildOf(t$1) {
					if (t$1.wrap !== this.wrap) return !1;
					const e$1 = this.canonical.z - t$1.canonical.z;
					return 0 === t$1.overscaledZ || t$1.overscaledZ < this.overscaledZ && t$1.canonical.x === this.canonical.x >> e$1 && t$1.canonical.y === this.canonical.y >> e$1;
				}
				children(t$1) {
					if (this.overscaledZ >= t$1) return [new _h(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					const e$1 = this.canonical.z + 1, r$1 = 2 * this.canonical.x, n$1 = 2 * this.canonical.y;
					return [
						new _h(e$1, this.wrap, e$1, r$1, n$1),
						new _h(e$1, this.wrap, e$1, r$1 + 1, n$1),
						new _h(e$1, this.wrap, e$1, r$1, n$1 + 1),
						new _h(e$1, this.wrap, e$1, r$1 + 1, n$1 + 1)
					];
				}
				isLessThan(t$1) {
					return this.wrap < t$1.wrap || !(this.wrap > t$1.wrap) && (this.overscaledZ < t$1.overscaledZ || !(this.overscaledZ > t$1.overscaledZ) && (this.canonical.x < t$1.canonical.x || !(this.canonical.x > t$1.canonical.x) && this.canonical.y < t$1.canonical.y));
				}
				wrapped() {
					return new _h(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(t$1) {
					return new _h(this.overscaledZ, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return Math.pow(2, this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new wh(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
				getTilePoint(t$1) {
					return this.canonical.getTilePoint(new xh(t$1.x - this.wrap, t$1.y));
				}
			}
			function Sh(t$1, e$1, r$1, n$1, i$1) {
				(t$1 *= 2) < 0 && (t$1 = -1 * t$1 - 1);
				const s$1 = 1 << r$1;
				return (s$1 * s$1 * t$1 + s$1 * i$1 + n$1).toString(36) + r$1.toString(36) + e$1.toString(36);
			}
			function Ah(t$1, e$1) {
				return e$1 ? t$1.properties[e$1] : t$1.id;
			}
			as$1("CanonicalTileID", bh), as$1("OverscaledTileID", _h, { omit: ["terrainRttPosMatrix32f"] });
			class kh {
				constructor() {
					this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity;
				}
				extend(t$1) {
					return this.minX = Math.min(this.minX, t$1.x), this.minY = Math.min(this.minY, t$1.y), this.maxX = Math.max(this.maxX, t$1.x), this.maxY = Math.max(this.maxY, t$1.y), this;
				}
				expandBy(t$1) {
					return this.minX -= t$1, this.minY -= t$1, this.maxX += t$1, this.maxY += t$1, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity), this;
				}
				shrinkBy(t$1) {
					return this.expandBy(-t$1);
				}
				map(t$1) {
					const e$1 = new kh();
					return e$1.extend(t$1(new r(this.minX, this.minY))), e$1.extend(t$1(new r(this.maxX, this.minY))), e$1.extend(t$1(new r(this.minX, this.maxY))), e$1.extend(t$1(new r(this.maxX, this.maxY))), e$1;
				}
				static fromPoints(t$1) {
					const e$1 = new kh();
					for (const r$1 of t$1) e$1.extend(r$1);
					return e$1;
				}
				contains(t$1) {
					return t$1.x >= this.minX && t$1.x <= this.maxX && t$1.y >= this.minY && t$1.y <= this.maxY;
				}
				empty() {
					return this.minX > this.maxX;
				}
				width() {
					return this.maxX - this.minX;
				}
				height() {
					return this.maxY - this.minY;
				}
				covers(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX >= this.minX && t$1.maxX <= this.maxX && t$1.minY >= this.minY && t$1.maxY <= this.maxY;
				}
				intersects(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX <= this.maxX && t$1.maxX >= this.minX && t$1.minY <= this.maxY && t$1.maxY >= this.minY;
				}
			}
			class Mh {
				constructor(t$1) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$1 = t$1[e$1];
						this._stringToNumber[r$1] = e$1, this._numberToString[e$1] = r$1;
					}
				}
				encode(t$1) {
					return this._stringToNumber[t$1];
				}
				decode(t$1) {
					if (t$1 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t$1} can't be >= this._numberToString.length ${this._numberToString.length}`);
					return this._numberToString[t$1];
				}
			}
			class Ih {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = "Feature", this._vectorTileFeature = t$1, t$1._z = e$1, t$1._x = r$1, t$1._y = n$1, this.properties = t$1.properties, this.id = i$1;
				}
				get geometry() {
					return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
				}
				set geometry(t$1) {
					this._geometry = t$1;
				}
				toJSON() {
					const t$1 = { geometry: this.geometry };
					for (const e$1 in this) "_geometry" !== e$1 && "_vectorTileFeature" !== e$1 && (t$1[e$1] = this[e$1]);
					return t$1;
				}
			}
			class zh {
				constructor(t$1, e$1) {
					this.tileID = t$1, this.x = t$1.canonical.x, this.y = t$1.canonical.y, this.z = t$1.canonical.z, this.grid = new is$1(P$1, 16, 0), this.grid3D = new is$1(P$1, 16, 0), this.featureIndexArray = new Pa$1(), this.promoteId = e$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(r$1, n$1, i$1);
					const o$1 = s$1 ? this.grid3D : this.grid;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const r$2 = e$1[t$2], n$2 = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let t$3 = 0; t$3 < r$2.length; t$3++) {
							const e$2 = r$2[t$3];
							n$2[0] = Math.min(n$2[0], e$2.x), n$2[1] = Math.min(n$2[1], e$2.y), n$2[2] = Math.max(n$2[2], e$2.x), n$2[3] = Math.max(n$2[3], e$2.y);
						}
						n$2[0] < P$1 && n$2[1] < P$1 && n$2[2] >= 0 && n$2[3] >= 0 && o$1.insert(a, n$2[0], n$2[1], n$2[2], n$2[3]);
					}
				}
				loadVTLayers() {
					return this.vtLayers || (this.vtLayers = new fu$1(new Ju$1(this.rawTileData)).layers, this.sourceLayerCoder = new Mh(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
				}
				query(t$1, e$1, n$1, i$1) {
					this.loadVTLayers();
					const s$1 = t$1.params, a = P$1 / t$1.tileSize / t$1.scale, o$1 = hi$1(s$1.filter), l$1 = t$1.queryGeometry, u$1 = t$1.queryPadding * a, c$1 = kh.fromPoints(l$1), h$1 = this.grid.query(c$1.minX - u$1, c$1.minY - u$1, c$1.maxX + u$1, c$1.maxY + u$1), p$1 = kh.fromPoints(t$1.cameraQueryGeometry).expandBy(u$1), f$1 = this.grid3D.query(p$1.minX, p$1.minY, p$1.maxX, p$1.maxY, ((e$2, n$2, i$2, s$2) => function(t$2, e$3, n$3, i$3, s$3) {
						for (const r$1 of t$2) if (e$3 <= r$1.x && n$3 <= r$1.y && i$3 >= r$1.x && s$3 >= r$1.y) return !0;
						const a$1 = [
							new r(e$3, n$3),
							new r(e$3, s$3),
							new r(i$3, s$3),
							new r(i$3, n$3)
						];
						if (t$2.length > 2) {
							for (const e$4 of a$1) if (Do$1(t$2, e$4)) return !0;
						}
						for (let e$4 = 0; e$4 < t$2.length - 1; e$4++) if (Ro$1(t$2[e$4], t$2[e$4 + 1], a$1)) return !0;
						return !1;
					}(t$1.cameraQueryGeometry, e$2 - u$1, n$2 - u$1, i$2 + u$1, s$2 + u$1)));
					for (const t$2 of f$1) h$1.push(t$2);
					h$1.sort(Ch);
					const d$1 = {};
					let y$1;
					for (let r$1 = 0; r$1 < h$1.length; r$1++) {
						const u$2 = h$1[r$1];
						if (u$2 === y$1) continue;
						y$1 = u$2;
						const c$2 = this.featureIndexArray.get(u$2);
						let p$2 = null;
						this.loadMatchingFeature(d$1, c$2.bucketIndex, c$2.sourceLayerIndex, c$2.featureIndex, o$1, s$1.layers, s$1.availableImages, e$1, n$1, i$1, ((e$2, r$2, n$2) => (p$2 || (p$2 = ko$1(e$2)), r$2.queryIntersectsFeature({
							queryGeometry: l$1,
							feature: e$2,
							featureState: n$2,
							geometry: p$2,
							zoom: this.z,
							transform: t$1.transform,
							pixelsToTileUnits: a,
							pixelPosMatrix: t$1.pixelPosMatrix,
							unwrappedTileID: this.tileID.toUnwrapped(),
							getElevation: t$1.getElevation
						}))));
					}
					return d$1;
				}
				loadMatchingFeature(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					const h$1 = this.bucketLayerIDs[e$1];
					if (s$1 && !h$1.some(((t$2) => s$1.has(t$2)))) return;
					const p$1 = this.sourceLayerCoder.decode(r$1), f$1 = this.vtLayers[p$1].feature(n$1);
					if (i$1.needGeometry) {
						const t$2 = Mo$1(f$1, !0);
						if (!i$1.filter(new Is$1(this.tileID.overscaledZ), t$2, this.tileID.canonical)) return;
					} else if (!i$1.filter(new Is$1(this.tileID.overscaledZ), f$1)) return;
					const d$1 = this.getId(f$1, p$1);
					for (let e$2 = 0; e$2 < h$1.length; e$2++) {
						const r$2 = h$1[e$2];
						if (s$1 && !s$1.has(r$2)) continue;
						const i$2 = o$1[r$2];
						if (!i$2) continue;
						let p$2 = {};
						d$1 && u$1 && (p$2 = u$1.getState(i$2.sourceLayer || "_geojsonTileLayer", d$1));
						const y$1 = O$1({}, l$1[r$2]);
						y$1.paint = Ph(y$1.paint, i$2.paint, f$1, p$2, a), y$1.layout = Ph(y$1.layout, i$2.layout, f$1, p$2, a);
						const m$1 = !c$1 || c$1(f$1, i$2, p$2);
						if (!m$1) continue;
						const g$2 = new Ih(f$1, this.z, this.x, this.y, d$1);
						g$2.layer = y$1;
						let x$1 = t$1[r$2];
						void 0 === x$1 && (x$1 = t$1[r$2] = []), x$1.push({
							featureIndex: n$1,
							feature: g$2,
							intersectionZ: m$1
						});
					}
				}
				lookupSymbolFeatures(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = {};
					this.loadVTLayers();
					const u$1 = hi$1(i$1);
					for (const i$2 of t$1) this.loadMatchingFeature(l$1, r$1, n$1, i$2, u$1, s$1, a, o$1, e$1);
					return l$1;
				}
				hasLayer(t$1) {
					for (const e$1 of this.bucketLayerIDs) for (const r$1 of e$1) if (t$1 === r$1) return !0;
					return !1;
				}
				getId(t$1, e$1) {
					var r$1;
					let n$1 = t$1.id;
					return this.promoteId && (n$1 = t$1.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e$1]], "boolean" == typeof n$1 && (n$1 = Number(n$1)), void 0 === n$1 && !(null === (r$1 = t$1.properties) || void 0 === r$1) && r$1.cluster && this.promoteId && (n$1 = Number(t$1.properties.cluster_id))), n$1;
				}
			}
			function Ph(t$1, e$1, r$1, n$1, i$1) {
				return R$2(t$1, ((t$2, s$1) => {
					const a = e$1 instanceof Fs$1 ? e$1.get(s$1) : null;
					return a && a.evaluate ? a.evaluate(r$1, n$1, i$1) : a;
				}));
			}
			function Ch(t$1, e$1) {
				return e$1 - t$1;
			}
			function Eh(t$1, e$1, n$1, i$1, s$1) {
				const a = [];
				for (let o$1 = 0; o$1 < t$1.length; o$1++) {
					const l$1 = t$1[o$1];
					let u$1;
					for (let t$2 = 0; t$2 < l$1.length - 1; t$2++) {
						let o$2 = l$1[t$2], c$1 = l$1[t$2 + 1];
						o$2.x < e$1 && c$1.x < e$1 || (o$2.x < e$1 ? o$2 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x < e$1 && (c$1 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y < n$1 && c$1.y < n$1 || (o$2.y < n$1 ? o$2 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round() : c$1.y < n$1 && (c$1 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round()), o$2.x >= i$1 && c$1.x >= i$1 || (o$2.x >= i$1 ? o$2 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x >= i$1 && (c$1 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y >= s$1 && c$1.y >= s$1 || (o$2.y >= s$1 ? o$2 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round() : c$1.y >= s$1 && (c$1 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round()), u$1 && o$2.equals(u$1[u$1.length - 1]) || (u$1 = [o$2], a.push(u$1)), u$1.push(c$1)))));
					}
				}
				return a;
			}
			as$1("FeatureIndex", zh, { omit: ["rawTileData", "sourceLayerCoder"] });
			class Bh extends r {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1), this.angle = r$1, void 0 !== n$1 && (this.segment = n$1);
				}
				clone() {
					return new Bh(this.x, this.y, this.angle, this.segment);
				}
			}
			function Vh(t$1, e$1, r$1, n$1, i$1) {
				if (void 0 === e$1.segment || 0 === r$1) return !0;
				let s$1 = e$1, a = e$1.segment + 1, o$1 = 0;
				for (; o$1 > -r$1 / 2;) {
					if (a--, a < 0) return !1;
					o$1 -= t$1[a].dist(s$1), s$1 = t$1[a];
				}
				o$1 += t$1[a].dist(t$1[a + 1]), a++;
				const l$1 = [];
				let u$1 = 0;
				for (; o$1 < r$1 / 2;) {
					const e$2 = t$1[a], r$2 = t$1[a + 1];
					if (!r$2) return !1;
					let s$2 = t$1[a - 1].angleTo(e$2) - e$2.angleTo(r$2);
					for (s$2 = Math.abs((s$2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l$1.push({
						distance: o$1,
						angleDelta: s$2
					}), u$1 += s$2; o$1 - l$1[0].distance > n$1;) u$1 -= l$1.shift().angleDelta;
					if (u$1 > i$1) return !1;
					a++, o$1 += e$2.dist(r$2);
				}
				return !0;
			}
			function Th(t$1) {
				let e$1 = 0;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += t$1[r$1].dist(t$1[r$1 + 1]);
				return e$1;
			}
			function Fh(t$1, e$1, r$1) {
				return t$1 ? .6 * e$1 * r$1 : 0;
			}
			function $h(t$1, e$1) {
				return Math.max(t$1 ? t$1.right - t$1.left : 0, e$1 ? e$1.right - e$1.left : 0);
			}
			function Lh(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = Fh(r$1, i$1, s$1), o$1 = $h(r$1, n$1) * s$1;
				let l$1 = 0;
				const u$1 = Th(t$1) / 2;
				for (let r$2 = 0; r$2 < t$1.length - 1; r$2++) {
					const n$2 = t$1[r$2], i$2 = t$1[r$2 + 1], s$2 = n$2.dist(i$2);
					if (l$1 + s$2 > u$1) {
						const c$1 = (u$1 - l$1) / s$2, f$1 = new Bh(dr$1.number(n$2.x, i$2.x, c$1), dr$1.number(n$2.y, i$2.y, c$1), i$2.angleTo(n$2), r$2);
						return f$1._round(), !a || Vh(t$1, f$1, o$1, a, e$1) ? f$1 : void 0;
					}
					l$1 += s$2;
				}
			}
			function Oh(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = Fh(n$1, s$1, a), c$1 = $h(n$1, i$1), h$1 = c$1 * a, p$1 = 0 === t$1[0].x || t$1[0].x === l$1 || 0 === t$1[0].y || t$1[0].y === l$1;
				return e$1 - h$1 < e$1 / 4 && (e$1 = h$1 + e$1 / 4), Dh(t$1, p$1 ? e$1 / 2 * o$1 % e$1 : (c$1 / 2 + 2 * s$1) * a * o$1 % e$1, e$1, u$1, r$1, h$1, p$1, !1, l$1);
			}
			function Dh(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = s$1 / 2, c$1 = Th(t$1);
				let h$1 = 0, p$1 = e$1 - r$1, f$1 = [];
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
					const a$1 = t$1[e$2], o$2 = t$1[e$2 + 1], d$1 = a$1.dist(o$2), y$1 = o$2.angleTo(a$1);
					for (; p$1 + r$1 < h$1 + d$1;) {
						p$1 += r$1;
						const m$1 = (p$1 - h$1) / d$1, g$2 = dr$1.number(a$1.x, o$2.x, m$1), x$1 = dr$1.number(a$1.y, o$2.y, m$1);
						if (g$2 >= 0 && g$2 < l$1 && x$1 >= 0 && x$1 < l$1 && p$1 - u$1 >= 0 && p$1 + u$1 <= c$1) {
							const r$2 = new Bh(g$2, x$1, y$1, e$2);
							r$2._round(), n$1 && !Vh(t$1, r$2, s$1, n$1, i$1) || f$1.push(r$2);
						}
					}
					h$1 += d$1;
				}
				return o$1 || f$1.length || a || (f$1 = Dh(t$1, h$1 / 2, r$1, n$1, i$1, s$1, a, !0, l$1)), f$1;
			}
			function Rh(t$1, e$1, n$1, i$1) {
				const s$1 = [], a = t$1.image, o$1 = a.pixelRatio, l$1 = a.paddedRect.w - 2, u$1 = a.paddedRect.h - 2;
				let c$1 = {
					x1: t$1.left,
					y1: t$1.top,
					x2: t$1.right,
					y2: t$1.bottom
				};
				const h$1 = a.stretchX || [[0, l$1]], p$1 = a.stretchY || [[0, u$1]], f$1 = (t$2, e$2) => t$2 + e$2[1] - e$2[0], d$1 = h$1.reduce(f$1, 0), y$1 = p$1.reduce(f$1, 0), m$1 = l$1 - d$1, g$2 = u$1 - y$1;
				let x$1 = 0, v$1 = d$1, b$2 = 0, w$1 = y$1, _$2 = 0, S$2 = m$1, A$1 = 0, k$2 = g$2;
				if (a.content && i$1) {
					const e$2 = a.content, r$1 = e$2[2] - e$2[0], n$2 = e$2[3] - e$2[1];
					(a.textFitWidth || a.textFitHeight) && (c$1 = $c$1(t$1)), x$1 = Uh(h$1, 0, e$2[0]), b$2 = Uh(p$1, 0, e$2[1]), v$1 = Uh(h$1, e$2[0], e$2[2]), w$1 = Uh(p$1, e$2[1], e$2[3]), _$2 = e$2[0] - x$1, A$1 = e$2[1] - b$2, S$2 = r$1 - v$1, k$2 = n$2 - w$1;
				}
				const M$2 = c$1.x1, I$2 = c$1.y1, z$2 = c$1.x2 - M$2, P$2 = c$1.y2 - I$2, C$1 = (t$2, i$2, s$2, l$2) => {
					const u$2 = Nh(t$2.stretch - x$1, v$1, z$2, M$2), c$2 = qh(t$2.fixed - _$2, S$2, t$2.stretch, d$1), h$2 = Nh(i$2.stretch - b$2, w$1, P$2, I$2), p$2 = qh(i$2.fixed - A$1, k$2, i$2.stretch, y$1), f$2 = Nh(s$2.stretch - x$1, v$1, z$2, M$2), m$2 = qh(s$2.fixed - _$2, S$2, s$2.stretch, d$1), g$3 = Nh(l$2.stretch - b$2, w$1, P$2, I$2), C$2 = qh(l$2.fixed - A$1, k$2, l$2.stretch, y$1), E$1 = new r(u$2, h$2), B$2 = new r(f$2, h$2), V$1 = new r(f$2, g$3), T$2 = new r(u$2, g$3), F$2 = new r(c$2 / o$1, p$2 / o$1), $$2 = new r(m$2 / o$1, C$2 / o$1), L$2 = e$1 * Math.PI / 180;
					if (L$2) {
						const t$3 = Math.sin(L$2), e$2 = Math.cos(L$2), r$1 = [
							e$2,
							-t$3,
							t$3,
							e$2
						];
						E$1._matMult(r$1), B$2._matMult(r$1), T$2._matMult(r$1), V$1._matMult(r$1);
					}
					const O$2 = t$2.stretch + t$2.fixed, D$2 = i$2.stretch + i$2.fixed;
					return {
						tl: E$1,
						tr: B$2,
						bl: T$2,
						br: V$1,
						tex: {
							x: a.paddedRect.x + 1 + O$2,
							y: a.paddedRect.y + 1 + D$2,
							w: s$2.stretch + s$2.fixed - O$2,
							h: l$2.stretch + l$2.fixed - D$2
						},
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: F$2,
						pixelOffsetBR: $$2,
						minFontScaleX: S$2 / o$1 / z$2,
						minFontScaleY: k$2 / o$1 / P$2,
						isSDF: n$1
					};
				};
				if (i$1 && (a.stretchX || a.stretchY)) {
					const t$2 = jh(h$1, m$1, d$1), e$2 = jh(p$1, g$2, y$1);
					for (let r$1 = 0; r$1 < t$2.length - 1; r$1++) {
						const n$2 = t$2[r$1], i$2 = t$2[r$1 + 1];
						for (let t$3 = 0; t$3 < e$2.length - 1; t$3++) s$1.push(C$1(n$2, e$2[t$3], i$2, e$2[t$3 + 1]));
					}
				} else s$1.push(C$1({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l$1 + 1
				}, {
					fixed: 0,
					stretch: u$1 + 1
				}));
				return s$1;
			}
			function Uh(t$1, e$1, r$1) {
				let n$1 = 0;
				for (const i$1 of t$1) n$1 += Math.max(e$1, Math.min(r$1, i$1[1])) - Math.max(e$1, Math.min(r$1, i$1[0]));
				return n$1;
			}
			function jh(t$1, e$1, r$1) {
				const n$1 = [{
					fixed: -1,
					stretch: 0
				}];
				for (const [e$2, r$2] of t$1) {
					const t$2 = n$1[n$1.length - 1];
					n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch
					}), n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch + (r$2 - e$2)
					});
				}
				return n$1.push({
					fixed: e$1 + 1,
					stretch: r$1
				}), n$1;
			}
			function Nh(t$1, e$1, r$1, n$1) {
				return t$1 / e$1 * r$1 + n$1;
			}
			function qh(t$1, e$1, r$1, n$1) {
				return t$1 - e$1 * r$1 / n$1;
			}
			as$1("Anchor", Bh);
			class Gh {
				constructor(t$1, e$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					var h$1;
					if (this.boxStartIndex = t$1.length, u$1) {
						let t$2 = a.top, e$2 = a.bottom;
						const r$1 = a.collisionPadding;
						r$1 && (t$2 -= r$1[1], e$2 += r$1[3]);
						let n$2 = e$2 - t$2;
						n$2 > 0 && (n$2 = Math.max(10, n$2), this.circleDiameter = n$2);
					} else {
						const u$2 = (null === (h$1 = a.image) || void 0 === h$1 ? void 0 : h$1.content) && (a.image.textFitWidth || a.image.textFitHeight) ? $c$1(a) : {
							x1: a.left,
							y1: a.top,
							x2: a.right,
							y2: a.bottom
						};
						u$2.y1 = u$2.y1 * o$1 - l$1[0], u$2.y2 = u$2.y2 * o$1 + l$1[2], u$2.x1 = u$2.x1 * o$1 - l$1[3], u$2.x2 = u$2.x2 * o$1 + l$1[1];
						const p$1 = a.collisionPadding;
						if (p$1 && (u$2.x1 -= p$1[0] * o$1, u$2.y1 -= p$1[1] * o$1, u$2.x2 += p$1[2] * o$1, u$2.y2 += p$1[3] * o$1), c$1) {
							const t$2 = new r(u$2.x1, u$2.y1), e$2 = new r(u$2.x2, u$2.y1), n$2 = new r(u$2.x1, u$2.y2), i$2 = new r(u$2.x2, u$2.y2), s$2 = c$1 * Math.PI / 180;
							t$2._rotate(s$2), e$2._rotate(s$2), n$2._rotate(s$2), i$2._rotate(s$2), u$2.x1 = Math.min(t$2.x, e$2.x, n$2.x, i$2.x), u$2.x2 = Math.max(t$2.x, e$2.x, n$2.x, i$2.x), u$2.y1 = Math.min(t$2.y, e$2.y, n$2.y, i$2.y), u$2.y2 = Math.max(t$2.y, e$2.y, n$2.y, i$2.y);
						}
						t$1.emplaceBack(e$1.x, e$1.y, u$2.x1, u$2.y1, u$2.x2, u$2.y2, n$1, i$1, s$1);
					}
					this.boxEndIndex = t$1.length;
				}
			}
			class Xh {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			}
			function Zh(t$1, e$1 = 1, n$1 = !1) {
				const i$1 = kh.fromPoints(t$1[0]), s$1 = Math.min(i$1.width(), i$1.height());
				let a = s$1 / 2;
				const o$1 = new Xh([], Yh), { minX: l$1, minY: u$1, maxX: c$1, maxY: h$1 } = i$1;
				if (0 === s$1) return new r(l$1, u$1);
				for (let e$2 = l$1; e$2 < c$1; e$2 += s$1) for (let r$1 = u$1; r$1 < h$1; r$1 += s$1) o$1.push(new Hh(e$2 + a, r$1 + a, a, t$1));
				let p$1 = function(t$2) {
					let e$2 = 0, r$1 = 0, n$2 = 0;
					const i$2 = t$2[0];
					for (let t$3 = 0, s$2 = i$2.length, a$1 = s$2 - 1; t$3 < s$2; a$1 = t$3++) {
						const s$3 = i$2[t$3], o$2 = i$2[a$1], l$2 = s$3.x * o$2.y - o$2.x * s$3.y;
						r$1 += (s$3.x + o$2.x) * l$2, n$2 += (s$3.y + o$2.y) * l$2, e$2 += 3 * l$2;
					}
					return new Hh(r$1 / e$2, n$2 / e$2, 0, t$2);
				}(t$1), f$1 = o$1.length;
				for (; o$1.length;) {
					const r$1 = o$1.pop();
					(r$1.d > p$1.d || !p$1.d) && (p$1 = r$1, n$1 && console.log("found best %d after %d probes", Math.round(1e4 * r$1.d) / 1e4, f$1)), r$1.max - p$1.d <= e$1 || (a = r$1.h / 2, o$1.push(new Hh(r$1.p.x - a, r$1.p.y - a, a, t$1)), o$1.push(new Hh(r$1.p.x + a, r$1.p.y - a, a, t$1)), o$1.push(new Hh(r$1.p.x - a, r$1.p.y + a, a, t$1)), o$1.push(new Hh(r$1.p.x + a, r$1.p.y + a, a, t$1)), f$1 += 4);
				}
				return n$1 && (console.log(`num probes: ${f$1}`), console.log(`best distance: ${p$1.d}`)), p$1.p;
			}
			function Yh(t$1, e$1) {
				return e$1.max - t$1.max;
			}
			function Hh(t$1, e$1, n$1, i$1) {
				this.p = new r(t$1, e$1), this.h = n$1, this.d = function(t$2, e$2) {
					let r$1 = !1, n$2 = Infinity;
					for (let i$2 = 0; i$2 < e$2.length; i$2++) {
						const s$1 = e$2[i$2];
						for (let e$3 = 0, i$3 = s$1.length, a = i$3 - 1; e$3 < i$3; a = e$3++) {
							const i$4 = s$1[e$3], o$1 = s$1[a];
							i$4.y > t$2.y != o$1.y > t$2.y && t$2.x < (o$1.x - i$4.x) * (t$2.y - i$4.y) / (o$1.y - i$4.y) + i$4.x && (r$1 = !r$1), n$2 = Math.min(n$2, Lo$1(t$2, i$4, o$1));
						}
					}
					return (r$1 ? 1 : -1) * Math.sqrt(n$2);
				}(this.p, i$1), this.max = this.d + this.h * Math.SQRT2;
			}
			var Kh;
			t.aE = void 0, (Kh = t.aE || (t.aE = {}))[Kh.center = 1] = "center", Kh[Kh.left = 2] = "left", Kh[Kh.right = 3] = "right", Kh[Kh.top = 4] = "top", Kh[Kh.bottom = 5] = "bottom", Kh[Kh["top-left"] = 6] = "top-left", Kh[Kh["top-right"] = 7] = "top-right", Kh[Kh["bottom-left"] = 8] = "bottom-left", Kh[Kh["bottom-right"] = 9] = "bottom-right";
			const Jh = Number.POSITIVE_INFINITY;
			function Wh(t$1, e$1) {
				return e$1[1] !== Jh ? function(t$2, e$2, r$1) {
					let n$1 = 0, i$1 = 0;
					switch (e$2 = Math.abs(e$2), r$1 = Math.abs(r$1), t$2) {
						case "top-right":
						case "top-left":
						case "top":
							i$1 = r$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": i$1 = 7 - r$1;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
						case "right":
							n$1 = -e$2;
							break;
						case "top-left":
						case "bottom-left":
						case "left": n$1 = e$2;
					}
					return [n$1, i$1];
				}(t$1, e$1[0], e$1[1]) : function(t$2, e$2) {
					let r$1 = 0, n$1 = 0;
					e$2 < 0 && (e$2 = 0);
					const i$1 = e$2 / Math.SQRT2;
					switch (t$2) {
						case "top-right":
						case "top-left":
							n$1 = i$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							n$1 = 7 - i$1;
							break;
						case "bottom":
							n$1 = 7 - e$2;
							break;
						case "top": n$1 = e$2 - 7;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
							r$1 = -i$1;
							break;
						case "top-left":
						case "bottom-left":
							r$1 = i$1;
							break;
						case "left":
							r$1 = e$2;
							break;
						case "right": r$1 = -e$2;
					}
					return [r$1, n$1];
				}(t$1, e$1[0]);
			}
			function Qh(t$1, e$1, r$1) {
				var n$1;
				const i$1 = t$1.layout, s$1 = null === (n$1 = i$1.get("text-variable-anchor-offset")) || void 0 === n$1 ? void 0 : n$1.evaluate(e$1, {}, r$1);
				if (s$1) {
					const t$2 = s$1.values, e$2 = [];
					for (let r$2 = 0; r$2 < t$2.length; r$2 += 2) {
						const n$2 = e$2[r$2] = t$2[r$2], i$2 = t$2[r$2 + 1].map(((t$3) => t$3 * Zu$1));
						n$2.startsWith("top") ? i$2[1] -= 7 : n$2.startsWith("bottom") && (i$2[1] += 7), e$2[r$2 + 1] = i$2;
					}
					return new $e$1(e$2);
				}
				const a = i$1.get("text-variable-anchor");
				if (a) {
					let n$2;
					n$2 = void 0 !== t$1._unevaluatedLayout.getValue("text-radial-offset") ? [i$1.get("text-radial-offset").evaluate(e$1, {}, r$1) * Zu$1, Jh] : i$1.get("text-offset").evaluate(e$1, {}, r$1).map(((t$2) => t$2 * Zu$1));
					const s$2 = [];
					for (const t$2 of a) s$2.push(t$2, Wh(t$2, n$2));
					return new $e$1(s$2);
				}
				return null;
			}
			function tp(t$1) {
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function ep(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
				let f$1 = a.textMaxSize.evaluate(r$1, {});
				void 0 === f$1 && (f$1 = o$1);
				const d$1 = e$1.layers[0].layout, y$1 = d$1.get("icon-offset").evaluate(r$1, {}, h$1), m$1 = np$1(n$1.horizontal), g$2 = o$1 / 24, x$1 = e$1.tilePixelRatio * g$2, v$1 = e$1.tilePixelRatio * f$1 / 24, b$2 = e$1.tilePixelRatio * l$1, w$1 = e$1.tilePixelRatio * d$1.get("symbol-spacing"), _$2 = d$1.get("text-padding") * e$1.tilePixelRatio, S$2 = function(t$1, e$2, r$2, n$2 = 1) {
					const i$2 = t$1.get("icon-padding").evaluate(e$2, {}, r$2), s$2 = i$2 && i$2.values;
					return [
						s$2[0] * n$2,
						s$2[1] * n$2,
						s$2[2] * n$2,
						s$2[3] * n$2
					];
				}(d$1, r$1, h$1, e$1.tilePixelRatio), A$1 = d$1.get("text-max-angle") / 180 * Math.PI, k$2 = "viewport" !== d$1.get("text-rotation-alignment") && "point" !== d$1.get("symbol-placement"), M$2 = "map" === d$1.get("icon-rotation-alignment") && "point" !== d$1.get("symbol-placement"), I$2 = d$1.get("symbol-placement"), z$2 = w$1 / 2, C$1 = d$1.get("icon-text-fit");
				let E$1;
				i$1 && "none" !== C$1 && (e$1.allowVerticalPlacement && n$1.vertical && (E$1 = Lc$1(i$1, n$1.vertical, C$1, d$1.get("icon-text-fit-padding"), y$1, g$2)), m$1 && (i$1 = Lc$1(i$1, m$1, C$1, d$1.get("icon-text-fit-padding"), y$1, g$2)));
				const B$2 = h$1 ? p$1.line.getGranularityForZoomLevel(h$1.z) : 1, V$1 = (l$2, p$2) => {
					p$2.x < 0 || p$2.x >= P$1 || p$2.y < 0 || p$2.y >= P$1 || function(e$2, r$2, n$2, i$2, s$2, a$1, o$2, l$3, u$2, c$2, h$2, p$3, f$2, d$2, y$2, m$2, g$3, x$2, v$2, b$3, w$2, _$3, S$3, A$2, k$3) {
						const M$3 = e$2.addToLineVertexArray(r$2, n$2);
						let I$3, z$3, P$2, C$2, E$2 = 0, B$3 = 0, V$2 = 0, T$2 = 0, F$2 = -1, $$2 = -1;
						const L$2 = {};
						let O$2 = ro$1("");
						if (e$2.allowVerticalPlacement && i$2.vertical) {
							const t$1 = l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2) + 90;
							P$2 = new Gh(u$2, r$2, c$2, h$2, p$3, i$2.vertical, f$2, d$2, y$2, t$1), o$2 && (C$2 = new Gh(u$2, r$2, c$2, h$2, p$3, o$2, g$3, x$2, y$2, t$1));
						}
						if (s$2) {
							const n$3 = l$3.layout.get("icon-rotate").evaluate(w$2, {}), i$3 = "none" !== l$3.layout.get("icon-text-fit"), a$2 = Rh(s$2, n$3, S$3, i$3), f$3 = o$2 ? Rh(o$2, n$3, S$3, i$3) : void 0;
							z$3 = new Gh(u$2, r$2, c$2, h$2, p$3, s$2, g$3, x$2, !1, n$3), E$2 = 4 * a$2.length;
							const d$3 = e$2.iconSizeData;
							let y$3 = null;
							"source" === d$3.kind ? (y$3 = [Oc$1 * l$3.layout.get("icon-size").evaluate(w$2, {})], y$3[0] > Dc$1 && q$1(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d$3.kind && (y$3 = [Oc$1 * _$3.compositeIconSizes[0].evaluate(w$2, {}, A$2), Oc$1 * _$3.compositeIconSizes[1].evaluate(w$2, {}, A$2)], (y$3[0] > Dc$1 || y$3[1] > Dc$1) && q$1(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e$2.addSymbols(e$2.icon, a$2, y$3, b$3, v$2, w$2, t.ao.none, r$2, M$3.lineStartIndex, M$3.lineLength, -1, A$2), F$2 = e$2.icon.placedSymbolArray.length - 1, f$3 && (B$3 = 4 * f$3.length, e$2.addSymbols(e$2.icon, f$3, y$3, b$3, v$2, w$2, t.ao.vertical, r$2, M$3.lineStartIndex, M$3.lineLength, -1, A$2), $$2 = e$2.icon.placedSymbolArray.length - 1);
						}
						const D$2 = Object.keys(i$2.horizontal);
						for (const n$3 of D$2) {
							const s$3 = i$2.horizontal[n$3];
							if (!I$3) {
								O$2 = ro$1(s$3.text);
								I$3 = new Gh(u$2, r$2, c$2, h$2, p$3, s$3, f$2, d$2, y$2, l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2));
							}
							const o$3 = 1 === s$3.positionedLines.length;
							if (V$2 += rp(e$2, r$2, s$3, a$1, l$3, y$2, w$2, m$2, M$3, i$2.vertical ? t.ao.horizontal : t.ao.horizontalOnly, o$3 ? D$2 : [n$3], L$2, F$2, _$3, A$2), o$3) break;
						}
						i$2.vertical && (T$2 += rp(e$2, r$2, i$2.vertical, a$1, l$3, y$2, w$2, m$2, M$3, t.ao.vertical, ["vertical"], L$2, $$2, _$3, A$2));
						const R$3 = I$3 ? I$3.boxStartIndex : e$2.collisionBoxArray.length, U$2 = I$3 ? I$3.boxEndIndex : e$2.collisionBoxArray.length, j$2 = P$2 ? P$2.boxStartIndex : e$2.collisionBoxArray.length, N$1 = P$2 ? P$2.boxEndIndex : e$2.collisionBoxArray.length, G$2 = z$3 ? z$3.boxStartIndex : e$2.collisionBoxArray.length, X$2 = z$3 ? z$3.boxEndIndex : e$2.collisionBoxArray.length, Z$2 = C$2 ? C$2.boxStartIndex : e$2.collisionBoxArray.length, Y$2 = C$2 ? C$2.boxEndIndex : e$2.collisionBoxArray.length;
						let H$2 = -1;
						const K$2 = (t$1, e$3) => t$1 && t$1.circleDiameter ? Math.max(t$1.circleDiameter, e$3) : e$3;
						H$2 = K$2(I$3, H$2), H$2 = K$2(P$2, H$2), H$2 = K$2(z$3, H$2), H$2 = K$2(C$2, H$2);
						const J$2 = H$2 > -1 ? 1 : 0;
						J$2 && (H$2 *= k$3 / Zu$1), e$2.glyphOffsetArray.length >= Yc.MAX_GLYPHS && q$1("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w$2.sortKey && e$2.addToSortKeyRanges(e$2.symbolInstances.length, w$2.sortKey);
						const W$2 = Qh(l$3, w$2, A$2), [Q$2, tt$2] = function(e$3, r$3) {
							const n$3 = e$3.length, i$3 = null == r$3 ? void 0 : r$3.values;
							if ((null == i$3 ? void 0 : i$3.length) > 0) for (let r$4 = 0; r$4 < i$3.length; r$4 += 2) {
								const n$4 = i$3[r$4 + 1];
								e$3.emplaceBack(t.aE[i$3[r$4]], n$4[0], n$4[1]);
							}
							return [n$3, e$3.length];
						}(e$2.textAnchorOffsets, W$2);
						e$2.symbolInstances.emplaceBack(r$2.x, r$2.y, L$2.right >= 0 ? L$2.right : -1, L$2.center >= 0 ? L$2.center : -1, L$2.left >= 0 ? L$2.left : -1, L$2.vertical || -1, F$2, $$2, O$2, R$3, U$2, j$2, N$1, G$2, X$2, Z$2, Y$2, c$2, V$2, T$2, E$2, B$3, J$2, 0, f$2, H$2, Q$2, tt$2);
					}(e$1, p$2, l$2, n$1, i$1, s$1, E$1, e$1.layers[0], e$1.collisionBoxArray, r$1.index, r$1.sourceLayerIndex, e$1.index, x$1, [
						_$2,
						_$2,
						_$2,
						_$2
					], k$2, u$1, b$2, S$2, M$2, y$1, r$1, a, c$1, h$1, o$1);
				};
				if ("line" === I$2) for (const t$1 of Eh(r$1.geometry, 0, 0, P$1, P$1)) {
					const r$2 = Kl$1(t$1, B$2), s$2 = Oh(r$2, w$1, A$1, n$1.vertical || m$1, i$1, 24, v$1, e$1.overscaling, P$1);
					for (const t$2 of s$2) m$1 && ip$1(e$1, m$1.text, z$2, t$2) || V$1(r$2, t$2);
				}
				else if ("line-center" === I$2) {
					for (const t$1 of r$1.geometry) if (t$1.length > 1) {
						const e$2 = Kl$1(t$1, B$2), r$2 = Lh(e$2, A$1, n$1.vertical || m$1, i$1, 24, v$1);
						r$2 && V$1(e$2, r$2);
					}
				} else if ("Polygon" === r$1.type) for (const t$1 of Qr$1(r$1.geometry, 0)) {
					const e$2 = Zh(t$1, 16);
					V$1(Kl$1(t$1[0], B$2, !0), new Bh(e$2.x, e$2.y, 0));
				}
				else if ("LineString" === r$1.type) for (const t$1 of r$1.geometry) {
					const e$2 = Kl$1(t$1, B$2);
					V$1(e$2, new Bh(e$2[0].x, e$2[0].y, 0));
				}
				else if ("Point" === r$1.type) for (const t$1 of r$1.geometry) for (const e$2 of t$1) V$1([e$2], new Bh(e$2.x, e$2.y, 0));
			}
			function rp(t$1, e$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = function(t$2, e$2, n$2, i$2, s$2, a$1, o$2, l$2) {
					const u$2 = i$2.layout.get("text-rotate").evaluate(a$1, {}) * Math.PI / 180, c$2 = [];
					for (const t$3 of e$2.positionedLines) for (const i$3 of t$3.positionedGlyphs) {
						if (!i$3.rect) continue;
						const a$2 = i$3.rect || {};
						let h$2 = 4, p$2 = !0, f$2 = 1, d$2 = 0;
						const y$2 = (s$2 || l$2) && i$3.vertical, m$2 = i$3.metrics.advance * i$3.scale / 2;
						if (l$2 && e$2.verticalizable && (d$2 = t$3.lineOffset / 2 - (i$3.imageName ? -(Zu$1 - i$3.metrics.width * i$3.scale) / 2 : (i$3.scale - 1) * Zu$1)), i$3.imageName) {
							const t$4 = o$2[i$3.imageName];
							p$2 = t$4.sdf, f$2 = t$4.pixelRatio, h$2 = 1 / f$2;
						}
						const g$3 = s$2 ? [i$3.x + m$2, i$3.y] : [0, 0];
						let x$2 = s$2 ? [0, 0] : [i$3.x + m$2 + n$2[0], i$3.y + n$2[1] - d$2], v$1 = [0, 0];
						y$2 && (v$1 = x$2, x$2 = [0, 0]);
						const b$2 = i$3.metrics.isDoubleResolution ? 2 : 1, w$1 = (i$3.metrics.left - h$2) * i$3.scale - m$2 + x$2[0], _$2 = (-i$3.metrics.top - h$2) * i$3.scale + x$2[1], S$2 = w$1 + a$2.w / b$2 * i$3.scale / f$2, A$1 = _$2 + a$2.h / b$2 * i$3.scale / f$2, k$2 = new r(w$1, _$2), M$2 = new r(S$2, _$2), I$2 = new r(w$1, A$1), z$2 = new r(S$2, A$1);
						if (y$2) {
							const t$4 = new r(-m$2, m$2 - -17), e$3 = -Math.PI / 2, n$3 = 12 - m$2, s$3 = new r(22 - n$3, -(i$3.imageName ? n$3 : 0)), a$3 = new r(...v$1);
							k$2._rotateAround(e$3, t$4)._add(s$3)._add(a$3), M$2._rotateAround(e$3, t$4)._add(s$3)._add(a$3), I$2._rotateAround(e$3, t$4)._add(s$3)._add(a$3), z$2._rotateAround(e$3, t$4)._add(s$3)._add(a$3);
						}
						if (u$2) {
							const t$4 = Math.sin(u$2), e$3 = Math.cos(u$2), r$1 = [
								e$3,
								-t$4,
								t$4,
								e$3
							];
							k$2._matMult(r$1), M$2._matMult(r$1), I$2._matMult(r$1), z$2._matMult(r$1);
						}
						const P$2 = new r(0, 0), C$1 = new r(0, 0);
						c$2.push({
							tl: k$2,
							tr: M$2,
							bl: I$2,
							br: z$2,
							tex: a$2,
							writingMode: e$2.writingMode,
							glyphOffset: g$3,
							sectionIndex: i$3.sectionIndex,
							isSDF: p$2,
							pixelOffsetTL: P$2,
							pixelOffsetBR: C$1,
							minFontScaleX: 0,
							minFontScaleY: 0
						});
					}
					return c$2;
				}(0, n$1, l$1, s$1, a, o$1, i$1, t$1.allowVerticalPlacement), g$2 = t$1.textSizeData;
				let x$1 = null;
				"source" === g$2.kind ? (x$1 = [Oc$1 * s$1.layout.get("text-size").evaluate(o$1, {})], x$1[0] > Dc$1 && q$1(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g$2.kind && (x$1 = [Oc$1 * d$1.compositeTextSizes[0].evaluate(o$1, {}, y$1), Oc$1 * d$1.compositeTextSizes[1].evaluate(o$1, {}, y$1)], (x$1[0] > Dc$1 || x$1[1] > Dc$1) && q$1(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t$1.addSymbols(t$1.text, m$1, x$1, l$1, a, o$1, c$1, e$1, u$1.lineStartIndex, u$1.lineLength, f$1, y$1);
				for (const e$2 of h$1) p$1[e$2] = t$1.text.placedSymbolArray.length - 1;
				return 4 * m$1.length;
			}
			function np$1(t$1) {
				for (const e$1 in t$1) return t$1[e$1];
				return null;
			}
			function ip$1(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.compareText;
				if (e$1 in i$1) {
					const t$2 = i$1[e$1];
					for (let e$2 = t$2.length - 1; e$2 >= 0; e$2--) if (n$1.dist(t$2[e$2]) < r$1) return !0;
				} else i$1[e$1] = [];
				return i$1[e$1].push(n$1), !1;
			}
			const sp$1 = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class ap$1 {
				static from(t$1) {
					if (!(t$1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
					const [e$1, r$1] = new Uint8Array(t$1, 0, 2);
					if (219 !== e$1) throw new Error("Data does not appear to be in a KDBush format.");
					const n$1 = r$1 >> 4;
					if (1 !== n$1) throw new Error(`Got v${n$1} data when expected v1.`);
					const i$1 = sp$1[15 & r$1];
					if (!i$1) throw new Error("Unrecognized array type.");
					const [s$1] = new Uint16Array(t$1, 2, 1), [a] = new Uint32Array(t$1, 4, 1);
					return new ap$1(a, s$1, i$1, t$1);
				}
				constructor(t$1, e$1 = 64, r$1 = Float64Array, n$1) {
					if (isNaN(t$1) || t$1 < 0) throw new Error(`Unpexpected numItems value: ${t$1}.`);
					this.numItems = +t$1, this.nodeSize = Math.min(Math.max(+e$1, 2), 65535), this.ArrayType = r$1, this.IndexArrayType = t$1 < 65536 ? Uint16Array : Uint32Array;
					const i$1 = sp$1.indexOf(this.ArrayType), s$1 = 2 * t$1 * this.ArrayType.BYTES_PER_ELEMENT, a = t$1 * this.IndexArrayType.BYTES_PER_ELEMENT, o$1 = (8 - a % 8) % 8;
					if (i$1 < 0) throw new Error(`Unexpected typed array class: ${r$1}.`);
					n$1 && n$1 instanceof ArrayBuffer ? (this.data = n$1, this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a + o$1, 2 * t$1), this._pos = 2 * t$1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s$1 + a + o$1), this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a + o$1, 2 * t$1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i$1]), new Uint16Array(this.data, 2, 1)[0] = e$1, new Uint32Array(this.data, 4, 1)[0] = t$1);
				}
				add(t$1, e$1) {
					const r$1 = this._pos >> 1;
					return this.ids[r$1] = r$1, this.coords[this._pos++] = t$1, this.coords[this._pos++] = e$1, r$1;
				}
				finish() {
					const t$1 = this._pos >> 1;
					if (t$1 !== this.numItems) throw new Error(`Added ${t$1} items when expected ${this.numItems}.`);
					return op$1(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(t$1, e$1, r$1, n$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: i$1, coords: s$1, nodeSize: a } = this, o$1 = [
						0,
						i$1.length - 1,
						0
					], l$1 = [];
					for (; o$1.length;) {
						const u$1 = o$1.pop() || 0, c$1 = o$1.pop() || 0, h$1 = o$1.pop() || 0;
						if (c$1 - h$1 <= a) {
							for (let a$1 = h$1; a$1 <= c$1; a$1++) {
								const o$2 = s$1[2 * a$1], u$2 = s$1[2 * a$1 + 1];
								o$2 >= t$1 && o$2 <= r$1 && u$2 >= e$1 && u$2 <= n$1 && l$1.push(i$1[a$1]);
							}
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = s$1[2 * p$1], d$1 = s$1[2 * p$1 + 1];
						f$1 >= t$1 && f$1 <= r$1 && d$1 >= e$1 && d$1 <= n$1 && l$1.push(i$1[p$1]), (0 === u$1 ? t$1 <= f$1 : e$1 <= d$1) && (o$1.push(h$1), o$1.push(p$1 - 1), o$1.push(1 - u$1)), (0 === u$1 ? r$1 >= f$1 : n$1 >= d$1) && (o$1.push(p$1 + 1), o$1.push(c$1), o$1.push(1 - u$1));
					}
					return l$1;
				}
				within(t$1, e$1, r$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: n$1, coords: i$1, nodeSize: s$1 } = this, a = [
						0,
						n$1.length - 1,
						0
					], o$1 = [], l$1 = r$1 * r$1;
					for (; a.length;) {
						const u$1 = a.pop() || 0, c$1 = a.pop() || 0, h$1 = a.pop() || 0;
						if (c$1 - h$1 <= s$1) {
							for (let r$2 = h$1; r$2 <= c$1; r$2++) hp$1(i$1[2 * r$2], i$1[2 * r$2 + 1], t$1, e$1) <= l$1 && o$1.push(n$1[r$2]);
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = i$1[2 * p$1], d$1 = i$1[2 * p$1 + 1];
						hp$1(f$1, d$1, t$1, e$1) <= l$1 && o$1.push(n$1[p$1]), (0 === u$1 ? t$1 - r$1 <= f$1 : e$1 - r$1 <= d$1) && (a.push(h$1), a.push(p$1 - 1), a.push(1 - u$1)), (0 === u$1 ? t$1 + r$1 >= f$1 : e$1 + r$1 >= d$1) && (a.push(p$1 + 1), a.push(c$1), a.push(1 - u$1));
					}
					return o$1;
				}
			}
			function op$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (i$1 - n$1 <= r$1) return;
				const a = n$1 + i$1 >> 1;
				lp$1(t$1, e$1, a, n$1, i$1, s$1), op$1(t$1, e$1, r$1, n$1, a - 1, 1 - s$1), op$1(t$1, e$1, r$1, a + 1, i$1, 1 - s$1);
			}
			function lp$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				for (; i$1 > n$1;) {
					if (i$1 - n$1 > 600) {
						const a$1 = i$1 - n$1 + 1, o$2 = r$1 - n$1 + 1, l$2 = Math.log(a$1), u$1 = .5 * Math.exp(2 * l$2 / 3), c$1 = .5 * Math.sqrt(l$2 * u$1 * (a$1 - u$1) / a$1) * (o$2 - a$1 / 2 < 0 ? -1 : 1);
						lp$1(t$1, e$1, r$1, Math.max(n$1, Math.floor(r$1 - o$2 * u$1 / a$1 + c$1)), Math.min(i$1, Math.floor(r$1 + (a$1 - o$2) * u$1 / a$1 + c$1)), s$1);
					}
					const a = e$1[2 * r$1 + s$1];
					let o$1 = n$1, l$1 = i$1;
					for (up$1(t$1, e$1, n$1, r$1), e$1[2 * i$1 + s$1] > a && up$1(t$1, e$1, n$1, i$1); o$1 < l$1;) {
						for (up$1(t$1, e$1, o$1, l$1), o$1++, l$1--; e$1[2 * o$1 + s$1] < a;) o$1++;
						for (; e$1[2 * l$1 + s$1] > a;) l$1--;
					}
					e$1[2 * n$1 + s$1] === a ? up$1(t$1, e$1, n$1, l$1) : (l$1++, up$1(t$1, e$1, l$1, i$1)), l$1 <= r$1 && (n$1 = l$1 + 1), r$1 <= l$1 && (i$1 = l$1 - 1);
				}
			}
			function up$1(t$1, e$1, r$1, n$1) {
				cp$1(t$1, r$1, n$1), cp$1(e$1, 2 * r$1, 2 * n$1), cp$1(e$1, 2 * r$1 + 1, 2 * n$1 + 1);
			}
			function cp$1(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function hp$1(t$1, e$1, r$1, n$1) {
				const i$1 = t$1 - r$1, s$1 = e$1 - n$1;
				return i$1 * i$1 + s$1 * s$1;
			}
			var pp$1;
			t.cx = void 0, (pp$1 = t.cx || (t.cx = {})).create = "create", pp$1.load = "load", pp$1.fullLoad = "fullLoad";
			let fp$1 = null, dp$1 = [];
			const yp$1 = 1e3 / 60, mp$1 = "loadTime", gp$1 = "fullLoadTime";
			t.$ = P$1, t.A = f, t.B = function([t$1, e$1, r$1]) {
				return e$1 += 90, e$1 *= Math.PI / 180, r$1 *= Math.PI / 180, {
					x: t$1 * Math.cos(e$1) * Math.sin(r$1),
					y: t$1 * Math.sin(e$1) * Math.sin(r$1),
					z: t$1 * Math.cos(r$1)
				};
			}, t.C = dr$1, t.D = $s$1, t.E = gt$1, t.F = Is$1, t.G = ts$1, t.H = function(t$1) {
				if (null == Z$1) {
					const e$1 = t$1.navigator ? t$1.navigator.userAgent : null;
					Z$1 = !!t$1.safari || !(!e$1 || !(/\b(iPad|iPhone|iPod)\b/.test(e$1) || e$1.match("Safari") && !e$1.match("Chrome")));
				}
				return Z$1;
			}, t.I = fc$1, t.J = class {
				constructor(t$1, e$1) {
					this.target = t$1, this.mapId = e$1, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new oh((() => this.process())), this.subscription = Q$1(this.target, "message", ((t$2) => this.receive(t$2)), !1), this.globalScope = X$1(self) ? t$1 : window;
				}
				registerMessageHandler(t$1, e$1) {
					this.messageHandlers[t$1] = e$1;
				}
				sendAsync(t$1, e$1) {
					return new Promise(((r$1, n$1) => {
						const i$1 = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10), s$1 = e$1 ? Q$1(e$1.signal, "abort", (() => {
							s$1?.unsubscribe(), delete this.resolveRejects[i$1];
							const e$2 = {
								id: i$1,
								type: "<cancel>",
								origin: location.origin,
								targetMapId: t$1.targetMapId,
								sourceMapId: this.mapId
							};
							this.target.postMessage(e$2);
						}), lh) : null;
						this.resolveRejects[i$1] = {
							resolve: (t$2) => {
								s$1?.unsubscribe(), r$1(t$2);
							},
							reject: (t$2) => {
								s$1?.unsubscribe(), n$1(t$2);
							}
						};
						const a = [], o$1 = Object.assign(Object.assign({}, t$1), {
							id: i$1,
							sourceMapId: this.mapId,
							origin: location.origin,
							data: cs$1(t$1.data, a)
						});
						this.target.postMessage(o$1, { transfer: a });
					}));
				}
				receive(t$1) {
					const e$1 = t$1.data, r$1 = e$1.id;
					if (!("file://" !== e$1.origin && "file://" !== location.origin && "resource://android" !== e$1.origin && "resource://android" !== location.origin && e$1.origin !== location.origin || e$1.targetMapId && this.mapId !== e$1.targetMapId)) {
						if ("<cancel>" === e$1.type) {
							delete this.tasks[r$1];
							const t$2 = this.abortControllers[r$1];
							delete this.abortControllers[r$1], t$2 && t$2.abort();
							return;
						}
						if (X$1(self) || e$1.mustQueue) return this.tasks[r$1] = e$1, this.taskQueue.push(r$1), void this.invoker.trigger();
						this.processTask(r$1, e$1);
					}
				}
				process() {
					if (0 === this.taskQueue.length) return;
					const t$1 = this.taskQueue.shift(), e$1 = this.tasks[t$1];
					delete this.tasks[t$1], this.taskQueue.length > 0 && this.invoker.trigger(), e$1 && this.processTask(t$1, e$1);
				}
				processTask(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if ("<response>" === r$1.type) {
							const e$2 = this.resolveRejects[t$1];
							if (delete this.resolveRejects[t$1], !e$2) return;
							r$1.error ? e$2.reject(hs$1(r$1.error)) : e$2.resolve(hs$1(r$1.data));
							return;
						}
						if (!this.messageHandlers[r$1.type]) return void this.completeTask(t$1, /* @__PURE__ */ new Error(`Could not find a registered handler for ${r$1.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
						const e$1 = hs$1(r$1.data), n$1 = new AbortController();
						this.abortControllers[t$1] = n$1;
						try {
							const i$1 = yield this.messageHandlers[r$1.type](r$1.sourceMapId, e$1, n$1);
							this.completeTask(t$1, null, i$1);
						} catch (e$2) {
							this.completeTask(t$1, e$2);
						}
					}));
				}
				completeTask(t$1, e$1, r$1) {
					const n$1 = [];
					delete this.abortControllers[t$1];
					const i$1 = {
						id: t$1,
						type: "<response>",
						sourceMapId: this.mapId,
						origin: location.origin,
						error: e$1 ? cs$1(e$1) : null,
						data: cs$1(r$1, n$1)
					};
					this.target.postMessage(i$1, { transfer: n$1 });
				}
				remove() {
					this.invoker.remove(), this.subscription.unsubscribe();
				}
			}, t.K = lt$1, t.L = function() {
				var t$1 = new f(16);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0), t$1[0] = 1, t$1[5] = 1, t$1[10] = 1, t$1[15] = 1, t$1;
			}, t.M = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1 = r$1[0], m$1 = r$1[1], g$2 = r$1[2];
				return e$1 === t$1 ? (t$1[12] = e$1[0] * y$1 + e$1[4] * m$1 + e$1[8] * g$2 + e$1[12], t$1[13] = e$1[1] * y$1 + e$1[5] * m$1 + e$1[9] * g$2 + e$1[13], t$1[14] = e$1[2] * y$1 + e$1[6] * m$1 + e$1[10] * g$2 + e$1[14], t$1[15] = e$1[3] * y$1 + e$1[7] * m$1 + e$1[11] * g$2 + e$1[15]) : (i$1 = e$1[1], s$1 = e$1[2], a = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], t$1[0] = n$1 = e$1[0], t$1[1] = i$1, t$1[2] = s$1, t$1[3] = a, t$1[4] = o$1, t$1[5] = l$1, t$1[6] = u$1, t$1[7] = c$1, t$1[8] = h$1, t$1[9] = p$1, t$1[10] = f$1, t$1[11] = d$1, t$1[12] = n$1 * y$1 + o$1 * m$1 + h$1 * g$2 + e$1[12], t$1[13] = i$1 * y$1 + l$1 * m$1 + p$1 * g$2 + e$1[13], t$1[14] = s$1 * y$1 + u$1 * m$1 + f$1 * g$2 + e$1[14], t$1[15] = a * y$1 + c$1 * m$1 + d$1 * g$2 + e$1[15]), t$1;
			}, t.N = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2];
				return t$1[0] = e$1[0] * n$1, t$1[1] = e$1[1] * n$1, t$1[2] = e$1[2] * n$1, t$1[3] = e$1[3] * n$1, t$1[4] = e$1[4] * i$1, t$1[5] = e$1[5] * i$1, t$1[6] = e$1[6] * i$1, t$1[7] = e$1[7] * i$1, t$1[8] = e$1[8] * s$1, t$1[9] = e$1[9] * s$1, t$1[10] = e$1[10] * s$1, t$1[11] = e$1[11] * s$1, t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.O = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], y$1 = e$1[12], m$1 = e$1[13], g$2 = e$1[14], x$1 = e$1[15], v$1 = r$1[0], b$2 = r$1[1], w$1 = r$1[2], _$2 = r$1[3];
				return t$1[0] = v$1 * n$1 + b$2 * o$1 + w$1 * h$1 + _$2 * y$1, t$1[1] = v$1 * i$1 + b$2 * l$1 + w$1 * p$1 + _$2 * m$1, t$1[2] = v$1 * s$1 + b$2 * u$1 + w$1 * f$1 + _$2 * g$2, t$1[3] = v$1 * a + b$2 * c$1 + w$1 * d$1 + _$2 * x$1, t$1[4] = (v$1 = r$1[4]) * n$1 + (b$2 = r$1[5]) * o$1 + (w$1 = r$1[6]) * h$1 + (_$2 = r$1[7]) * y$1, t$1[5] = v$1 * i$1 + b$2 * l$1 + w$1 * p$1 + _$2 * m$1, t$1[6] = v$1 * s$1 + b$2 * u$1 + w$1 * f$1 + _$2 * g$2, t$1[7] = v$1 * a + b$2 * c$1 + w$1 * d$1 + _$2 * x$1, t$1[8] = (v$1 = r$1[8]) * n$1 + (b$2 = r$1[9]) * o$1 + (w$1 = r$1[10]) * h$1 + (_$2 = r$1[11]) * y$1, t$1[9] = v$1 * i$1 + b$2 * l$1 + w$1 * p$1 + _$2 * m$1, t$1[10] = v$1 * s$1 + b$2 * u$1 + w$1 * f$1 + _$2 * g$2, t$1[11] = v$1 * a + b$2 * c$1 + w$1 * d$1 + _$2 * x$1, t$1[12] = (v$1 = r$1[12]) * n$1 + (b$2 = r$1[13]) * o$1 + (w$1 = r$1[14]) * h$1 + (_$2 = r$1[15]) * y$1, t$1[13] = v$1 * i$1 + b$2 * l$1 + w$1 * p$1 + _$2 * m$1, t$1[14] = v$1 * s$1 + b$2 * u$1 + w$1 * f$1 + _$2 * g$2, t$1[15] = v$1 * a + b$2 * c$1 + w$1 * d$1 + _$2 * x$1, t$1;
			}, t.P = r, t.Q = function(t$1, e$1) {
				const r$1 = {};
				for (let n$1 = 0; n$1 < e$1.length; n$1++) {
					const i$1 = e$1[n$1];
					i$1 in t$1 && (r$1[i$1] = t$1[i$1]);
				}
				return r$1;
			}, t.R = rl$1, t.S = ch, t.T = hl$1, t.U = dh, t.V = fh, t.W = c, t.X = h, t.Y = K$1, t.Z = _h, t._ = e, t.a = at$2, t.a$ = S$1, t.a0 = function(t$1, e$1) {
				var r$1, n$1, i$1, s$1;
				if (!t$1) return null != e$1 ? e$1 : {};
				if (!e$1) return t$1;
				const a = Object.assign({}, t$1);
				if (e$1.removeAll && (a.removeAll = !0), e$1.remove) {
					const t$2 = new Set(a.remove ? a.remove.concat(e$1.remove) : e$1.remove);
					a.remove = Array.from(t$2.values());
				}
				if (e$1.add) {
					const t$2 = a.add ? a.add.concat(e$1.add) : e$1.add, r$2 = new Map(t$2.map(((t$3) => [t$3.id, t$3])));
					a.add = Array.from(r$2.values());
				}
				if (e$1.update) {
					const t$2 = new Map(null === (r$1 = a.update) || void 0 === r$1 ? void 0 : r$1.map(((t$3) => [t$3.id, t$3])));
					for (const r$2 of e$1.update) {
						const e$2 = null !== (n$1 = t$2.get(r$2.id)) && void 0 !== n$1 ? n$1 : { id: r$2.id };
						r$2.newGeometry && (e$2.newGeometry = r$2.newGeometry), r$2.addOrUpdateProperties && (e$2.addOrUpdateProperties = (null !== (i$1 = e$2.addOrUpdateProperties) && void 0 !== i$1 ? i$1 : []).concat(r$2.addOrUpdateProperties)), r$2.removeProperties && (e$2.removeProperties = (null !== (s$1 = e$2.removeProperties) && void 0 !== s$1 ? s$1 : []).concat(r$2.removeProperties)), r$2.removeAllProperties && (e$2.removeAllProperties = !0), t$2.set(r$2.id, e$2);
					}
					a.update = Array.from(t$2.values());
				}
				return a;
			}, t.a1 = xh, t.a2 = kh, t.a3 = 25, t.a4 = bh, t.a5 = (t$1) => {
				const e$1 = window.document.createElement("video");
				return e$1.muted = !0, new Promise(((r$1) => {
					e$1.onloadstart = () => {
						r$1(e$1);
					};
					for (const r$2 of t$1) {
						const t$2 = window.document.createElement("source");
						pt$1(r$2) || (e$1.crossOrigin = "Anonymous"), t$2.src = r$2, e$1.appendChild(t$2);
					}
				}));
			}, t.a6 = Ct$1, t.a7 = function() {
				return D$1++;
			}, t.a8 = va$1, t.a9 = Yc, t.aA = function(t$1) {
				let e$1 = Infinity, r$1 = Infinity, n$1 = -Infinity, i$1 = -Infinity;
				for (const s$1 of t$1) e$1 = Math.min(e$1, s$1.x), r$1 = Math.min(r$1, s$1.y), n$1 = Math.max(n$1, s$1.x), i$1 = Math.max(i$1, s$1.y);
				return [
					e$1,
					r$1,
					n$1,
					i$1
				];
			}, t.aB = Zu$1, t.aC = C, t.aD = function(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (!r$1[0] && !r$1[1]) return [0, 0];
				const s$1 = i$1 ? "map" === n$1 ? -t$1.bearingInRadians : 0 : "viewport" === n$1 ? t$1.bearingInRadians : 0;
				if (s$1) {
					const t$2 = Math.sin(s$1), e$2 = Math.cos(s$1);
					r$1 = [r$1[0] * e$2 - r$1[1] * t$2, r$1[0] * t$2 + r$1[1] * e$2];
				}
				return [i$1 ? r$1[0] : C(e$1, r$1[0], t$1.zoom), i$1 ? r$1[1] : C(e$1, r$1[1], t$1.zoom)];
			}, t.aF = Uc$1, t.aG = tp, t.aH = zc$1, t.aI = ap$1, t.aJ = Zs$1, t.aK = Gl$1, t.aL = Ca$1, t.aM = Xa$1, t.aN = ja$1, t.aO = L$1, t.aP = et$1, t.aQ = gh, t.aR = b$1, t.aS = v, t.aT = function(t$1) {
				var e$1 = new f(3);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1;
			}, t.aU = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1[2] = e$1[2] - r$1[2], t$1;
			}, t.aV = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
				return s$1 > 0 && (s$1 = 1 / Math.sqrt(s$1)), t$1[0] = e$1[0] * s$1, t$1[1] = e$1[1] * s$1, t$1[2] = e$1[2] * s$1, t$1;
			}, t.aW = w, t.aX = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2];
			}, t.aY = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1[0], t$1[1] = e$1[1] * r$1[1], t$1[2] = e$1[2] * r$1[2], t$1[3] = e$1[3] * r$1[3], t$1;
			}, t.aZ = g$1, t.a_ = function(t$1, e$1, r$1) {
				const n$1 = e$1[0] * r$1[0] + e$1[1] * r$1[1] + e$1[2] * r$1[2];
				return 0 === n$1 ? null : (-(t$1[0] * r$1[0] + t$1[1] * r$1[1] + t$1[2] * r$1[2]) - r$1[3]) / n$1;
			}, t.aa = hi$1, t.ab = Mo$1, t.ac = Ih, t.ad = function(t$1) {
				const e$1 = {};
				if (t$1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t$2, r$1, n$1, i$1) => {
					const s$1 = n$1 || i$1;
					return e$1[r$1] = !s$1 || s$1.toLowerCase(), "";
				})), e$1["max-age"]) {
					const t$2 = parseInt(e$1["max-age"], 10);
					isNaN(t$2) ? delete e$1["max-age"] : e$1["max-age"] = t$2;
				}
				return e$1;
			}, t.ae = tt$1, t.af = function(t$1) {
				return Math.pow(2, t$1);
			}, t.ag = y, t.ah = $$1, t.ai = 85.051129, t.aj = yh, t.ak = function(t$1) {
				return Math.log(t$1) / Math.LN2;
			}, t.al = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return e$1 * e$1 + r$1 * r$1;
			}, t.am = function(t$1, e$1) {
				const r$1 = [];
				for (const n$1 in t$1) n$1 in e$1 || r$1.push(n$1);
				return r$1;
			}, t.an = function(t$1, e$1) {
				let r$1 = 0, n$1 = 0;
				if ("constant" === t$1.kind) n$1 = t$1.layoutSize;
				else if ("source" !== t$1.kind) {
					const { interpolationType: i$1, minZoom: s$1, maxZoom: a } = t$1, o$1 = i$1 ? $$1(pr$1.interpolationFactor(i$1, e$1, s$1, a), 0, 1) : 0;
					"camera" === t$1.kind ? n$1 = dr$1.number(t$1.minSize, t$1.maxSize, o$1) : r$1 = o$1;
				}
				return {
					uSizeT: r$1,
					uSize: n$1
				};
			}, t.ap = function(t$1, { uSize: e$1, uSizeT: r$1 }, { lowerSize: n$1, upperSize: i$1 }) {
				return "source" === t$1.kind ? n$1 / Oc$1 : "composite" === t$1.kind ? dr$1.number(n$1 / Oc$1, i$1 / Oc$1, r$1) : e$1;
			}, t.aq = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a = e$1[4], o$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = e$1[9], p$1 = e$1[10], f$1 = e$1[11], d$1 = e$1[12], y$1 = e$1[13], m$1 = e$1[14], g$2 = e$1[15], x$1 = r$1 * o$1 - n$1 * a, v$1 = r$1 * l$1 - i$1 * a, b$2 = r$1 * u$1 - s$1 * a, w$1 = n$1 * l$1 - i$1 * o$1, _$2 = n$1 * u$1 - s$1 * o$1, S$2 = i$1 * u$1 - s$1 * l$1, A$1 = c$1 * y$1 - h$1 * d$1, k$2 = c$1 * m$1 - p$1 * d$1, M$2 = c$1 * g$2 - f$1 * d$1, I$2 = h$1 * m$1 - p$1 * y$1, z$2 = h$1 * g$2 - f$1 * y$1, P$2 = p$1 * g$2 - f$1 * m$1, C$1 = x$1 * P$2 - v$1 * z$2 + b$2 * I$2 + w$1 * M$2 - _$2 * k$2 + S$2 * A$1;
				return C$1 ? (t$1[0] = (o$1 * P$2 - l$1 * z$2 + u$1 * I$2) * (C$1 = 1 / C$1), t$1[1] = (i$1 * z$2 - n$1 * P$2 - s$1 * I$2) * C$1, t$1[2] = (y$1 * S$2 - m$1 * _$2 + g$2 * w$1) * C$1, t$1[3] = (p$1 * _$2 - h$1 * S$2 - f$1 * w$1) * C$1, t$1[4] = (l$1 * M$2 - a * P$2 - u$1 * k$2) * C$1, t$1[5] = (r$1 * P$2 - i$1 * M$2 + s$1 * k$2) * C$1, t$1[6] = (m$1 * b$2 - d$1 * S$2 - g$2 * v$1) * C$1, t$1[7] = (c$1 * S$2 - p$1 * b$2 + f$1 * v$1) * C$1, t$1[8] = (a * z$2 - o$1 * M$2 + u$1 * A$1) * C$1, t$1[9] = (n$1 * M$2 - r$1 * z$2 - s$1 * A$1) * C$1, t$1[10] = (d$1 * _$2 - y$1 * b$2 + g$2 * x$1) * C$1, t$1[11] = (h$1 * b$2 - c$1 * _$2 - f$1 * x$1) * C$1, t$1[12] = (o$1 * k$2 - a * I$2 - l$1 * A$1) * C$1, t$1[13] = (r$1 * I$2 - n$1 * k$2 + i$1 * A$1) * C$1, t$1[14] = (y$1 * v$1 - d$1 * w$1 - m$1 * x$1) * C$1, t$1[15] = (c$1 * w$1 - h$1 * v$1 + p$1 * x$1) * C$1, t$1) : null;
			}, t.ar = I$1, t.as = function(t$1) {
				return Math.hypot(t$1[0], t$1[1]);
			}, t.at = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1;
			}, t.au = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1;
			}, t.av = qc$1, t.aw = A, t.ax = function(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.y - t$1.y, a = e$1.x - t$1.x, o$1 = i$1.y - n$1.y, l$1 = i$1.x - n$1.x, u$1 = o$1 * a - l$1 * s$1;
				if (0 === u$1) return null;
				const c$1 = (l$1 * (t$1.y - n$1.y) - o$1 * (t$1.x - n$1.x)) / u$1;
				return new r(t$1.x + c$1 * a, t$1.y + c$1 * s$1);
			}, t.ay = Eh, t.az = Co$1, t.b = Y$1, t.b$ = class extends oa$1 {}, t.b0 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1[3] = e$1[3] * r$1, t$1;
			}, t.b1 = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3];
			}, t.b2 = wh, t.b3 = Sh, t.b4 = function(t$1, e$1, r$1, n$1, i$1) {
				var s$1, a = 1 / Math.tan(e$1 / 2);
				return t$1[0] = a / r$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = a, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = -1, t$1[12] = 0, t$1[13] = 0, t$1[15] = 0, null != i$1 && i$1 !== Infinity ? (t$1[10] = (i$1 + n$1) * (s$1 = 1 / (n$1 - i$1)), t$1[14] = 2 * i$1 * n$1 * s$1) : (t$1[10] = -1, t$1[14] = -2 * n$1), t$1;
			}, t.b5 = function(t$1) {
				var e$1 = new f(16);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1[3] = t$1[3], e$1[4] = t$1[4], e$1[5] = t$1[5], e$1[6] = t$1[6], e$1[7] = t$1[7], e$1[8] = t$1[8], e$1[9] = t$1[9], e$1[10] = t$1[10], e$1[11] = t$1[11], e$1[12] = t$1[12], e$1[13] = t$1[13], e$1[14] = t$1[14], e$1[15] = t$1[15], e$1;
			}, t.b6 = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[4], c$1 = e$1[5], h$1 = e$1[6], p$1 = e$1[7];
				return e$1 !== t$1 && (t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 + u$1 * n$1, t$1[1] = a * i$1 + c$1 * n$1, t$1[2] = o$1 * i$1 + h$1 * n$1, t$1[3] = l$1 * i$1 + p$1 * n$1, t$1[4] = u$1 * i$1 - s$1 * n$1, t$1[5] = c$1 * i$1 - a * n$1, t$1[6] = h$1 * i$1 - o$1 * n$1, t$1[7] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.b7 = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[4], a = e$1[5], o$1 = e$1[6], l$1 = e$1[7], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[4] = s$1 * i$1 + u$1 * n$1, t$1[5] = a * i$1 + c$1 * n$1, t$1[6] = o$1 * i$1 + h$1 * n$1, t$1[7] = l$1 * i$1 + p$1 * n$1, t$1[8] = u$1 * i$1 - s$1 * n$1, t$1[9] = c$1 * i$1 - a * n$1, t$1[10] = h$1 * i$1 - o$1 * n$1, t$1[11] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.b8 = function() {
				const t$1 = new Float32Array(16);
				return y(t$1), t$1;
			}, t.b9 = function() {
				const t$1 = new Float64Array(16);
				return y(t$1), t$1;
			}, t.bA = function(t$1, e$1) {
				const r$1 = E(t$1, 360), n$1 = E(e$1, 360), i$1 = n$1 - r$1, s$1 = n$1 > r$1 ? i$1 - 360 : i$1 + 360;
				return Math.abs(i$1) < Math.abs(s$1) ? i$1 : s$1;
			}, t.bB = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1;
			}, t.bC = function(t$1, e$1, r$1, n$1) {
				const i$1 = Math.sqrt(t$1 * t$1 + e$1 * e$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
				t$1 /= i$1, e$1 /= i$1, r$1 /= s$1, n$1 /= s$1;
				const a = Math.acos(t$1 * r$1 + e$1 * n$1);
				return -e$1 * r$1 + t$1 * n$1 > 0 ? a : -a;
			}, t.bD = function(t$1, e$1) {
				const r$1 = E(t$1, 2 * Math.PI), n$1 = E(e$1, 2 * Math.PI);
				return Math.min(Math.abs(r$1 - n$1), Math.abs(r$1 - n$1 + 2 * Math.PI), Math.abs(r$1 - n$1 - 2 * Math.PI));
			}, t.bE = function() {
				const t$1 = {}, e$1 = xt$1.$version;
				for (const r$1 in xt$1.$root) {
					const n$1 = xt$1.$root[r$1];
					if (n$1.required) {
						let i$1 = null;
						i$1 = "version" === r$1 ? e$1 : "array" === n$1.type ? [] : {}, null != i$1 && (t$1[r$1] = i$1);
					}
				}
				return t$1;
			}, t.bF = ps$1, t.bG = ct, t.bH = function t$1(e$1, r$1) {
				if (Array.isArray(e$1)) {
					if (!Array.isArray(r$1) || e$1.length !== r$1.length) return !1;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				if ("object" == typeof e$1 && null !== e$1 && null !== r$1) {
					if ("object" != typeof r$1) return !1;
					if (Object.keys(e$1).length !== Object.keys(r$1).length) return !1;
					for (const n$1 in e$1) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				return e$1 === r$1;
			}, t.bI = function(t$1) {
				t$1 = t$1.slice();
				const e$1 = Object.create(null);
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[t$1[r$1].id] = t$1[r$1];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) "ref" in t$1[r$1] && (t$1[r$1] = bt$1(t$1[r$1], e$1[t$1[r$1].ref]));
				return t$1;
			}, t.bJ = function(t$1) {
				if ("custom" === t$1.type) return new ah(t$1);
				switch (t$1.type) {
					case "background": return new rh(t$1);
					case "circle": return new Zo$1(t$1);
					case "color-relief": return new dl$1(t$1);
					case "fill": return new iu$1(t$1);
					case "fill-extrusion": return new Su$1(t$1);
					case "heatmap": return new sl$1(t$1);
					case "hillshade": return new ll$1(t$1);
					case "line": return new Ou$1(t$1);
					case "raster": return new sh(t$1);
					case "symbol": return new Qc(t$1);
				}
			}, t.bK = j$1, t.bL = function(t$1, e$1) {
				if (!t$1) return [{
					command: "setStyle",
					args: [e$1]
				}];
				let r$1 = [];
				try {
					if (!wt$1(t$1.version, e$1.version)) return [{
						command: "setStyle",
						args: [e$1]
					}];
					wt$1(t$1.center, e$1.center) || r$1.push({
						command: "setCenter",
						args: [e$1.center]
					}), wt$1(t$1.state, e$1.state) || r$1.push({
						command: "setGlobalState",
						args: [e$1.state]
					}), wt$1(t$1.centerAltitude, e$1.centerAltitude) || r$1.push({
						command: "setCenterAltitude",
						args: [e$1.centerAltitude]
					}), wt$1(t$1.zoom, e$1.zoom) || r$1.push({
						command: "setZoom",
						args: [e$1.zoom]
					}), wt$1(t$1.bearing, e$1.bearing) || r$1.push({
						command: "setBearing",
						args: [e$1.bearing]
					}), wt$1(t$1.pitch, e$1.pitch) || r$1.push({
						command: "setPitch",
						args: [e$1.pitch]
					}), wt$1(t$1.roll, e$1.roll) || r$1.push({
						command: "setRoll",
						args: [e$1.roll]
					}), wt$1(t$1.sprite, e$1.sprite) || r$1.push({
						command: "setSprite",
						args: [e$1.sprite]
					}), wt$1(t$1.glyphs, e$1.glyphs) || r$1.push({
						command: "setGlyphs",
						args: [e$1.glyphs]
					}), wt$1(t$1.transition, e$1.transition) || r$1.push({
						command: "setTransition",
						args: [e$1.transition]
					}), wt$1(t$1.light, e$1.light) || r$1.push({
						command: "setLight",
						args: [e$1.light]
					}), wt$1(t$1.terrain, e$1.terrain) || r$1.push({
						command: "setTerrain",
						args: [e$1.terrain]
					}), wt$1(t$1.sky, e$1.sky) || r$1.push({
						command: "setSky",
						args: [e$1.sky]
					}), wt$1(t$1.projection, e$1.projection) || r$1.push({
						command: "setProjection",
						args: [e$1.projection]
					});
					const n$1 = {}, i$1 = [];
					(function(t$2, e$2, r$2, n$2) {
						let i$2;
						for (i$2 in e$2 = e$2 || {}, t$2 = t$2 || {}) Object.prototype.hasOwnProperty.call(t$2, i$2) && (Object.prototype.hasOwnProperty.call(e$2, i$2) || At$1(i$2, r$2, n$2));
						for (i$2 in e$2) Object.prototype.hasOwnProperty.call(e$2, i$2) && (Object.prototype.hasOwnProperty.call(t$2, i$2) ? wt$1(t$2[i$2], e$2[i$2]) || ("geojson" === t$2[i$2].type && "geojson" === e$2[i$2].type && Mt$1(t$2, e$2, i$2) ? _t$1(r$2, {
							command: "setGeoJSONSourceData",
							args: [i$2, e$2[i$2].data]
						}) : kt$1(i$2, e$2, r$2, n$2)) : St$1(i$2, e$2, r$2));
					})(t$1.sources, e$1.sources, i$1, n$1);
					const s$1 = [];
					t$1.layers && t$1.layers.forEach(((t$2) => {
						"source" in t$2 && n$1[t$2.source] ? r$1.push({
							command: "removeLayer",
							args: [t$2.id]
						}) : s$1.push(t$2);
					})), r$1 = r$1.concat(i$1), function(t$2, e$2, r$2) {
						e$2 = e$2 || [];
						const n$2 = (t$2 = t$2 || []).map(zt), i$2 = e$2.map(zt), s$2 = t$2.reduce(Pt$1, {}), a = e$2.reduce(Pt$1, {}), o$1 = n$2.slice(), l$1 = Object.create(null);
						let u$1, c$1, h$1, p$1, f$1;
						for (let t$3 = 0, e$3 = 0; t$3 < n$2.length; t$3++) u$1 = n$2[t$3], Object.prototype.hasOwnProperty.call(a, u$1) ? e$3++ : (_t$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.indexOf(u$1, e$3), 1));
						for (let t$3 = 0, e$3 = 0; t$3 < i$2.length; t$3++) u$1 = i$2[i$2.length - 1 - t$3], o$1[o$1.length - 1 - t$3] !== u$1 && (Object.prototype.hasOwnProperty.call(s$2, u$1) ? (_t$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.lastIndexOf(u$1, o$1.length - e$3), 1)) : e$3++, p$1 = o$1[o$1.length - t$3], _t$1(r$2, {
							command: "addLayer",
							args: [a[u$1], p$1]
						}), o$1.splice(o$1.length - t$3, 0, u$1), l$1[u$1] = !0);
						for (let t$3 = 0; t$3 < i$2.length; t$3++) if (u$1 = i$2[t$3], c$1 = s$2[u$1], h$1 = a[u$1], !l$1[u$1] && !wt$1(c$1, h$1)) if (wt$1(c$1.source, h$1.source) && wt$1(c$1["source-layer"], h$1["source-layer"]) && wt$1(c$1.type, h$1.type)) {
							for (f$1 in It$1(c$1.layout, h$1.layout, r$2, u$1, null, "setLayoutProperty"), It$1(c$1.paint, h$1.paint, r$2, u$1, null, "setPaintProperty"), wt$1(c$1.filter, h$1.filter) || _t$1(r$2, {
								command: "setFilter",
								args: [u$1, h$1.filter]
							}), wt$1(c$1.minzoom, h$1.minzoom) && wt$1(c$1.maxzoom, h$1.maxzoom) || _t$1(r$2, {
								command: "setLayerZoomRange",
								args: [
									u$1,
									h$1.minzoom,
									h$1.maxzoom
								]
							}), c$1) Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It$1(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : wt$1(c$1[f$1], h$1[f$1]) || _t$1(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
							for (f$1 in h$1) Object.prototype.hasOwnProperty.call(h$1, f$1) && !Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It$1(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : wt$1(c$1[f$1], h$1[f$1]) || _t$1(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
						} else _t$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), p$1 = o$1[o$1.lastIndexOf(u$1) + 1], _t$1(r$2, {
							command: "addLayer",
							args: [h$1, p$1]
						});
					}(s$1, e$1.layers, r$1);
				} catch (t$2) {
					console.warn("Unable to compute style diff:", t$2), r$1 = [{
						command: "setStyle",
						args: [e$1]
					}];
				}
				return r$1;
			}, t.bM = function(t$1) {
				const e$1 = [], r$1 = t$1.id;
				return void 0 === r$1 && e$1.push({ message: `layers.${r$1}: missing required property "id"` }), void 0 === t$1.render && e$1.push({ message: `layers.${r$1}: missing required method "render"` }), t$1.renderingMode && "2d" !== t$1.renderingMode && "3d" !== t$1.renderingMode && e$1.push({ message: `layers.${r$1}: property "renderingMode" must be either "2d" or "3d"` }), e$1;
			}, t.bN = R$2, t.bO = U$1, t.bP = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1i(this.location, t$1));
				}
			}, t.bQ = co$1, t.bR = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = ho$1;
				}
				set(t$1) {
					if (t$1[12] !== this.current[12] || t$1[0] !== this.current[0]) return this.current = t$1, void this.gl.uniformMatrix4fv(this.location, !1, t$1);
					for (let e$1 = 1; e$1 < 16; e$1++) if (t$1[e$1] !== this.current[e$1]) {
						this.current = t$1, this.gl.uniformMatrix4fv(this.location, !1, t$1);
						break;
					}
				}
			}, t.bS = uo$1, t.bT = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] || (this.current = t$1, this.gl.uniform3f(this.location, t$1[0], t$1[1], t$1[2]));
				}
			}, t.bU = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [0, 0];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] || (this.current = t$1, this.gl.uniform2f(this.location, t$1[0], t$1[1]));
				}
			}, t.bV = d, t.bW = function(t$1, e$1) {
				var r$1 = Math.sin(e$1), n$1 = Math.cos(e$1);
				return t$1[0] = n$1, t$1[1] = r$1, t$1[2] = 0, t$1[3] = -r$1, t$1[4] = n$1, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 1, t$1;
			}, t.bX = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2];
				return t$1[0] = n$1 * r$1[0] + i$1 * r$1[3] + s$1 * r$1[6], t$1[1] = n$1 * r$1[1] + i$1 * r$1[4] + s$1 * r$1[7], t$1[2] = n$1 * r$1[2] + i$1 * r$1[5] + s$1 * r$1[8], t$1;
			}, t.bY = function(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				var o$1 = 1 / (e$1 - r$1), l$1 = 1 / (n$1 - i$1), u$1 = 1 / (s$1 - a);
				return t$1[0] = -2 * o$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = -2 * l$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 2 * u$1, t$1[11] = 0, t$1[12] = (e$1 + r$1) * o$1, t$1[13] = (i$1 + n$1) * l$1, t$1[14] = (a + s$1) * u$1, t$1[15] = 1, t$1;
			}, t.bZ = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(4 * t$1.length);
						for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[4 * r$1] = t$1[r$1].r, e$1[4 * r$1 + 1] = t$1[r$1].g, e$1[4 * r$1 + 2] = t$1[r$1].b, e$1[4 * r$1 + 3] = t$1[r$1].a;
						this.gl.uniform4fv(this.location, e$1);
					}
				}
			}, t.b_ = class extends oo$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(t$1);
						this.gl.uniform1fv(this.location, e$1);
					}
				}
			}, t.ba = function() {
				return new Float64Array(16);
			}, t.bb = function(t$1, e$1, r$1) {
				const n$1 = new Float64Array(4);
				return M$1(n$1, t$1, e$1 - 90, r$1), n$1;
			}, t.bc = function(t$1, e$1, r$1, n$1) {
				var i$1, s$1, a, o$1, l$1, u$1 = e$1[0], c$1 = e$1[1], h$1 = e$1[2], f$1 = e$1[3], d$1 = r$1[0], y$1 = r$1[1], m$1 = r$1[2], g$2 = r$1[3];
				return (s$1 = u$1 * d$1 + c$1 * y$1 + h$1 * m$1 + f$1 * g$2) < 0 && (s$1 = -s$1, d$1 = -d$1, y$1 = -y$1, m$1 = -m$1, g$2 = -g$2), 1 - s$1 > p ? (i$1 = Math.acos(s$1), a = Math.sin(i$1), o$1 = Math.sin((1 - n$1) * i$1) / a, l$1 = Math.sin(n$1 * i$1) / a) : (o$1 = 1 - n$1, l$1 = n$1), t$1[0] = o$1 * u$1 + l$1 * d$1, t$1[1] = o$1 * c$1 + l$1 * y$1, t$1[2] = o$1 * h$1 + l$1 * m$1, t$1[3] = o$1 * f$1 + l$1 * g$2, t$1;
			}, t.bd = function(t$1) {
				const e$1 = new Float64Array(9);
				var r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1 = (i$1 = (n$1 = t$1)[0]) * (l$1 = i$1 + i$1), p$1 = (s$1 = n$1[1]) * l$1, f$1, d$1 = (a = n$1[2]) * l$1, y$1 = a * (u$1 = s$1 + s$1), m$1, g$2 = (o$1 = n$1[3]) * l$1, x$1 = o$1 * u$1, v$1 = o$1 * (c$1 = a + a);
				(r$1 = e$1)[0] = 1 - (f$1 = s$1 * u$1) - (m$1 = a * c$1), r$1[3] = p$1 - v$1, r$1[6] = d$1 + x$1, r$1[1] = p$1 + v$1, r$1[4] = 1 - h$1 - m$1, r$1[7] = y$1 - g$2, r$1[2] = d$1 - x$1, r$1[5] = y$1 + g$2, r$1[8] = 1 - h$1 - f$1;
				const b$2 = et$1(-Math.asin($$1(e$1[2], -1, 1)));
				let w$1, _$2;
				return Math.hypot(e$1[5], e$1[8]) < .001 ? (w$1 = 0, _$2 = -et$1(Math.atan2(e$1[3], e$1[4]))) : (w$1 = et$1(0 === e$1[5] && 0 === e$1[8] ? 0 : Math.atan2(e$1[5], e$1[8])), _$2 = et$1(0 === e$1[1] && 0 === e$1[0] ? 0 : Math.atan2(e$1[1], e$1[0]))), {
					roll: w$1,
					pitch: b$2 + 90,
					bearing: _$2
				};
			}, t.be = function(t$1, e$1) {
				return t$1.roll == e$1.roll && t$1.pitch == e$1.pitch && t$1.bearing == e$1.bearing;
			}, t.bf = Me$1, t.bg = lo$1, t.bh = Xl$1, t.bi = Zl$1, t.bj = ql$1, t.bk = B$1, t.bl = V, t.bm = Oe$1, t.bn = function(t$1, e$1, r$1, n$1, i$1) {
				return B$1(n$1, i$1, $$1((t$1 - e$1) / (r$1 - e$1), 0, 1));
			}, t.bo = E, t.bp = function() {
				return new Float64Array(3);
			}, t.bq = function(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1[0] + r$1[0] * n$1, t$1[1] = e$1[1] + r$1[1] * n$1, t$1[2] = e$1[2] + r$1[2] * n$1, t$1;
			}, t.br = M$1, t.bs = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2], a = e$1[0], o$1 = e$1[1], l$1 = e$1[2], u$1 = i$1 * l$1 - s$1 * o$1, c$1 = s$1 * a - n$1 * l$1, h$1 = n$1 * o$1 - i$1 * a, p$1 = i$1 * h$1 - s$1 * c$1, f$1 = s$1 * u$1 - n$1 * h$1, d$1 = n$1 * c$1 - i$1 * u$1, y$1 = 2 * r$1[3];
				return c$1 *= y$1, h$1 *= y$1, f$1 *= 2, d$1 *= 2, t$1[0] = a + (u$1 *= y$1) + (p$1 *= 2), t$1[1] = o$1 + c$1 + f$1, t$1[2] = l$1 + h$1 + d$1, t$1;
			}, t.bt = function(t$1, e$1, r$1) {
				const n$1 = (i$1 = [
					t$1[0],
					t$1[1],
					t$1[2],
					e$1[0],
					e$1[1],
					e$1[2],
					r$1[0],
					r$1[1],
					r$1[2]
				])[0] * ((c$1 = i$1[8]) * (a = i$1[4]) - (o$1 = i$1[5]) * (u$1 = i$1[7])) + i$1[1] * (-c$1 * (s$1 = i$1[3]) + o$1 * (l$1 = i$1[6])) + i$1[2] * (u$1 * s$1 - a * l$1);
				var i$1, s$1, a, o$1, l$1, u$1, c$1;
				if (0 === n$1) return null;
				const h$1 = w([], [
					e$1[0],
					e$1[1],
					e$1[2]
				], [
					r$1[0],
					r$1[1],
					r$1[2]
				]), p$1 = w([], [
					r$1[0],
					r$1[1],
					r$1[2]
				], [
					t$1[0],
					t$1[1],
					t$1[2]
				]), f$1 = w([], [
					t$1[0],
					t$1[1],
					t$1[2]
				], [
					e$1[0],
					e$1[1],
					e$1[2]
				]), d$1 = b$1([], h$1, -t$1[3]);
				return v(d$1, d$1, b$1([], p$1, -e$1[3])), v(d$1, d$1, b$1([], f$1, -r$1[3])), b$1(d$1, d$1, 1 / n$1), d$1;
			}, t.bu = uh, t.bv = function() {
				return new Float64Array(4);
			}, t.bw = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0] * Math.cos(n$1) - i$1[1] * Math.sin(n$1), s$1[1] = i$1[0] * Math.sin(n$1) + i$1[1] * Math.cos(n$1), s$1[2] = i$1[2], t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bx = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0], s$1[1] = i$1[1] * Math.cos(n$1) - i$1[2] * Math.sin(n$1), s$1[2] = i$1[1] * Math.sin(n$1) + i$1[2] * Math.cos(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.by = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[2] * Math.sin(n$1) + i$1[0] * Math.cos(n$1), s$1[1] = i$1[1], s$1[2] = i$1[2] * Math.cos(n$1) - i$1[0] * Math.sin(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bz = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 - u$1 * n$1, t$1[1] = a * i$1 - c$1 * n$1, t$1[2] = o$1 * i$1 - h$1 * n$1, t$1[3] = l$1 * i$1 - p$1 * n$1, t$1[8] = s$1 * n$1 + u$1 * i$1, t$1[9] = a * n$1 + c$1 * i$1, t$1[10] = o$1 * n$1 + h$1 * i$1, t$1[11] = l$1 * n$1 + p$1 * i$1, t$1;
			}, t.c = st$1, t.c0 = qu$1, t.c1 = class extends ua$1 {}, t.c2 = il$1, t.c3 = function(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t$1) / Math.LN2));
			}, t.c4 = nl, t.c5 = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15];
				return t$1[0] = (r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12]) / (a = a || 1), t$1[1] = (r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13]) / a, t$1[2] = (r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14]) / a, t$1;
			}, t.c6 = class extends Js$1 {}, t.c7 = class extends ma$1 {}, t.c8 = function(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2] && t$1[3] === e$1[3] && t$1[4] === e$1[4] && t$1[5] === e$1[5] && t$1[6] === e$1[6] && t$1[7] === e$1[7] && t$1[8] === e$1[8] && t$1[9] === e$1[9] && t$1[10] === e$1[10] && t$1[11] === e$1[11] && t$1[12] === e$1[12] && t$1[13] === e$1[13] && t$1[14] === e$1[14] && t$1[15] === e$1[15];
			}, t.c9 = function(t$1, e$1) {
				var r$1 = t$1[0], n$1 = t$1[1], i$1 = t$1[2], s$1 = t$1[3], a = t$1[4], o$1 = t$1[5], l$1 = t$1[6], u$1 = t$1[7], c$1 = t$1[8], h$1 = t$1[9], f$1 = t$1[10], d$1 = t$1[11], y$1 = t$1[12], m$1 = t$1[13], g$2 = t$1[14], x$1 = t$1[15], v$1 = e$1[0], b$2 = e$1[1], w$1 = e$1[2], _$2 = e$1[3], S$2 = e$1[4], A$1 = e$1[5], k$2 = e$1[6], M$2 = e$1[7], I$2 = e$1[8], z$2 = e$1[9], P$2 = e$1[10], C$1 = e$1[11], E$1 = e$1[12], B$2 = e$1[13], V$1 = e$1[14], T$2 = e$1[15];
				return Math.abs(r$1 - v$1) <= p * Math.max(1, Math.abs(r$1), Math.abs(v$1)) && Math.abs(n$1 - b$2) <= p * Math.max(1, Math.abs(n$1), Math.abs(b$2)) && Math.abs(i$1 - w$1) <= p * Math.max(1, Math.abs(i$1), Math.abs(w$1)) && Math.abs(s$1 - _$2) <= p * Math.max(1, Math.abs(s$1), Math.abs(_$2)) && Math.abs(a - S$2) <= p * Math.max(1, Math.abs(a), Math.abs(S$2)) && Math.abs(o$1 - A$1) <= p * Math.max(1, Math.abs(o$1), Math.abs(A$1)) && Math.abs(l$1 - k$2) <= p * Math.max(1, Math.abs(l$1), Math.abs(k$2)) && Math.abs(u$1 - M$2) <= p * Math.max(1, Math.abs(u$1), Math.abs(M$2)) && Math.abs(c$1 - I$2) <= p * Math.max(1, Math.abs(c$1), Math.abs(I$2)) && Math.abs(h$1 - z$2) <= p * Math.max(1, Math.abs(h$1), Math.abs(z$2)) && Math.abs(f$1 - P$2) <= p * Math.max(1, Math.abs(f$1), Math.abs(P$2)) && Math.abs(d$1 - C$1) <= p * Math.max(1, Math.abs(d$1), Math.abs(C$1)) && Math.abs(y$1 - E$1) <= p * Math.max(1, Math.abs(y$1), Math.abs(E$1)) && Math.abs(m$1 - B$2) <= p * Math.max(1, Math.abs(m$1), Math.abs(B$2)) && Math.abs(g$2 - V$1) <= p * Math.max(1, Math.abs(g$2), Math.abs(V$1)) && Math.abs(x$1 - T$2) <= p * Math.max(1, Math.abs(x$1), Math.abs(T$2));
			}, t.cA = function(t$1, e$1) {
				at$2.REGISTERED_PROTOCOLS[t$1] = e$1;
			}, t.cB = function(t$1) {
				delete at$2.REGISTERED_PROTOCOLS[t$1];
			}, t.cC = function(t$1, e$1) {
				const r$1 = {};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) {
					const i$1 = e$1 && e$1[t$1[n$2].id] || bi$1(t$1[n$2]);
					e$1 && (e$1[t$1[n$2].id] = i$1);
					let s$1 = r$1[i$1];
					s$1 || (s$1 = r$1[i$1] = []), s$1.push(t$1[n$2]);
				}
				const n$1 = [];
				for (const t$2 in r$1) n$1.push(r$1[t$2]);
				return n$1;
			}, t.cD = as$1, t.cE = Mh, t.cF = zh, t.cG = dc$1, t.cH = function(e$1) {
				e$1.bucket.createArrays(), e$1.bucket.tilePixelRatio = P$1 / (512 * e$1.bucket.overscaling), e$1.bucket.compareText = {}, e$1.bucket.iconsNeedLinear = !1;
				const r$1 = e$1.bucket.layers[0], n$1 = r$1.layout, i$1 = r$1._unevaluatedLayout._values, s$1 = {
					layoutIconSize: i$1["icon-size"].possiblyEvaluate(new Is$1(e$1.bucket.zoom + 1), e$1.canonical),
					layoutTextSize: i$1["text-size"].possiblyEvaluate(new Is$1(e$1.bucket.zoom + 1), e$1.canonical),
					textMaxSize: i$1["text-size"].possiblyEvaluate(new Is$1(18))
				};
				if ("composite" === e$1.bucket.textSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.textSizeData;
					s$1.compositeTextSizes = [i$1["text-size"].possiblyEvaluate(new Is$1(t$1), e$1.canonical), i$1["text-size"].possiblyEvaluate(new Is$1(r$2), e$1.canonical)];
				}
				if ("composite" === e$1.bucket.iconSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.iconSizeData;
					s$1.compositeIconSizes = [i$1["icon-size"].possiblyEvaluate(new Is$1(t$1), e$1.canonical), i$1["icon-size"].possiblyEvaluate(new Is$1(r$2), e$1.canonical)];
				}
				const a = n$1.get("text-line-height") * Zu$1, o$1 = "viewport" !== n$1.get("text-rotation-alignment") && "point" !== n$1.get("symbol-placement"), l$1 = n$1.get("text-keep-upright"), u$1 = n$1.get("text-size");
				for (const i$2 of e$1.bucket.features) {
					const c$1 = n$1.get("text-font").evaluate(i$2, {}, e$1.canonical).join(","), h$1 = u$1.evaluate(i$2, {}, e$1.canonical), p$1 = s$1.layoutTextSize.evaluate(i$2, {}, e$1.canonical), f$1 = s$1.layoutIconSize.evaluate(i$2, {}, e$1.canonical), d$1 = {
						horizontal: {},
						vertical: void 0
					}, y$1 = i$2.text;
					let m$1, g$2 = [0, 0];
					if (y$1) {
						const s$2 = y$1.toString(), u$2 = n$1.get("text-letter-spacing").evaluate(i$2, {}, e$1.canonical) * Zu$1, f$2 = ys$1(s$2) ? u$2 : 0, m$2 = n$1.get("text-anchor").evaluate(i$2, {}, e$1.canonical), x$2 = Qh(r$1, i$2, e$1.canonical);
						if (!x$2) {
							const t$1 = n$1.get("text-radial-offset").evaluate(i$2, {}, e$1.canonical);
							g$2 = t$1 ? Wh(m$2, [t$1 * Zu$1, Jh]) : n$1.get("text-offset").evaluate(i$2, {}, e$1.canonical).map(((t$2) => t$2 * Zu$1));
						}
						let v$2 = o$1 ? "center" : n$1.get("text-justify").evaluate(i$2, {}, e$1.canonical);
						const b$2 = "point" === n$1.get("symbol-placement") ? n$1.get("text-max-width").evaluate(i$2, {}, e$1.canonical) * Zu$1 : Infinity, w$1 = () => {
							e$1.bucket.allowVerticalPlacement && ds$1(s$2) && (d$1.vertical = xc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$2, a, m$2, "left", f$2, g$2, t.ao.vertical, !0, p$1, h$1));
						};
						if (!o$1 && x$2) {
							const r$2 = /* @__PURE__ */ new Set();
							if ("auto" === v$2) for (let t$1 = 0; t$1 < x$2.values.length; t$1 += 2) r$2.add(tp(x$2.values[t$1]));
							else r$2.add(v$2);
							let n$2 = !1;
							for (const i$3 of r$2) if (!d$1.horizontal[i$3]) if (n$2) d$1.horizontal[i$3] = d$1.horizontal[0];
							else {
								const r$3 = xc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$2, a, "center", i$3, f$2, g$2, t.ao.horizontal, !1, p$1, h$1);
								r$3 && (d$1.horizontal[i$3] = r$3, n$2 = 1 === r$3.positionedLines.length);
							}
							w$1();
						} else {
							"auto" === v$2 && (v$2 = tp(m$2));
							const r$2 = xc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$2, a, m$2, v$2, f$2, g$2, t.ao.horizontal, !1, p$1, h$1);
							r$2 && (d$1.horizontal[v$2] = r$2), w$1(), ds$1(s$2) && o$1 && l$1 && (d$1.vertical = xc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$2, a, m$2, v$2, f$2, g$2, t.ao.vertical, !1, p$1, h$1));
						}
					}
					let x$1 = !1;
					if (i$2.icon && i$2.icon.name) {
						const t$1 = e$1.imageMap[i$2.icon.name];
						t$1 && (m$1 = Fc$1(e$1.imagePositions[i$2.icon.name], n$1.get("icon-offset").evaluate(i$2, {}, e$1.canonical), n$1.get("icon-anchor").evaluate(i$2, {}, e$1.canonical)), x$1 = !!t$1.sdf, void 0 === e$1.bucket.sdfIcons ? e$1.bucket.sdfIcons = x$1 : e$1.bucket.sdfIcons !== x$1 && q$1("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t$1.pixelRatio !== e$1.bucket.pixelRatio || 0 !== n$1.get("icon-rotate").constantOr(1)) && (e$1.bucket.iconsNeedLinear = !0));
					}
					const v$1 = np$1(d$1.horizontal) || d$1.vertical;
					e$1.bucket.iconsInText = !!v$1 && v$1.iconsInText, (v$1 || m$1) && ep(e$1.bucket, i$2, d$1, m$1, e$1.imageMap, s$1, p$1, f$1, g$2, x$1, e$1.canonical, e$1.subdivisionGranularity);
				}
				e$1.showCollisionBoxes && e$1.bucket.generateCollisionDebugBuffers();
			}, t.cI = Bu$1, t.cJ = tu$1, t.cK = gu$1, t.cL = fu$1, t.cM = Ju$1, t.cN = class {
				constructor(t$1) {
					this._marks = {
						start: [t$1.url, "start"].join("#"),
						end: [t$1.url, "end"].join("#"),
						measure: t$1.url.toString()
					}, performance.mark(this._marks.start);
				}
				finish() {
					performance.mark(this._marks.end);
					let t$1 = performance.getEntriesByName(this._marks.measure);
					return 0 === t$1.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t$1 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t$1;
				}
			}, t.cO = function(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if (h()) try {
						return yield K$1(t$1, r$1, n$1, i$1, s$1);
					} catch (t$2) {}
					return function(t$2, e$1, r$2, n$2, i$2) {
						const s$2 = t$2.width, a = t$2.height;
						J$1 && W$1 || (J$1 = new OffscreenCanvas(s$2, a), W$1 = J$1.getContext("2d", { willReadFrequently: !0 })), J$1.width = s$2, J$1.height = a, W$1.drawImage(t$2, 0, 0, s$2, a);
						const o$1 = W$1.getImageData(e$1, r$2, n$2, i$2);
						return W$1.clearRect(0, 0, s$2, a), o$1.data;
					}(t$1, r$1, n$1, i$1, s$1);
				}));
			}, t.cP = pl$1, t.cQ = n, t.cR = hu$1, t.cS = lu$1, t.cT = ri$1, t.cU = function(t$1, e$1) {
				const r$1 = /* @__PURE__ */ new Map();
				if (null == t$1);
				else if ("Feature" === t$1.type) r$1.set(Ah(t$1, e$1), t$1);
				else for (const n$1 of t$1.features) r$1.set(Ah(n$1, e$1), n$1);
				return r$1;
			}, t.cV = function(t$1, e$1) {
				if (null == t$1) return !0;
				if ("Feature" === t$1.type) return null != Ah(t$1, e$1);
				if ("FeatureCollection" === t$1.type) {
					const r$1 = /* @__PURE__ */ new Set();
					for (const n$1 of t$1.features) {
						const t$2 = Ah(n$1, e$1);
						if (null == t$2) return !1;
						if (r$1.has(t$2)) return !1;
						r$1.add(t$2);
					}
					return !0;
				}
				return !1;
			}, t.cW = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, a;
				if (e$1.removeAll && t$1.clear(), e$1.remove) for (const r$2 of e$1.remove) t$1.delete(r$2);
				if (e$1.add) for (const n$2 of e$1.add) {
					const e$2 = Ah(n$2, r$1);
					null != e$2 && t$1.set(e$2, n$2);
				}
				if (e$1.update) for (const r$2 of e$1.update) {
					let e$2 = t$1.get(r$2.id);
					if (null == e$2) continue;
					const o$1 = !r$2.removeAllProperties && ((null === (n$1 = r$2.removeProperties) || void 0 === n$1 ? void 0 : n$1.length) > 0 || (null === (i$1 = r$2.addOrUpdateProperties) || void 0 === i$1 ? void 0 : i$1.length) > 0);
					if ((r$2.newGeometry || r$2.removeAllProperties || o$1) && (e$2 = Object.assign({}, e$2), t$1.set(r$2.id, e$2), o$1 && (e$2.properties = Object.assign({}, e$2.properties))), r$2.newGeometry && (e$2.geometry = r$2.newGeometry), r$2.removeAllProperties) e$2.properties = {};
					else if ((null === (s$1 = r$2.removeProperties) || void 0 === s$1 ? void 0 : s$1.length) > 0) for (const t$2 of r$2.removeProperties) Object.prototype.hasOwnProperty.call(e$2.properties, t$2) && delete e$2.properties[t$2];
					if ((null === (a = r$2.addOrUpdateProperties) || void 0 === a ? void 0 : a.length) > 0) for (const { key: t$2, value: n$2 } of r$2.addOrUpdateProperties) e$2.properties[t$2] = n$2;
				}
			}, t.cX = Ms$1, t.ca = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.cb = (t$1) => "symbol" === t$1.type, t.cc = (t$1) => "circle" === t$1.type, t.cd = (t$1) => "heatmap" === t$1.type, t.ce = (t$1) => "line" === t$1.type, t.cf = (t$1) => "fill" === t$1.type, t.cg = (t$1) => "fill-extrusion" === t$1.type, t.ch = (t$1) => "hillshade" === t$1.type, t.ci = (t$1) => "color-relief" === t$1.type, t.cj = (t$1) => "raster" === t$1.type, t.ck = (t$1) => "background" === t$1.type, t.cl = (t$1) => "custom" === t$1.type, t.cm = T$1, t.cn = function(t$1, e$1, r$1) {
				const n$1 = z$1(e$1.x - r$1.x, e$1.y - r$1.y), i$1 = z$1(t$1.x - r$1.x, t$1.y - r$1.y);
				var s$1, a;
				return et$1(Math.atan2(n$1[0] * i$1[1] - n$1[1] * i$1[0], (s$1 = n$1)[0] * (a = i$1)[0] + s$1[1] * a[1]));
			}, t.co = F$1, t.cp = function(t$1, e$1) {
				return nt$1[e$1] && (t$1 instanceof MouseEvent || t$1 instanceof WheelEvent);
			}, t.cq = function(t$1, e$1) {
				return rt$1[e$1] && "touches" in t$1;
			}, t.cr = function(t$1) {
				return rt$1[t$1] || nt$1[t$1];
			}, t.cs = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[12], t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[13], t$1;
			}, t.ct = function(t$1, e$1) {
				const { x: r$1, y: n$1 } = xh.fromLngLat(e$1);
				return !(t$1 < 0 || t$1 > 25 || n$1 < 0 || n$1 >= 1 || r$1 < 0 || r$1 >= 1);
			}, t.cu = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = e$1[1], t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = e$1[2], t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}, t.cv = class extends Ks$1 {}, t.cw = {
				mark(t$1) {
					performance.mark(t$1);
				},
				frame(t$1) {
					const e$1 = t$1;
					null != fp$1 && dp$1.push(e$1 - fp$1), fp$1 = e$1;
				},
				clearMetrics() {
					fp$1 = null, dp$1 = [], performance.clearMeasures(mp$1), performance.clearMeasures(gp$1);
					for (const e$1 in t.cx) performance.clearMarks(t.cx[e$1]);
				},
				getPerformanceMetrics() {
					performance.measure(mp$1, t.cx.create, t.cx.load), performance.measure(gp$1, t.cx.create, t.cx.fullLoad);
					const e$1 = performance.getEntriesByName(mp$1)[0].duration, r$1 = performance.getEntriesByName(gp$1)[0].duration, n$1 = dp$1.length, i$1 = 1 / (dp$1.reduce(((t$1, e$2) => t$1 + e$2), 0) / n$1 / 1e3), s$1 = dp$1.filter(((t$1) => t$1 > yp$1)).reduce(((t$1, e$2) => t$1 + (e$2 - yp$1) / yp$1), 0);
					return {
						loadTime: e$1,
						fullLoadTime: r$1,
						fps: i$1,
						percentDroppedFrames: s$1 / (n$1 + s$1) * 100,
						totalFrames: n$1
					};
				}
			}, t.cy = function(t$1) {
				return t$1.message === it$1;
			}, t.cz = ut$1, t.d = pt$1, t.e = O$1, t.f = (t$1) => e(void 0, void 0, void 0, (function* () {
				if (0 === t$1.byteLength) return createImageBitmap(new ImageData(1, 1));
				const e$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				try {
					return createImageBitmap(e$1);
				} catch (t$2) {
					throw new Error(`Could not load image because of ${t$2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
				}
			})), t.g = ot$1, t.h = (t$1) => new Promise(((e$1, r$1) => {
				const n$1 = new Image();
				n$1.onload = () => {
					e$1(n$1), URL.revokeObjectURL(n$1.src), n$1.onload = null, window.requestAnimationFrame((() => {
						n$1.src = H$1;
					}));
				}, n$1.onerror = () => r$1(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
				const i$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				n$1.src = t$1.byteLength ? URL.createObjectURL(i$1) : H$1;
			})), t.i = X$1, t.j = (t$1, e$1) => ht(O$1(t$1, { type: "json" }), e$1), t.k = mt$1, t.l = yt$1, t.m = ht, t.n = (t$1, e$1) => ht(O$1(t$1, { type: "arrayBuffer" }), e$1), t.o = function(t$1) {
				return new Ju$1(t$1).readFields(uc$1, []);
			}, t.p = pc$1, t.q = el$1, t.r = Us$1, t.s = Q$1, t.t = Cs$1, t.u = fs$1, t.v = xt$1, t.w = q$1, t.x = Qi$1, t.y = ns$1, t.z = Wi$1;
		}));
		define$1("worker", ["./shared"], (function(e) {
			class t {
				constructor(e$1) {
					this.keyCache = {}, e$1 && this.replace(e$1);
				}
				replace(e$1) {
					this._layerConfigs = {}, this._layers = {}, this.update(e$1, []);
				}
				update(t$1, i$1) {
					for (const i$2 of t$1) {
						this._layerConfigs[i$2.id] = i$2;
						const t$2 = this._layers[i$2.id] = e.bJ(i$2);
						t$2._featureFilter = e.aa(t$2.filter), this.keyCache[i$2.id] && delete this.keyCache[i$2.id];
					}
					for (const e$1 of i$1) delete this.keyCache[e$1], delete this._layerConfigs[e$1], delete this._layers[e$1];
					this.familiesBySource = {};
					const o$1 = e.cC(Object.values(this._layerConfigs), this.keyCache);
					for (const e$1 of o$1) {
						const t$2 = e$1.map(((e$2) => this._layers[e$2.id])), i$2 = t$2[0];
						if ("none" === i$2.visibility) continue;
						const o$2 = i$2.source || "";
						let s$1 = this.familiesBySource[o$2];
						s$1 || (s$1 = this.familiesBySource[o$2] = {});
						const n$1 = i$2.sourceLayer || "_geojsonTileLayer";
						let r$1 = s$1[n$1];
						r$1 || (r$1 = s$1[n$1] = []), r$1.push(t$2);
					}
				}
			}
			class i {
				constructor(t$1) {
					const i$1 = {}, o$1 = [];
					for (const e$1 in t$1) {
						const s$2 = t$1[e$1], n$2 = i$1[e$1] = {};
						for (const e$2 in s$2) {
							const t$2 = s$2[+e$2];
							if (!t$2 || 0 === t$2.bitmap.width || 0 === t$2.bitmap.height) continue;
							const i$2 = {
								x: 0,
								y: 0,
								w: t$2.bitmap.width + 2,
								h: t$2.bitmap.height + 2
							};
							o$1.push(i$2), n$2[e$2] = {
								rect: i$2,
								metrics: t$2.metrics
							};
						}
					}
					const { w: s$1, h: n$1 } = e.p(o$1), r$1 = new e.q({
						width: s$1 || 1,
						height: n$1 || 1
					});
					for (const o$2 in t$1) {
						const s$2 = t$1[o$2];
						for (const t$2 in s$2) {
							const n$2 = s$2[+t$2];
							if (!n$2 || 0 === n$2.bitmap.width || 0 === n$2.bitmap.height) continue;
							const a$1 = i$1[o$2][t$2].rect;
							e.q.copy(n$2.bitmap, r$1, {
								x: 0,
								y: 0
							}, {
								x: a$1.x + 1,
								y: a$1.y + 1
							}, n$2.bitmap);
						}
					}
					this.image = r$1, this.positions = i$1;
				}
			}
			e.cD("GlyphAtlas", i);
			class o {
				constructor(t$1) {
					this.tileID = new e.Z(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.uid = t$1.uid, this.zoom = t$1.zoom, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t$1.showCollisionBoxes, this.collectResourceTiming = !!t$1.collectResourceTiming, this.returnDependencies = !!t$1.returnDependencies, this.promoteId = t$1.promoteId, this.inFlightDependencies = [], this.globalState = t$1.globalState;
				}
				parse(t$1, o$1, n$1, r$1, a$1) {
					return e._(this, void 0, void 0, (function* () {
						this.status = "parsing", this.data = t$1, this.collisionBoxArray = new e.a8();
						const l$1 = new e.cE(Object.keys(t$1.layers).sort()), c$1 = new e.cF(this.tileID, this.promoteId);
						c$1.bucketLayerIDs = [];
						const u$1 = {}, h$1 = {
							featureIndex: c$1,
							iconDependencies: {},
							patternDependencies: {},
							glyphDependencies: {},
							availableImages: n$1,
							subdivisionGranularity: a$1
						}, d$1 = o$1.familiesBySource[this.source];
						for (const i$1 in d$1) {
							const o$2 = t$1.layers[i$1];
							if (!o$2) continue;
							1 === o$2.version && e.w(`Vector tile source "${this.source}" layer "${i$1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
							const r$2 = l$1.encode(i$1), a$2 = [];
							for (let e$1 = 0; e$1 < o$2.length; e$1++) {
								const t$2 = o$2.feature(e$1), s$1 = c$1.getId(t$2, i$1);
								a$2.push({
									feature: t$2,
									id: s$1,
									index: e$1,
									sourceLayerIndex: r$2
								});
							}
							for (const t$2 of d$1[i$1]) {
								const i$2 = t$2[0];
								i$2.source !== this.source && e.w(`layer.source = ${i$2.source} does not equal this.source = ${this.source}`), i$2.minzoom && this.zoom < Math.floor(i$2.minzoom) || i$2.maxzoom && this.zoom >= i$2.maxzoom || "none" !== i$2.visibility && (s(t$2, this.zoom, n$1), (u$1[i$2.id] = i$2.createBucket({
									index: c$1.bucketLayerIDs.length,
									layers: t$2,
									zoom: this.zoom,
									pixelRatio: this.pixelRatio,
									overscaling: this.overscaling,
									collisionBoxArray: this.collisionBoxArray,
									sourceLayerIndex: r$2,
									sourceID: this.source,
									globalState: this.globalState
								})).populate(a$2, h$1, this.tileID.canonical), c$1.bucketLayerIDs.push(t$2.map(((e$1) => e$1.id))));
							}
						}
						const f$1 = e.bN(h$1.glyphDependencies, ((e$1) => Object.keys(e$1).map(Number)));
						this.inFlightDependencies.forEach(((e$1) => null == e$1 ? void 0 : e$1.abort())), this.inFlightDependencies = [];
						let g$2 = Promise.resolve({});
						if (Object.keys(f$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), g$2 = r$1.sendAsync({
								type: "GG",
								data: {
									stacks: f$1,
									source: this.source,
									tileID: this.tileID,
									type: "glyphs"
								}
							}, e$1);
						}
						const p$1 = Object.keys(h$1.iconDependencies);
						let m$1 = Promise.resolve({});
						if (p$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), m$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: p$1,
									source: this.source,
									tileID: this.tileID,
									type: "icons"
								}
							}, e$1);
						}
						const y$1 = Object.keys(h$1.patternDependencies);
						let v$1 = Promise.resolve({});
						if (y$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), v$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: y$1,
									source: this.source,
									tileID: this.tileID,
									type: "patterns"
								}
							}, e$1);
						}
						const [w$1, x$1, b$2] = yield Promise.all([
							g$2,
							m$1,
							v$1
						]), S$2 = new i(w$1), M$2 = new e.cG(x$1, b$2);
						for (const t$2 in u$1) {
							const i$1 = u$1[t$2];
							i$1 instanceof e.a9 ? (s(i$1.layers, this.zoom, n$1), e.cH({
								bucket: i$1,
								glyphMap: w$1,
								glyphPositions: S$2.positions,
								imageMap: x$1,
								imagePositions: M$2.iconPositions,
								showCollisionBoxes: this.showCollisionBoxes,
								canonical: this.tileID.canonical,
								subdivisionGranularity: h$1.subdivisionGranularity
							})) : i$1.hasPattern && (i$1 instanceof e.cI || i$1 instanceof e.cJ || i$1 instanceof e.cK) && (s(i$1.layers, this.zoom, n$1), i$1.addFeatures(h$1, this.tileID.canonical, M$2.patternPositions));
						}
						return this.status = "done", {
							buckets: Object.values(u$1).filter(((e$1) => !e$1.isEmpty())),
							featureIndex: c$1,
							collisionBoxArray: this.collisionBoxArray,
							glyphAtlasImage: S$2.image,
							imageAtlas: M$2,
							glyphMap: this.returnDependencies ? w$1 : null,
							iconMap: this.returnDependencies ? x$1 : null,
							glyphPositions: this.returnDependencies ? S$2.positions : null
						};
					}));
				}
			}
			function s(t$1, i$1, o$1) {
				const s$1 = new e.F(i$1);
				for (const e$1 of t$1) e$1.recalculate(s$1, o$1);
			}
			class n {
				constructor(e$1, t$1, i$1) {
					this.actor = e$1, this.layerIndex = t$1, this.availableImages = i$1, this.fetching = {}, this.loading = {}, this.loaded = {};
				}
				loadVectorTile(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$1 = yield e.n(t$1.request, i$1);
						try {
							return {
								vectorTile: new e.cL(new e.cM(o$1.data)),
								rawData: o$1.data,
								cacheControl: o$1.cacheControl,
								expires: o$1.expires
							};
						} catch (e$1) {
							const i$2 = new Uint8Array(o$1.data);
							let s$1 = `Unable to parse the tile at ${t$1.request.url}, `;
							throw s$1 += 31 === i$2[0] && 139 === i$2[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e$1.message}`, new Error(s$1);
						}
					}));
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = t$1.uid, s$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.cN(t$1.request), n$1 = new o(t$1);
						this.loading[i$1] = n$1;
						const r$1 = new AbortController();
						n$1.abort = r$1;
						try {
							const o$1 = yield this.loadVectorTile(t$1, r$1);
							if (delete this.loading[i$1], !o$1) return null;
							const a$1 = o$1.rawData, l$1 = {};
							o$1.expires && (l$1.expires = o$1.expires), o$1.cacheControl && (l$1.cacheControl = o$1.cacheControl);
							const c$1 = {};
							if (s$1) {
								const e$1 = s$1.finish();
								e$1 && (c$1.resourceTiming = JSON.parse(JSON.stringify(e$1)));
							}
							n$1.vectorTile = o$1.vectorTile;
							const u$1 = n$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							this.loaded[i$1] = n$1, this.fetching[i$1] = {
								rawTileData: a$1,
								cacheControl: l$1,
								resourceTiming: c$1
							};
							try {
								const t$2 = yield u$1;
								return e.e({ rawTileData: a$1.slice(0) }, t$2, l$1, c$1);
							} finally {
								delete this.fetching[i$1];
							}
						} catch (e$1) {
							throw delete this.loading[i$1], n$1.status = "done", this.loaded[i$1] = n$1, e$1;
						}
					}));
				}
				reloadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = t$1.uid;
						if (!this.loaded || !this.loaded[i$1]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
						const o$1 = this.loaded[i$1];
						if (o$1.showCollisionBoxes = t$1.showCollisionBoxes, o$1.globalState = t$1.globalState, "parsing" === o$1.status) {
							const s$1 = yield o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							let n$1;
							if (this.fetching[i$1]) {
								const { rawTileData: t$2, cacheControl: o$2, resourceTiming: r$1 } = this.fetching[i$1];
								delete this.fetching[i$1], n$1 = e.e({ rawTileData: t$2.slice(0) }, s$1, o$2, r$1);
							} else n$1 = s$1;
							return n$1;
						}
						if ("done" === o$1.status && o$1.vectorTile) return o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
					}));
				}
				abortTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const e$1 = this.loading, i$1 = t$1.uid;
						e$1 && e$1[i$1] && e$1[i$1].abort && (e$1[i$1].abort.abort(), delete e$1[i$1]);
					}));
				}
				removeTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this.loaded && this.loaded[t$1.uid] && delete this.loaded[t$1.uid];
					}));
				}
			}
			class r {
				constructor() {
					this.loaded = {};
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: i$1, encoding: o$1, rawImageData: s$1, redFactor: n$1, greenFactor: r$1, blueFactor: a$1, baseShift: l$1 } = t$1, c$1 = s$1.width + 2, u$1 = s$1.height + 2, h$1 = e.b(s$1) ? new e.R({
							width: c$1,
							height: u$1
						}, yield e.cO(s$1, -1, -1, c$1, u$1)) : s$1, d$1 = new e.cP(i$1, h$1, o$1, n$1, r$1, a$1, l$1);
						return this.loaded = this.loaded || {}, this.loaded[i$1] = d$1, d$1;
					}));
				}
				removeTile(e$1) {
					const t$1 = this.loaded, i$1 = e$1.uid;
					t$1 && t$1[i$1] && delete t$1[i$1];
				}
			}
			var a, l, c = function() {
				if (l) return a;
				function e$1(e$2, i$1) {
					if (0 !== e$2.length) {
						t$1(e$2[0], i$1);
						for (var o$1 = 1; o$1 < e$2.length; o$1++) t$1(e$2[o$1], !i$1);
					}
				}
				function t$1(e$2, t$2) {
					for (var i$1 = 0, o$1 = 0, s$1 = 0, n$1 = e$2.length, r$1 = n$1 - 1; s$1 < n$1; r$1 = s$1++) {
						var a$1 = (e$2[s$1][0] - e$2[r$1][0]) * (e$2[r$1][1] + e$2[s$1][1]), l$1 = i$1 + a$1;
						o$1 += Math.abs(i$1) >= Math.abs(a$1) ? i$1 - l$1 + a$1 : a$1 - l$1 + i$1, i$1 = l$1;
					}
					i$1 + o$1 >= 0 != !!t$2 && e$2.reverse();
				}
				return l = 1, a = function t$2(i$1, o$1) {
					var s$1, n$1 = i$1 && i$1.type;
					if ("FeatureCollection" === n$1) for (s$1 = 0; s$1 < i$1.features.length; s$1++) t$2(i$1.features[s$1], o$1);
					else if ("GeometryCollection" === n$1) for (s$1 = 0; s$1 < i$1.geometries.length; s$1++) t$2(i$1.geometries[s$1], o$1);
					else if ("Feature" === n$1) t$2(i$1.geometry, o$1);
					else if ("Polygon" === n$1) e$1(i$1.coordinates, o$1);
					else if ("MultiPolygon" === n$1) for (s$1 = 0; s$1 < i$1.coordinates.length; s$1++) e$1(i$1.coordinates[s$1], o$1);
					return i$1;
				};
			}(), u = e.cQ(c);
			class h extends e.cS {
				constructor(t$1, i$1) {
					super(new e.cM(), 0, i$1, [], []), this.feature = t$1, this.type = t$1.type, this.properties = t$1.tags ? t$1.tags : {}, "id" in t$1 && ("string" == typeof t$1.id ? this.id = parseInt(t$1.id, 10) : "number" != typeof t$1.id || isNaN(t$1.id) || (this.id = t$1.id));
				}
				loadGeometry() {
					const t$1 = [], i$1 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
					for (const o$1 of i$1) {
						const i$2 = [];
						for (const t$2 of o$1) i$2.push(new e.P(t$2[0], t$2[1]));
						t$1.push(i$2);
					}
					return t$1;
				}
			}
			class d extends e.cR {
				constructor(t$1, i$1) {
					super(new e.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = i$1 ? i$1.version : 1, this.extent = i$1 ? i$1.extent : 4096, this.length = t$1.length, this.features = t$1;
				}
				feature(e$1) {
					return new h(this.features[e$1], this.extent);
				}
			}
			function f(e$1, t$1) {
				t$1.writeVarintField(15, e$1.version || 1), t$1.writeStringField(1, e$1.name || ""), t$1.writeVarintField(5, e$1.extent || 4096);
				const i$1 = {
					keys: [],
					values: [],
					keycache: {},
					valuecache: {}
				};
				for (let o$2 = 0; o$2 < e$1.length; o$2++) i$1.feature = e$1.feature(o$2), t$1.writeMessage(2, g$1, i$1);
				const o$1 = i$1.keys;
				for (const e$2 of o$1) t$1.writeStringField(3, e$2);
				const s$1 = i$1.values;
				for (const e$2 of s$1) t$1.writeMessage(4, w, e$2);
			}
			function g$1(e$1, t$1) {
				if (!e$1.feature) return;
				const i$1 = e$1.feature;
				void 0 !== i$1.id && t$1.writeVarintField(1, i$1.id), t$1.writeMessage(2, p, e$1), t$1.writeVarintField(3, i$1.type), t$1.writeMessage(4, v, i$1);
			}
			function p(e$1, t$1) {
				for (const i$1 in e$1.feature?.properties) {
					let o$1 = e$1.feature.properties[i$1], s$1 = e$1.keycache[i$1];
					if (null === o$1) continue;
					void 0 === s$1 && (e$1.keys.push(i$1), s$1 = e$1.keys.length - 1, e$1.keycache[i$1] = s$1), t$1.writeVarint(s$1), "string" != typeof o$1 && "boolean" != typeof o$1 && "number" != typeof o$1 && (o$1 = JSON.stringify(o$1));
					const n$1 = typeof o$1 + ":" + o$1;
					let r$1 = e$1.valuecache[n$1];
					void 0 === r$1 && (e$1.values.push(o$1), r$1 = e$1.values.length - 1, e$1.valuecache[n$1] = r$1), t$1.writeVarint(r$1);
				}
			}
			function m(e$1, t$1) {
				return (t$1 << 3) + (7 & e$1);
			}
			function y(e$1) {
				return e$1 << 1 ^ e$1 >> 31;
			}
			function v(e$1, t$1) {
				const i$1 = e$1.loadGeometry(), o$1 = e$1.type;
				let s$1 = 0, n$1 = 0;
				for (const r$1 of i$1) {
					let i$2 = 1;
					1 === o$1 && (i$2 = r$1.length), t$1.writeVarint(m(1, i$2));
					const a$1 = 3 === o$1 ? r$1.length - 1 : r$1.length;
					for (let e$2 = 0; e$2 < a$1; e$2++) {
						1 === e$2 && 1 !== o$1 && t$1.writeVarint(m(2, a$1 - 1));
						const i$3 = r$1[e$2].x - s$1, l$1 = r$1[e$2].y - n$1;
						t$1.writeVarint(y(i$3)), t$1.writeVarint(y(l$1)), s$1 += i$3, n$1 += l$1;
					}
					3 === e$1.type && t$1.writeVarint(m(7, 1));
				}
			}
			function w(e$1, t$1) {
				const i$1 = typeof e$1;
				"string" === i$1 ? t$1.writeStringField(1, e$1) : "boolean" === i$1 ? t$1.writeBooleanField(7, e$1) : "number" === i$1 && (e$1 % 1 != 0 ? t$1.writeDoubleField(3, e$1) : e$1 < 0 ? t$1.writeSVarintField(6, e$1) : t$1.writeVarintField(5, e$1));
			}
			const x = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e$1) => e$1
			}, b$1 = Math.fround || (S$1 = new Float32Array(1), (e$1) => (S$1[0] = +e$1, S$1[0]));
			var S$1;
			class M$1 {
				constructor(e$1) {
					this.options = Object.assign(Object.create(x), e$1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e$1) {
					const { log: t$1, minZoom: i$1, maxZoom: o$1 } = this.options;
					t$1 && console.time("total time");
					const s$1 = `prepare ${e$1.length} points`;
					t$1 && console.time(s$1), this.points = e$1;
					const n$1 = [];
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const i$2 = e$1[t$2];
						if (!i$2.geometry) continue;
						const [o$2, s$2] = i$2.geometry.coordinates, r$2 = b$1(k$1(o$2)), a$1 = b$1(P$1(s$2));
						n$1.push(r$2, a$1, Infinity, t$2, -1, 1), this.options.reduce && n$1.push(0);
					}
					let r$1 = this.trees[o$1 + 1] = this._createTree(n$1);
					t$1 && console.timeEnd(s$1);
					for (let e$2 = o$1; e$2 >= i$1; e$2--) {
						const i$2 = +Date.now();
						r$1 = this.trees[e$2] = this._createTree(this._cluster(r$1, e$2)), t$1 && console.log("z%d: %d clusters in %dms", e$2, r$1.numItems, +Date.now() - i$2);
					}
					return t$1 && console.timeEnd("total time"), this;
				}
				getClusters(e$1, t$1) {
					let i$1 = ((e$1[0] + 180) % 360 + 360) % 360 - 180;
					const o$1 = Math.max(-90, Math.min(90, e$1[1]));
					let s$1 = 180 === e$1[2] ? 180 : ((e$1[2] + 180) % 360 + 360) % 360 - 180;
					const n$1 = Math.max(-90, Math.min(90, e$1[3]));
					if (e$1[2] - e$1[0] >= 360) i$1 = -180, s$1 = 180;
					else if (i$1 > s$1) {
						const e$2 = this.getClusters([
							i$1,
							o$1,
							180,
							n$1
						], t$1), r$2 = this.getClusters([
							-180,
							o$1,
							s$1,
							n$1
						], t$1);
						return e$2.concat(r$2);
					}
					const r$1 = this.trees[this._limitZoom(t$1)], a$1 = r$1.range(k$1(i$1), P$1(n$1), k$1(s$1), P$1(o$1)), l$1 = r$1.data, c$1 = [];
					for (const e$2 of a$1) {
						const t$2 = this.stride * e$2;
						c$1.push(l$1[t$2 + 5] > 1 ? _$1(l$1, t$2, this.clusterProps) : this.points[l$1[t$2 + 3]]);
					}
					return c$1;
				}
				getChildren(e$1) {
					const t$1 = this._getOriginId(e$1), i$1 = this._getOriginZoom(e$1), o$1 = "No cluster with the specified id.", s$1 = this.trees[i$1];
					if (!s$1) throw new Error(o$1);
					const n$1 = s$1.data;
					if (t$1 * this.stride >= n$1.length) throw new Error(o$1);
					const r$1 = this.options.radius / (this.options.extent * Math.pow(2, i$1 - 1)), a$1 = s$1.within(n$1[t$1 * this.stride], n$1[t$1 * this.stride + 1], r$1), l$1 = [];
					for (const t$2 of a$1) {
						const i$2 = t$2 * this.stride;
						n$1[i$2 + 4] === e$1 && l$1.push(n$1[i$2 + 5] > 1 ? _$1(n$1, i$2, this.clusterProps) : this.points[n$1[i$2 + 3]]);
					}
					if (0 === l$1.length) throw new Error(o$1);
					return l$1;
				}
				getLeaves(e$1, t$1, i$1) {
					const o$1 = [];
					return this._appendLeaves(o$1, e$1, t$1 = t$1 || 10, i$1 = i$1 || 0, 0), o$1;
				}
				getTile(e$1, t$1, i$1) {
					const o$1 = this.trees[this._limitZoom(e$1)], s$1 = Math.pow(2, e$1), { extent: n$1, radius: r$1 } = this.options, a$1 = r$1 / n$1, l$1 = (i$1 - a$1) / s$1, c$1 = (i$1 + 1 + a$1) / s$1, u$1 = { features: [] };
					return this._addTileFeatures(o$1.range((t$1 - a$1) / s$1, l$1, (t$1 + 1 + a$1) / s$1, c$1), o$1.data, t$1, i$1, s$1, u$1), 0 === t$1 && this._addTileFeatures(o$1.range(1 - a$1 / s$1, l$1, 1, c$1), o$1.data, s$1, i$1, s$1, u$1), t$1 === s$1 - 1 && this._addTileFeatures(o$1.range(0, l$1, a$1 / s$1, c$1), o$1.data, -1, i$1, s$1, u$1), u$1.features.length ? u$1 : null;
				}
				getClusterExpansionZoom(e$1) {
					let t$1 = this._getOriginZoom(e$1) - 1;
					for (; t$1 <= this.options.maxZoom;) {
						const i$1 = this.getChildren(e$1);
						if (t$1++, 1 !== i$1.length) break;
						e$1 = i$1[0].properties.cluster_id;
					}
					return t$1;
				}
				_appendLeaves(e$1, t$1, i$1, o$1, s$1) {
					const n$1 = this.getChildren(t$1);
					for (const t$2 of n$1) {
						const n$2 = t$2.properties;
						if (n$2 && n$2.cluster ? s$1 + n$2.point_count <= o$1 ? s$1 += n$2.point_count : s$1 = this._appendLeaves(e$1, n$2.cluster_id, i$1, o$1, s$1) : s$1 < o$1 ? s$1++ : e$1.push(t$2), e$1.length === i$1) break;
					}
					return s$1;
				}
				_createTree(t$1) {
					const i$1 = new e.aI(t$1.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e$1 = 0; e$1 < t$1.length; e$1 += this.stride) i$1.add(t$1[e$1], t$1[e$1 + 1]);
					return i$1.finish(), i$1.data = t$1, i$1;
				}
				_addTileFeatures(e$1, t$1, i$1, o$1, s$1, n$1) {
					for (const r$1 of e$1) {
						const e$2 = r$1 * this.stride, a$1 = t$1[e$2 + 5] > 1;
						let l$1, c$1, u$1;
						if (a$1) l$1 = I$1(t$1, e$2, this.clusterProps), c$1 = t$1[e$2], u$1 = t$1[e$2 + 1];
						else {
							const i$2 = this.points[t$1[e$2 + 3]];
							l$1 = i$2.properties;
							const [o$2, s$2] = i$2.geometry.coordinates;
							c$1 = k$1(o$2), u$1 = P$1(s$2);
						}
						const h$1 = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (c$1 * s$1 - i$1)), Math.round(this.options.extent * (u$1 * s$1 - o$1))]],
							tags: l$1
						};
						let d$1;
						d$1 = a$1 || this.options.generateId ? t$1[e$2 + 3] : this.points[t$1[e$2 + 3]].id, void 0 !== d$1 && (h$1.id = d$1), n$1.features.push(h$1);
					}
				}
				_limitZoom(e$1) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e$1), this.options.maxZoom + 1));
				}
				_cluster(e$1, t$1) {
					const { radius: i$1, extent: o$1, reduce: s$1, minPoints: n$1 } = this.options, r$1 = i$1 / (o$1 * Math.pow(2, t$1)), a$1 = e$1.data, l$1 = [], c$1 = this.stride;
					for (let i$2 = 0; i$2 < a$1.length; i$2 += c$1) {
						if (a$1[i$2 + 2] <= t$1) continue;
						a$1[i$2 + 2] = t$1;
						const o$2 = a$1[i$2], u$1 = a$1[i$2 + 1], h$1 = e$1.within(a$1[i$2], a$1[i$2 + 1], r$1), d$1 = a$1[i$2 + 5];
						let f$1 = d$1;
						for (const e$2 of h$1) {
							const i$3 = e$2 * c$1;
							a$1[i$3 + 2] > t$1 && (f$1 += a$1[i$3 + 5]);
						}
						if (f$1 > d$1 && f$1 >= n$1) {
							let e$2, n$2 = o$2 * d$1, r$2 = u$1 * d$1, g$2 = -1;
							const p$1 = (i$2 / c$1 << 5) + (t$1 + 1) + this.points.length;
							for (const o$3 of h$1) {
								const l$2 = o$3 * c$1;
								if (a$1[l$2 + 2] <= t$1) continue;
								a$1[l$2 + 2] = t$1;
								const u$2 = a$1[l$2 + 5];
								n$2 += a$1[l$2] * u$2, r$2 += a$1[l$2 + 1] * u$2, a$1[l$2 + 4] = p$1, s$1 && (e$2 || (e$2 = this._map(a$1, i$2, !0), g$2 = this.clusterProps.length, this.clusterProps.push(e$2)), s$1(e$2, this._map(a$1, l$2)));
							}
							a$1[i$2 + 4] = p$1, l$1.push(n$2 / f$1, r$2 / f$1, Infinity, p$1, -1, f$1), s$1 && l$1.push(g$2);
						} else {
							for (let e$2 = 0; e$2 < c$1; e$2++) l$1.push(a$1[i$2 + e$2]);
							if (f$1 > 1) for (const e$2 of h$1) {
								const i$3 = e$2 * c$1;
								if (!(a$1[i$3 + 2] <= t$1)) {
									a$1[i$3 + 2] = t$1;
									for (let e$3 = 0; e$3 < c$1; e$3++) l$1.push(a$1[i$3 + e$3]);
								}
							}
						}
					}
					return l$1;
				}
				_getOriginId(e$1) {
					return e$1 - this.points.length >> 5;
				}
				_getOriginZoom(e$1) {
					return (e$1 - this.points.length) % 32;
				}
				_map(e$1, t$1, i$1) {
					if (e$1[t$1 + 5] > 1) {
						const o$2 = this.clusterProps[e$1[t$1 + 6]];
						return i$1 ? Object.assign({}, o$2) : o$2;
					}
					const o$1 = this.points[e$1[t$1 + 3]].properties, s$1 = this.options.map(o$1);
					return i$1 && s$1 === o$1 ? Object.assign({}, s$1) : s$1;
				}
			}
			function _$1(e$1, t$1, i$1) {
				return {
					type: "Feature",
					id: e$1[t$1 + 3],
					properties: I$1(e$1, t$1, i$1),
					geometry: {
						type: "Point",
						coordinates: [(o$1 = e$1[t$1], 360 * (o$1 - .5)), T$1(e$1[t$1 + 1])]
					}
				};
				var o$1;
			}
			function I$1(e$1, t$1, i$1) {
				const o$1 = e$1[t$1 + 5], s$1 = o$1 >= 1e4 ? `${Math.round(o$1 / 1e3)}k` : o$1 >= 1e3 ? Math.round(o$1 / 100) / 10 + "k" : o$1, n$1 = e$1[t$1 + 6], r$1 = -1 === n$1 ? {} : Object.assign({}, i$1[n$1]);
				return Object.assign(r$1, {
					cluster: !0,
					cluster_id: e$1[t$1 + 3],
					point_count: o$1,
					point_count_abbreviated: s$1
				});
			}
			function k$1(e$1) {
				return e$1 / 360 + .5;
			}
			function P$1(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), i$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return i$1 < 0 ? 0 : i$1 > 1 ? 1 : i$1;
			}
			function T$1(e$1) {
				const t$1 = (180 - 360 * e$1) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t$1)) / Math.PI - 90;
			}
			function D$1(e$1, t$1, i$1, o$1) {
				let s$1 = o$1;
				const n$1 = t$1 + (i$1 - t$1 >> 1);
				let r$1, a$1 = i$1 - t$1;
				const l$1 = e$1[t$1], c$1 = e$1[t$1 + 1], u$1 = e$1[i$1], h$1 = e$1[i$1 + 1];
				for (let o$2 = t$1 + 3; o$2 < i$1; o$2 += 3) {
					const t$2 = C(e$1[o$2], e$1[o$2 + 1], l$1, c$1, u$1, h$1);
					if (t$2 > s$1) r$1 = o$2, s$1 = t$2;
					else if (t$2 === s$1) {
						const e$2 = Math.abs(o$2 - n$1);
						e$2 < a$1 && (r$1 = o$2, a$1 = e$2);
					}
				}
				s$1 > o$1 && (r$1 - t$1 > 3 && D$1(e$1, t$1, r$1, o$1), e$1[r$1 + 2] = s$1, i$1 - r$1 > 3 && D$1(e$1, r$1, i$1, o$1));
			}
			function C(e$1, t$1, i$1, o$1, s$1, n$1) {
				let r$1 = s$1 - i$1, a$1 = n$1 - o$1;
				if (0 !== r$1 || 0 !== a$1) {
					const l$1 = ((e$1 - i$1) * r$1 + (t$1 - o$1) * a$1) / (r$1 * r$1 + a$1 * a$1);
					l$1 > 1 ? (i$1 = s$1, o$1 = n$1) : l$1 > 0 && (i$1 += r$1 * l$1, o$1 += a$1 * l$1);
				}
				return r$1 = e$1 - i$1, a$1 = t$1 - o$1, r$1 * r$1 + a$1 * a$1;
			}
			function L$1(e$1, t$1, i$1, o$1) {
				const s$1 = {
					id: null == e$1 ? null : e$1,
					type: t$1,
					geometry: i$1,
					tags: o$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				if ("Point" === t$1 || "MultiPoint" === t$1 || "LineString" === t$1) O$1(s$1, i$1);
				else if ("Polygon" === t$1) O$1(s$1, i$1[0]);
				else if ("MultiLineString" === t$1) for (const e$2 of i$1) O$1(s$1, e$2);
				else if ("MultiPolygon" === t$1) for (const e$2 of i$1) O$1(s$1, e$2[0]);
				return s$1;
			}
			function O$1(e$1, t$1) {
				for (let i$1 = 0; i$1 < t$1.length; i$1 += 3) e$1.minX = Math.min(e$1.minX, t$1[i$1]), e$1.minY = Math.min(e$1.minY, t$1[i$1 + 1]), e$1.maxX = Math.max(e$1.maxX, t$1[i$1]), e$1.maxY = Math.max(e$1.maxY, t$1[i$1 + 1]);
			}
			function F$1(e$1, t$1, i$1, o$1) {
				if (!t$1.geometry) return;
				const s$1 = t$1.geometry.coordinates;
				if (s$1 && 0 === s$1.length) return;
				const n$1 = t$1.geometry.type, r$1 = Math.pow(i$1.tolerance / ((1 << i$1.maxZoom) * i$1.extent), 2);
				let a$1 = [], l$1 = t$1.id;
				if (i$1.promoteId ? l$1 = t$1.properties[i$1.promoteId] : i$1.generateId && (l$1 = o$1 || 0), "Point" === n$1) z$1(s$1, a$1);
				else if ("MultiPoint" === n$1) for (const e$2 of s$1) z$1(e$2, a$1);
				else if ("LineString" === n$1) E(s$1, a$1, r$1, !1);
				else if ("MultiLineString" === n$1) {
					if (i$1.lineMetrics) {
						for (const i$2 of s$1) a$1 = [], E(i$2, a$1, r$1, !1), e$1.push(L$1(l$1, "LineString", a$1, t$1.properties));
						return;
					}
					A(s$1, a$1, r$1, !1);
				} else if ("Polygon" === n$1) A(s$1, a$1, r$1, !0);
				else {
					if ("MultiPolygon" !== n$1) {
						if ("GeometryCollection" === n$1) {
							for (const s$2 of t$1.geometry.geometries) F$1(e$1, {
								id: l$1,
								geometry: s$2,
								properties: t$1.properties
							}, i$1, o$1);
							return;
						}
						throw new Error("Input data is not a valid GeoJSON object.");
					}
					for (const e$2 of s$1) {
						const t$2 = [];
						A(e$2, t$2, r$1, !0), a$1.push(t$2);
					}
				}
				e$1.push(L$1(l$1, n$1, a$1, t$1.properties));
			}
			function z$1(e$1, t$1) {
				t$1.push(Z$1(e$1[0]), j$1(e$1[1]), 0);
			}
			function E(e$1, t$1, i$1, o$1) {
				let s$1, n$1, r$1 = 0;
				for (let i$2 = 0; i$2 < e$1.length; i$2++) {
					const a$2 = Z$1(e$1[i$2][0]), l$1 = j$1(e$1[i$2][1]);
					t$1.push(a$2, l$1, 0), i$2 > 0 && (r$1 += o$1 ? (s$1 * l$1 - a$2 * n$1) / 2 : Math.sqrt(Math.pow(a$2 - s$1, 2) + Math.pow(l$1 - n$1, 2))), s$1 = a$2, n$1 = l$1;
				}
				const a$1 = t$1.length - 3;
				t$1[2] = 1, D$1(t$1, 0, a$1, i$1), t$1[a$1 + 2] = 1, t$1.size = Math.abs(r$1), t$1.start = 0, t$1.end = t$1.size;
			}
			function A(e$1, t$1, i$1, o$1) {
				for (let s$1 = 0; s$1 < e$1.length; s$1++) {
					const n$1 = [];
					E(e$1[s$1], n$1, i$1, o$1), t$1.push(n$1);
				}
			}
			function Z$1(e$1) {
				return e$1 / 360 + .5;
			}
			function j$1(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), i$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return i$1 < 0 ? 0 : i$1 > 1 ? 1 : i$1;
			}
			function G$1(e$1, t$1, i$1, o$1, s$1, n$1, r$1, a$1) {
				if (o$1 /= t$1, n$1 >= (i$1 /= t$1) && r$1 < o$1) return e$1;
				if (r$1 < i$1 || n$1 >= o$1) return null;
				const l$1 = [];
				for (const t$2 of e$1) {
					const e$2 = t$2.geometry;
					let n$2 = t$2.type;
					const r$2 = 0 === s$1 ? t$2.minX : t$2.minY, c$1 = 0 === s$1 ? t$2.maxX : t$2.maxY;
					if (r$2 >= i$1 && c$1 < o$1) {
						l$1.push(t$2);
						continue;
					}
					if (c$1 < i$1 || r$2 >= o$1) continue;
					let u$1 = [];
					if ("Point" === n$2 || "MultiPoint" === n$2) N(e$2, u$1, i$1, o$1, s$1);
					else if ("LineString" === n$2) R$2(e$2, u$1, i$1, o$1, s$1, !1, a$1.lineMetrics);
					else if ("MultiLineString" === n$2) J$1(e$2, u$1, i$1, o$1, s$1, !1);
					else if ("Polygon" === n$2) J$1(e$2, u$1, i$1, o$1, s$1, !0);
					else if ("MultiPolygon" === n$2) for (const t$3 of e$2) {
						const e$3 = [];
						J$1(t$3, e$3, i$1, o$1, s$1, !0), e$3.length && u$1.push(e$3);
					}
					if (u$1.length) {
						if (a$1.lineMetrics && "LineString" === n$2) {
							for (const e$3 of u$1) l$1.push(L$1(t$2.id, n$2, e$3, t$2.tags));
							continue;
						}
						"LineString" !== n$2 && "MultiLineString" !== n$2 || (1 === u$1.length ? (n$2 = "LineString", u$1 = u$1[0]) : n$2 = "MultiLineString"), "Point" !== n$2 && "MultiPoint" !== n$2 || (n$2 = 3 === u$1.length ? "Point" : "MultiPoint"), l$1.push(L$1(t$2.id, n$2, u$1, t$2.tags));
					}
				}
				return l$1.length ? l$1 : null;
			}
			function N(e$1, t$1, i$1, o$1, s$1) {
				for (let n$1 = 0; n$1 < e$1.length; n$1 += 3) {
					const r$1 = e$1[n$1 + s$1];
					r$1 >= i$1 && r$1 <= o$1 && Y$1(t$1, e$1[n$1], e$1[n$1 + 1], e$1[n$1 + 2]);
				}
			}
			function R$2(e$1, t$1, i$1, o$1, s$1, n$1, r$1) {
				let a$1 = W$1(e$1);
				const l$1 = 0 === s$1 ? q$1 : X$1;
				let c$1, u$1, h$1 = e$1.start;
				for (let d$2 = 0; d$2 < e$1.length - 3; d$2 += 3) {
					const f$2 = e$1[d$2], g$3 = e$1[d$2 + 1], p$2 = e$1[d$2 + 2], m$1 = e$1[d$2 + 3], y$1 = e$1[d$2 + 4], v$1 = 0 === s$1 ? f$2 : g$3, w$1 = 0 === s$1 ? m$1 : y$1;
					let x$1 = !1;
					r$1 && (c$1 = Math.sqrt(Math.pow(f$2 - m$1, 2) + Math.pow(g$3 - y$1, 2))), v$1 < i$1 ? w$1 > i$1 && (u$1 = l$1(a$1, f$2, g$3, m$1, y$1, i$1), r$1 && (a$1.start = h$1 + c$1 * u$1)) : v$1 > o$1 ? w$1 < o$1 && (u$1 = l$1(a$1, f$2, g$3, m$1, y$1, o$1), r$1 && (a$1.start = h$1 + c$1 * u$1)) : Y$1(a$1, f$2, g$3, p$2), w$1 < i$1 && v$1 >= i$1 && (u$1 = l$1(a$1, f$2, g$3, m$1, y$1, i$1), x$1 = !0), w$1 > o$1 && v$1 <= o$1 && (u$1 = l$1(a$1, f$2, g$3, m$1, y$1, o$1), x$1 = !0), !n$1 && x$1 && (r$1 && (a$1.end = h$1 + c$1 * u$1), t$1.push(a$1), a$1 = W$1(e$1)), r$1 && (h$1 += c$1);
				}
				let d$1 = e$1.length - 3;
				const f$1 = e$1[d$1], g$2 = e$1[d$1 + 1], p$1 = 0 === s$1 ? f$1 : g$2;
				p$1 >= i$1 && p$1 <= o$1 && Y$1(a$1, f$1, g$2, e$1[d$1 + 2]), d$1 = a$1.length - 3, n$1 && d$1 >= 3 && (a$1[d$1] !== a$1[0] || a$1[d$1 + 1] !== a$1[1]) && Y$1(a$1, a$1[0], a$1[1], a$1[2]), a$1.length && t$1.push(a$1);
			}
			function W$1(e$1) {
				const t$1 = [];
				return t$1.size = e$1.size, t$1.start = e$1.start, t$1.end = e$1.end, t$1;
			}
			function J$1(e$1, t$1, i$1, o$1, s$1, n$1) {
				for (const r$1 of e$1) R$2(r$1, t$1, i$1, o$1, s$1, n$1, !1);
			}
			function Y$1(e$1, t$1, i$1, o$1) {
				e$1.push(t$1, i$1, o$1);
			}
			function q$1(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = (n$1 - t$1) / (o$1 - t$1);
				return Y$1(e$1, n$1, i$1 + (s$1 - i$1) * r$1, 1), r$1;
			}
			function X$1(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = (n$1 - i$1) / (s$1 - i$1);
				return Y$1(e$1, t$1 + (o$1 - t$1) * r$1, n$1, 1), r$1;
			}
			function H$1(e$1, t$1) {
				const i$1 = [];
				for (let o$1 = 0; o$1 < e$1.length; o$1++) {
					const s$1 = e$1[o$1], n$1 = s$1.type;
					let r$1;
					if ("Point" === n$1 || "MultiPoint" === n$1 || "LineString" === n$1) r$1 = V(s$1.geometry, t$1);
					else if ("MultiLineString" === n$1 || "Polygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) r$1.push(V(e$2, t$1));
					} else if ("MultiPolygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) {
							const i$2 = [];
							for (const o$2 of e$2) i$2.push(V(o$2, t$1));
							r$1.push(i$2);
						}
					}
					i$1.push(L$1(s$1.id, n$1, r$1, s$1.tags));
				}
				return i$1;
			}
			function V(e$1, t$1) {
				const i$1 = [];
				i$1.size = e$1.size, void 0 !== e$1.start && (i$1.start = e$1.start, i$1.end = e$1.end);
				for (let o$1 = 0; o$1 < e$1.length; o$1 += 3) i$1.push(e$1[o$1] + t$1, e$1[o$1 + 1], e$1[o$1 + 2]);
				return i$1;
			}
			function B$1(e$1, t$1) {
				if (e$1.transformed) return e$1;
				const i$1 = 1 << e$1.z, o$1 = e$1.x, s$1 = e$1.y;
				for (const n$1 of e$1.features) {
					const e$2 = n$1.geometry, r$1 = n$1.type;
					if (n$1.geometry = [], 1 === r$1) for (let r$2 = 0; r$2 < e$2.length; r$2 += 2) n$1.geometry.push($$1(e$2[r$2], e$2[r$2 + 1], t$1, i$1, o$1, s$1));
					else for (let r$2 = 0; r$2 < e$2.length; r$2++) {
						const a$1 = [];
						for (let n$2 = 0; n$2 < e$2[r$2].length; n$2 += 2) a$1.push($$1(e$2[r$2][n$2], e$2[r$2][n$2 + 1], t$1, i$1, o$1, s$1));
						n$1.geometry.push(a$1);
					}
				}
				return e$1.transformed = !0, e$1;
			}
			function $$1(e$1, t$1, i$1, o$1, s$1, n$1) {
				return [Math.round(i$1 * (e$1 * o$1 - s$1)), Math.round(i$1 * (t$1 * o$1 - n$1))];
			}
			function U$1(e$1, t$1, i$1, o$1, s$1) {
				const n$1 = t$1 === s$1.maxZoom ? 0 : s$1.tolerance / ((1 << t$1) * s$1.extent), r$1 = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e$1.length,
					source: null,
					x: i$1,
					y: o$1,
					z: t$1,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (const t$2 of e$1) K$1(r$1, t$2, n$1, s$1);
				return r$1;
			}
			function K$1(e$1, t$1, i$1, o$1) {
				const s$1 = t$1.geometry, n$1 = t$1.type, r$1 = [];
				if (e$1.minX = Math.min(e$1.minX, t$1.minX), e$1.minY = Math.min(e$1.minY, t$1.minY), e$1.maxX = Math.max(e$1.maxX, t$1.maxX), e$1.maxY = Math.max(e$1.maxY, t$1.maxY), "Point" === n$1 || "MultiPoint" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) r$1.push(s$1[t$2], s$1[t$2 + 1]), e$1.numPoints++, e$1.numSimplified++;
				else if ("LineString" === n$1) Q$1(r$1, s$1, e$1, i$1, !1, !1);
				else if ("MultiLineString" === n$1 || "Polygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) Q$1(r$1, s$1[t$2], e$1, i$1, "Polygon" === n$1, 0 === t$2);
				else if ("MultiPolygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) {
					const o$2 = s$1[t$2];
					for (let t$3 = 0; t$3 < o$2.length; t$3++) Q$1(r$1, o$2[t$3], e$1, i$1, !0, 0 === t$3);
				}
				if (r$1.length) {
					let i$2 = t$1.tags || null;
					if ("LineString" === n$1 && o$1.lineMetrics) {
						i$2 = {};
						for (const e$2 in t$1.tags) i$2[e$2] = t$1.tags[e$2];
						i$2.mapbox_clip_start = s$1.start / s$1.size, i$2.mapbox_clip_end = s$1.end / s$1.size;
					}
					const a$1 = {
						geometry: r$1,
						type: "Polygon" === n$1 || "MultiPolygon" === n$1 ? 3 : "LineString" === n$1 || "MultiLineString" === n$1 ? 2 : 1,
						tags: i$2
					};
					null !== t$1.id && (a$1.id = t$1.id), e$1.features.push(a$1);
				}
			}
			function Q$1(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = o$1 * o$1;
				if (o$1 > 0 && t$1.size < (s$1 ? r$1 : o$1)) return void (i$1.numPoints += t$1.length / 3);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2 += 3) (0 === o$1 || t$1[e$2 + 2] > r$1) && (i$1.numSimplified++, a$1.push(t$1[e$2], t$1[e$2 + 1])), i$1.numPoints++;
				s$1 && function(e$2, t$2) {
					let i$2 = 0;
					for (let t$3 = 0, o$2 = e$2.length, s$2 = o$2 - 2; t$3 < o$2; s$2 = t$3, t$3 += 2) i$2 += (e$2[t$3] - e$2[s$2]) * (e$2[t$3 + 1] + e$2[s$2 + 1]);
					if (i$2 > 0 === t$2) for (let t$3 = 0, i$3 = e$2.length; t$3 < i$3 / 2; t$3 += 2) {
						const o$2 = e$2[t$3], s$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[i$3 - 2 - t$3], e$2[t$3 + 1] = e$2[i$3 - 1 - t$3], e$2[i$3 - 2 - t$3] = o$2, e$2[i$3 - 1 - t$3] = s$2;
					}
				}(a$1, n$1), e$1.push(a$1);
			}
			const ee = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				debug: 0
			};
			class te$1 {
				constructor(e$1, t$1) {
					const i$1 = (t$1 = this.options = function(e$2, t$2) {
						for (const i$2 in t$2) e$2[i$2] = t$2[i$2];
						return e$2;
					}(Object.create(ee), t$1)).debug;
					if (i$1 && console.time("preprocess data"), t$1.maxZoom < 0 || t$1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
					if (t$1.promoteId && t$1.generateId) throw new Error("promoteId and generateId cannot be used together.");
					let o$1 = function(e$2, t$2) {
						const i$2 = [];
						if ("FeatureCollection" === e$2.type) for (let o$2 = 0; o$2 < e$2.features.length; o$2++) F$1(i$2, e$2.features[o$2], t$2, o$2);
						else F$1(i$2, "Feature" === e$2.type ? e$2 : { geometry: e$2 }, t$2);
						return i$2;
					}(e$1, t$1);
					this.tiles = {}, this.tileCoords = [], i$1 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t$1.indexMaxZoom, t$1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o$1 = function(e$2, t$2) {
						const i$2 = t$2.buffer / t$2.extent;
						let o$2 = e$2;
						const s$1 = G$1(e$2, 1, -1 - i$2, i$2, 0, -1, 2, t$2), n$1 = G$1(e$2, 1, 1 - i$2, 2 + i$2, 0, -1, 2, t$2);
						return (s$1 || n$1) && (o$2 = G$1(e$2, 1, -i$2, 1 + i$2, 0, -1, 2, t$2) || [], s$1 && (o$2 = H$1(s$1, 1).concat(o$2)), n$1 && (o$2 = o$2.concat(H$1(n$1, -1)))), o$2;
					}(o$1, t$1), o$1.length && this.splitTile(o$1, 0, 0, 0), i$1 && (o$1.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e$1, t$1, i$1, o$1, s$1, n$1, r$1) {
					const a$1 = [
						e$1,
						t$1,
						i$1,
						o$1
					], l$1 = this.options, c$1 = l$1.debug;
					for (; a$1.length;) {
						o$1 = a$1.pop(), i$1 = a$1.pop(), t$1 = a$1.pop(), e$1 = a$1.pop();
						const u$1 = 1 << t$1, h$1 = ie$1(t$1, i$1, o$1);
						let d$1 = this.tiles[h$1];
						if (!d$1 && (c$1 > 1 && console.time("creation"), d$1 = this.tiles[h$1] = U$1(e$1, t$1, i$1, o$1, l$1), this.tileCoords.push({
							z: t$1,
							x: i$1,
							y: o$1
						}), c$1)) {
							c$1 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t$1, i$1, o$1, d$1.numFeatures, d$1.numPoints, d$1.numSimplified), console.timeEnd("creation"));
							const e$2 = `z${t$1}`;
							this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
						}
						if (d$1.source = e$1, null == s$1) {
							if (t$1 === l$1.indexMaxZoom || d$1.numPoints <= l$1.indexMaxPoints) continue;
						} else {
							if (t$1 === l$1.maxZoom || t$1 === s$1) continue;
							if (null != s$1) {
								const e$2 = s$1 - t$1;
								if (i$1 !== n$1 >> e$2 || o$1 !== r$1 >> e$2) continue;
							}
						}
						if (d$1.source = null, 0 === e$1.length) continue;
						c$1 > 1 && console.time("clipping");
						const f$1 = .5 * l$1.buffer / l$1.extent, g$2 = .5 - f$1, p$1 = .5 + f$1, m$1 = 1 + f$1;
						let y$1 = null, v$1 = null, w$1 = null, x$1 = null, b$2 = G$1(e$1, u$1, i$1 - f$1, i$1 + p$1, 0, d$1.minX, d$1.maxX, l$1), S$2 = G$1(e$1, u$1, i$1 + g$2, i$1 + m$1, 0, d$1.minX, d$1.maxX, l$1);
						e$1 = null, b$2 && (y$1 = G$1(b$2, u$1, o$1 - f$1, o$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), v$1 = G$1(b$2, u$1, o$1 + g$2, o$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), b$2 = null), S$2 && (w$1 = G$1(S$2, u$1, o$1 - f$1, o$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), x$1 = G$1(S$2, u$1, o$1 + g$2, o$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), S$2 = null), c$1 > 1 && console.timeEnd("clipping"), a$1.push(y$1 || [], t$1 + 1, 2 * i$1, 2 * o$1), a$1.push(v$1 || [], t$1 + 1, 2 * i$1, 2 * o$1 + 1), a$1.push(w$1 || [], t$1 + 1, 2 * i$1 + 1, 2 * o$1), a$1.push(x$1 || [], t$1 + 1, 2 * i$1 + 1, 2 * o$1 + 1);
					}
				}
				getTile(e$1, t$1, i$1) {
					e$1 = +e$1, t$1 = +t$1, i$1 = +i$1;
					const { extent: s$1, debug: n$1 } = this.options;
					if (e$1 < 0 || e$1 > 24) return null;
					const r$1 = 1 << e$1, a$1 = ie$1(e$1, t$1 = t$1 + r$1 & r$1 - 1, i$1);
					if (this.tiles[a$1]) return B$1(this.tiles[a$1], s$1);
					n$1 > 1 && console.log("drilling down to z%d-%d-%d", e$1, t$1, i$1);
					let l$1, c$1 = e$1, u$1 = t$1, h$1 = i$1;
					for (; !l$1 && c$1 > 0;) c$1--, u$1 >>= 1, h$1 >>= 1, l$1 = this.tiles[ie$1(c$1, u$1, h$1)];
					return l$1 && l$1.source ? (n$1 > 1 && (console.log("found parent tile z%d-%d-%d", c$1, u$1, h$1), console.time("drilling down")), this.splitTile(l$1.source, c$1, u$1, h$1, e$1, t$1, i$1), n$1 > 1 && console.timeEnd("drilling down"), this.tiles[a$1] ? B$1(this.tiles[a$1], s$1) : null) : null;
				}
			}
			function ie$1(e$1, t$1, i$1) {
				return 32 * ((1 << e$1) * i$1 + t$1) + e$1;
			}
			class oe$1 extends n {
				constructor() {
					super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
				}
				loadVectorTile(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$2 = t$1.tileID.canonical;
						if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
						const o$1 = this._geoJSONIndex.getTile(i$2.z, i$2.x, i$2.y);
						if (!o$1) return null;
						const s$1 = new d(o$1.features, {
							version: 2,
							extent: e.$
						});
						let n$1 = function(t$2) {
							const i$3 = new e.cM();
							return function(e$1, t$3) {
								for (const i$4 in e$1.layers) t$3.writeMessage(3, f, e$1.layers[i$4]);
							}(t$2, i$3), i$3.finish();
						}(s$1);
						return 0 === n$1.byteOffset && n$1.byteLength === n$1.buffer.byteLength || (n$1 = new Uint8Array(n$1)), {
							vectorTile: s$1,
							rawData: n$1.buffer
						};
					}));
				}
				loadData(t$1) {
					return e._(this, void 0, void 0, (function* () {
						var i$1;
						null === (i$1 = this._pendingRequest) || void 0 === i$1 || i$1.abort();
						const o$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.cN(t$1.request);
						this._pendingRequest = new AbortController();
						try {
							this._pendingData = this.loadAndProcessGeoJSON(t$1, this._pendingRequest);
							const i$2 = yield this._pendingData;
							this._geoJSONIndex = t$1.cluster ? new M$1(function({ superclusterOptions: t$2, clusterProperties: i$3 }) {
								if (!i$3 || !t$2) return t$2;
								const o$2 = {}, s$2 = {}, n$1 = {
									accumulated: null,
									zoom: 0
								}, r$1 = { properties: null }, a$1 = Object.keys(i$3);
								for (const t$3 of a$1) {
									const [n$2, r$2] = i$3[t$3], a$2 = e.cT(r$2), l$1 = e.cT("string" == typeof n$2 ? [
										n$2,
										["accumulated"],
										["get", t$3]
									] : n$2);
									o$2[t$3] = a$2.value, s$2[t$3] = l$1.value;
								}
								return t$2.map = (e$1) => {
									r$1.properties = e$1;
									const t$3 = {};
									for (const e$2 of a$1) t$3[e$2] = o$2[e$2].evaluate(n$1, r$1);
									return t$3;
								}, t$2.reduce = (e$1, t$3) => {
									r$1.properties = t$3;
									for (const t$4 of a$1) n$1.accumulated = e$1[t$4], e$1[t$4] = s$2[t$4].evaluate(n$1, r$1);
								}, t$2;
							}(t$1)).load(i$2.features) : function(e$1, t$2) {
								return new te$1(e$1, t$2);
							}(i$2, t$1.geojsonVtOptions), this.loaded = {};
							const s$1 = { data: i$2 };
							if (o$1) {
								const e$1 = o$1.finish();
								e$1 && (s$1.resourceTiming = {}, s$1.resourceTiming[t$1.source] = JSON.parse(JSON.stringify(e$1)));
							}
							return s$1;
						} catch (t$2) {
							if (delete this._pendingRequest, e.cy(t$2)) return { abandoned: !0 };
							throw t$2;
						}
					}));
				}
				getData() {
					return e._(this, void 0, void 0, (function* () {
						return this._pendingData;
					}));
				}
				reloadTile(e$1) {
					const t$1 = this.loaded;
					return t$1 && t$1[e$1.uid] ? super.reloadTile(e$1) : this.loadTile(e$1);
				}
				loadAndProcessGeoJSON(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						let o$1 = yield this.loadGeoJSON(t$1, i$1);
						if (delete this._pendingRequest, "object" != typeof o$1) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						if (u(o$1, !0), t$1.filter) {
							const i$2 = e.cT(t$1.filter, {
								type: "boolean",
								"property-type": "data-driven",
								overridable: !1,
								transition: !1
							});
							if ("error" === i$2.result) throw new Error(i$2.value.map(((e$1) => `${e$1.key}: ${e$1.message}`)).join(", "));
							o$1 = {
								type: "FeatureCollection",
								features: o$1.features.filter(((e$1) => i$2.value.evaluate({ zoom: 0 }, e$1)))
							};
						}
						return o$1;
					}));
				}
				loadGeoJSON(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const { promoteId: o$1 } = t$1;
						if (t$1.request) {
							const s$1 = yield e.j(t$1.request, i$1);
							return this._dataUpdateable = e.cV(s$1.data, o$1) ? e.cU(s$1.data, o$1) : void 0, s$1.data;
						}
						if ("string" == typeof t$1.data) try {
							const i$2 = JSON.parse(t$1.data);
							return this._dataUpdateable = e.cV(i$2, o$1) ? e.cU(i$2, o$1) : void 0, i$2;
						} catch (e$1) {
							throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						}
						if (!t$1.dataDiff) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t$1.source}`);
						return e.cW(this._dataUpdateable, t$1.dataDiff, o$1), {
							type: "FeatureCollection",
							features: Array.from(this._dataUpdateable.values())
						};
					}));
				}
				removeSource(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this._pendingRequest && this._pendingRequest.abort();
					}));
				}
				getClusterExpansionZoom(e$1) {
					return this._geoJSONIndex.getClusterExpansionZoom(e$1.clusterId);
				}
				getClusterChildren(e$1) {
					return this._geoJSONIndex.getChildren(e$1.clusterId);
				}
				getClusterLeaves(e$1) {
					return this._geoJSONIndex.getLeaves(e$1.clusterId, e$1.limit, e$1.offset);
				}
			}
			class se$1 {
				constructor(t$1) {
					this.self = t$1, this.actor = new e.J(t$1), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e$1, t$2) => {
						if (this.externalWorkerSourceTypes[e$1]) throw new Error(`Worker source with name "${e$1}" already registered.`);
						this.externalWorkerSourceTypes[e$1] = t$2;
					}, this.self.addProtocol = e.cA, this.self.removeProtocol = e.cB, this.self.registerRTLTextPlugin = (t$2) => {
						e.cX.setMethods(t$2);
					}, this.actor.registerMessageHandler("LDT", ((e$1, t$2) => this._getDEMWorkerSource(e$1, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RDT", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getDEMWorkerSource(t$2, i$1.source).removeTile(i$1);
					})))), this.actor.registerMessageHandler("GCEZ", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterExpansionZoom(i$1);
					})))), this.actor.registerMessageHandler("GCC", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterChildren(i$1);
					})))), this.actor.registerMessageHandler("GCL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterLeaves(i$1);
					})))), this.actor.registerMessageHandler("LD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadData(t$2))), this.actor.registerMessageHandler("GD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).getData())), this.actor.registerMessageHandler("LT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).reloadTile(t$2))), this.actor.registerMessageHandler("AT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).abortTile(t$2))), this.actor.registerMessageHandler("RMT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).removeTile(t$2))), this.actor.registerMessageHandler("RS", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						if (!this.workerSources[t$2] || !this.workerSources[t$2][i$1.type] || !this.workerSources[t$2][i$1.type][i$1.source]) return;
						const e$1 = this.workerSources[t$2][i$1.type][i$1.source];
						delete this.workerSources[t$2][i$1.type][i$1.source], void 0 !== e$1.removeSource && e$1.removeSource(i$1);
					})))), this.actor.registerMessageHandler("RM", ((t$2) => e._(this, void 0, void 0, (function* () {
						delete this.layerIndexes[t$2], delete this.availableImages[t$2], delete this.workerSources[t$2], delete this.demWorkerSources[t$2];
					})))), this.actor.registerMessageHandler("SR", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this.referrer = i$1;
					})))), this.actor.registerMessageHandler("SRPS", ((e$1, t$2) => this._syncRTLPluginState(e$1, t$2))), this.actor.registerMessageHandler("IS", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this.self.importScripts(i$1);
					})))), this.actor.registerMessageHandler("SI", ((e$1, t$2) => this._setImages(e$1, t$2))), this.actor.registerMessageHandler("UL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).update(i$1.layers, i$1.removedIds);
					})))), this.actor.registerMessageHandler("SL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).replace(i$1);
					}))));
				}
				_setImages(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						this.availableImages[t$1] = i$1;
						for (const e$1 in this.workerSources[t$1]) {
							const o$1 = this.workerSources[t$1][e$1];
							for (const e$2 in o$1) o$1[e$2].availableImages = i$1;
						}
					}));
				}
				_syncRTLPluginState(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						return yield e.cX.syncState(i$1, this.self.importScripts);
					}));
				}
				_getAvailableImages(e$1) {
					let t$1 = this.availableImages[e$1];
					return t$1 || (t$1 = []), t$1;
				}
				_getLayerIndex(e$1) {
					let i$1 = this.layerIndexes[e$1];
					return i$1 || (i$1 = this.layerIndexes[e$1] = new t()), i$1;
				}
				_getWorkerSource(e$1, t$1, i$1) {
					if (this.workerSources[e$1] || (this.workerSources[e$1] = {}), this.workerSources[e$1][t$1] || (this.workerSources[e$1][t$1] = {}), !this.workerSources[e$1][t$1][i$1]) {
						const o$1 = { sendAsync: (t$2, i$2) => (t$2.targetMapId = e$1, this.actor.sendAsync(t$2, i$2)) };
						switch (t$1) {
							case "vector":
								this.workerSources[e$1][t$1][i$1] = new n(o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							case "geojson":
								this.workerSources[e$1][t$1][i$1] = new oe$1(o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							default: this.workerSources[e$1][t$1][i$1] = new this.externalWorkerSourceTypes[t$1](o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
						}
					}
					return this.workerSources[e$1][t$1][i$1];
				}
				_getDEMWorkerSource(e$1, t$1) {
					return this.demWorkerSources[e$1] || (this.demWorkerSources[e$1] = {}), this.demWorkerSources[e$1][t$1] || (this.demWorkerSources[e$1][t$1] = new r()), this.demWorkerSources[e$1][t$1];
				}
			}
			return e.i(self) && (self.worker = new se$1(self)), se$1;
		}));
		define$1("index", ["exports", "./shared"], (function(e, t) {
			var i = "5.6.2";
			function o() {
				var e$1 = new t.A(4);
				return t.A != Float32Array && (e$1[1] = 0, e$1[2] = 0), e$1[0] = 1, e$1[3] = 1, e$1;
			}
			let r, a;
			const s = {
				now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
				frame(e$1, i$1, o$1) {
					const r$1 = requestAnimationFrame(((e$2) => {
						a$1(), i$1(e$2);
					})), { unsubscribe: a$1 } = t.s(e$1.signal, "abort", (() => {
						a$1(), cancelAnimationFrame(r$1), o$1(t.c());
					}), !1);
				},
				frameAsync(e$1) {
					return new Promise(((t$1, i$1) => {
						this.frame(e$1, t$1, i$1);
					}));
				},
				getImageData(e$1, t$1 = 0) {
					return this.getImageCanvasContext(e$1).getImageData(-t$1, -t$1, e$1.width + 2 * t$1, e$1.height + 2 * t$1);
				},
				getImageCanvasContext(e$1) {
					const t$1 = window.document.createElement("canvas"), i$1 = t$1.getContext("2d", { willReadFrequently: !0 });
					if (!i$1) throw new Error("failed to create canvas 2d context");
					return t$1.width = e$1.width, t$1.height = e$1.height, i$1.drawImage(e$1, 0, 0, e$1.width, e$1.height), i$1;
				},
				resolveURL: (e$1) => (r || (r = document.createElement("a")), r.href = e$1, r.href),
				hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
				get prefersReducedMotion() {
					return !!matchMedia && (a ??= matchMedia("(prefers-reduced-motion: reduce)"), a.matches);
				}
			};
			class n {
				static testProp(e$1) {
					if (!n.docStyle) return e$1[0];
					for (let t$1 = 0; t$1 < e$1.length; t$1++) if (e$1[t$1] in n.docStyle) return e$1[t$1];
					return e$1[0];
				}
				static create(e$1, t$1, i$1) {
					const o$1 = window.document.createElement(e$1);
					return void 0 !== t$1 && (o$1.className = t$1), i$1 && i$1.appendChild(o$1), o$1;
				}
				static createNS(e$1, t$1) {
					return window.document.createElementNS(e$1, t$1);
				}
				static disableDrag() {
					n.docStyle && n.selectProp && (n.userSelect = n.docStyle[n.selectProp], n.docStyle[n.selectProp] = "none");
				}
				static enableDrag() {
					n.docStyle && n.selectProp && (n.docStyle[n.selectProp] = n.userSelect);
				}
				static setTransform(e$1, t$1) {
					e$1.style[n.transformProp] = t$1;
				}
				static addEventListener(e$1, t$1, i$1, o$1 = {}) {
					e$1.addEventListener(t$1, i$1, "passive" in o$1 ? o$1 : o$1.capture);
				}
				static removeEventListener(e$1, t$1, i$1, o$1 = {}) {
					e$1.removeEventListener(t$1, i$1, "passive" in o$1 ? o$1 : o$1.capture);
				}
				static suppressClickInternal(e$1) {
					e$1.preventDefault(), e$1.stopPropagation(), window.removeEventListener("click", n.suppressClickInternal, !0);
				}
				static suppressClick() {
					window.addEventListener("click", n.suppressClickInternal, !0), window.setTimeout((() => {
						window.removeEventListener("click", n.suppressClickInternal, !0);
					}), 0);
				}
				static getScale(e$1) {
					const t$1 = e$1.getBoundingClientRect();
					return {
						x: t$1.width / e$1.offsetWidth || 1,
						y: t$1.height / e$1.offsetHeight || 1,
						boundingClientRect: t$1
					};
				}
				static getPoint(e$1, i$1, o$1) {
					const r$1 = i$1.boundingClientRect;
					return new t.P((o$1.clientX - r$1.left) / i$1.x - e$1.clientLeft, (o$1.clientY - r$1.top) / i$1.y - e$1.clientTop);
				}
				static mousePos(e$1, t$1) {
					const i$1 = n.getScale(e$1);
					return n.getPoint(e$1, i$1, t$1);
				}
				static touchPos(e$1, t$1) {
					const i$1 = [], o$1 = n.getScale(e$1);
					for (let r$1 = 0; r$1 < t$1.length; r$1++) i$1.push(n.getPoint(e$1, o$1, t$1[r$1]));
					return i$1;
				}
				static mouseButton(e$1) {
					return e$1.button;
				}
				static remove(e$1) {
					e$1.parentNode && e$1.parentNode.removeChild(e$1);
				}
				static sanitize(e$1) {
					const t$1 = new DOMParser().parseFromString(e$1, "text/html").body || document.createElement("body"), i$1 = t$1.querySelectorAll("script");
					for (const e$2 of i$1) e$2.remove();
					return n.clean(t$1), t$1.innerHTML;
				}
				static isPossiblyDangerous(e$1, t$1) {
					const i$1 = t$1.replace(/\s+/g, "").toLowerCase();
					return !(![
						"src",
						"href",
						"xlink:href"
					].includes(e$1) || !i$1.includes("javascript:") && !i$1.includes("data:")) || !!e$1.startsWith("on") || void 0;
				}
				static clean(e$1) {
					const t$1 = e$1.children;
					for (const e$2 of t$1) n.removeAttributes(e$2), n.clean(e$2);
				}
				static removeAttributes(e$1) {
					for (const { name: t$1, value: i$1 } of e$1.attributes) n.isPossiblyDangerous(t$1, i$1) && e$1.removeAttribute(t$1);
				}
			}
			n.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n.selectProp = n.testProp([
				"userSelect",
				"MozUserSelect",
				"WebkitUserSelect",
				"msUserSelect"
			]), n.transformProp = n.testProp(["transform", "WebkitTransform"]);
			const l = {
				supported: !1,
				testSupport: function(e$1) {
					!u && h && (d ? _$1(e$1) : c = e$1);
				}
			};
			let c, h, u = !1, d = !1;
			function _$1(e$1) {
				const t$1 = e$1.createTexture();
				e$1.bindTexture(e$1.TEXTURE_2D, t$1);
				try {
					if (e$1.texImage2D(e$1.TEXTURE_2D, 0, e$1.RGBA, e$1.RGBA, e$1.UNSIGNED_BYTE, h), e$1.isContextLost()) return;
					l.supported = !0;
				} catch (e$2) {}
				e$1.deleteTexture(t$1), u = !0;
			}
			var p;
			"undefined" != typeof document && (h = document.createElement("img"), h.onload = () => {
				c && _$1(c), c = null, d = !0;
			}, h.onerror = () => {
				u = !0, c = null;
			}, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e$1) {
				let i$1, o$1, r$1, a$1;
				e$1.resetRequestQueue = () => {
					i$1 = [], o$1 = 0, r$1 = 0, a$1 = {};
				}, e$1.addThrottleControl = (e$2) => {
					const t$1 = r$1++;
					return a$1[t$1] = e$2, t$1;
				}, e$1.removeThrottleControl = (e$2) => {
					delete a$1[e$2], n$1();
				}, e$1.getImage = (e$2, o$2, r$2 = !0) => new Promise(((a$2, s$2) => {
					l.supported && (e$2.headers || (e$2.headers = {}), e$2.headers.accept = "image/webp,*/*"), t.e(e$2, { type: "image" }), i$1.push({
						abortController: o$2,
						requestParameters: e$2,
						supportImageRefresh: r$2,
						state: "queued",
						onError: (e$3) => {
							s$2(e$3);
						},
						onSuccess: (e$3) => {
							a$2(e$3);
						}
					}), n$1();
				}));
				const s$1 = (e$2) => t._(this, void 0, void 0, (function* () {
					e$2.state = "running";
					const { requestParameters: i$2, supportImageRefresh: r$2, onError: a$2, onSuccess: s$2, abortController: l$1 } = e$2, h$1 = !1 === r$2 && !t.i(self) && !t.g(i$2.url) && (!i$2.headers || Object.keys(i$2.headers).reduce(((e$3, t$1) => e$3 && "accept" === t$1), !0));
					o$1++;
					const u$1 = h$1 ? c$1(i$2, l$1) : t.m(i$2, l$1);
					try {
						const i$3 = yield u$1;
						delete e$2.abortController, e$2.state = "completed", i$3.data instanceof HTMLImageElement || t.b(i$3.data) ? s$2(i$3) : i$3.data && s$2({
							data: yield (d$1 = i$3.data, "function" == typeof createImageBitmap ? t.f(d$1) : t.h(d$1)),
							cacheControl: i$3.cacheControl,
							expires: i$3.expires
						});
					} catch (t$1) {
						delete e$2.abortController, a$2(t$1);
					} finally {
						o$1--, n$1();
					}
					var d$1;
				})), n$1 = () => {
					const e$2 = (() => {
						for (const e$3 of Object.keys(a$1)) if (a$1[e$3]()) return !0;
						return !1;
					})() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
					for (let t$1 = o$1; t$1 < e$2 && i$1.length > 0; t$1++) {
						const e$3 = i$1.shift();
						e$3.abortController.signal.aborted ? t$1-- : s$1(e$3);
					}
				}, c$1 = (e$2, i$2) => new Promise(((o$2, r$2) => {
					const a$2 = new Image(), s$2 = e$2.url, n$2 = e$2.credentials;
					n$2 && "include" === n$2 ? a$2.crossOrigin = "use-credentials" : (n$2 && "same-origin" === n$2 || !t.d(s$2)) && (a$2.crossOrigin = "anonymous"), i$2.signal.addEventListener("abort", (() => {
						a$2.src = "", r$2(t.c());
					})), a$2.fetchPriority = "high", a$2.onload = () => {
						a$2.onerror = a$2.onload = null, o$2({ data: a$2 });
					}, a$2.onerror = () => {
						a$2.onerror = a$2.onload = null, i$2.signal.aborted || r$2(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
					}, a$2.src = s$2;
				}));
			}(p || (p = {})), p.resetRequestQueue();
			class m {
				constructor(e$1) {
					this._transformRequestFn = null != e$1 ? e$1 : null;
				}
				transformRequest(e$1, t$1) {
					return this._transformRequestFn && this._transformRequestFn(e$1, t$1) || { url: e$1 };
				}
				setTransformRequest(e$1) {
					this._transformRequestFn = e$1;
				}
			}
			function f(e$1) {
				const t$1 = [];
				if ("string" == typeof e$1) t$1.push({
					id: "default",
					url: e$1
				});
				else if (e$1 && e$1.length > 0) {
					const i$1 = [];
					for (const { id: o$1, url: r$1 } of e$1) {
						const e$2 = `${o$1}${r$1}`;
						-1 === i$1.indexOf(e$2) && (i$1.push(e$2), t$1.push({
							id: o$1,
							url: r$1
						}));
					}
				}
				return t$1;
			}
			function g$1(e$1, t$1, i$1) {
				try {
					const o$1 = new URL(e$1);
					return o$1.pathname += `${t$1}${i$1}`, o$1.toString();
				} catch (t$2) {
					throw new Error(`Invalid sprite URL "${e$1}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
				}
			}
			function v(e$1) {
				const { userImage: t$1 } = e$1;
				return !!(t$1 && t$1.render && t$1.render()) && (e$1.data.replace(new Uint8Array(t$1.data.buffer)), !0);
			}
			class b$1 extends t.E {
				constructor() {
					super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				isLoaded() {
					return this.loaded;
				}
				setLoaded(e$1) {
					if (this.loaded !== e$1 && (this.loaded = e$1, e$1)) {
						for (const { ids: e$2, promiseResolve: t$1 } of this.requestors) t$1(this._getImagesForIds(e$2));
						this.requestors = [];
					}
				}
				getImage(e$1) {
					const i$1 = this.images[e$1];
					if (i$1 && !i$1.data && i$1.spriteData) {
						const e$2 = i$1.spriteData;
						i$1.data = new t.R({
							width: e$2.width,
							height: e$2.height
						}, e$2.context.getImageData(e$2.x, e$2.y, e$2.width, e$2.height).data), i$1.spriteData = null;
					}
					return i$1;
				}
				addImage(e$1, t$1) {
					if (this.images[e$1]) throw new Error(`Image id ${e$1} already exist, use updateImage instead`);
					this._validate(e$1, t$1) && (this.images[e$1] = t$1);
				}
				_validate(e$1, i$1) {
					let o$1 = !0;
					const r$1 = i$1.data || i$1.spriteData;
					return this._validateStretch(i$1.stretchX, r$1 && r$1.width) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchX" value`))), o$1 = !1), this._validateStretch(i$1.stretchY, r$1 && r$1.height) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchY" value`))), o$1 = !1), this._validateContent(i$1.content, i$1) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "content" value`))), o$1 = !1), o$1;
				}
				_validateStretch(e$1, t$1) {
					if (!e$1) return !0;
					let i$1 = 0;
					for (const o$1 of e$1) {
						if (o$1[0] < i$1 || o$1[1] < o$1[0] || t$1 < o$1[1]) return !1;
						i$1 = o$1[1];
					}
					return !0;
				}
				_validateContent(e$1, t$1) {
					if (!e$1) return !0;
					if (4 !== e$1.length) return !1;
					const i$1 = t$1.spriteData, o$1 = i$1 && i$1.width || t$1.data.width, r$1 = i$1 && i$1.height || t$1.data.height;
					return !(e$1[0] < 0 || o$1 < e$1[0] || e$1[1] < 0 || r$1 < e$1[1] || e$1[2] < 0 || o$1 < e$1[2] || e$1[3] < 0 || r$1 < e$1[3] || e$1[2] < e$1[0] || e$1[3] < e$1[1]);
				}
				updateImage(e$1, t$1, i$1 = !0) {
					const o$1 = this.getImage(e$1);
					if (i$1 && (o$1.data.width !== t$1.data.width || o$1.data.height !== t$1.data.height)) throw new Error(`size mismatch between old image (${o$1.data.width}x${o$1.data.height}) and new image (${t$1.data.width}x${t$1.data.height}).`);
					t$1.version = o$1.version + 1, this.images[e$1] = t$1, this.updatedImages[e$1] = !0;
				}
				removeImage(e$1) {
					const t$1 = this.images[e$1];
					delete this.images[e$1], delete this.patterns[e$1], t$1.userImage && t$1.userImage.onRemove && t$1.userImage.onRemove();
				}
				listImages() {
					return Object.keys(this.images);
				}
				getImages(e$1) {
					return new Promise(((t$1, i$1) => {
						let o$1 = !0;
						if (!this.isLoaded()) for (const t$2 of e$1) this.images[t$2] || (o$1 = !1);
						this.isLoaded() || o$1 ? t$1(this._getImagesForIds(e$1)) : this.requestors.push({
							ids: e$1,
							promiseResolve: t$1
						});
					}));
				}
				_getImagesForIds(e$1) {
					const i$1 = {};
					for (const o$1 of e$1) {
						let e$2 = this.getImage(o$1);
						e$2 || (this.fire(new t.l("styleimagemissing", { id: o$1 })), e$2 = this.getImage(o$1)), e$2 ? i$1[o$1] = {
							data: e$2.data.clone(),
							pixelRatio: e$2.pixelRatio,
							sdf: e$2.sdf,
							version: e$2.version,
							stretchX: e$2.stretchX,
							stretchY: e$2.stretchY,
							content: e$2.content,
							textFitWidth: e$2.textFitWidth,
							textFitHeight: e$2.textFitHeight,
							hasRenderCallback: Boolean(e$2.userImage && e$2.userImage.render)
						} : t.w(`Image "${o$1}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
					}
					return i$1;
				}
				getPixelSize() {
					const { width: e$1, height: t$1 } = this.atlasImage;
					return {
						width: e$1,
						height: t$1
					};
				}
				getPattern(e$1) {
					const i$1 = this.patterns[e$1], o$1 = this.getImage(e$1);
					if (!o$1) return null;
					if (i$1 && i$1.position.version === o$1.version) return i$1.position;
					if (i$1) i$1.position.version = o$1.version;
					else {
						const i$2 = {
							w: o$1.data.width + 2,
							h: o$1.data.height + 2,
							x: 0,
							y: 0
						}, r$1 = new t.I(i$2, o$1);
						this.patterns[e$1] = {
							bin: i$2,
							position: r$1
						};
					}
					return this._updatePatternAtlas(), this.patterns[e$1].position;
				}
				bind(e$1) {
					const i$1 = e$1.gl;
					this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.T(e$1, this.atlasImage, i$1.RGBA), this.atlasTexture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas() {
					const e$1 = [];
					for (const t$1 in this.patterns) e$1.push(this.patterns[t$1].bin);
					const { w: i$1, h: o$1 } = t.p(e$1), r$1 = this.atlasImage;
					r$1.resize({
						width: i$1 || 1,
						height: o$1 || 1
					});
					for (const e$2 in this.patterns) {
						const { bin: i$2 } = this.patterns[e$2], o$2 = i$2.x + 1, a$1 = i$2.y + 1, s$1 = this.getImage(e$2).data, n$1 = s$1.width, l$1 = s$1.height;
						t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2,
							y: a$1
						}, {
							width: n$1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: l$1 - 1
						}, {
							x: o$2,
							y: a$1 - 1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2,
							y: a$1 + l$1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: n$1 - 1,
							y: 0
						}, {
							x: o$2 - 1,
							y: a$1
						}, {
							width: 1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2 + n$1,
							y: a$1
						}, {
							width: 1,
							height: l$1
						});
					}
					this.dirty = !0;
				}
				beginFrame() {
					this.callbackDispatchedThisFrame = {};
				}
				dispatchRenderCallbacks(e$1) {
					for (const i$1 of e$1) {
						if (this.callbackDispatchedThisFrame[i$1]) continue;
						this.callbackDispatchedThisFrame[i$1] = !0;
						const e$2 = this.getImage(i$1);
						e$2 || t.w(`Image with ID: "${i$1}" was not found`), v(e$2) && this.updateImage(i$1, e$2);
					}
				}
			}
			const x = 0x56bc75e2d63100000;
			function y(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				for (let c$1 = t$1; c$1 < t$1 + o$1; c$1++) w(e$1, i$1 * a$1 + c$1, a$1, r$1, s$1, n$1, l$1);
				for (let c$1 = i$1; c$1 < i$1 + r$1; c$1++) w(e$1, c$1 * a$1 + t$1, 1, o$1, s$1, n$1, l$1);
			}
			function w(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
				a$1[0] = 0, s$1[0] = -x, s$1[1] = x, r$1[0] = e$1[t$1];
				for (let n$1 = 1, l$1 = 0, c$1 = 0; n$1 < o$1; n$1++) {
					r$1[n$1] = e$1[t$1 + n$1 * i$1];
					const o$2 = n$1 * n$1;
					do {
						const e$2 = a$1[l$1];
						c$1 = (r$1[n$1] - r$1[e$2] + o$2 - e$2 * e$2) / (n$1 - e$2) / 2;
					} while (c$1 <= s$1[l$1] && --l$1 > -1);
					l$1++, a$1[l$1] = n$1, s$1[l$1] = c$1, s$1[l$1 + 1] = x;
				}
				for (let n$1 = 0, l$1 = 0; n$1 < o$1; n$1++) {
					for (; s$1[l$1 + 1] < n$1;) l$1++;
					const o$2 = a$1[l$1], c$1 = n$1 - o$2;
					e$1[t$1 + n$1 * i$1] = r$1[o$2] + c$1 * c$1;
				}
			}
			class T$1 {
				constructor(e$1, t$1) {
					this.requestManager = e$1, this.localIdeographFontFamily = t$1, this.entries = {};
				}
				setURL(e$1) {
					this.url = e$1;
				}
				getGlyphs(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = [];
						for (const i$2 in e$1) for (const o$2 of e$1[i$2]) t$1.push(this._getAndCacheGlyphsPromise(i$2, o$2));
						const i$1 = yield Promise.all(t$1), o$1 = {};
						for (const { stack: e$2, id: t$2, glyph: r$1 } of i$1) o$1[e$2] || (o$1[e$2] = {}), o$1[e$2][t$2] = r$1 && {
							id: r$1.id,
							bitmap: r$1.bitmap.clone(),
							metrics: r$1.metrics
						};
						return o$1;
					}));
				}
				_getAndCacheGlyphsPromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						let t$1 = this.entries[e$1];
						t$1 || (t$1 = this.entries[e$1] = {
							glyphs: {},
							requests: {},
							ranges: {}
						});
						let o$1 = t$1.glyphs[i$1];
						if (void 0 !== o$1) return {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						if (o$1 = this._tinySDF(t$1, e$1, i$1), o$1) return t$1.glyphs[i$1] = o$1, {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						const r$1 = Math.floor(i$1 / 256);
						if (256 * r$1 > 65535) throw new Error("glyphs > 65535 not supported");
						if (t$1.ranges[r$1]) return {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						if (!this.url) throw new Error("glyphsUrl is not set");
						if (!t$1.requests[r$1]) {
							const i$2 = T$1.loadGlyphRange(e$1, r$1, this.url, this.requestManager);
							t$1.requests[r$1] = i$2;
						}
						const a$1 = yield t$1.requests[r$1];
						for (const e$2 in a$1) this._doesCharSupportLocalGlyph(+e$2) || (t$1.glyphs[+e$2] = a$1[+e$2]);
						return t$1.ranges[r$1] = !0, {
							stack: e$1,
							id: i$1,
							glyph: a$1[i$1] || null
						};
					}));
				}
				_doesCharSupportLocalGlyph(e$1) {
					return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e$1)) || t.u["CJK Unified Ideographs"](e$1) || t.u["Hangul Syllables"](e$1) || t.u.Hiragana(e$1) || t.u.Katakana(e$1) || t.u["CJK Symbols and Punctuation"](e$1) || t.u["Halfwidth and Fullwidth Forms"](e$1));
				}
				_tinySDF(e$1, i$1, o$1) {
					const r$1 = this.localIdeographFontFamily;
					if (!r$1) return;
					if (!this._doesCharSupportLocalGlyph(o$1)) return;
					let a$1 = e$1.tinySDF;
					if (!a$1) {
						let t$1 = "400";
						/bold/i.test(i$1) ? t$1 = "900" : /medium/i.test(i$1) ? t$1 = "500" : /light/i.test(i$1) && (t$1 = "200"), a$1 = e$1.tinySDF = new T$1.TinySDF({
							fontSize: 48,
							buffer: 6,
							radius: 16,
							cutoff: .25,
							fontFamily: r$1,
							fontWeight: t$1
						});
					}
					const s$1 = a$1.draw(String.fromCharCode(o$1));
					return {
						id: o$1,
						bitmap: new t.q({
							width: s$1.width || 60,
							height: s$1.height || 60
						}, s$1.data),
						metrics: {
							width: s$1.glyphWidth / 2 || 24,
							height: s$1.glyphHeight / 2 || 24,
							left: s$1.glyphLeft / 2 + .5 || 0,
							top: s$1.glyphTop / 2 - 27.5 || -8,
							advance: s$1.glyphAdvance / 2 || 24,
							isDoubleResolution: !0
						}
					};
				}
			}
			T$1.loadGlyphRange = function(e$1, i$1, o$1, r$1) {
				return t._(this, void 0, void 0, (function* () {
					const a$1 = 256 * i$1, s$1 = a$1 + 255, n$1 = r$1.transformRequest(o$1.replace("{fontstack}", e$1).replace("{range}", `${a$1}-${s$1}`), "Glyphs"), l$1 = yield t.n(n$1, new AbortController());
					if (!l$1 || !l$1.data) throw new Error(`Could not load glyph range. range: ${i$1}, ${a$1}-${s$1}`);
					const c$1 = {};
					for (const e$2 of t.o(l$1.data)) c$1[e$2.id] = e$2;
					return c$1;
				}));
			}, T$1.TinySDF = class {
				constructor({ fontSize: e$1 = 24, buffer: t$1 = 3, radius: i$1 = 8, cutoff: o$1 = .25, fontFamily: r$1 = "sans-serif", fontWeight: a$1 = "normal", fontStyle: s$1 = "normal", lang: n$1 = null } = {}) {
					this.buffer = t$1, this.cutoff = o$1, this.radius = i$1, this.lang = n$1;
					const l$1 = this.size = e$1 + 4 * t$1, h$1 = this.ctx = this._createCanvas(l$1).getContext("2d", { willReadFrequently: !0 });
					h$1.font = `${s$1} ${a$1} ${e$1}px ${r$1}`, h$1.textBaseline = "alphabetic", h$1.textAlign = "left", h$1.fillStyle = "black", this.gridOuter = new Float64Array(l$1 * l$1), this.gridInner = new Float64Array(l$1 * l$1), this.f = new Float64Array(l$1), this.z = new Float64Array(l$1 + 1), this.v = new Uint16Array(l$1);
				}
				_createCanvas(e$1) {
					const t$1 = document.createElement("canvas");
					return t$1.width = t$1.height = e$1, t$1;
				}
				draw(e$1) {
					const { width: t$1, actualBoundingBoxAscent: i$1, actualBoundingBoxDescent: o$1, actualBoundingBoxLeft: r$1, actualBoundingBoxRight: a$1 } = this.ctx.measureText(e$1), s$1 = Math.ceil(i$1), n$1 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a$1 - r$1))), l$1 = Math.min(this.size - this.buffer, s$1 + Math.ceil(o$1)), c$1 = n$1 + 2 * this.buffer, h$1 = l$1 + 2 * this.buffer, u$1 = Math.max(c$1 * h$1, 0), d$1 = new Uint8ClampedArray(u$1), _$2 = {
						data: d$1,
						width: c$1,
						height: h$1,
						glyphWidth: n$1,
						glyphHeight: l$1,
						glyphTop: s$1,
						glyphLeft: 0,
						glyphAdvance: t$1
					};
					if (0 === n$1 || 0 === l$1) return _$2;
					const { ctx: p$1, buffer: m$1, gridInner: f$1, gridOuter: g$2 } = this;
					this.lang && (p$1.lang = this.lang), p$1.clearRect(m$1, m$1, n$1, l$1), p$1.fillText(e$1, m$1, m$1 + s$1);
					const v$1 = p$1.getImageData(m$1, m$1, n$1, l$1);
					g$2.fill(x, 0, u$1), f$1.fill(0, 0, u$1);
					for (let e$2 = 0; e$2 < l$1; e$2++) for (let t$2 = 0; t$2 < n$1; t$2++) {
						const i$2 = v$1.data[4 * (e$2 * n$1 + t$2) + 3] / 255;
						if (0 === i$2) continue;
						const o$2 = (e$2 + m$1) * c$1 + t$2 + m$1;
						if (1 === i$2) g$2[o$2] = 0, f$1[o$2] = x;
						else {
							const e$3 = .5 - i$2;
							g$2[o$2] = e$3 > 0 ? e$3 * e$3 : 0, f$1[o$2] = e$3 < 0 ? e$3 * e$3 : 0;
						}
					}
					y(g$2, 0, 0, c$1, h$1, c$1, this.f, this.v, this.z), y(f$1, m$1, m$1, n$1, l$1, c$1, this.f, this.v, this.z);
					for (let e$2 = 0; e$2 < u$1; e$2++) {
						const t$2 = Math.sqrt(g$2[e$2]) - Math.sqrt(f$1[e$2]);
						d$1[e$2] = Math.round(255 - 255 * (t$2 / this.radius + this.cutoff));
					}
					return _$2;
				}
			};
			class P$1 {
				constructor() {
					this.specification = t.v.light.position;
				}
				possiblyEvaluate(e$1, i$1) {
					return t.B(e$1.expression.evaluate(i$1));
				}
				interpolate(e$1, i$1, o$1) {
					return {
						x: t.C.number(e$1.x, i$1.x, o$1),
						y: t.C.number(e$1.y, i$1.y, o$1),
						z: t.C.number(e$1.z, i$1.z, o$1)
					};
				}
			}
			let C;
			class I$1 extends t.E {
				constructor(e$1) {
					super(), C = C || new t.r({
						anchor: new t.D(t.v.light.anchor),
						position: new P$1(),
						color: new t.D(t.v.light.color),
						intensity: new t.D(t.v.light.intensity)
					}), this._transitionable = new t.t(C), this.setLight(e$1), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e$1, i$1 = {}) {
					if (!this._validate(t.x, e$1, i$1)) for (const t$1 in e$1) {
						const i$2 = e$1[t$1];
						t$1.endsWith("-transition") ? this._transitionable.setTransition(t$1.slice(0, -11), i$2) : this._transitionable.setValue(t$1, i$2);
					}
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && t.y(this, e$1.call(t.z, {
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					}));
				}
			}
			const M$1 = new t.r({
				"sky-color": new t.D(t.v.sky["sky-color"]),
				"horizon-color": new t.D(t.v.sky["horizon-color"]),
				"fog-color": new t.D(t.v.sky["fog-color"]),
				"fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]),
				"horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]),
				"sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]),
				"atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"])
			});
			class S$1 extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.t(M$1), this.setSky(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0));
				}
				setSky(e$1, i$1 = {}) {
					if (!this._validate(t.G, e$1, i$1)) {
						e$1 || (e$1 = {
							"sky-color": "transparent",
							"horizon-color": "transparent",
							"fog-color": "transparent",
							"fog-ground-blend": 1,
							"atmosphere-blend": 0
						});
						for (const t$1 in e$1) {
							const i$2 = e$1[t$1];
							t$1.endsWith("-transition") ? this._transitionable.setTransition(t$1.slice(0, -11), i$2) : this._transitionable.setValue(t$1, i$2);
						}
					}
				}
				getSky() {
					return this._transitionable.serialize();
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, o$1 = {}) {
					return !1 !== (null == o$1 ? void 0 : o$1.validate) && t.y(this, e$1.call(t.z, t.e({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					})));
				}
				calculateFogBlendOpacity(e$1) {
					return e$1 < 60 ? 0 : e$1 < 70 ? (e$1 - 60) / 10 : 1;
				}
			}
			class E {
				constructor(e$1, t$1) {
					this.width = e$1, this.height = t$1, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
				}
				getDash(e$1, t$1) {
					const i$1 = e$1.join(",") + String(t$1);
					return this.dashEntry[i$1] || (this.dashEntry[i$1] = this.addDash(e$1, t$1)), this.dashEntry[i$1];
				}
				getDashRanges(e$1, t$1, i$1) {
					const o$1 = [];
					let r$1 = e$1.length % 2 == 1 ? -e$1[e$1.length - 1] * i$1 : 0, a$1 = e$1[0] * i$1, s$1 = !0;
					o$1.push({
						left: r$1,
						right: a$1,
						isDash: s$1,
						zeroLength: 0 === e$1[0]
					});
					let n$1 = e$1[0];
					for (let t$2 = 1; t$2 < e$1.length; t$2++) {
						s$1 = !s$1;
						const l$1 = e$1[t$2];
						r$1 = n$1 * i$1, n$1 += l$1, a$1 = n$1 * i$1, o$1.push({
							left: r$1,
							right: a$1,
							isDash: s$1,
							zeroLength: 0 === l$1
						});
					}
					return o$1;
				}
				addRoundDash(e$1, t$1, i$1) {
					const o$1 = t$1 / 2;
					for (let t$2 = -i$1; t$2 <= i$1; t$2++) {
						const r$1 = this.width * (this.nextRow + i$1 + t$2);
						let a$1 = 0, s$1 = e$1[a$1];
						for (let n$1 = 0; n$1 < this.width; n$1++) {
							n$1 / s$1.right > 1 && (s$1 = e$1[++a$1]);
							const l$1 = Math.abs(n$1 - s$1.left), c$1 = Math.abs(n$1 - s$1.right), h$1 = Math.min(l$1, c$1);
							let u$1;
							const d$1 = t$2 / i$1 * (o$1 + 1);
							if (s$1.isDash) {
								const e$2 = o$1 - Math.abs(d$1);
								u$1 = Math.sqrt(h$1 * h$1 + e$2 * e$2);
							} else u$1 = o$1 - Math.sqrt(h$1 * h$1 + d$1 * d$1);
							this.data[r$1 + n$1] = Math.max(0, Math.min(255, u$1 + 128));
						}
					}
				}
				addRegularDash(e$1) {
					for (let t$2 = e$1.length - 1; t$2 >= 0; --t$2) {
						const i$2 = e$1[t$2], o$2 = e$1[t$2 + 1];
						i$2.zeroLength ? e$1.splice(t$2, 1) : o$2 && o$2.isDash === i$2.isDash && (o$2.left = i$2.left, e$1.splice(t$2, 1));
					}
					const t$1 = e$1[0], i$1 = e$1[e$1.length - 1];
					t$1.isDash === i$1.isDash && (t$1.left = i$1.left - this.width, i$1.right = t$1.right + this.width);
					const o$1 = this.width * this.nextRow;
					let r$1 = 0, a$1 = e$1[r$1];
					for (let t$2 = 0; t$2 < this.width; t$2++) {
						t$2 / a$1.right > 1 && (a$1 = e$1[++r$1]);
						const i$2 = Math.abs(t$2 - a$1.left), s$1 = Math.abs(t$2 - a$1.right), n$1 = Math.min(i$2, s$1);
						this.data[o$1 + t$2] = Math.max(0, Math.min(255, (a$1.isDash ? n$1 : -n$1) + 128));
					}
				}
				addDash(e$1, i$1) {
					const o$1 = i$1 ? 7 : 0, r$1 = 2 * o$1 + 1;
					if (this.nextRow + r$1 > this.height) return t.w("LineAtlas out of space"), null;
					let a$1 = 0;
					for (let t$1 = 0; t$1 < e$1.length; t$1++) a$1 += e$1[t$1];
					if (0 !== a$1) {
						const t$1 = this.width / a$1, r$2 = this.getDashRanges(e$1, this.width, t$1);
						i$1 ? this.addRoundDash(r$2, t$1, o$1) : this.addRegularDash(r$2);
					}
					const s$1 = {
						y: (this.nextRow + o$1 + .5) / this.height,
						height: 2 * o$1 / this.height,
						width: a$1
					};
					return this.nextRow += r$1, this.dirty = !0, s$1;
				}
				bind(e$1) {
					const t$1 = e$1.gl;
					this.texture ? (t$1.bindTexture(t$1.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t$1.texSubImage2D(t$1.TEXTURE_2D, 0, 0, 0, this.width, this.height, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data))) : (this.texture = t$1.createTexture(), t$1.bindTexture(t$1.TEXTURE_2D, this.texture), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_S, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_T, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MIN_FILTER, t$1.LINEAR), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MAG_FILTER, t$1.LINEAR), t$1.texImage2D(t$1.TEXTURE_2D, 0, t$1.ALPHA, this.width, this.height, 0, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data));
				}
			}
			const R$2 = "maplibre_preloaded_worker_pool";
			class z$1 {
				constructor() {
					this.active = {};
				}
				acquire(e$1) {
					if (!this.workers) for (this.workers = []; this.workers.length < z$1.workerCount;) this.workers.push(new Worker(t.a.WORKER_URL));
					return this.active[e$1] = !0, this.workers.slice();
				}
				release(e$1) {
					delete this.active[e$1], 0 === this.numActive() && (this.workers.forEach(((e$2) => {
						e$2.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[R$2];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			const D$1 = Math.floor(s.hardwareConcurrency / 2);
			let A, L$1;
			function k$1() {
				return A || (A = new z$1()), A;
			}
			z$1.workerCount = t.H(globalThis) ? Math.max(Math.min(D$1, 3), 1) : 1;
			class F$1 {
				constructor(e$1, i$1) {
					this.workerPool = e$1, this.actors = [], this.currentActor = 0, this.id = i$1;
					const o$1 = this.workerPool.acquire(i$1);
					for (let e$2 = 0; e$2 < o$1.length; e$2++) {
						const r$1 = new t.J(o$1[e$2], i$1);
						r$1.name = `Worker ${e$2}`, this.actors.push(r$1);
					}
					if (!this.actors.length) throw new Error("No actors found");
				}
				broadcast(e$1, t$1) {
					const i$1 = [];
					for (const o$1 of this.actors) i$1.push(o$1.sendAsync({
						type: e$1,
						data: t$1
					}));
					return Promise.all(i$1);
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove(e$1 = !0) {
					this.actors.forEach(((e$2) => {
						e$2.remove();
					})), this.actors = [], e$1 && this.workerPool.release(this.id);
				}
				registerMessageHandler(e$1, t$1) {
					for (const i$1 of this.actors) i$1.registerMessageHandler(e$1, t$1);
				}
			}
			function B$1() {
				return L$1 || (L$1 = new F$1(k$1(), t.K), L$1.registerMessageHandler("GR", ((e$1, i$1, o$1) => t.m(i$1, o$1)))), L$1;
			}
			function O$1(e$1, i$1) {
				const o$1 = t.L();
				return t.M(o$1, o$1, [
					1,
					1,
					0
				]), t.N(o$1, o$1, [
					.5 * e$1.width,
					.5 * e$1.height,
					1
				]), e$1.calculatePosMatrix ? t.O(o$1, o$1, e$1.calculatePosMatrix(i$1.toUnwrapped())) : o$1;
			}
			function j$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
				var n$1;
				const l$1 = function(e$2, t$2, i$2) {
					if (e$2) for (const o$2 of e$2) {
						const e$3 = t$2[o$2];
						if (e$3 && e$3.source === i$2 && "fill-extrusion" === e$3.type) return !0;
					}
					else for (const e$3 in t$2) {
						const o$2 = t$2[e$3];
						if (o$2.source === i$2 && "fill-extrusion" === o$2.type) return !0;
					}
					return !1;
				}(null !== (n$1 = null == r$1 ? void 0 : r$1.layers) && void 0 !== n$1 ? n$1 : null, t$1, e$1.id), c$1 = a$1.maxPitchScaleFactor(), h$1 = e$1.tilesIn(o$1, c$1, l$1);
				h$1.sort(N);
				const u$1 = [];
				for (const o$2 of h$1) u$1.push({
					wrappedTileID: o$2.tileID.wrapped().key,
					queryResults: o$2.tile.queryRenderedFeatures(t$1, i$1, e$1._state, o$2.queryGeometry, o$2.cameraQueryGeometry, o$2.scale, r$1, a$1, c$1, O$1(e$1.transform, o$2.tileID), s$1 ? (e$2, t$2) => s$1(o$2.tileID, e$2, t$2) : void 0)
				});
				return function(e$2, t$2) {
					for (const i$2 in e$2) for (const o$2 of e$2[i$2]) U$1(o$2, t$2);
					return e$2;
				}(function(e$2) {
					const t$2 = {}, i$2 = {};
					for (const o$2 of e$2) {
						const e$3 = o$2.queryResults, r$2 = o$2.wrappedTileID, a$2 = i$2[r$2] = i$2[r$2] || {};
						for (const i$3 in e$3) {
							const o$3 = e$3[i$3], r$3 = a$2[i$3] = a$2[i$3] || {}, s$2 = t$2[i$3] = t$2[i$3] || [];
							for (const e$4 of o$3) r$3[e$4.featureIndex] || (r$3[e$4.featureIndex] = !0, s$2.push(e$4));
						}
					}
					return t$2;
				}(u$1), e$1);
			}
			function N(e$1, t$1) {
				const i$1 = e$1.tileID, o$1 = t$1.tileID;
				return i$1.overscaledZ - o$1.overscaledZ || i$1.canonical.y - o$1.canonical.y || i$1.wrap - o$1.wrap || i$1.canonical.x - o$1.canonical.x;
			}
			function U$1(e$1, t$1) {
				const i$1 = e$1.feature, o$1 = t$1.getFeatureState(i$1.layer["source-layer"], i$1.id);
				i$1.source = i$1.layer.source, i$1.layer["source-layer"] && (i$1.sourceLayer = i$1.layer["source-layer"]), i$1.state = o$1;
			}
			function Z$1(e$1, i$1, o$1) {
				return t._(this, void 0, void 0, (function* () {
					let r$1 = e$1;
					if (e$1.url ? r$1 = (yield t.j(i$1.transformRequest(e$1.url, "Source"), o$1)).data : yield s.frameAsync(o$1), !r$1) return null;
					const a$1 = t.Q(t.e(r$1, e$1), [
						"tiles",
						"minzoom",
						"maxzoom",
						"attribution",
						"bounds",
						"scheme",
						"tileSize",
						"encoding"
					]);
					return "vector_layers" in r$1 && r$1.vector_layers && (a$1.vectorLayerIds = r$1.vector_layers.map(((e$2) => e$2.id))), a$1;
				}));
			}
			class G$1 {
				constructor(e$1, t$1) {
					e$1 && (t$1 ? this.setSouthWest(e$1).setNorthEast(t$1) : Array.isArray(e$1) && (4 === e$1.length ? this.setSouthWest([e$1[0], e$1[1]]).setNorthEast([e$1[2], e$1[3]]) : this.setSouthWest(e$1[0]).setNorthEast(e$1[1])));
				}
				setNorthEast(e$1) {
					return this._ne = e$1 instanceof t.S ? new t.S(e$1.lng, e$1.lat) : t.S.convert(e$1), this;
				}
				setSouthWest(e$1) {
					return this._sw = e$1 instanceof t.S ? new t.S(e$1.lng, e$1.lat) : t.S.convert(e$1), this;
				}
				extend(e$1) {
					const i$1 = this._sw, o$1 = this._ne;
					let r$1, a$1;
					if (e$1 instanceof t.S) r$1 = e$1, a$1 = e$1;
					else {
						if (!(e$1 instanceof G$1)) return Array.isArray(e$1) ? 4 === e$1.length || e$1.every(Array.isArray) ? this.extend(G$1.convert(e$1)) : this.extend(t.S.convert(e$1)) : e$1 && ("lng" in e$1 || "lon" in e$1) && "lat" in e$1 ? this.extend(t.S.convert(e$1)) : this;
						if (r$1 = e$1._sw, a$1 = e$1._ne, !r$1 || !a$1) return this;
					}
					return i$1 || o$1 ? (i$1.lng = Math.min(r$1.lng, i$1.lng), i$1.lat = Math.min(r$1.lat, i$1.lat), o$1.lng = Math.max(a$1.lng, o$1.lng), o$1.lat = Math.max(a$1.lat, o$1.lat)) : (this._sw = new t.S(r$1.lng, r$1.lat), this._ne = new t.S(a$1.lng, a$1.lat)), this;
				}
				getCenter() {
					return new t.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new t.S(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new t.S(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(e$1) {
					const { lng: i$1, lat: o$1 } = t.S.convert(e$1);
					let r$1 = this._sw.lng <= i$1 && i$1 <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (r$1 = this._sw.lng >= i$1 && i$1 >= this._ne.lng), this._sw.lat <= o$1 && o$1 <= this._ne.lat && r$1;
				}
				static convert(e$1) {
					return e$1 instanceof G$1 ? e$1 : e$1 ? new G$1(e$1) : e$1;
				}
				static fromLngLat(e$1, i$1 = 0) {
					const o$1 = 360 * i$1 / 40075017, r$1 = o$1 / Math.cos(Math.PI / 180 * e$1.lat);
					return new G$1(new t.S(e$1.lng - r$1, e$1.lat - o$1), new t.S(e$1.lng + r$1, e$1.lat + o$1));
				}
				adjustAntiMeridian() {
					const e$1 = new t.S(this._sw.lng, this._sw.lat), i$1 = new t.S(this._ne.lng, this._ne.lat);
					return new G$1(e$1, e$1.lng > i$1.lng ? new t.S(i$1.lng + 360, i$1.lat) : i$1);
				}
			}
			class V {
				constructor(e$1, t$1, i$1) {
					this.bounds = G$1.convert(this.validateBounds(e$1)), this.minzoom = t$1 || 0, this.maxzoom = i$1 || 24;
				}
				validateBounds(e$1) {
					return Array.isArray(e$1) && 4 === e$1.length ? [
						Math.max(-180, e$1[0]),
						Math.max(-90, e$1[1]),
						Math.min(180, e$1[2]),
						Math.min(90, e$1[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				contains(e$1) {
					const i$1 = Math.pow(2, e$1.z), o$1 = Math.floor(t.V(this.bounds.getWest()) * i$1), r$1 = Math.floor(t.U(this.bounds.getNorth()) * i$1), a$1 = Math.ceil(t.V(this.bounds.getEast()) * i$1), s$1 = Math.ceil(t.U(this.bounds.getSouth()) * i$1);
					return e$1.x >= o$1 && e$1.x < a$1 && e$1.y >= r$1 && e$1.y < s$1;
				}
			}
			class $$1 extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					if (super(), this.id = e$1, this.dispatcher = o$1, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.Q(i$1, [
						"url",
						"scheme",
						"tileSize",
						"promoteId"
					])), this._options = t.e({ type: "vector" }, i$1), this._collectResourceTiming = i$1.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(r$1);
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const e$1 = yield Z$1(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e$1 && (t.e(this, e$1), e$1.bounds && (this.tileBounds = new V(e$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content"
							})));
						} catch (e$1) {
							this._tileJSONRequest = null, this.fire(new t.k(e$1));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && this._tileJSONRequest.abort(), e$1(), this.load();
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				serialize() {
					return t.e({}, this._options);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i$1 = {
							request: this.map._requestManager.transformRequest(t$1, "Tile"),
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							tileSize: this.tileSize * e$1.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
							globalState: this.map.getGlobalState()
						};
						i$1.request.collectResourceTiming = this._collectResourceTiming;
						let o$1 = "RT";
						if (e$1.actor && "expired" !== e$1.state) {
							if ("loading" === e$1.state) return new Promise(((t$2, i$2) => {
								e$1.reloadPromise = {
									resolve: t$2,
									reject: i$2
								};
							}));
						} else e$1.actor = this.dispatcher.getActor(), o$1 = "LT";
						e$1.abortController = new AbortController();
						try {
							const t$2 = yield e$1.actor.sendAsync({
								type: o$1,
								data: i$1
							}, e$1.abortController);
							if (delete e$1.abortController, e$1.aborted) return;
							this._afterTileLoadWorkerResponse(e$1, t$2);
						} catch (t$2) {
							if (delete e$1.abortController, e$1.aborted) return;
							if (t$2 && 404 !== t$2.status) throw t$2;
							this._afterTileLoadWorkerResponse(e$1, null);
						}
					}));
				}
				_afterTileLoadWorkerResponse(e$1, t$1) {
					if (t$1 && t$1.resourceTiming && (e$1.resourceTiming = t$1.resourceTiming), t$1 && this.map._refreshExpiredTiles && e$1.setExpiryData(t$1), e$1.loadVectorData(t$1, this.map.painter), e$1.reloadPromise) {
						const t$2 = e$1.reloadPromise;
						e$1.reloadPromise = null, this.loadTile(e$1).then(t$2.resolve).catch(t$2.reject);
					}
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.actor && (yield e$1.actor.sendAsync({
							type: "AT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), e$1.actor && (yield e$1.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class q$1 extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					super(), this.id = e$1, this.dispatcher = o$1, this.setEventedParent(r$1), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, i$1), t.e(this, t.Q(i$1, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load() {
					return t._(this, arguments, void 0, (function* (e$1 = !1) {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const i$1 = yield Z$1(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, i$1 && (t.e(this, i$1), i$1.bounds && (this.tileBounds = new V(i$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content",
								sourceDataChanged: e$1
							})));
						} catch (e$2) {
							this._tileJSONRequest = null, this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e$1(), this.load(!0);
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				serialize() {
					return t.e({}, this._options);
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
						e$1.abortController = new AbortController();
						try {
							const o$1 = yield p.getImage(this.map._requestManager.transformRequest(i$1, "Tile"), e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (o$1 && o$1.data) {
								this.map._refreshExpiredTiles && (o$1.cacheControl || o$1.expires) && e$1.setExpiryData({
									cacheControl: o$1.cacheControl,
									expires: o$1.expires
								});
								const i$2 = this.map.painter.context, r$1 = i$2.gl, a$1 = o$1.data;
								e$1.texture = this.map.painter.getTileTexture(a$1.width), e$1.texture ? e$1.texture.update(a$1, { useMipmap: !0 }) : (e$1.texture = new t.T(i$2, a$1, r$1.RGBA, { useMipmap: !0 }), e$1.texture.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE, r$1.LINEAR_MIPMAP_NEAREST)), e$1.state = "loaded";
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController);
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.texture && this.map.painter.saveTileTexture(e$1.texture);
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class W$1 extends q$1 {
				constructor(e$1, i$1, o$1, r$1) {
					super(e$1, i$1, o$1, r$1), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i$1), this.encoding = i$1.encoding || "mapbox", this.redFactor = i$1.redFactor, this.greenFactor = i$1.greenFactor, this.blueFactor = i$1.blueFactor, this.baseShift = i$1.baseShift;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o$1 = this.map._requestManager.transformRequest(i$1, "Tile");
						e$1.neighboringTiles = this._getNeighboringTiles(e$1.tileID), e$1.abortController = new AbortController();
						try {
							const i$2 = yield p.getImage(o$1, e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (i$2 && i$2.data) {
								const o$2 = i$2.data;
								this.map._refreshExpiredTiles && (i$2.cacheControl || i$2.expires) && e$1.setExpiryData({
									cacheControl: i$2.cacheControl,
									expires: i$2.expires
								});
								const r$1 = t.b(o$2) && t.W() ? o$2 : yield this.readImageNow(o$2), a$1 = {
									type: this.type,
									uid: e$1.uid,
									source: this.id,
									rawImageData: r$1,
									encoding: this.encoding,
									redFactor: this.redFactor,
									greenFactor: this.greenFactor,
									blueFactor: this.blueFactor,
									baseShift: this.baseShift
								};
								if (!e$1.actor || "expired" === e$1.state) {
									e$1.actor = this.dispatcher.getActor();
									e$1.dem = yield e$1.actor.sendAsync({
										type: "LDT",
										data: a$1
									}), e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0, e$1.state = "loaded";
								}
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				readImageNow(e$1) {
					return t._(this, void 0, void 0, (function* () {
						if ("undefined" != typeof VideoFrame && t.X()) {
							const i$1 = e$1.width + 2, o$1 = e$1.height + 2;
							try {
								return new t.R({
									width: i$1,
									height: o$1
								}, yield t.Y(e$1, -1, -1, i$1, o$1));
							} catch (e$2) {}
						}
						return s.getImageData(e$1, 1);
					}));
				}
				_getNeighboringTiles(e$1) {
					const i$1 = e$1.canonical, o$1 = Math.pow(2, i$1.z), r$1 = (i$1.x - 1 + o$1) % o$1, a$1 = 0 === i$1.x ? e$1.wrap - 1 : e$1.wrap, s$1 = (i$1.x + 1 + o$1) % o$1, n$1 = i$1.x + 1 === o$1 ? e$1.wrap + 1 : e$1.wrap, l$1 = {};
					return l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y).key] = { backfilled: !1 }, i$1.y > 0 && (l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y - 1).key] = { backfilled: !1 }), i$1.y + 1 < o$1 && (l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y + 1).key] = { backfilled: !1 }), l$1;
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.demTexture && this.map.painter.saveTileTexture(e$1.demTexture), e$1.fbo && (e$1.fbo.destroy(), delete e$1.fbo), e$1.dem && delete e$1.dem, delete e$1.neighboringTiles, e$1.state = "unloaded", e$1.actor && (yield e$1.actor.sendAsync({
							type: "RDT",
							data: {
								type: this.type,
								uid: e$1.uid,
								source: this.id
							}
						}));
					}));
				}
			}
			class H$1 extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					super(), this.id = e$1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: i$1.data }, this.actor = o$1.getActor(), this.setEventedParent(r$1), this._data = i$1.data, this._options = t.e({}, i$1), this._collectResourceTiming = i$1.collectResourceTiming, void 0 !== i$1.maxzoom && (this.maxzoom = i$1.maxzoom), i$1.type && (this.type = i$1.type), i$1.attribution && (this.attribution = i$1.attribution), this.promoteId = i$1.promoteId, void 0 !== i$1.clusterMaxZoom && this.maxzoom <= i$1.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i$1.clusterMaxZoom}".`), this.workerOptions = t.e({
						source: this.id,
						cluster: i$1.cluster || !1,
						geojsonVtOptions: {
							buffer: this._pixelsToTileUnits(void 0 !== i$1.buffer ? i$1.buffer : 128),
							tolerance: this._pixelsToTileUnits(void 0 !== i$1.tolerance ? i$1.tolerance : .375),
							extent: t.$,
							maxZoom: this.maxzoom,
							lineMetrics: i$1.lineMetrics || !1,
							generateId: i$1.generateId || !1
						},
						superclusterOptions: {
							maxZoom: this._getClusterMaxZoom(i$1.clusterMaxZoom),
							minPoints: Math.max(2, i$1.clusterMinPoints || 2),
							extent: t.$,
							radius: this._pixelsToTileUnits(i$1.clusterRadius || 50),
							log: !1,
							generateId: i$1.generateId || !1
						},
						clusterProperties: i$1.clusterProperties,
						filter: i$1.filter
					}, i$1.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
				}
				_pixelsToTileUnits(e$1) {
					return e$1 * (t.$ / this.tileSize);
				}
				_getClusterMaxZoom(e$1) {
					const i$1 = e$1 ? Math.round(e$1) : this.maxzoom - 1;
					return Number.isInteger(e$1) || void 0 === e$1 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e$1}" rounded to "${i$1}"`), i$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						yield this._updateWorkerData();
					}));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setData(e$1) {
					return this._data = e$1, this._pendingWorkerUpdate = { data: e$1 }, this._updateWorkerData(), this;
				}
				updateData(e$1) {
					return this._pendingWorkerUpdate.diff = t.a0(this._pendingWorkerUpdate.diff, e$1), this._updateWorkerData(), this;
				}
				getData() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = t.e({ type: this.type }, this.workerOptions);
						return this.actor.sendAsync({
							type: "GD",
							data: e$1
						});
					}));
				}
				getCoordinatesFromGeometry(e$1) {
					return "GeometryCollection" === e$1.type ? e$1.geometries.map(((e$2) => e$2.coordinates)).flat(Infinity) : e$1.coordinates.flat(Infinity);
				}
				getBounds() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = new G$1(), t$1 = yield this.getData();
						let i$1;
						switch (t$1.type) {
							case "FeatureCollection":
								i$1 = t$1.features.map(((e$2) => this.getCoordinatesFromGeometry(e$2.geometry))).flat(Infinity);
								break;
							case "Feature":
								i$1 = this.getCoordinatesFromGeometry(t$1.geometry);
								break;
							default: i$1 = this.getCoordinatesFromGeometry(t$1);
						}
						if (0 == i$1.length) return e$1;
						for (let t$2 = 0; t$2 < i$1.length - 1; t$2 += 2) e$1.extend([i$1[t$2], i$1[t$2 + 1]]);
						return e$1;
					}));
				}
				setClusterOptions(e$1) {
					return this.workerOptions.cluster = e$1.cluster, e$1 && (void 0 !== e$1.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e$1.clusterRadius)), void 0 !== e$1.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e$1.clusterMaxZoom))), this._updateWorkerData(), this;
				}
				getClusterExpansionZoom(e$1) {
					return this.actor.sendAsync({
						type: "GCEZ",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterChildren(e$1) {
					return this.actor.sendAsync({
						type: "GCC",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterLeaves(e$1, t$1, i$1) {
					return this.actor.sendAsync({
						type: "GCL",
						data: {
							type: this.type,
							source: this.id,
							clusterId: e$1,
							limit: t$1,
							offset: i$1
						}
					});
				}
				_updateWorkerData() {
					return t._(this, void 0, void 0, (function* () {
						if (this._isUpdatingWorker) return;
						const { data: e$1, diff: i$1 } = this._pendingWorkerUpdate;
						if (!e$1 && !i$1) return void t.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
						const o$1 = t.e({ type: this.type }, this.workerOptions);
						e$1 ? ("string" == typeof e$1 ? (o$1.request = this.map._requestManager.transformRequest(s.resolveURL(e$1), "Source"), o$1.request.collectResourceTiming = this._collectResourceTiming) : o$1.data = JSON.stringify(e$1), this._pendingWorkerUpdate.data = void 0) : i$1 && (o$1.dataDiff = i$1, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new t.l("dataloading", { dataType: "source" }));
						try {
							const e$2 = yield this.actor.sendAsync({
								type: "LD",
								data: o$1
							});
							if (this._isUpdatingWorker = !1, this._removed || e$2.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this._data = e$2.data;
							let i$2 = null;
							e$2.resourceTiming && e$2.resourceTiming[this.id] && (i$2 = e$2.resourceTiming[this.id].slice(0));
							const r$1 = { dataType: "source" };
							this._collectResourceTiming && i$2 && i$2.length > 0 && t.e(r$1, { resourceTiming: i$2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), { sourceDataType: "content" })));
						} catch (e$2) {
							if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this.fire(new t.k(e$2));
						} finally {
							(this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
						}
					}));
				}
				loaded() {
					return !this._isUpdatingWorker && void 0 === this._pendingWorkerUpdate.data && void 0 === this._pendingWorkerUpdate.diff;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.actor ? "RT" : "LT";
						e$1.actor = this.actor;
						const i$1 = {
							type: this.type,
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
							globalState: this.map.getGlobalState()
						};
						e$1.abortController = new AbortController();
						const o$1 = yield this.actor.sendAsync({
							type: t$1,
							data: i$1
						}, e$1.abortController);
						delete e$1.abortController, e$1.unloadVectorData(), e$1.aborted || e$1.loadVectorData(o$1, this.map.painter, "RT" === t$1);
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.aborted = !0;
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), yield this.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						});
					}));
				}
				onRemove() {
					this._removed = !0, this.actor.sendAsync({
						type: "RS",
						data: {
							type: this.type,
							source: this.id
						}
					});
				}
				serialize() {
					return t.e({}, this._options, {
						type: this.type,
						data: this._data
					});
				}
				hasTransition() {
					return !1;
				}
			}
			class X$1 extends t.E {
				constructor(e$1, t$1, i$1, o$1) {
					super(), this.flippedWindingOrder = !1, this.id = e$1, this.dispatcher = i$1, this.coordinates = t$1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o$1), this.options = t$1;
				}
				load(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
						try {
							const t$1 = yield p.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
							this._request = null, this._loaded = !0, t$1 && t$1.data && (this.image = t$1.data, e$1 && (this.coordinates = e$1), this._finishLoading());
						} catch (e$2) {
							this._request = null, this._loaded = !0, this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(e$1) {
					return e$1.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e$1.url, this.load(e$1.coordinates).finally((() => {
						this.texture = null;
					})), this) : this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._request && (this._request.abort(), this._request = null);
				}
				setCoordinates(e$1) {
					this.coordinates = e$1;
					const i$1 = e$1.map(t.a1.fromLngLat);
					var o$1;
					return this.tileID = function(e$2) {
						const i$2 = t.a2.fromPoints(e$2), o$2 = i$2.width(), r$1 = i$2.height(), a$1 = Math.max(o$2, r$1), s$1 = Math.max(0, Math.floor(-Math.log(a$1) / Math.LN2)), n$1 = Math.pow(2, s$1);
						return new t.a4(s$1, Math.floor((i$2.minX + i$2.maxX) / 2 * n$1), Math.floor((i$2.minY + i$2.maxY) / 2 * n$1));
					}(i$1), this.terrainTileRanges = this._getOverlappingTileRanges(i$1), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i$1.map(((e$2) => this.tileID.getTilePoint(e$2)._round())), this.flippedWindingOrder = ((o$1 = this.tileCoords)[1].x - o$1[0].x) * (o$1[2].y - o$1[0].y) - (o$1[1].y - o$1[0].y) * (o$1[2].x - o$1[0].x) < 0, this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || !this.image) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture || (this.texture = new t.T(e$1, this.image, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let o$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, o$1 = !0);
					}
					o$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this.tileID && this.tileID.equals(e$1.tileID.canonical) ? (this.tiles[String(e$1.tileID.wrap)] = e$1, e$1.buckets = {}) : e$1.state = "errored";
					}));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				_getOverlappingTileRanges(e$1) {
					const { minX: i$1, minY: o$1, maxX: r$1, maxY: a$1 } = t.a2.fromPoints(e$1), s$1 = {};
					for (let e$2 = 0; e$2 <= t.a3; e$2++) {
						const t$1 = Math.pow(2, e$2);
						s$1[e$2] = {
							minTileX: Math.floor(i$1 * t$1),
							minTileY: Math.floor(o$1 * t$1),
							maxTileX: Math.floor(r$1 * t$1),
							maxTileY: Math.floor(a$1 * t$1)
						};
					}
					return s$1;
				}
			}
			class K$1 extends X$1 {
				constructor(e$1, t$1, i$1, o$1) {
					super(e$1, t$1, i$1, o$1), this.roundZoom = !0, this.type = "video", this.options = t$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1;
						const e$1 = this.options;
						this.urls = [];
						for (const t$1 of e$1.urls) this.urls.push(this.map._requestManager.transformRequest(t$1, "Source").url);
						try {
							const e$2 = yield t.a5(this.urls);
							if (this._loaded = !0, !e$2) return;
							this.video = e$2, this.video.loop = !0, this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading();
						} catch (e$2) {
							this.fire(new t.k(e$2));
						}
					}));
				}
				pause() {
					this.video && this.video.pause();
				}
				play() {
					this.video && this.video.play();
				}
				seek(e$1) {
					if (this.video) {
						const i$1 = this.video.seekable;
						e$1 < i$1.start(0) || e$1 > i$1.end(0) ? this.fire(new t.k(new t.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i$1.start(0)} and ${i$1.end(0)}-second mark.`))) : this.video.currentTime = e$1;
					}
				}
				getVideo() {
					return this.video;
				}
				onAdd(e$1) {
					this.map || (this.map = e$1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture ? this.video.paused || (this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), i$1.texSubImage2D(i$1.TEXTURE_2D, 0, 0, 0, i$1.RGBA, i$1.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e$1, this.video, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let o$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, o$1 = !0);
					}
					o$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "video",
						urls: this.urls,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this.video && !this.video.paused;
				}
			}
			class Y$1 extends X$1 {
				constructor(e$1, i$1, o$1, r$1) {
					super(e$1, i$1, o$1, r$1), i$1.coordinates ? Array.isArray(i$1.coordinates) && 4 === i$1.coordinates.length && !i$1.coordinates.some(((e$2) => !Array.isArray(e$2) || 2 !== e$2.length || e$2.some(((e$3) => "number" != typeof e$3)))) || this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "missing required property \"coordinates\""))), i$1.animate && "boolean" != typeof i$1.animate && this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "optional \"animate\" property must be a boolean value"))), i$1.canvas ? "string" == typeof i$1.canvas || i$1.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "missing required property \"canvas\""))), this.options = i$1, this.animate = void 0 === i$1.animate || i$1.animate;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(/* @__PURE__ */ new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing && (this.prepare(), this._playing = !1);
						}, this._finishLoading());
					}));
				}
				getCanvas() {
					return this.canvas;
				}
				onAdd(e$1) {
					this.map = e$1, this.load(), this.canvas && this.animate && this.play();
				}
				onRemove() {
					this.pause();
				}
				prepare() {
					let e$1 = !1;
					if (this.canvas.width !== this.width && (this.width = this.canvas.width, e$1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e$1 = !0), this._hasInvalidDimensions()) return;
					if (0 === Object.keys(this.tiles).length) return;
					const i$1 = this.map.painter.context, o$1 = i$1.gl;
					this.texture ? (e$1 || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new t.T(i$1, this.canvas, o$1.RGBA, { premultiply: !0 });
					let r$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, r$1 = !0);
					}
					r$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "canvas",
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this._playing;
				}
				_hasInvalidDimensions() {
					for (const e$1 of [this.canvas.width, this.canvas.height]) if (isNaN(e$1) || e$1 <= 0) return !0;
					return !1;
				}
			}
			const Q$1 = {}, J$1 = (e$1) => {
				switch (e$1) {
					case "geojson": return H$1;
					case "image": return X$1;
					case "raster": return q$1;
					case "raster-dem": return W$1;
					case "vector": return $$1;
					case "video": return K$1;
					case "canvas": return Y$1;
				}
				return Q$1[e$1];
			}, ee = "RTLPluginLoaded";
			class te$1 extends t.E {
				constructor() {
					super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = B$1();
				}
				_syncState(e$1) {
					return this.status = e$1, this.dispatcher.broadcast("SRPS", {
						pluginStatus: e$1,
						pluginURL: this.url
					}).catch(((e$2) => {
						throw this.status = "error", e$2;
					}));
				}
				getRTLTextPluginStatus() {
					return this.status;
				}
				clearRTLTextPlugin() {
					this.status = "unavailable", this.url = null;
				}
				setRTLTextPlugin(e$1) {
					return t._(this, arguments, void 0, (function* (e$2, t$1 = !1) {
						if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
						if (this.url = s.resolveURL(e$2), !this.url) throw new Error(`requested url ${e$2} is invalid`);
						if ("unavailable" === this.status) {
							if (!t$1) return this._requestImport();
							this.status = "deferred", this._syncState(this.status);
						} else if ("requested" === this.status) return this._requestImport();
					}));
				}
				_requestImport() {
					return t._(this, void 0, void 0, (function* () {
						yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(ee));
					}));
				}
				lazyLoad() {
					"unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
				}
			}
			let ie$1 = null;
			function oe$1() {
				return ie$1 || (ie$1 = new te$1()), ie$1;
			}
			class re$1 {
				constructor(e$1, i$1) {
					this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e$1, this.uid = t.a7(), this.uses = 0, this.tileSize = i$1, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
				}
				registerFadeDuration(e$1) {
					const t$1 = e$1 + this.timeAdded;
					t$1 < this.fadeEndTime || (this.fadeEndTime = t$1);
				}
				wasRequested() {
					return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
				}
				clearTextures(e$1) {
					this.demTexture && e$1.saveTileTexture(this.demTexture), this.demTexture = null;
				}
				loadVectorData(e$1, i$1, o$1) {
					if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e$1) {
						e$1.featureIndex && (this.latestFeatureIndex = e$1.featureIndex, e$1.rawTileData ? (this.latestRawTileData = e$1.rawTileData, this.latestFeatureIndex.rawTileData = e$1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e$1.collisionBoxArray, this.buckets = function(e$2, t$1) {
							const i$2 = {};
							if (!t$1) return i$2;
							for (const o$2 of e$2) {
								const e$3 = o$2.layerIds.map(((e$4) => t$1.getLayer(e$4))).filter(Boolean);
								if (0 !== e$3.length) {
									o$2.layers = e$3, o$2.stateDependentLayerIds && (o$2.stateDependentLayers = o$2.stateDependentLayerIds.map(((t$2) => e$3.filter(((e$4) => e$4.id === t$2))[0])));
									for (const t$2 of e$3) i$2[t$2.id] = o$2;
								}
							}
							return i$2;
						}(e$1.buckets, null == i$1 ? void 0 : i$1.style), this.hasSymbolBuckets = !1;
						for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.a9) {
								if (this.hasSymbolBuckets = !0, !o$1) break;
								i$2.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.a9 && i$2.hasRTLText) {
								this.hasRTLText = !0, oe$1().lazyLoad();
								break;
							}
						}
						this.queryPadding = 0;
						for (const e$2 in this.buckets) {
							const t$1 = this.buckets[e$2];
							this.queryPadding = Math.max(this.queryPadding, i$1.style.getLayer(e$2).queryRadius(t$1));
						}
						e$1.imageAtlas && (this.imageAtlas = e$1.imageAtlas), e$1.glyphAtlasImage && (this.glyphAtlasImage = e$1.glyphAtlasImage);
					} else this.collisionBoxArray = new t.a8();
				}
				unloadVectorData() {
					for (const e$1 in this.buckets) this.buckets[e$1].destroy();
					this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
				}
				getBucket(e$1) {
					return this.buckets[e$1.id];
				}
				upload(e$1) {
					for (const t$1 in this.buckets) {
						const i$2 = this.buckets[t$1];
						i$2.uploadPending() && i$2.upload(e$1);
					}
					const i$1 = e$1.gl;
					this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e$1, this.imageAtlas.image, i$1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e$1, this.glyphAtlasImage, i$1.ALPHA), this.glyphAtlasImage = null);
				}
				prepare(e$1) {
					this.imageAtlas && this.imageAtlas.patchUpdatedImages(e$1, this.imageAtlasTexture);
				}
				queryRenderedFeatures(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1) {
					return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
						queryGeometry: o$1,
						cameraQueryGeometry: r$1,
						scale: a$1,
						tileSize: this.tileSize,
						pixelPosMatrix: c$1,
						transform: n$1,
						params: s$1,
						queryPadding: this.queryPadding * l$1,
						getElevation: h$1
					}, e$1, t$1, i$1) : {};
				}
				querySourceFeatures(e$1, i$1) {
					const o$1 = this.latestFeatureIndex;
					if (!o$1 || !o$1.rawTileData) return;
					const r$1 = o$1.loadVTLayers(), a$1 = i$1 && i$1.sourceLayer ? i$1.sourceLayer : "", s$1 = r$1._geojsonTileLayer || r$1[a$1];
					if (!s$1) return;
					const n$1 = t.aa(i$1 && i$1.filter), { z: l$1, x: c$1, y: h$1 } = this.tileID.canonical, u$1 = {
						z: l$1,
						x: c$1,
						y: h$1
					};
					for (let i$2 = 0; i$2 < s$1.length; i$2++) {
						const r$2 = s$1.feature(i$2);
						if (n$1.needGeometry) {
							const e$2 = t.ab(r$2, !0);
							if (!n$1.filter(new t.F(this.tileID.overscaledZ), e$2, this.tileID.canonical)) continue;
						} else if (!n$1.filter(new t.F(this.tileID.overscaledZ), r$2)) continue;
						const d$1 = o$1.getId(r$2, a$1), _$2 = new t.ac(r$2, l$1, c$1, h$1, d$1);
						_$2.tile = u$1, e$1.push(_$2);
					}
				}
				hasData() {
					return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
				}
				patternsLoaded() {
					return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
				}
				setExpiryData(e$1) {
					const i$1 = this.expirationTime;
					if (e$1.cacheControl) {
						const i$2 = t.ad(e$1.cacheControl);
						i$2["max-age"] && (this.expirationTime = Date.now() + 1e3 * i$2["max-age"]);
					} else e$1.expires && (this.expirationTime = new Date(e$1.expires).getTime());
					if (this.expirationTime) {
						const e$2 = Date.now();
						let t$1 = !1;
						if (this.expirationTime > e$2) t$1 = !1;
						else if (i$1) if (this.expirationTime < i$1) t$1 = !0;
						else {
							const o$1 = this.expirationTime - i$1;
							o$1 ? this.expirationTime = e$2 + Math.max(o$1, 3e4) : t$1 = !0;
						}
						else t$1 = !0;
						t$1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
				}
				setFeatureState(e$1, t$1) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e$1).length) return;
					const i$1 = this.latestFeatureIndex.loadVTLayers();
					for (const o$1 in this.buckets) {
						if (!t$1.style.hasLayer(o$1)) continue;
						const r$1 = this.buckets[o$1], a$1 = r$1.layers[0].sourceLayer || "_geojsonTileLayer", s$1 = i$1[a$1], n$1 = e$1[a$1];
						if (!s$1 || !n$1 || 0 === Object.keys(n$1).length) continue;
						r$1.update(n$1, s$1, this.imageAtlas && this.imageAtlas.patternPositions || {});
						const l$1 = t$1 && t$1.style && t$1.style.getLayer(o$1);
						l$1 && (this.queryPadding = Math.max(this.queryPadding, l$1.queryRadius(r$1)));
					}
				}
				holdingForFade() {
					return void 0 !== this.symbolFadeHoldUntil;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.now();
				}
				clearFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setHoldDuration(e$1) {
					this.symbolFadeHoldUntil = s.now() + e$1;
				}
				setDependencies(e$1, t$1) {
					const i$1 = {};
					for (const e$2 of t$1) i$1[e$2] = !0;
					this.dependencies[e$1] = i$1;
				}
				hasDependency(e$1, t$1) {
					for (const i$1 of e$1) {
						const e$2 = this.dependencies[i$1];
						if (e$2) {
							for (const i$2 of t$1) if (e$2[i$2]) return !0;
						}
					}
					return !1;
				}
			}
			class ae$1 {
				constructor(e$1, t$1) {
					this.max = e$1, this.onRemove = t$1, this.reset();
				}
				reset() {
					for (const e$1 in this.data) for (const t$1 of this.data[e$1]) t$1.timeout && clearTimeout(t$1.timeout), this.onRemove(t$1.value);
					return this.data = {}, this.order = [], this;
				}
				add(e$1, t$1, i$1) {
					const o$1 = e$1.wrapped().key;
					void 0 === this.data[o$1] && (this.data[o$1] = []);
					const r$1 = {
						value: t$1,
						timeout: void 0
					};
					if (void 0 !== i$1 && (r$1.timeout = setTimeout((() => {
						this.remove(e$1, r$1);
					}), i$1)), this.data[o$1].push(r$1), this.order.push(o$1), this.order.length > this.max) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				has(e$1) {
					return e$1.wrapped().key in this.data;
				}
				getAndRemove(e$1) {
					return this.has(e$1) ? this._getAndRemoveByKey(e$1.wrapped().key) : null;
				}
				_getAndRemoveByKey(e$1) {
					const t$1 = this.data[e$1].shift();
					return t$1.timeout && clearTimeout(t$1.timeout), 0 === this.data[e$1].length && delete this.data[e$1], this.order.splice(this.order.indexOf(e$1), 1), t$1.value;
				}
				getByKey(e$1) {
					const t$1 = this.data[e$1];
					return t$1 ? t$1[0].value : null;
				}
				get(e$1) {
					return this.has(e$1) ? this.data[e$1.wrapped().key][0].value : null;
				}
				remove(e$1, t$1) {
					if (!this.has(e$1)) return this;
					const i$1 = e$1.wrapped().key, o$1 = void 0 === t$1 ? 0 : this.data[i$1].indexOf(t$1), r$1 = this.data[i$1][o$1];
					return this.data[i$1].splice(o$1, 1), r$1.timeout && clearTimeout(r$1.timeout), 0 === this.data[i$1].length && delete this.data[i$1], this.onRemove(r$1.value), this.order.splice(this.order.indexOf(i$1), 1), this;
				}
				setMaxSize(e$1) {
					for (this.max = e$1; this.order.length > this.max;) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				filter(e$1) {
					const t$1 = [];
					for (const i$1 in this.data) for (const o$1 of this.data[i$1]) e$1(o$1.value) || t$1.push(o$1);
					for (const e$2 of t$1) this.remove(e$2.value.tileID, e$2);
				}
			}
			class se$1 {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e$1, i$1, o$1) {
					const r$1 = String(i$1);
					if (this.stateChanges[e$1] = this.stateChanges[e$1] || {}, this.stateChanges[e$1][r$1] = this.stateChanges[e$1][r$1] || {}, t.e(this.stateChanges[e$1][r$1], o$1), null === this.deletedStates[e$1]) {
						this.deletedStates[e$1] = {};
						for (const t$1 in this.state[e$1]) t$1 !== r$1 && (this.deletedStates[e$1][t$1] = null);
					} else if (this.deletedStates[e$1] && null === this.deletedStates[e$1][r$1]) {
						this.deletedStates[e$1][r$1] = {};
						for (const t$1 in this.state[e$1][r$1]) o$1[t$1] || (this.deletedStates[e$1][r$1][t$1] = null);
					} else for (const t$1 in o$1) this.deletedStates[e$1] && this.deletedStates[e$1][r$1] && null === this.deletedStates[e$1][r$1][t$1] && delete this.deletedStates[e$1][r$1][t$1];
				}
				removeFeatureState(e$1, t$1, i$1) {
					if (null === this.deletedStates[e$1]) return;
					const o$1 = String(t$1);
					if (this.deletedStates[e$1] = this.deletedStates[e$1] || {}, i$1 && void 0 !== t$1) null !== this.deletedStates[e$1][o$1] && (this.deletedStates[e$1][o$1] = this.deletedStates[e$1][o$1] || {}, this.deletedStates[e$1][o$1][i$1] = null);
					else if (void 0 !== t$1) if (this.stateChanges[e$1] && this.stateChanges[e$1][o$1]) for (i$1 in this.deletedStates[e$1][o$1] = {}, this.stateChanges[e$1][o$1]) this.deletedStates[e$1][o$1][i$1] = null;
					else this.deletedStates[e$1][o$1] = null;
					else this.deletedStates[e$1] = null;
				}
				getState(e$1, i$1) {
					const o$1 = String(i$1), r$1 = t.e({}, (this.state[e$1] || {})[o$1], (this.stateChanges[e$1] || {})[o$1]);
					if (null === this.deletedStates[e$1]) return {};
					if (this.deletedStates[e$1]) {
						const t$1 = this.deletedStates[e$1][i$1];
						if (null === t$1) return {};
						for (const e$2 in t$1) delete r$1[e$2];
					}
					return r$1;
				}
				initializeTileState(e$1, t$1) {
					e$1.setFeatureState(this.state, t$1);
				}
				coalesceChanges(e$1, i$1) {
					const o$1 = {};
					for (const e$2 in this.stateChanges) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						for (const o$2 in this.stateChanges[e$2]) this.state[e$2][o$2] || (this.state[e$2][o$2] = {}), t.e(this.state[e$2][o$2], this.stateChanges[e$2][o$2]), i$2[o$2] = this.state[e$2][o$2];
						o$1[e$2] = i$2;
					}
					for (const e$2 in this.deletedStates) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						if (null === this.deletedStates[e$2]) for (const t$1 in this.state[e$2]) i$2[t$1] = {}, this.state[e$2][t$1] = {};
						else for (const t$1 in this.deletedStates[e$2]) {
							if (null === this.deletedStates[e$2][t$1]) this.state[e$2][t$1] = {};
							else for (const i$3 of Object.keys(this.deletedStates[e$2][t$1])) delete this.state[e$2][t$1][i$3];
							i$2[t$1] = this.state[e$2][t$1];
						}
						o$1[e$2] = o$1[e$2] || {}, t.e(o$1[e$2], i$2);
					}
					if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o$1).length) for (const t$1 in e$1) e$1[t$1].setFeatureState(o$1, i$1);
				}
			}
			const ne$1 = 89.25;
			function le$1(e$1, i$1) {
				const o$1 = t.ah(i$1.lat, -t.ai, t.ai);
				return new t.P(t.V(i$1.lng) * e$1, t.U(o$1) * e$1);
			}
			function ce$1(e$1, i$1) {
				return new t.a1(i$1.x / e$1, i$1.y / e$1).toLngLat();
			}
			function he$1(e$1) {
				return e$1.cameraToCenterDistance * Math.min(.85 * Math.tan(t.ae(90 - e$1.pitch)), Math.tan(t.ae(ne$1 - e$1.pitch)));
			}
			function ue$1(e$1, i$1) {
				const o$1 = e$1.canonical, r$1 = i$1 / t.af(o$1.z), a$1 = o$1.x + Math.pow(2, o$1.z) * e$1.wrap, s$1 = t.ag(new Float64Array(16));
				return t.M(s$1, s$1, [
					a$1 * r$1,
					o$1.y * r$1,
					0
				]), t.N(s$1, s$1, [
					r$1 / t.$,
					r$1 / t.$,
					1
				]), s$1;
			}
			function de$1(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = t.a1.fromLngLat(e$1, i$1), n$1 = a$1 * t.aj(1, e$1.lat), l$1 = n$1 * Math.cos(t.ae(o$1)), c$1 = Math.sqrt(n$1 * n$1 - l$1 * l$1), h$1 = c$1 * Math.sin(t.ae(-r$1)), u$1 = c$1 * Math.cos(t.ae(-r$1));
				return new t.a1(s$1.x + h$1, s$1.y + u$1, s$1.z + l$1);
			}
			function _e$1(e$1, t$1, i$1) {
				const o$1 = t$1.intersectsFrustum(e$1);
				if (!i$1 || 0 === o$1) return o$1;
				const r$1 = t$1.intersectsPlane(i$1);
				return 0 === r$1 ? 0 : 2 === o$1 && 2 === r$1 ? 2 : 1;
			}
			function pe$1(e$1, t$1, i$1) {
				let o$1 = 0;
				const r$1 = (i$1 - t$1) / 10;
				for (let a$1 = 0; a$1 < 10; a$1++) o$1 += r$1 * Math.pow(Math.cos(t$1 + (a$1 + .5) / 10 * (i$1 - t$1)), e$1);
				return o$1;
			}
			function me$1(e$1, i$1) {
				return function(o$1, r$1, a$1, s$1, n$1) {
					const l$1 = 2 * ((e$1 - 1) / t.ak(Math.cos(t.ae(ne$1 - n$1)) / Math.cos(t.ae(ne$1))) - 1), c$1 = Math.acos(a$1 / s$1), h$1 = 2 * pe$1(l$1 - 1, 0, t.ae(n$1 / 2)), u$1 = Math.min(t.ae(ne$1), c$1 + t.ae(n$1 / 2)), d$1 = pe$1(l$1 - 1, Math.min(u$1, c$1 - t.ae(n$1 / 2)), u$1), _$2 = Math.atan(r$1 / a$1), p$1 = Math.hypot(r$1, a$1);
					let m$1 = o$1;
					return m$1 += t.ak(s$1 / p$1 / Math.max(.5, Math.cos(t.ae(n$1 / 2)))), m$1 += l$1 * t.ak(Math.cos(_$2)) / 2, m$1 -= t.ak(Math.max(1, d$1 / h$1 / i$1)) / 2, m$1;
				};
			}
			const fe$1 = me$1(9.314, 3);
			function ge$1(e$1, i$1) {
				const o$1 = (i$1.roundZoom ? Math.round : Math.floor)(e$1.zoom + t.ak(e$1.tileSize / i$1.tileSize));
				return Math.max(0, o$1);
			}
			function ve$1(e$1, i$1) {
				const o$1 = e$1.getCameraFrustum(), r$1 = e$1.getClippingPlane(), a$1 = e$1.screenPointToMercatorCoordinate(e$1.getCameraPoint()), s$1 = t.a1.fromLngLat(e$1.center, e$1.elevation);
				a$1.z = s$1.z + Math.cos(e$1.pitchInRadians) * e$1.cameraToCenterDistance / e$1.worldSize;
				const n$1 = e$1.getCoveringTilesDetailsProvider(), l$1 = n$1.allowVariableZoom(e$1, i$1), c$1 = ge$1(e$1, i$1), h$1 = i$1.minzoom || 0, u$1 = void 0 !== i$1.maxzoom ? i$1.maxzoom : e$1.maxZoom, d$1 = Math.min(Math.max(0, c$1), u$1), _$2 = Math.pow(2, d$1), p$1 = [
					_$2 * a$1.x,
					_$2 * a$1.y,
					0
				], m$1 = [
					_$2 * s$1.x,
					_$2 * s$1.y,
					0
				], f$1 = Math.hypot(s$1.x - a$1.x, s$1.y - a$1.y), g$2 = Math.abs(s$1.z - a$1.z), v$1 = Math.hypot(f$1, g$2), b$2 = (e$2) => ({
					zoom: 0,
					x: 0,
					y: 0,
					wrap: e$2,
					fullyVisible: !1
				}), x$1 = [], y$1 = [];
				if (e$1.renderWorldCopies && n$1.allowWorldCopies()) for (let e$2 = 1; e$2 <= 3; e$2++) x$1.push(b$2(-e$2)), x$1.push(b$2(e$2));
				for (x$1.push(b$2(0)); x$1.length > 0;) {
					const _$3 = x$1.pop(), f$2 = _$3.x, b$3 = _$3.y;
					let w$1 = _$3.fullyVisible;
					const T$2 = {
						x: f$2,
						y: b$3,
						z: _$3.zoom
					}, P$2 = n$1.getTileBoundingVolume(T$2, _$3.wrap, e$1.elevation, i$1);
					if (!w$1) {
						const e$2 = _e$1(o$1, P$2, r$1);
						if (0 === e$2) continue;
						w$1 = 2 === e$2;
					}
					const C$1 = n$1.distanceToTile2d(a$1.x, a$1.y, T$2, P$2);
					let I$2 = c$1;
					l$1 && (I$2 = (i$1.calculateTileZoom || fe$1)(e$1.zoom + t.ak(e$1.tileSize / i$1.tileSize), C$1, g$2, v$1, e$1.fov)), I$2 = (i$1.roundZoom ? Math.round : Math.floor)(I$2), I$2 = Math.max(0, I$2);
					const M$2 = Math.min(I$2, u$1);
					if (_$3.wrap = n$1.getWrap(s$1, T$2, _$3.wrap), _$3.zoom >= M$2) {
						if (_$3.zoom < h$1) continue;
						const e$2 = d$1 - _$3.zoom, o$2 = p$1[0] - .5 - (f$2 << e$2), r$2 = p$1[1] - .5 - (b$3 << e$2), a$2 = i$1.reparseOverscaled ? Math.max(_$3.zoom, I$2) : _$3.zoom;
						y$1.push({
							tileID: new t.Z(_$3.zoom === u$1 ? a$2 : _$3.zoom, _$3.wrap, _$3.zoom, f$2, b$3),
							distanceSq: t.al([m$1[0] - .5 - f$2, m$1[1] - .5 - b$3]),
							tileDistanceToCamera: Math.sqrt(o$2 * o$2 + r$2 * r$2)
						});
					} else for (let e$2 = 0; e$2 < 4; e$2++) x$1.push({
						zoom: _$3.zoom + 1,
						x: (f$2 << 1) + e$2 % 2,
						y: (b$3 << 1) + (e$2 >> 1),
						wrap: _$3.wrap,
						fullyVisible: w$1
					});
				}
				return y$1.sort(((e$2, t$1) => e$2.distanceSq - t$1.distanceSq)).map(((e$2) => e$2.tileID));
			}
			const be = t.a2.fromPoints([new t.P(0, 0), new t.P(t.$, t.$)]);
			class xe$1 extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this.id = e$1, this.dispatcher = i$1, this.on("data", ((e$2) => this._dataHandler(e$2))), this.on("dataloading", (() => {
						this._sourceErrored = !1;
					})), this.on("error", (() => {
						this._sourceErrored = this._source.loaded();
					})), this._source = ((e$2, t$2, i$2, o$1) => {
						const r$1 = new (J$1(t$2.type))(e$2, t$2, i$2, o$1);
						if (r$1.id !== e$2) throw new Error(`Expected Source id to be ${e$2} instead of ${r$1.id}`);
						return r$1;
					})(e$1, t$1, i$1, this), this._tiles = {}, this._cache = new ae$1(0, ((e$2) => this._unloadTile(e$2))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new se$1(), this._didEmitContent = !1, this._updated = !1;
				}
				onAdd(e$1) {
					this.map = e$1, this._maxTileCacheSize = e$1 ? e$1._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e$1 ? e$1._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e$1);
				}
				onRemove(e$1) {
					this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e$1);
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded) return !1;
					if (!this._source.loaded()) return !1;
					if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return !0;
					if (!this._updated) return !1;
					for (const e$1 in this._tiles) {
						const t$1 = this._tiles[e$1];
						if ("loaded" !== t$1.state && "errored" !== t$1.state) return !1;
					}
					return !0;
				}
				getSource() {
					return this._source;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					const e$1 = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e$1 && this.reload(), this.transform && this.update(this.transform, this.terrain);
				}
				_loadTile(e$1, i$1, o$1) {
					return t._(this, void 0, void 0, (function* () {
						try {
							yield this._source.loadTile(e$1), this._tileLoaded(e$1, i$1, o$1);
						} catch (i$2) {
							e$1.state = "errored", 404 !== i$2.status ? this._source.fire(new t.k(i$2, { tile: e$1 })) : this.update(this.transform, this.terrain);
						}
					}));
				}
				_unloadTile(e$1) {
					this._source.unloadTile && this._source.unloadTile(e$1);
				}
				_abortTile(e$1) {
					this._source.abortTile && this._source.abortTile(e$1), this._source.fire(new t.l("dataabort", {
						tile: e$1,
						coord: e$1.tileID,
						dataType: "source"
					}));
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e$1) {
					this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						i$1.upload(e$1), i$1.prepare(this.map.style.imageManager);
					}
				}
				getIds() {
					return Object.values(this._tiles).map(((e$1) => e$1.tileID)).sort(ye$1).map(((e$1) => e$1.key));
				}
				getRenderableIds(e$1) {
					const i$1 = [];
					for (const t$1 in this._tiles) this._isIdRenderable(t$1, e$1) && i$1.push(this._tiles[t$1]);
					return e$1 ? i$1.sort(((e$2, i$2) => {
						const o$1 = e$2.tileID, r$1 = i$2.tileID, a$1 = new t.P(o$1.canonical.x, o$1.canonical.y)._rotate(-this.transform.bearingInRadians), s$1 = new t.P(r$1.canonical.x, r$1.canonical.y)._rotate(-this.transform.bearingInRadians);
						return o$1.overscaledZ - r$1.overscaledZ || s$1.y - a$1.y || s$1.x - a$1.x;
					})).map(((e$2) => e$2.tileID.key)) : i$1.map(((e$2) => e$2.tileID)).sort(ye$1).map(((e$2) => e$2.key));
				}
				hasRenderableParent(e$1) {
					const t$1 = this.findLoadedParent(e$1, 0);
					return !!t$1 && this._isIdRenderable(t$1.tileID.key);
				}
				_isIdRenderable(e$1, t$1) {
					return this._tiles[e$1] && this._tiles[e$1].hasData() && !this._coveredTiles[e$1] && (t$1 || !this._tiles[e$1].holdingForFade());
				}
				reload(e$1) {
					if (this._paused) this._shouldReloadOnResume = !0;
					else {
						this._cache.reset();
						for (const t$1 in this._tiles) e$1 ? this._reloadTile(t$1, "expired") : "errored" !== this._tiles[t$1].state && this._reloadTile(t$1, "reloading");
					}
				}
				_reloadTile(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this._tiles[e$1];
						t$1 && ("loading" !== t$1.state && (t$1.state = i$1), yield this._loadTile(t$1, e$1, i$1));
					}));
				}
				_tileLoaded(e$1, i$1, o$1) {
					e$1.timeAdded = s.now(), "expired" === o$1 && (e$1.refreshedUponExpiration = !0), this._setTileReloadTimer(i$1, e$1), "raster-dem" === this.getSource().type && e$1.dem && this._backfillDEM(e$1), this._state.initializeTileState(e$1, this.map ? this.map.painter : null), e$1.aborted || this._source.fire(new t.l("data", {
						dataType: "source",
						tile: e$1,
						coord: e$1.tileID
					}));
				}
				_backfillDEM(e$1) {
					const t$1 = this.getRenderableIds();
					for (let o$1 = 0; o$1 < t$1.length; o$1++) {
						const r$1 = t$1[o$1];
						if (e$1.neighboringTiles && e$1.neighboringTiles[r$1]) {
							const t$2 = this.getTileByID(r$1);
							i$1(e$1, t$2), i$1(t$2, e$1);
						}
					}
					function i$1(e$2, t$2) {
						e$2.needsHillshadePrepare = !0, e$2.needsTerrainPrepare = !0;
						let i$2 = t$2.tileID.canonical.x - e$2.tileID.canonical.x;
						const o$1 = t$2.tileID.canonical.y - e$2.tileID.canonical.y, r$1 = Math.pow(2, e$2.tileID.canonical.z), a$1 = t$2.tileID.key;
						0 === i$2 && 0 === o$1 || Math.abs(o$1) > 1 || (Math.abs(i$2) > 1 && (1 === Math.abs(i$2 + r$1) ? i$2 += r$1 : 1 === Math.abs(i$2 - r$1) && (i$2 -= r$1)), t$2.dem && e$2.dem && (e$2.dem.backfillBorder(t$2.dem, i$2, o$1), e$2.neighboringTiles && e$2.neighboringTiles[a$1] && (e$2.neighboringTiles[a$1].backfilled = !0)));
					}
				}
				getTile(e$1) {
					return this.getTileByID(e$1.key);
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				_retainLoadedChildren(e$1, t$1, i$1, o$1) {
					for (const r$1 in this._tiles) {
						let a$1 = this._tiles[r$1];
						if (o$1[r$1] || !a$1.hasData() || a$1.tileID.overscaledZ <= t$1 || a$1.tileID.overscaledZ > i$1) continue;
						let s$1 = a$1.tileID;
						for (; a$1 && a$1.tileID.overscaledZ > t$1 + 1;) {
							const e$2 = a$1.tileID.scaledTo(a$1.tileID.overscaledZ - 1);
							a$1 = this._tiles[e$2.key], a$1 && a$1.hasData() && (s$1 = e$2);
						}
						let n$1 = s$1;
						for (; n$1.overscaledZ > t$1;) if (n$1 = n$1.scaledTo(n$1.overscaledZ - 1), e$1[n$1.key] || e$1[n$1.canonical.key]) {
							o$1[s$1.key] = s$1;
							break;
						}
					}
				}
				findLoadedParent(e$1, t$1) {
					if (e$1.key in this._loadedParentTiles) {
						const i$1 = this._loadedParentTiles[e$1.key];
						return i$1 && i$1.tileID.overscaledZ >= t$1 ? i$1 : null;
					}
					for (let i$1 = e$1.overscaledZ - 1; i$1 >= t$1; i$1--) {
						const t$2 = e$1.scaledTo(i$1), o$1 = this._getLoadedTile(t$2);
						if (o$1) return o$1;
					}
				}
				findLoadedSibling(e$1) {
					return this._getLoadedTile(e$1);
				}
				_getLoadedTile(e$1) {
					const t$1 = this._tiles[e$1.key];
					return t$1 && t$1.hasData() ? t$1 : this._cache.getByKey(e$1.wrapped().key);
				}
				updateCacheSize(e$1) {
					const i$1 = Math.ceil(e$1.width / this._source.tileSize) + 1, o$1 = Math.ceil(e$1.height / this._source.tileSize) + 1, r$1 = Math.floor(i$1 * o$1 * (null === this._maxTileCacheZoomLevels ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a$1 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r$1) : r$1;
					this._cache.setMaxSize(a$1);
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - (void 0 === this._prevLng ? e$1 : this._prevLng)) / 360);
					if (this._prevLng = e$1, t$1) {
						const e$2 = {};
						for (const i$1 in this._tiles) {
							const o$1 = this._tiles[i$1];
							o$1.tileID = o$1.tileID.unwrapTo(o$1.tileID.wrap + t$1), e$2[o$1.tileID.key] = o$1;
						}
						this._tiles = e$2;
						for (const e$3 in this._timers) clearTimeout(this._timers[e$3]), delete this._timers[e$3];
						for (const e$3 in this._tiles) this._setTileReloadTimer(e$3, this._tiles[e$3]);
					}
				}
				_updateCoveredAndRetainedTiles(e$1, t$1, i$1, o$1, r$1, a$1) {
					const n$1 = {}, l$1 = {}, c$1 = Object.keys(e$1), h$1 = s.now();
					for (const i$2 of c$1) {
						const o$2 = e$1[i$2], r$2 = this._tiles[i$2];
						if (!r$2 || 0 !== r$2.fadeEndTime && r$2.fadeEndTime <= h$1) continue;
						const a$2 = this.findLoadedParent(o$2, t$1), s$1 = this.findLoadedSibling(o$2), c$2 = a$2 || s$1 || null;
						c$2 && (this._addTile(c$2.tileID), n$1[c$2.tileID.key] = c$2.tileID), l$1[i$2] = o$2;
					}
					this._retainLoadedChildren(l$1, o$1, i$1, e$1);
					for (const t$2 in n$1) e$1[t$2] || (this._coveredTiles[t$2] = !0, e$1[t$2] = n$1[t$2]);
					if (a$1) {
						const t$2 = {}, i$2 = {};
						for (const e$2 of r$1) this._tiles[e$2.key].hasData() ? t$2[e$2.key] = e$2 : i$2[e$2.key] = e$2;
						for (const o$2 in i$2) {
							const r$2 = i$2[o$2].children(this._source.maxzoom);
							this._tiles[r$2[0].key] && this._tiles[r$2[1].key] && this._tiles[r$2[2].key] && this._tiles[r$2[3].key] && (t$2[r$2[0].key] = e$1[r$2[0].key] = r$2[0], t$2[r$2[1].key] = e$1[r$2[1].key] = r$2[1], t$2[r$2[2].key] = e$1[r$2[2].key] = r$2[2], t$2[r$2[3].key] = e$1[r$2[3].key] = r$2[3], delete i$2[o$2]);
						}
						for (const o$2 in i$2) {
							const r$2 = i$2[o$2], a$2 = this.findLoadedParent(r$2, this._source.minzoom), s$1 = this.findLoadedSibling(r$2), n$2 = a$2 || s$1 || null;
							if (n$2) {
								t$2[n$2.tileID.key] = e$1[n$2.tileID.key] = n$2.tileID;
								for (const e$2 in t$2) t$2[e$2].isChildOf(n$2.tileID) && delete t$2[e$2];
							}
						}
						for (const e$2 in this._tiles) t$2[e$2] || (this._coveredTiles[e$2] = !0);
					}
				}
				update(e$1, i$1) {
					if (!this._sourceLoaded || this._paused) return;
					let o$1;
					this.transform = e$1, this.terrain = i$1, this.updateCacheSize(e$1), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o$1 = e$1.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e$2) => new t.Z(e$2.canonical.z, e$2.wrap, e$2.canonical.z, e$2.canonical.x, e$2.canonical.y))) : (o$1 = ve$1(e$1, {
						tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: this._source.maxzoom,
						roundZoom: !this.usedForTerrain && this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled,
						terrain: i$1,
						calculateTileZoom: this._source.calculateTileZoom
					}), this._source.hasTile && (o$1 = o$1.filter(((e$2) => this._source.hasTile(e$2))))) : o$1 = [];
					const r$1 = ge$1(e$1, this._source), a$1 = Math.max(r$1 - xe$1.maxOverzooming, this._source.minzoom), s$1 = Math.max(r$1 + xe$1.maxUnderzooming, this._source.minzoom);
					if (this.usedForTerrain) {
						const e$2 = {};
						for (const t$1 of o$1) if (t$1.canonical.z > this._source.minzoom) {
							const i$2 = t$1.scaledTo(t$1.canonical.z - 1);
							e$2[i$2.key] = i$2;
							const o$2 = t$1.scaledTo(Math.max(this._source.minzoom, Math.min(t$1.canonical.z, 5)));
							e$2[o$2.key] = o$2;
						}
						o$1 = o$1.concat(Object.values(e$2));
					}
					const n$1 = 0 === o$1.length && !this._updated && this._didEmitContent;
					this._updated = !0, n$1 && this.fire(new t.l("data", {
						sourceDataType: "idle",
						dataType: "source",
						sourceId: this.id
					}));
					const l$1 = this._updateRetainedTiles(o$1, r$1);
					we$1(this._source.type) && this._updateCoveredAndRetainedTiles(l$1, a$1, s$1, r$1, o$1, i$1);
					for (const e$2 in l$1) this._tiles[e$2].clearFadeHold();
					const c$1 = t.am(this._tiles, l$1);
					for (const e$2 of c$1) {
						const t$1 = this._tiles[e$2];
						t$1.hasSymbolBuckets && !t$1.holdingForFade() ? t$1.setHoldDuration(this.map._fadeDuration) : t$1.hasSymbolBuckets && !t$1.symbolFadeFinished() || this._removeTile(e$2);
					}
					this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
				}
				releaseSymbolFadeTiles() {
					for (const e$1 in this._tiles) this._tiles[e$1].holdingForFade() && this._removeTile(e$1);
				}
				_updateRetainedTiles(e$1, t$1) {
					var i$1;
					const o$1 = {}, r$1 = {}, a$1 = Math.max(t$1 - xe$1.maxOverzooming, this._source.minzoom), s$1 = Math.max(t$1 + xe$1.maxUnderzooming, this._source.minzoom), n$1 = {};
					for (const i$2 of e$1) {
						const e$2 = this._addTile(i$2);
						o$1[i$2.key] = i$2, e$2.hasData() || t$1 < this._source.maxzoom && (n$1[i$2.key] = i$2);
					}
					this._retainLoadedChildren(n$1, t$1, s$1, o$1);
					for (const s$2 of e$1) {
						let e$2 = this._tiles[s$2.key];
						if (e$2.hasData()) continue;
						if (t$1 + 1 > this._source.maxzoom) {
							const e$3 = s$2.children(this._source.maxzoom)[0], t$2 = this.getTile(e$3);
							if (t$2 && t$2.hasData()) {
								o$1[e$3.key] = e$3;
								continue;
							}
						} else {
							const e$3 = s$2.children(this._source.maxzoom);
							if (o$1[e$3[0].key] && o$1[e$3[1].key] && o$1[e$3[2].key] && o$1[e$3[3].key]) continue;
						}
						let n$2 = e$2.wasRequested();
						for (let t$2 = s$2.overscaledZ - 1; t$2 >= a$1; --t$2) {
							const a$2 = s$2.scaledTo(t$2);
							if (r$1[a$2.key]) break;
							if (r$1[a$2.key] = !0, e$2 = this.getTile(a$2), !e$2 && n$2 && (e$2 = this._addTile(a$2)), e$2) {
								const t$3 = e$2.hasData();
								if ((t$3 || !(null === (i$1 = this.map) || void 0 === i$1 ? void 0 : i$1.cancelPendingTileRequestsWhileZooming) || n$2) && (o$1[a$2.key] = a$2), n$2 = e$2.wasRequested(), t$3) break;
							}
						}
					}
					return o$1;
				}
				_updateLoadedParentTileCache() {
					this._loadedParentTiles = {};
					for (const e$1 in this._tiles) {
						const t$1 = [];
						let i$1, o$1 = this._tiles[e$1].tileID;
						for (; o$1.overscaledZ > 0;) {
							if (o$1.key in this._loadedParentTiles) {
								i$1 = this._loadedParentTiles[o$1.key];
								break;
							}
							t$1.push(o$1.key);
							const e$2 = o$1.scaledTo(o$1.overscaledZ - 1);
							if (i$1 = this._getLoadedTile(e$2), i$1) break;
							o$1 = e$2;
						}
						for (const e$2 of t$1) this._loadedParentTiles[e$2] = i$1;
					}
				}
				_updateLoadedSiblingTileCache() {
					this._loadedSiblingTiles = {};
					for (const e$1 in this._tiles) {
						const t$1 = this._tiles[e$1].tileID, i$1 = this._getLoadedTile(t$1);
						this._loadedSiblingTiles[t$1.key] = i$1;
					}
				}
				_addTile(e$1) {
					let i$1 = this._tiles[e$1.key];
					if (i$1) return i$1;
					i$1 = this._cache.getAndRemove(e$1), i$1 && (this._setTileReloadTimer(e$1.key, i$1), i$1.tileID = e$1, this._state.initializeTileState(i$1, this.map ? this.map.painter : null), this._cacheTimers[e$1.key] && (clearTimeout(this._cacheTimers[e$1.key]), delete this._cacheTimers[e$1.key], this._setTileReloadTimer(e$1.key, i$1)));
					const o$1 = i$1;
					return i$1 || (i$1 = new re$1(e$1, this._source.tileSize * e$1.overscaleFactor()), this._loadTile(i$1, e$1.key, i$1.state)), i$1.uses++, this._tiles[e$1.key] = i$1, o$1 || this._source.fire(new t.l("dataloading", {
						tile: i$1,
						coord: i$1.tileID,
						dataType: "source"
					})), i$1;
				}
				_setTileReloadTimer(e$1, t$1) {
					e$1 in this._timers && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]);
					const i$1 = t$1.getExpiryTimeout();
					i$1 && (this._timers[e$1] = setTimeout((() => {
						this._reloadTile(e$1, "expired"), delete this._timers[e$1];
					}), i$1));
				}
				refreshTiles(e$1) {
					for (const t$1 in this._tiles) (this._isIdRenderable(t$1) || "errored" == this._tiles[t$1].state) && e$1.some(((e$2) => e$2.equals(this._tiles[t$1].tileID.canonical))) && this._reloadTile(t$1, "expired");
				}
				_removeTile(e$1) {
					const t$1 = this._tiles[e$1];
					t$1 && (t$1.uses--, delete this._tiles[e$1], this._timers[e$1] && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]), t$1.uses > 0 || (t$1.hasData() && "reloading" !== t$1.state ? this._cache.add(t$1.tileID, t$1, t$1.getExpiryTimeout()) : (t$1.aborted = !0, this._abortTile(t$1), this._unloadTile(t$1))));
				}
				_dataHandler(e$1) {
					const t$1 = e$1.sourceDataType;
					"source" === e$1.dataType && "metadata" === t$1 && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e$1.dataType && "content" === t$1 && (this.reload(e$1.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
				}
				clearTiles() {
					this._shouldReloadOnResume = !1, this._paused = !1;
					for (const e$1 in this._tiles) this._removeTile(e$1);
					this._cache.reset();
				}
				tilesIn(e$1, i$1, o$1) {
					const r$1 = [], a$1 = this.transform;
					if (!a$1) return r$1;
					const s$1 = a$1.getCoveringTilesDetailsProvider().allowWorldCopies(), n$1 = o$1 ? a$1.getCameraQueryGeometry(e$1) : e$1, l$1 = (e$2) => a$1.screenPointToMercatorCoordinate(e$2, this.terrain), c$1 = this.transformBbox(e$1, l$1, !s$1), h$1 = this.transformBbox(n$1, l$1, !s$1), u$1 = this.getIds(), d$1 = t.a2.fromPoints(h$1);
					for (let e$2 = 0; e$2 < u$1.length; e$2++) {
						const o$2 = this._tiles[u$1[e$2]];
						if (o$2.holdingForFade()) continue;
						const n$2 = s$1 ? [o$2.tileID] : [o$2.tileID.unwrapTo(-1), o$2.tileID.unwrapTo(0)], l$2 = Math.pow(2, a$1.zoom - o$2.tileID.overscaledZ), _$2 = i$1 * o$2.queryPadding * t.$ / o$2.tileSize / l$2;
						for (const e$3 of n$2) {
							const i$2 = d$1.map(((i$3) => e$3.getTilePoint(new t.a1(i$3.x, i$3.y))));
							if (i$2.expandBy(_$2), i$2.intersects(be)) {
								const t$1 = c$1.map(((t$2) => e$3.getTilePoint(t$2))), i$3 = h$1.map(((t$2) => e$3.getTilePoint(t$2)));
								r$1.push({
									tile: o$2,
									tileID: s$1 ? e$3 : e$3.unwrapTo(0),
									queryGeometry: t$1,
									cameraQueryGeometry: i$3,
									scale: l$2
								});
							}
						}
					}
					return r$1;
				}
				transformBbox(e$1, i$1, o$1) {
					let r$1 = e$1.map(i$1);
					if (o$1) {
						const o$2 = t.a2.fromPoints(e$1);
						o$2.shrinkBy(.001 * Math.min(o$2.width(), o$2.height()));
						const a$1 = o$2.map(i$1);
						t.a2.fromPoints(r$1).covers(a$1) || (r$1 = r$1.map(((e$2) => e$2.x > .5 ? new t.a1(e$2.x - 1, e$2.y, e$2.z) : e$2)));
					}
					return r$1;
				}
				getVisibleCoordinates(e$1) {
					const t$1 = this.getRenderableIds(e$1).map(((e$2) => this._tiles[e$2].tileID));
					return this.transform && this.transform.populateCache(t$1), t$1;
				}
				hasTransition() {
					if (this._source.hasTransition()) return !0;
					if (we$1(this._source.type)) {
						const e$1 = s.now();
						for (const t$1 in this._tiles) if (this._tiles[t$1].fadeEndTime >= e$1) return !0;
					}
					return !1;
				}
				setFeatureState(e$1, t$1, i$1) {
					this._state.updateState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				removeFeatureState(e$1, t$1, i$1) {
					this._state.removeFeatureState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				getFeatureState(e$1, t$1) {
					return this._state.getState(e$1 = e$1 || "_geojsonTileLayer", t$1);
				}
				setDependencies(e$1, t$1, i$1) {
					const o$1 = this._tiles[e$1];
					o$1 && o$1.setDependencies(t$1, i$1);
				}
				reloadTilesForDependencies(e$1, t$1) {
					for (const i$1 in this._tiles) this._tiles[i$1].hasDependency(e$1, t$1) && this._reloadTile(i$1, "reloading");
					this._cache.filter(((i$1) => !i$1.hasDependency(e$1, t$1)));
				}
			}
			function ye$1(e$1, t$1) {
				const i$1 = Math.abs(2 * e$1.wrap) - +(e$1.wrap < 0), o$1 = Math.abs(2 * t$1.wrap) - +(t$1.wrap < 0);
				return e$1.overscaledZ - t$1.overscaledZ || o$1 - i$1 || t$1.canonical.y - e$1.canonical.y || t$1.canonical.x - e$1.canonical.x;
			}
			function we$1(e$1) {
				return "raster" === e$1 || "image" === e$1 || "video" === e$1;
			}
			xe$1.maxOverzooming = 10, xe$1.maxUnderzooming = 3;
			class Te$1 {
				constructor(e$1, t$1) {
					this.reset(e$1, t$1);
				}
				reset(e$1, t$1) {
					this.points = e$1 || [], this._distances = [0];
					for (let e$2 = 1; e$2 < this.points.length; e$2++) this._distances[e$2] = this._distances[e$2 - 1] + this.points[e$2].dist(this.points[e$2 - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t$1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(e$1) {
					if (1 === this.points.length) return this.points[0];
					e$1 = t.ah(e$1, 0, 1);
					let i$1 = 1, o$1 = this._distances[i$1];
					const r$1 = e$1 * this.paddedLength + this.padding;
					for (; o$1 < r$1 && i$1 < this._distances.length;) o$1 = this._distances[++i$1];
					const a$1 = i$1 - 1, s$1 = this._distances[a$1], n$1 = o$1 - s$1, l$1 = n$1 > 0 ? (r$1 - s$1) / n$1 : 0;
					return this.points[a$1].mult(1 - l$1).add(this.points[i$1].mult(l$1));
				}
			}
			function Pe$1(e$1, t$1) {
				let i$1 = !0;
				return "always" === e$1 || "never" !== e$1 && "never" !== t$1 || (i$1 = !1), i$1;
			}
			class Ce {
				constructor(e$1, t$1, i$1) {
					const o$1 = this.boxCells = [], r$1 = this.circleCells = [];
					this.xCellCount = Math.ceil(e$1 / i$1), this.yCellCount = Math.ceil(t$1 / i$1);
					for (let e$2 = 0; e$2 < this.xCellCount * this.yCellCount; e$2++) o$1.push([]), r$1.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e$1, this.height = t$1, this.xScale = this.xCellCount / e$1, this.yScale = this.yCellCount / t$1, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e$1, t$1, i$1, o$1, r$1) {
					this._forEachCell(t$1, i$1, o$1, r$1, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e$1), this.bboxes.push(t$1), this.bboxes.push(i$1), this.bboxes.push(o$1), this.bboxes.push(r$1);
				}
				insertCircle(e$1, t$1, i$1, o$1) {
					this._forEachCell(t$1 - o$1, i$1 - o$1, t$1 + o$1, i$1 + o$1, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e$1), this.circles.push(t$1), this.circles.push(i$1), this.circles.push(o$1);
				}
				_insertBoxCell(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.boxCells[r$1].push(a$1);
				}
				_insertCircleCell(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.circleCells[r$1].push(a$1);
				}
				_query(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
					if (i$1 < 0 || e$1 > this.width || o$1 < 0 || t$1 > this.height) return [];
					const n$1 = [];
					if (e$1 <= 0 && t$1 <= 0 && this.width <= i$1 && this.height <= o$1) {
						if (r$1) return [{
							key: null,
							x1: e$1,
							y1: t$1,
							x2: i$1,
							y2: o$1
						}];
						for (let e$2 = 0; e$2 < this.boxKeys.length; e$2++) n$1.push({
							key: this.boxKeys[e$2],
							x1: this.bboxes[4 * e$2],
							y1: this.bboxes[4 * e$2 + 1],
							x2: this.bboxes[4 * e$2 + 2],
							y2: this.bboxes[4 * e$2 + 3]
						});
						for (let e$2 = 0; e$2 < this.circleKeys.length; e$2++) {
							const t$2 = this.circles[3 * e$2], i$2 = this.circles[3 * e$2 + 1], o$2 = this.circles[3 * e$2 + 2];
							n$1.push({
								key: this.circleKeys[e$2],
								x1: t$2 - o$2,
								y1: i$2 - o$2,
								x2: t$2 + o$2,
								y2: i$2 + o$2
							});
						}
					} else this._forEachCell(e$1, t$1, i$1, o$1, this._queryCell, n$1, {
						hitTest: r$1,
						overlapMode: a$1,
						seenUids: {
							box: {},
							circle: {}
						}
					}, s$1);
					return n$1;
				}
				query(e$1, t$1, i$1, o$1) {
					return this._query(e$1, t$1, i$1, o$1, !1, null);
				}
				hitTest(e$1, t$1, i$1, o$1, r$1, a$1) {
					return this._query(e$1, t$1, i$1, o$1, !0, r$1, a$1).length > 0;
				}
				hitTestCircle(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = e$1 - i$1, s$1 = e$1 + i$1, n$1 = t$1 - i$1, l$1 = t$1 + i$1;
					if (s$1 < 0 || a$1 > this.width || l$1 < 0 || n$1 > this.height) return !1;
					const c$1 = [];
					return this._forEachCell(a$1, n$1, s$1, l$1, this._queryCellCircle, c$1, {
						hitTest: !0,
						overlapMode: o$1,
						circle: {
							x: e$1,
							y: t$1,
							radius: i$1
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, r$1), c$1.length > 0;
				}
				_queryCell(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const { seenUids: l$1, hitTest: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const r$2 = this.bboxes;
						for (const s$2 of u$1) if (!l$1.box[s$2]) {
							l$1.box[s$2] = !0;
							const u$2 = 4 * s$2, d$2 = this.boxKeys[s$2];
							if (e$1 <= r$2[u$2 + 2] && t$1 <= r$2[u$2 + 3] && i$1 >= r$2[u$2 + 0] && o$1 >= r$2[u$2 + 1] && (!n$1 || n$1(d$2)) && (!c$1 || !Pe$1(h$1, d$2.overlapMode)) && (a$1.push({
								key: d$2,
								x1: r$2[u$2],
								y1: r$2[u$2 + 1],
								x2: r$2[u$2 + 2],
								y2: r$2[u$2 + 3]
							}), c$1)) return !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const r$2 = this.circles;
						for (const s$2 of d$1) if (!l$1.circle[s$2]) {
							l$1.circle[s$2] = !0;
							const u$2 = 3 * s$2, d$2 = this.circleKeys[s$2];
							if (this._circleAndRectCollide(r$2[u$2], r$2[u$2 + 1], r$2[u$2 + 2], e$1, t$1, i$1, o$1) && (!n$1 || n$1(d$2)) && (!c$1 || !Pe$1(h$1, d$2.overlapMode))) {
								const e$2 = r$2[u$2], t$2 = r$2[u$2 + 1], i$2 = r$2[u$2 + 2];
								if (a$1.push({
									key: d$2,
									x1: e$2 - i$2,
									y1: t$2 - i$2,
									x2: e$2 + i$2,
									y2: t$2 + i$2
								}), c$1) return !0;
							}
						}
					}
					return !1;
				}
				_queryCellCircle(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const { circle: l$1, seenUids: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const e$2 = this.bboxes;
						for (const t$2 of u$1) if (!c$1.box[t$2]) {
							c$1.box[t$2] = !0;
							const i$2 = 4 * t$2, o$2 = this.boxKeys[t$2];
							if (this._circleAndRectCollide(l$1.x, l$1.y, l$1.radius, e$2[i$2 + 0], e$2[i$2 + 1], e$2[i$2 + 2], e$2[i$2 + 3]) && (!n$1 || n$1(o$2)) && !Pe$1(h$1, o$2.overlapMode)) return a$1.push(!0), !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const e$2 = this.circles;
						for (const t$2 of d$1) if (!c$1.circle[t$2]) {
							c$1.circle[t$2] = !0;
							const i$2 = 3 * t$2, o$2 = this.circleKeys[t$2];
							if (this._circlesCollide(e$2[i$2], e$2[i$2 + 1], e$2[i$2 + 2], l$1.x, l$1.y, l$1.radius) && (!n$1 || n$1(o$2)) && !Pe$1(h$1, o$2.overlapMode)) return a$1.push(!0), !0;
						}
					}
				}
				_forEachCell(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const l$1 = this._convertToXCellCoord(e$1), c$1 = this._convertToYCellCoord(t$1), h$1 = this._convertToXCellCoord(i$1), u$1 = this._convertToYCellCoord(o$1);
					for (let d$1 = l$1; d$1 <= h$1; d$1++) for (let l$2 = c$1; l$2 <= u$1; l$2++) if (r$1.call(this, e$1, t$1, i$1, o$1, this.xCellCount * l$2 + d$1, a$1, s$1, n$1)) return;
				}
				_convertToXCellCoord(e$1) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e$1 * this.xScale)));
				}
				_convertToYCellCoord(e$1) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e$1 * this.yScale)));
				}
				_circlesCollide(e$1, t$1, i$1, o$1, r$1, a$1) {
					const s$1 = o$1 - e$1, n$1 = r$1 - t$1, l$1 = i$1 + a$1;
					return l$1 * l$1 > s$1 * s$1 + n$1 * n$1;
				}
				_circleAndRectCollide(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
					const n$1 = (a$1 - o$1) / 2, l$1 = Math.abs(e$1 - (o$1 + n$1));
					if (l$1 > n$1 + i$1) return !1;
					const c$1 = (s$1 - r$1) / 2, h$1 = Math.abs(t$1 - (r$1 + c$1));
					if (h$1 > c$1 + i$1) return !1;
					if (l$1 <= n$1 || h$1 <= c$1) return !0;
					const u$1 = l$1 - n$1, d$1 = h$1 - c$1;
					return u$1 * u$1 + d$1 * d$1 <= i$1 * i$1;
				}
			}
			function Ie$1(e$1, i$1, r$1) {
				const a$1 = t.L();
				if (!e$1) {
					const { vecSouth: e$2, vecEast: t$1 } = Se$1(i$1), r$2 = o();
					r$2[0] = t$1[0], r$2[1] = t$1[1], r$2[2] = e$2[0], r$2[3] = e$2[1], s$1 = r$2, (d$1 = (l$1 = (n$1 = r$2)[0]) * (u$1 = n$1[3]) - (h$1 = n$1[2]) * (c$1 = n$1[1])) && (s$1[0] = u$1 * (d$1 = 1 / d$1), s$1[1] = -c$1 * d$1, s$1[2] = -h$1 * d$1, s$1[3] = l$1 * d$1), a$1[0] = r$2[0], a$1[1] = r$2[1], a$1[4] = r$2[2], a$1[5] = r$2[3];
				}
				var s$1, n$1, l$1, c$1, h$1, u$1, d$1;
				return t.N(a$1, a$1, [
					1 / r$1,
					1 / r$1,
					1
				]), a$1;
			}
			function Me$1(e$1, i$1, o$1, r$1) {
				if (e$1) {
					const e$2 = t.L();
					if (!i$1) {
						const { vecSouth: t$1, vecEast: i$2 } = Se$1(o$1);
						e$2[0] = i$2[0], e$2[1] = i$2[1], e$2[4] = t$1[0], e$2[5] = t$1[1];
					}
					return t.N(e$2, e$2, [
						r$1,
						r$1,
						1
					]), e$2;
				}
				return o$1.pixelsToClipSpaceMatrix;
			}
			function Se$1(e$1) {
				const i$1 = Math.cos(e$1.rollInRadians), o$1 = Math.sin(e$1.rollInRadians), r$1 = Math.cos(e$1.pitchInRadians), a$1 = Math.cos(e$1.bearingInRadians), s$1 = Math.sin(e$1.bearingInRadians), n$1 = t.ar();
				n$1[0] = -a$1 * r$1 * o$1 - s$1 * i$1, n$1[1] = -s$1 * r$1 * o$1 + a$1 * i$1;
				const l$1 = t.as(n$1);
				l$1 < 1e-9 ? t.at(n$1) : t.au(n$1, n$1, 1 / l$1);
				const c$1 = t.ar();
				c$1[0] = a$1 * r$1 * i$1 - s$1 * o$1, c$1[1] = s$1 * r$1 * i$1 + a$1 * o$1;
				const h$1 = t.as(c$1);
				return h$1 < 1e-9 ? t.at(c$1) : t.au(c$1, c$1, 1 / h$1), {
					vecEast: c$1,
					vecSouth: n$1
				};
			}
			function Ee(e$1, i$1, o$1, r$1) {
				let a$1;
				r$1 ? (a$1 = [
					e$1,
					i$1,
					r$1(e$1, i$1),
					1
				], t.aw(a$1, a$1, o$1)) : (a$1 = [
					e$1,
					i$1,
					0,
					1
				], qe$1(a$1, a$1, o$1));
				const s$1 = a$1[3];
				return {
					point: new t.P(a$1[0] / s$1, a$1[1] / s$1),
					signedDistanceFromCamera: s$1,
					isOccluded: !1
				};
			}
			function Re$1(e$1, t$1) {
				return .5 + e$1 / t$1 * .5;
			}
			function ze$1(e$1, t$1) {
				return e$1.x >= -t$1[0] && e$1.x <= t$1[0] && e$1.y >= -t$1[1] && e$1.y <= t$1[1];
			}
			function De$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) {
				const p$1 = o$1 ? e$1.textSizeData : e$1.iconSizeData, m$1 = t.an(p$1, i$1.transform.zoom), f$1 = [256 / i$1.width * 2 + 1, 256 / i$1.height * 2 + 1], g$2 = o$1 ? e$1.text.dynamicLayoutVertexArray : e$1.icon.dynamicLayoutVertexArray;
				g$2.clear();
				const v$1 = e$1.lineVertexArray, b$2 = o$1 ? e$1.text.placedSymbolArray : e$1.icon.placedSymbolArray, x$1 = i$1.transform.width / i$1.transform.height;
				let y$1 = !1;
				for (let o$2 = 0; o$2 < b$2.length; o$2++) {
					const w$1 = b$2.get(o$2);
					if (w$1.hidden || w$1.writingMode === t.ao.vertical && !y$1) {
						$e$1(w$1.numGlyphs, g$2);
						continue;
					}
					y$1 = !1;
					const T$2 = new t.P(w$1.anchorX, w$1.anchorY), P$2 = {
						getElevation: _$2,
						pitchedLabelPlaneMatrix: r$1,
						lineVertexArray: v$1,
						pitchWithMap: s$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: i$1.transform,
						tileAnchorPoint: T$2,
						unwrappedTileID: c$1,
						width: h$1,
						height: u$1,
						translation: d$1
					}, C$1 = Ne$1(w$1.anchorX, w$1.anchorY, P$2);
					if (!ze$1(C$1.point, f$1)) {
						$e$1(w$1.numGlyphs, g$2);
						continue;
					}
					const I$2 = Re$1(i$1.transform.cameraToCenterDistance, C$1.signedDistanceFromCamera), M$2 = t.ap(p$1, m$1, w$1), S$2 = s$1 ? M$2 * i$1.transform.getPitchedTextCorrection(w$1.anchorX, w$1.anchorY, c$1) / I$2 : M$2 * I$2, E$1 = ke$1({
						projectionContext: P$2,
						pitchedLabelPlaneMatrixInverse: a$1,
						symbol: w$1,
						fontSize: S$2,
						flip: !1,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$2,
						aspectRatio: x$1,
						rotateToLine: l$1
					});
					y$1 = E$1.useVertical, (E$1.notEnoughRoom || y$1 || E$1.needsFlipping && ke$1({
						projectionContext: P$2,
						pitchedLabelPlaneMatrixInverse: a$1,
						symbol: w$1,
						fontSize: S$2,
						flip: !0,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$2,
						aspectRatio: x$1,
						rotateToLine: l$1
					}).notEnoughRoom) && $e$1(w$1.numGlyphs, g$2);
				}
				o$1 ? e$1.text.dynamicLayoutVertexBuffer.updateData(g$2) : e$1.icon.dynamicLayoutVertexBuffer.updateData(g$2);
			}
			function Ae$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
				const l$1 = a$1.glyphStartIndex + a$1.numGlyphs, c$1 = a$1.lineStartIndex, h$1 = a$1.lineStartIndex + a$1.lineLength, u$1 = t$1.getoffsetX(a$1.glyphStartIndex), d$1 = t$1.getoffsetX(l$1 - 1), _$2 = Ge$1(e$1 * u$1, i$1, o$1, r$1, a$1.segment, c$1, h$1, n$1, s$1);
				if (!_$2) return null;
				const p$1 = Ge$1(e$1 * d$1, i$1, o$1, r$1, a$1.segment, c$1, h$1, n$1, s$1);
				return p$1 ? n$1.projectionCache.anyProjectionOccluded ? null : {
					first: _$2,
					last: p$1
				} : null;
			}
			function Le(e$1, i$1, o$1, r$1) {
				return e$1 === t.ao.horizontal && Math.abs(o$1.y - i$1.y) > Math.abs(o$1.x - i$1.x) * r$1 ? { useVertical: !0 } : (e$1 === t.ao.vertical ? i$1.y < o$1.y : i$1.x > o$1.x) ? { needsFlipping: !0 } : null;
			}
			function ke$1(e$1) {
				const { projectionContext: i$1, pitchedLabelPlaneMatrixInverse: o$1, symbol: r$1, fontSize: a$1, flip: s$1, keepUpright: n$1, glyphOffsetArray: l$1, dynamicLayoutVertexArray: c$1, aspectRatio: h$1, rotateToLine: u$1 } = e$1, d$1 = a$1 / 24, _$2 = r$1.lineOffsetX * d$1, p$1 = r$1.lineOffsetY * d$1;
				let m$1;
				if (r$1.numGlyphs > 1) {
					const e$2 = r$1.glyphStartIndex + r$1.numGlyphs, t$1 = r$1.lineStartIndex, a$2 = r$1.lineStartIndex + r$1.lineLength, c$2 = Ae$1(d$1, l$1, _$2, p$1, s$1, r$1, u$1, i$1);
					if (!c$2) return { notEnoughRoom: !0 };
					const f$1 = je$1(c$2.first.point.x, c$2.first.point.y, i$1, o$1), g$2 = je$1(c$2.last.point.x, c$2.last.point.y, i$1, o$1);
					if (n$1 && !s$1) {
						const e$3 = Le(r$1.writingMode, f$1, g$2, h$1);
						if (e$3) return e$3;
					}
					m$1 = [c$2.first];
					for (let o$2 = r$1.glyphStartIndex + 1; o$2 < e$2 - 1; o$2++) {
						const e$3 = Ge$1(d$1 * l$1.getoffsetX(o$2), _$2, p$1, s$1, r$1.segment, t$1, a$2, i$1, u$1);
						if (!e$3) return { notEnoughRoom: !0 };
						m$1.push(e$3);
					}
					m$1.push(c$2.last);
				} else {
					if (n$1 && !s$1) {
						const e$3 = Oe$1(i$1.tileAnchorPoint.x, i$1.tileAnchorPoint.y, i$1).point, a$2 = r$1.lineStartIndex + r$1.segment + 1, s$2 = new t.P(i$1.lineVertexArray.getx(a$2), i$1.lineVertexArray.gety(a$2)), n$2 = Oe$1(s$2.x, s$2.y, i$1), l$2 = n$2.signedDistanceFromCamera > 0 ? n$2.point : Fe$1(i$1.tileAnchorPoint, s$2, e$3, 1, i$1), c$2 = je$1(e$3.x, e$3.y, i$1, o$1), u$2 = je$1(l$2.x, l$2.y, i$1, o$1), d$2 = Le(r$1.writingMode, c$2, u$2, h$1);
						if (d$2) return d$2;
					}
					const e$2 = Ge$1(d$1 * l$1.getoffsetX(r$1.glyphStartIndex), _$2, p$1, s$1, r$1.segment, r$1.lineStartIndex, r$1.lineStartIndex + r$1.lineLength, i$1, u$1);
					if (!e$2 || i$1.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
					m$1 = [e$2];
				}
				for (const e$2 of m$1) t.av(c$1, e$2.point, e$2.angle);
				return {};
			}
			function Fe$1(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1.add(e$1.sub(t$1)._unit()), s$1 = Oe$1(a$1.x, a$1.y, r$1).point, n$1 = i$1.sub(s$1);
				return i$1.add(n$1._mult(o$1 / n$1.mag()));
			}
			function Be$1(e$1, i$1, o$1) {
				const r$1 = i$1.projectionCache;
				if (r$1.projections[e$1]) return r$1.projections[e$1];
				const a$1 = new t.P(i$1.lineVertexArray.getx(e$1), i$1.lineVertexArray.gety(e$1)), s$1 = Oe$1(a$1.x, a$1.y, i$1);
				if (s$1.signedDistanceFromCamera > 0) return r$1.projections[e$1] = s$1.point, r$1.anyProjectionOccluded = r$1.anyProjectionOccluded || s$1.isOccluded, s$1.point;
				const n$1 = e$1 - o$1.direction;
				return Fe$1(0 === o$1.distanceFromAnchor ? i$1.tileAnchorPoint : new t.P(i$1.lineVertexArray.getx(n$1), i$1.lineVertexArray.gety(n$1)), a$1, o$1.previousVertex, o$1.absOffsetX - o$1.distanceFromAnchor + 1, i$1);
			}
			function Oe$1(e$1, t$1, i$1) {
				const o$1 = e$1 + i$1.translation[0], r$1 = t$1 + i$1.translation[1];
				let a$1;
				return i$1.pitchWithMap ? (a$1 = Ee(o$1, r$1, i$1.pitchedLabelPlaneMatrix, i$1.getElevation), a$1.isOccluded = !1) : (a$1 = i$1.transform.projectTileCoordinates(o$1, r$1, i$1.unwrappedTileID, i$1.getElevation), a$1.point.x = (.5 * a$1.point.x + .5) * i$1.width, a$1.point.y = (.5 * -a$1.point.y + .5) * i$1.height), a$1;
			}
			function je$1(e$1, i$1, o$1, r$1) {
				if (o$1.pitchWithMap) {
					const a$1 = [
						e$1,
						i$1,
						0,
						1
					];
					return t.aw(a$1, a$1, r$1), o$1.transform.projectTileCoordinates(a$1[0] / a$1[3], a$1[1] / a$1[3], o$1.unwrappedTileID, o$1.getElevation).point;
				}
				return {
					x: e$1 / o$1.width * 2 - 1,
					y: 1 - i$1 / o$1.height * 2
				};
			}
			function Ne$1(e$1, t$1, i$1) {
				return i$1.transform.projectTileCoordinates(e$1, t$1, i$1.unwrappedTileID, i$1.getElevation);
			}
			function Ue$1(e$1, t$1, i$1) {
				return e$1._unit()._perp()._mult(t$1 * i$1);
			}
			function Ze$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1) {
				if (l$1.projectionCache.offsets[e$1]) return l$1.projectionCache.offsets[e$1];
				const h$1 = o$1.add(i$1);
				if (e$1 + c$1.direction < r$1 || e$1 + c$1.direction >= a$1) return l$1.projectionCache.offsets[e$1] = h$1, h$1;
				const u$1 = Be$1(e$1 + c$1.direction, l$1, c$1), d$1 = Ue$1(u$1.sub(o$1), n$1, c$1.direction), _$2 = o$1.add(d$1), p$1 = u$1.add(d$1);
				return l$1.projectionCache.offsets[e$1] = t.ax(s$1, h$1, _$2, p$1) || h$1, l$1.projectionCache.offsets[e$1];
			}
			function Ge$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = o$1 ? e$1 - t$1 : e$1 + t$1;
				let h$1 = c$1 > 0 ? 1 : -1, u$1 = 0;
				o$1 && (h$1 *= -1, u$1 = Math.PI), h$1 < 0 && (u$1 += Math.PI);
				let d$1, _$2 = h$1 > 0 ? a$1 + r$1 : a$1 + r$1 + 1;
				n$1.projectionCache.cachedAnchorPoint ? d$1 = n$1.projectionCache.cachedAnchorPoint : (d$1 = Oe$1(n$1.tileAnchorPoint.x, n$1.tileAnchorPoint.y, n$1).point, n$1.projectionCache.cachedAnchorPoint = d$1);
				let p$1, m$1, f$1 = d$1, g$2 = d$1, v$1 = 0, b$2 = 0;
				const x$1 = Math.abs(c$1), y$1 = [];
				let w$1;
				for (; v$1 + b$2 <= x$1;) {
					if (_$2 += h$1, _$2 < a$1 || _$2 >= s$1) return null;
					v$1 += b$2, g$2 = f$1, m$1 = p$1;
					const e$2 = {
						absOffsetX: x$1,
						direction: h$1,
						distanceFromAnchor: v$1,
						previousVertex: g$2
					};
					if (f$1 = Be$1(_$2, n$1, e$2), 0 === i$1) y$1.push(g$2), w$1 = f$1.sub(g$2);
					else {
						let t$2;
						const o$2 = f$1.sub(g$2);
						t$2 = 0 === o$2.mag() ? Ue$1(Be$1(_$2 + h$1, n$1, e$2).sub(f$1), i$1, h$1) : Ue$1(o$2, i$1, h$1), m$1 || (m$1 = g$2.add(t$2)), p$1 = Ze$1(_$2, t$2, f$1, a$1, s$1, m$1, i$1, n$1, e$2), y$1.push(m$1), w$1 = p$1.sub(m$1);
					}
					b$2 = w$1.mag();
				}
				const T$2 = w$1._mult((x$1 - v$1) / b$2)._add(m$1 || g$2), P$2 = u$1 + Math.atan2(f$1.y - g$2.y, f$1.x - g$2.x);
				return y$1.push(T$2), {
					point: T$2,
					angle: l$1 ? P$2 : 0,
					path: y$1
				};
			}
			const Ve$1 = new Float32Array([
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0
			]);
			function $e$1(e$1, t$1) {
				for (let i$1 = 0; i$1 < e$1; i$1++) {
					const e$2 = t$1.length;
					t$1.resize(e$2 + 4), t$1.float32.set(Ve$1, 3 * e$2);
				}
			}
			function qe$1(e$1, t$1, i$1) {
				const o$1 = t$1[0], r$1 = t$1[1];
				return e$1[0] = i$1[0] * o$1 + i$1[4] * r$1 + i$1[12], e$1[1] = i$1[1] * o$1 + i$1[5] * r$1 + i$1[13], e$1[3] = i$1[3] * o$1 + i$1[7] * r$1 + i$1[15], e$1;
			}
			const We$1 = 100;
			class He$1 {
				constructor(e$1, t$1 = new Ce(e$1.width + 200, e$1.height + 200, 25), i$1 = new Ce(e$1.width + 200, e$1.height + 200, 25)) {
					this.transform = e$1, this.grid = t$1, this.ignoredGrid = i$1, this.pitchFactor = Math.cos(e$1.pitch * Math.PI / 180) * e$1.cameraToCenterDistance, this.screenRightBoundary = e$1.width + We$1, this.screenBottomBoundary = e$1.height + We$1, this.gridRightBoundary = e$1.width + 200, this.gridBottomBoundary = e$1.height + 200, this.perspectiveRatioCutoff = .6;
				}
				placeCollisionBox(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					const d$1 = this.projectAndGetPerspectiveRatio(e$1.anchorPointX + n$1[0], e$1.anchorPointY + n$1[1], r$1, c$1, u$1), _$2 = i$1 * d$1.perspectiveRatio;
					let p$1;
					if (a$1 || s$1) p$1 = this._projectCollisionBox(e$1, _$2, o$1, r$1, a$1, s$1, n$1, d$1, c$1, h$1, u$1);
					else {
						const t$2 = d$1.x + (h$1 ? h$1.x * _$2 : 0), i$2 = d$1.y + (h$1 ? h$1.y * _$2 : 0);
						p$1 = {
							allPointsOccluded: !1,
							box: [
								t$2 + e$1.x1 * _$2,
								i$2 + e$1.y1 * _$2,
								t$2 + e$1.x2 * _$2,
								i$2 + e$1.y2 * _$2
							]
						};
					}
					const [m$1, f$1, g$2, v$1] = p$1.box, b$2 = a$1 ? p$1.allPointsOccluded : d$1.isOccluded;
					let x$1 = b$2;
					return x$1 || (x$1 = d$1.perspectiveRatio < this.perspectiveRatioCutoff), x$1 || (x$1 = !this.isInsideGrid(m$1, f$1, g$2, v$1)), x$1 || "always" !== t$1 && this.grid.hitTest(m$1, f$1, g$2, v$1, t$1, l$1) ? {
						box: [
							m$1,
							f$1,
							g$2,
							v$1
						],
						placeable: !1,
						offscreen: !1,
						occluded: b$2
					} : {
						box: [
							m$1,
							f$1,
							g$2,
							v$1
						],
						placeable: !0,
						offscreen: this.isOffscreen(m$1, f$1, g$2, v$1),
						occluded: b$2
					};
				}
				placeCollisionCircles(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1) {
					const m$1 = [], f$1 = new t.P(i$1.anchorX, i$1.anchorY), g$2 = this.getPerspectiveRatio(f$1.x, f$1.y, s$1, p$1), v$1 = (c$1 ? a$1 * this.transform.getPitchedTextCorrection(i$1.anchorX, i$1.anchorY, s$1) / g$2 : a$1 * g$2) / t.aB, b$2 = {
						getElevation: p$1,
						pitchedLabelPlaneMatrix: n$1,
						lineVertexArray: o$1,
						pitchWithMap: c$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: this.transform,
						tileAnchorPoint: f$1,
						unwrappedTileID: s$1,
						width: this.transform.width,
						height: this.transform.height,
						translation: _$2
					}, x$1 = Ae$1(v$1, r$1, i$1.lineOffsetX * v$1, i$1.lineOffsetY * v$1, !1, i$1, !1, b$2);
					let y$1 = !1, w$1 = !1, T$2 = !0;
					if (x$1) {
						const i$2 = .5 * u$1 * g$2 + d$1, o$2 = new t.P(-100, -100), r$2 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), a$2 = new Te$1(), s$2 = x$1.first, n$2 = x$1.last;
						let _$3 = [];
						for (let e$2 = s$2.path.length - 1; e$2 >= 1; e$2--) _$3.push(s$2.path[e$2]);
						for (let e$2 = 1; e$2 < n$2.path.length; e$2++) _$3.push(n$2.path[e$2]);
						const p$2 = 2.5 * i$2;
						if (c$1) {
							const e$2 = this.projectPathToScreenSpace(_$3, b$2);
							_$3 = e$2.some(((e$3) => e$3.signedDistanceFromCamera <= 0)) ? [] : e$2.map(((e$3) => e$3.point));
						}
						let f$2 = [];
						if (_$3.length > 0) {
							const e$2 = _$3[0].clone(), i$3 = _$3[0].clone();
							for (let t$1 = 1; t$1 < _$3.length; t$1++) e$2.x = Math.min(e$2.x, _$3[t$1].x), e$2.y = Math.min(e$2.y, _$3[t$1].y), i$3.x = Math.max(i$3.x, _$3[t$1].x), i$3.y = Math.max(i$3.y, _$3[t$1].y);
							f$2 = e$2.x >= o$2.x && i$3.x <= r$2.x && e$2.y >= o$2.y && i$3.y <= r$2.y ? [_$3] : i$3.x < o$2.x || e$2.x > r$2.x || i$3.y < o$2.y || e$2.y > r$2.y ? [] : t.ay([_$3], o$2.x, o$2.y, r$2.x, r$2.y);
						}
						for (const t$1 of f$2) {
							a$2.reset(t$1, .25 * i$2);
							let o$3 = 0;
							o$3 = a$2.length <= .5 * i$2 ? 1 : Math.ceil(a$2.paddedLength / p$2) + 1;
							for (let t$2 = 0; t$2 < o$3; t$2++) {
								const r$3 = t$2 / Math.max(o$3 - 1, 1), s$3 = a$2.lerp(r$3), n$3 = s$3.x + We$1, c$2 = s$3.y + We$1;
								m$1.push(n$3, c$2, i$2, 0);
								const u$2 = n$3 - i$2, d$2 = c$2 - i$2, _$4 = n$3 + i$2, p$3 = c$2 + i$2;
								if (T$2 = T$2 && this.isOffscreen(u$2, d$2, _$4, p$3), w$1 = w$1 || this.isInsideGrid(u$2, d$2, _$4, p$3), "always" !== e$1 && this.grid.hitTestCircle(n$3, c$2, i$2, e$1, h$1) && (y$1 = !0, !l$1)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: y$1
								};
							}
						}
					}
					return {
						circles: !l$1 && y$1 || !w$1 || g$2 < this.perspectiveRatioCutoff ? [] : m$1,
						offscreen: T$2,
						collisionDetected: y$1
					};
				}
				projectPathToScreenSpace(e$1, i$1) {
					return function(e$2) {
						let t$1 = 0, i$2 = 0, o$1 = 0, r$1 = 0;
						for (let a$1 = 0; a$1 < e$2.length; a$1++) e$2[a$1].isOccluded ? (o$1 = a$1 + 1, r$1 = 0) : (r$1++, r$1 > i$2 && (i$2 = r$1, t$1 = o$1));
						return e$2.slice(t$1, t$1 + i$2);
					}(function(e$2, i$2) {
						const o$1 = t.L();
						return t.aq(o$1, i$2.pitchedLabelPlaneMatrix), e$2.map(((e$3) => {
							const t$1 = Ee(e$3.x, e$3.y, o$1, i$2.getElevation), r$1 = i$2.transform.projectTileCoordinates(t$1.point.x, t$1.point.y, i$2.unwrappedTileID, i$2.getElevation);
							return r$1.point.x = (.5 * r$1.point.x + .5) * i$2.width, r$1.point.y = (.5 * -r$1.point.y + .5) * i$2.height, r$1;
						}));
					}(e$1, i$1));
				}
				queryRenderedSymbols(e$1) {
					if (0 === e$1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
					const i$1 = [], o$1 = new t.a2();
					for (const r$2 of e$1) {
						const e$2 = new t.P(r$2.x + We$1, r$2.y + We$1);
						o$1.extend(e$2), i$1.push(e$2);
					}
					const { minX: r$1, minY: a$1, maxX: s$1, maxY: n$1 } = o$1, l$1 = this.grid.query(r$1, a$1, s$1, n$1).concat(this.ignoredGrid.query(r$1, a$1, s$1, n$1)), c$1 = {}, h$1 = {};
					for (const e$2 of l$1) {
						const o$2 = e$2.key;
						if (void 0 === c$1[o$2.bucketInstanceId] && (c$1[o$2.bucketInstanceId] = {}), c$1[o$2.bucketInstanceId][o$2.featureIndex]) continue;
						const r$2 = [
							new t.P(e$2.x1, e$2.y1),
							new t.P(e$2.x2, e$2.y1),
							new t.P(e$2.x2, e$2.y2),
							new t.P(e$2.x1, e$2.y2)
						];
						t.az(i$1, r$2) && (c$1[o$2.bucketInstanceId][o$2.featureIndex] = !0, void 0 === h$1[o$2.bucketInstanceId] && (h$1[o$2.bucketInstanceId] = []), h$1[o$2.bucketInstanceId].push(o$2.featureIndex));
					}
					return h$1;
				}
				insertCollisionBox(e$1, t$1, i$1, o$1, r$1, a$1) {
					(i$1 ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: o$1,
						featureIndex: r$1,
						collisionGroupID: a$1,
						overlapMode: t$1
					}, e$1[0], e$1[1], e$1[2], e$1[3]);
				}
				insertCollisionCircles(e$1, t$1, i$1, o$1, r$1, a$1) {
					const s$1 = i$1 ? this.ignoredGrid : this.grid, n$1 = {
						bucketInstanceId: o$1,
						featureIndex: r$1,
						collisionGroupID: a$1,
						overlapMode: t$1
					};
					for (let t$2 = 0; t$2 < e$1.length; t$2 += 4) s$1.insertCircle(n$1, e$1[t$2], e$1[t$2 + 1], e$1[t$2 + 2]);
				}
				projectAndGetPerspectiveRatio(e$1, i$1, o$1, r$1, a$1) {
					if (a$1) {
						let o$2;
						r$1 ? (o$2 = [
							e$1,
							i$1,
							r$1(e$1, i$1),
							1
						], t.aw(o$2, o$2, a$1)) : (o$2 = [
							e$1,
							i$1,
							0,
							1
						], qe$1(o$2, o$2, a$1));
						const s$1 = o$2[3];
						return {
							x: (o$2[0] / s$1 + 1) / 2 * this.transform.width + We$1,
							y: (-o$2[1] / s$1 + 1) / 2 * this.transform.height + We$1,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / s$1 * .5,
							isOccluded: !1,
							signedDistanceFromCamera: s$1
						};
					}
					{
						const t$1 = this.transform.projectTileCoordinates(e$1, i$1, o$1, r$1);
						return {
							x: (t$1.point.x + 1) / 2 * this.transform.width + We$1,
							y: (1 - t$1.point.y) / 2 * this.transform.height + We$1,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t$1.signedDistanceFromCamera * .5,
							isOccluded: t$1.isOccluded,
							signedDistanceFromCamera: t$1.signedDistanceFromCamera
						};
					}
				}
				getPerspectiveRatio(e$1, t$1, i$1, o$1) {
					const r$1 = this.transform.projectTileCoordinates(e$1, t$1, i$1, o$1);
					return .5 + this.transform.cameraToCenterDistance / r$1.signedDistanceFromCamera * .5;
				}
				isOffscreen(e$1, t$1, i$1, o$1) {
					return i$1 < We$1 || e$1 >= this.screenRightBoundary || o$1 < We$1 || t$1 > this.screenBottomBoundary;
				}
				isInsideGrid(e$1, t$1, i$1, o$1) {
					return i$1 >= 0 && e$1 < this.gridRightBoundary && o$1 >= 0 && t$1 < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					const e$1 = t.ag([]);
					return t.M(e$1, e$1, [
						-100,
						-100,
						0
					]), e$1;
				}
				_projectCollisionBox(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					let d$1 = 1, _$2 = 0, p$1 = 0, m$1 = 1;
					const f$1 = e$1.anchorPointX + n$1[0], g$2 = e$1.anchorPointY + n$1[1];
					if (s$1 && !a$1) {
						const e$2 = this.projectAndGetPerspectiveRatio(f$1 + 1, g$2, r$1, c$1, u$1), t$1 = e$2.x - l$1.x, i$2 = Math.atan((e$2.y - l$1.y) / t$1) + (t$1 < 0 ? Math.PI : 0), o$2 = Math.sin(i$2), a$2 = Math.cos(i$2);
						d$1 = a$2, _$2 = o$2, p$1 = -o$2, m$1 = a$2;
					} else if (!s$1 && a$1) {
						const e$2 = Se$1(this.transform);
						d$1 = e$2.vecEast[0], _$2 = e$2.vecEast[1], p$1 = e$2.vecSouth[0], m$1 = e$2.vecSouth[1];
					}
					let v$1 = l$1.x, b$2 = l$1.y, x$1 = i$1;
					a$1 && (v$1 = f$1, b$2 = g$2, x$1 = Math.pow(2, -(this.transform.zoom - o$1.overscaledZ)), x$1 *= this.transform.getPitchedTextCorrection(f$1, g$2, r$1), h$1 || (x$1 *= t.ah(.5 + l$1.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), h$1 && (v$1 += d$1 * h$1.x * x$1 + p$1 * h$1.y * x$1, b$2 += _$2 * h$1.x * x$1 + m$1 * h$1.y * x$1);
					const y$1 = e$1.x1 * x$1, w$1 = e$1.x2 * x$1, T$2 = (y$1 + w$1) / 2, P$2 = e$1.y1 * x$1, C$1 = e$1.y2 * x$1, I$2 = (P$2 + C$1) / 2, M$2 = [
						{
							offsetX: y$1,
							offsetY: P$2
						},
						{
							offsetX: T$2,
							offsetY: P$2
						},
						{
							offsetX: w$1,
							offsetY: P$2
						},
						{
							offsetX: w$1,
							offsetY: I$2
						},
						{
							offsetX: w$1,
							offsetY: C$1
						},
						{
							offsetX: T$2,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: I$2
						}
					];
					let S$2 = [];
					for (const { offsetX: e$2, offsetY: i$2 } of M$2) S$2.push(new t.P(v$1 + d$1 * e$2 + p$1 * i$2, b$2 + _$2 * e$2 + m$1 * i$2));
					let E$1 = !1;
					if (a$1) {
						const e$2 = S$2.map(((e$3) => this.projectAndGetPerspectiveRatio(e$3.x, e$3.y, r$1, c$1, u$1)));
						E$1 = e$2.some(((e$3) => !e$3.isOccluded)), S$2 = e$2.map(((e$3) => new t.P(e$3.x, e$3.y)));
					} else E$1 = !0;
					return {
						box: t.aA(S$2),
						allPointsOccluded: !E$1
					};
				}
			}
			class Xe$1 {
				constructor(e$1, t$1, i$1, o$1) {
					this.opacity = e$1 ? Math.max(0, Math.min(1, e$1.opacity + (e$1.placed ? t$1 : -t$1))) : o$1 && i$1 ? 1 : 0, this.placed = i$1;
				}
				isHidden() {
					return 0 === this.opacity && !this.placed;
				}
			}
			class Ke$1 {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.text = new Xe$1(e$1 ? e$1.text : null, t$1, i$1, r$1), this.icon = new Xe$1(e$1 ? e$1.icon : null, t$1, o$1, r$1);
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class Ye$1 {
				constructor(e$1, t$1, i$1) {
					this.text = e$1, this.icon = t$1, this.skipFade = i$1;
				}
			}
			class Qe$1 {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.bucketInstanceId = e$1, this.featureIndex = t$1, this.sourceLayerIndex = i$1, this.bucketIndex = o$1, this.tileID = r$1;
				}
			}
			class Je$1 {
				constructor(e$1) {
					this.crossSourceCollisions = e$1, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e$1) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e$1]) {
						const t$1 = ++this.maxGroupID;
						this.collisionGroups[e$1] = {
							ID: t$1,
							predicate: (e$2) => e$2.collisionGroupID === t$1
						};
					}
					return this.collisionGroups[e$1];
				}
			}
			function et$1(e$1, i$1, o$1, r$1, a$1) {
				const { horizontalAlign: s$1, verticalAlign: n$1 } = t.aH(e$1);
				return new t.P(-(s$1 - .5) * i$1 + r$1[0] * a$1, -(n$1 - .5) * o$1 + r$1[1] * a$1);
			}
			class tt$1 {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.transform = e$1.clone(), this.terrain = t$1, this.collisionIndex = new He$1(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i$1, this.retainedQueryData = {}, this.collisionGroups = new Je$1(o$1), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = r$1, r$1 && (r$1.prevPlacement = void 0), this.placedOrientations = {};
				}
				_getTerrainElevationFunc(e$1) {
					const t$1 = this.terrain;
					return t$1 ? (i$1, o$1) => t$1.getElevation(e$1, i$1, o$1) : null;
				}
				getBucketParts(e$1, i$1, o$1, r$1) {
					const a$1 = o$1.getBucket(i$1), s$1 = o$1.latestFeatureIndex;
					if (!a$1 || !s$1 || i$1.id !== a$1.layerIds[0]) return;
					const n$1 = o$1.collisionBoxArray, l$1 = a$1.layers[0].layout, c$1 = a$1.layers[0].paint, h$1 = Math.pow(2, this.transform.zoom - o$1.tileID.overscaledZ), u$1 = o$1.tileSize / t.$, d$1 = o$1.tileID.toUnwrapped(), _$2 = "map" === l$1.get("text-rotation-alignment"), p$1 = t.aC(o$1, 1, this.transform.zoom), m$1 = t.aD(this.collisionIndex.transform, o$1, c$1.get("text-translate"), c$1.get("text-translate-anchor")), f$1 = t.aD(this.collisionIndex.transform, o$1, c$1.get("icon-translate"), c$1.get("icon-translate-anchor")), g$2 = Ie$1(_$2, this.transform, p$1);
					this.retainedQueryData[a$1.bucketInstanceId] = new Qe$1(a$1.bucketInstanceId, s$1, a$1.sourceLayerIndex, a$1.index, o$1.tileID);
					const v$1 = {
						bucket: a$1,
						layout: l$1,
						translationText: m$1,
						translationIcon: f$1,
						unwrappedTileID: d$1,
						pitchedLabelPlaneMatrix: g$2,
						scale: h$1,
						textPixelRatio: u$1,
						holdingForFade: o$1.holdingForFade(),
						collisionBoxArray: n$1,
						partiallyEvaluatedTextSize: t.an(a$1.textSizeData, this.transform.zoom),
						collisionGroup: this.collisionGroups.get(a$1.sourceID)
					};
					if (r$1) for (const t$1 of a$1.sortKeyRanges) {
						const { sortKey: i$2, symbolInstanceStart: o$2, symbolInstanceEnd: r$2 } = t$1;
						e$1.push({
							sortKey: i$2,
							symbolInstanceStart: o$2,
							symbolInstanceEnd: r$2,
							parameters: v$1
						});
					}
					else e$1.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: a$1.symbolInstances.length,
						parameters: v$1
					});
				}
				attemptAnchorPlacement(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1, m$1, f$1, g$2, v$1, b$2, x$1) {
					const y$1 = t.aE[e$1.textAnchor], w$1 = [e$1.textOffset0, e$1.textOffset1], T$2 = et$1(y$1, o$1, r$1, w$1, a$1), P$2 = this.collisionIndex.placeCollisionBox(i$1, d$1, l$1, c$1, h$1, n$1, s$1, f$1, u$1.predicate, b$2, T$2, x$1);
					if ((!v$1 || this.collisionIndex.placeCollisionBox(v$1, d$1, l$1, c$1, h$1, n$1, s$1, g$2, u$1.predicate, b$2, T$2, x$1).placeable) && P$2.placeable) {
						let e$2;
						if (this.prevPlacement && this.prevPlacement.variableOffsets[_$2.crossTileID] && this.prevPlacement.placements[_$2.crossTileID] && this.prevPlacement.placements[_$2.crossTileID].text && (e$2 = this.prevPlacement.variableOffsets[_$2.crossTileID].anchor), 0 === _$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						return this.variableOffsets[_$2.crossTileID] = {
							textOffset: w$1,
							width: o$1,
							height: r$1,
							anchor: y$1,
							textBoxScale: a$1,
							prevAnchor: e$2
						}, this.markUsedJustification(p$1, y$1, _$2, m$1), p$1.allowVerticalPlacement && (this.markUsedOrientation(p$1, m$1, _$2), this.placedOrientations[_$2.crossTileID] = m$1), {
							shift: T$2,
							placedGlyphBoxes: P$2
						};
					}
				}
				placeLayerBucketPart(e$1, i$1, o$1) {
					const { bucket: r$1, layout: a$1, translationText: s$1, translationIcon: n$1, unwrappedTileID: l$1, pitchedLabelPlaneMatrix: c$1, textPixelRatio: h$1, holdingForFade: u$1, collisionBoxArray: d$1, partiallyEvaluatedTextSize: _$2, collisionGroup: p$1 } = e$1.parameters, m$1 = a$1.get("text-optional"), f$1 = a$1.get("icon-optional"), g$2 = t.aF(a$1, "text-overlap", "text-allow-overlap"), v$1 = "always" === g$2, b$2 = t.aF(a$1, "icon-overlap", "icon-allow-overlap"), x$1 = "always" === b$2, y$1 = "map" === a$1.get("text-rotation-alignment"), w$1 = "map" === a$1.get("text-pitch-alignment"), T$2 = "none" !== a$1.get("icon-text-fit"), P$2 = "viewport-y" === a$1.get("symbol-z-order"), C$1 = v$1 && (x$1 || !r$1.hasIconData() || f$1), I$2 = x$1 && (v$1 || !r$1.hasTextData() || m$1);
					!r$1.collisionArrays && d$1 && r$1.deserializeCollisionBoxes(d$1);
					const M$2 = this.retainedQueryData[r$1.bucketInstanceId].tileID, S$2 = this._getTerrainElevationFunc(M$2), E$1 = this.transform.getFastPathSimpleProjectionMatrix(M$2), R$3 = (e$2, d$2, x$2) => {
						var P$3, R$4;
						if (i$1[e$2.crossTileID]) return;
						if (u$1) return void (this.placements[e$2.crossTileID] = new Ye$1(!1, !1, !1));
						let z$2 = !1, D$2 = !1, A$1 = !0, L$2 = null, k$2 = {
							box: null,
							placeable: !1,
							offscreen: null,
							occluded: !1
						}, F$2 = { placeable: !1 }, B$2 = null, O$2 = null, j$2 = null, N$1 = 0, U$2 = 0, Z$2 = 0;
						d$2.textFeatureIndex ? N$1 = d$2.textFeatureIndex : e$2.useRuntimeCollisionCircles && (N$1 = e$2.featureIndex), d$2.verticalTextFeatureIndex && (U$2 = d$2.verticalTextFeatureIndex);
						const G$2 = d$2.textBox;
						if (G$2) {
							const i$2 = (i$3) => {
								let o$2 = t.ao.horizontal;
								if (r$1.allowVerticalPlacement && !i$3 && this.prevPlacement) {
									const t$1 = this.prevPlacement.placedOrientations[e$2.crossTileID];
									t$1 && (this.placedOrientations[e$2.crossTileID] = t$1, o$2 = t$1, this.markUsedOrientation(r$1, o$2, e$2));
								}
								return o$2;
							}, a$2 = (i$3, o$2) => {
								if (r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && d$2.verticalTextBox) {
									for (const e$3 of r$1.writingModes) if (e$3 === t.ao.vertical ? (k$2 = o$2(), F$2 = k$2) : k$2 = i$3(), k$2 && k$2.placeable) break;
								} else k$2 = i$3();
							}, c$2 = e$2.textAnchorOffsetStartIndex, u$2 = e$2.textAnchorOffsetEndIndex;
							if (u$2 === c$2) {
								const o$2 = (t$1, i$3) => {
									const o$3 = this.collisionIndex.placeCollisionBox(t$1, g$2, h$1, M$2, l$1, w$1, y$1, s$1, p$1.predicate, S$2, void 0, E$1);
									return o$3 && o$3.placeable && (this.markUsedOrientation(r$1, i$3, e$2), this.placedOrientations[e$2.crossTileID] = i$3), o$3;
								};
								a$2((() => o$2(G$2, t.ao.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && i$3 ? o$2(i$3, t.ao.vertical) : {
										box: null,
										offscreen: null
									};
								})), i$2(k$2 && k$2.placeable);
							} else {
								let _$3 = t.aE[null === (R$4 = null === (P$3 = this.prevPlacement) || void 0 === P$3 ? void 0 : P$3.variableOffsets[e$2.crossTileID]) || void 0 === R$4 ? void 0 : R$4.anchor];
								const m$2 = (t$1, i$3, a$3) => {
									const d$3 = t$1.x2 - t$1.x1, m$3 = t$1.y2 - t$1.y1, f$3 = e$2.textBoxScale, v$2 = T$2 && "never" === b$2 ? i$3 : null;
									let x$3 = null, P$4 = "never" === g$2 ? 1 : 2, C$2 = "never";
									_$3 && P$4++;
									for (let i$4 = 0; i$4 < P$4; i$4++) {
										for (let i$5 = c$2; i$5 < u$2; i$5++) {
											const o$2 = r$1.textAnchorOffsets.get(i$5);
											if (_$3 && o$2.textAnchor !== _$3) continue;
											const c$3 = this.attemptAnchorPlacement(o$2, t$1, d$3, m$3, f$3, y$1, w$1, h$1, M$2, l$1, p$1, C$2, e$2, r$1, a$3, s$1, n$1, v$2, S$2);
											if (c$3 && (x$3 = c$3.placedGlyphBoxes, x$3 && x$3.placeable)) return z$2 = !0, L$2 = c$3.shift, x$3;
										}
										_$3 ? _$3 = null : C$2 = g$2;
									}
									return o$1 && !x$3 && (x$3 = {
										box: this.collisionIndex.placeCollisionBox(G$2, "always", h$1, M$2, l$1, w$1, y$1, s$1, p$1.predicate, S$2, void 0, E$1).box,
										offscreen: !1,
										placeable: !1,
										occluded: !1
									}), x$3;
								};
								a$2((() => m$2(G$2, d$2.iconBox, t.ao.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && (!k$2 || !k$2.placeable) && e$2.numVerticalGlyphVertices > 0 && i$3 ? m$2(i$3, d$2.verticalIconBox, t.ao.vertical) : {
										box: null,
										occluded: !0,
										offscreen: null
									};
								})), k$2 && (z$2 = k$2.placeable, A$1 = k$2.offscreen);
								const f$2 = i$2(k$2 && k$2.placeable);
								if (!z$2 && this.prevPlacement) {
									const t$1 = this.prevPlacement.variableOffsets[e$2.crossTileID];
									t$1 && (this.variableOffsets[e$2.crossTileID] = t$1, this.markUsedJustification(r$1, t$1.anchor, e$2, f$2));
								}
							}
						}
						if (B$2 = k$2, z$2 = B$2 && B$2.placeable, A$1 = B$2 && B$2.offscreen, e$2.useRuntimeCollisionCircles) {
							const i$2 = r$1.text.placedSymbolArray.get(e$2.centerJustifiedTextSymbolIndex), n$2 = t.ap(r$1.textSizeData, _$2, i$2), h$2 = a$1.get("text-padding");
							O$2 = this.collisionIndex.placeCollisionCircles(g$2, i$2, r$1.lineVertexArray, r$1.glyphOffsetArray, n$2, l$1, c$1, o$1, w$1, p$1.predicate, e$2.collisionCircleDiameter, h$2, s$1, S$2), O$2.circles.length && O$2.collisionDetected && !o$1 && t.w("Collisions detected, but collision boxes are not shown"), z$2 = v$1 || O$2.circles.length > 0 && !O$2.collisionDetected, A$1 = A$1 && O$2.offscreen;
						}
						if (d$2.iconFeatureIndex && (Z$2 = d$2.iconFeatureIndex), d$2.iconBox) {
							const e$3 = (e$4) => this.collisionIndex.placeCollisionBox(e$4, b$2, h$1, M$2, l$1, w$1, y$1, n$1, p$1.predicate, S$2, T$2 && L$2 ? L$2 : void 0, E$1);
							F$2 && F$2.placeable && d$2.verticalIconBox ? (j$2 = e$3(d$2.verticalIconBox), D$2 = j$2.placeable) : (j$2 = e$3(d$2.iconBox), D$2 = j$2.placeable), A$1 = A$1 && j$2.offscreen;
						}
						const V$1 = m$1 || 0 === e$2.numHorizontalGlyphVertices && 0 === e$2.numVerticalGlyphVertices, $$2 = f$1 || 0 === e$2.numIconVertices;
						V$1 || $$2 ? $$2 ? V$1 || (D$2 = D$2 && z$2) : z$2 = D$2 && z$2 : D$2 = z$2 = D$2 && z$2;
						const q$2 = D$2 && j$2.placeable;
						if (z$2 && B$2.placeable && this.collisionIndex.insertCollisionBox(B$2.box, g$2, a$1.get("text-ignore-placement"), r$1.bucketInstanceId, F$2 && F$2.placeable && U$2 ? U$2 : N$1, p$1.ID), q$2 && this.collisionIndex.insertCollisionBox(j$2.box, b$2, a$1.get("icon-ignore-placement"), r$1.bucketInstanceId, Z$2, p$1.ID), O$2 && z$2 && this.collisionIndex.insertCollisionCircles(O$2.circles, g$2, a$1.get("text-ignore-placement"), r$1.bucketInstanceId, N$1, p$1.ID), o$1 && this.storeCollisionData(r$1.bucketInstanceId, x$2, d$2, B$2, j$2, O$2), 0 === e$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						if (0 === r$1.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
						this.placements[e$2.crossTileID] = new Ye$1((z$2 || C$1) && !(null == B$2 ? void 0 : B$2.occluded), (D$2 || I$2) && !(null == j$2 ? void 0 : j$2.occluded), A$1 || r$1.justReloaded), i$1[e$2.crossTileID] = !0;
					};
					if (P$2) {
						if (0 !== e$1.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
						const t$1 = r$1.getSortedSymbolIndexes(-this.transform.bearingInRadians);
						for (let e$2 = t$1.length - 1; e$2 >= 0; --e$2) {
							const i$2 = t$1[e$2];
							R$3(r$1.symbolInstances.get(i$2), r$1.collisionArrays[i$2], i$2);
						}
					} else for (let t$1 = e$1.symbolInstanceStart; t$1 < e$1.symbolInstanceEnd; t$1++) R$3(r$1.symbolInstances.get(t$1), r$1.collisionArrays[t$1], t$1);
					r$1.justReloaded = !1;
				}
				storeCollisionData(e$1, t$1, i$1, o$1, r$1, a$1) {
					if (i$1.textBox || i$1.iconBox) {
						let a$2, s$1;
						this.collisionBoxArrays.has(e$1) ? a$2 = this.collisionBoxArrays.get(e$1) : (a$2 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e$1, a$2)), a$2.has(t$1) ? s$1 = a$2.get(t$1) : (s$1 = {
							text: null,
							icon: null
						}, a$2.set(t$1, s$1)), i$1.textBox && (s$1.text = o$1.box), i$1.iconBox && (s$1.icon = r$1.box);
					}
					if (a$1) {
						let t$2 = this.collisionCircleArrays[e$1];
						void 0 === t$2 && (t$2 = this.collisionCircleArrays[e$1] = []);
						for (let e$2 = 0; e$2 < a$1.circles.length; e$2 += 4) t$2.push(a$1.circles[e$2 + 0] - We$1), t$2.push(a$1.circles[e$2 + 1] - We$1), t$2.push(a$1.circles[e$2 + 2]), t$2.push(a$1.collisionDetected ? 1 : 0);
					}
				}
				markUsedJustification(e$1, i$1, o$1, r$1) {
					let a$1;
					a$1 = r$1 === t.ao.vertical ? o$1.verticalPlacedTextSymbolIndex : {
						left: o$1.leftJustifiedTextSymbolIndex,
						center: o$1.centerJustifiedTextSymbolIndex,
						right: o$1.rightJustifiedTextSymbolIndex
					}[t.aG(i$1)];
					const s$1 = [
						o$1.leftJustifiedTextSymbolIndex,
						o$1.centerJustifiedTextSymbolIndex,
						o$1.rightJustifiedTextSymbolIndex,
						o$1.verticalPlacedTextSymbolIndex
					];
					for (const t$1 of s$1) t$1 >= 0 && (e$1.text.placedSymbolArray.get(t$1).crossTileID = a$1 >= 0 && t$1 !== a$1 ? 0 : o$1.crossTileID);
				}
				markUsedOrientation(e$1, i$1, o$1) {
					const r$1 = i$1 === t.ao.horizontal || i$1 === t.ao.horizontalOnly ? i$1 : 0, a$1 = i$1 === t.ao.vertical ? i$1 : 0, s$1 = [
						o$1.leftJustifiedTextSymbolIndex,
						o$1.centerJustifiedTextSymbolIndex,
						o$1.rightJustifiedTextSymbolIndex
					];
					for (const t$1 of s$1) e$1.text.placedSymbolArray.get(t$1).placedOrientation = r$1;
					o$1.verticalPlacedTextSymbolIndex && (e$1.text.placedSymbolArray.get(o$1.verticalPlacedTextSymbolIndex).placedOrientation = a$1);
				}
				commit(e$1) {
					this.commitTime = e$1, this.zoomAtLastRecencyCheck = this.transform.zoom;
					const t$1 = this.prevPlacement;
					let i$1 = !1;
					this.prevZoomAdjustment = t$1 ? t$1.zoomAdjustment(this.transform.zoom) : 0;
					const o$1 = t$1 ? t$1.symbolFadeChange(e$1) : 1, r$1 = t$1 ? t$1.opacities : {}, a$1 = t$1 ? t$1.variableOffsets : {}, s$1 = t$1 ? t$1.placedOrientations : {};
					for (const e$2 in this.placements) {
						const t$2 = this.placements[e$2], a$2 = r$1[e$2];
						a$2 ? (this.opacities[e$2] = new Ke$1(a$2, o$1, t$2.text, t$2.icon), i$1 = i$1 || t$2.text !== a$2.text.placed || t$2.icon !== a$2.icon.placed) : (this.opacities[e$2] = new Ke$1(null, o$1, t$2.text, t$2.icon, t$2.skipFade), i$1 = i$1 || t$2.text || t$2.icon);
					}
					for (const e$2 in r$1) {
						const t$2 = r$1[e$2];
						if (!this.opacities[e$2]) {
							const r$2 = new Ke$1(t$2, o$1, !1, !1);
							r$2.isHidden() || (this.opacities[e$2] = r$2, i$1 = i$1 || t$2.text.placed || t$2.icon.placed);
						}
					}
					for (const e$2 in a$1) this.variableOffsets[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.variableOffsets[e$2] = a$1[e$2]);
					for (const e$2 in s$1) this.placedOrientations[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.placedOrientations[e$2] = s$1[e$2]);
					if (t$1 && void 0 === t$1.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
					i$1 ? this.lastPlacementChangeTime = e$1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t$1 ? t$1.lastPlacementChangeTime : e$1);
				}
				updateLayerOpacities(e$1, t$1) {
					const i$1 = {};
					for (const o$1 of t$1) {
						const t$2 = o$1.getBucket(e$1);
						t$2 && o$1.latestFeatureIndex && e$1.id === t$2.layerIds[0] && this.updateBucketOpacities(t$2, o$1.tileID, i$1, o$1.collisionBoxArray);
					}
				}
				updateBucketOpacities(e$1, i$1, o$1, r$1) {
					e$1.hasTextData() && (e$1.text.opacityVertexArray.clear(), e$1.text.hasVisibleVertices = !1), e$1.hasIconData() && (e$1.icon.opacityVertexArray.clear(), e$1.icon.hasVisibleVertices = !1), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexArray.clear(), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexArray.clear();
					const a$1 = e$1.layers[0], s$1 = a$1.layout, n$1 = new Ke$1(null, 0, !1, !1, !0), l$1 = s$1.get("text-allow-overlap"), c$1 = s$1.get("icon-allow-overlap"), h$1 = a$1._unevaluatedLayout.hasValue("text-variable-anchor") || a$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u$1 = "map" === s$1.get("text-rotation-alignment"), d$1 = "map" === s$1.get("text-pitch-alignment"), _$2 = "none" !== s$1.get("icon-text-fit"), p$1 = new Ke$1(null, 0, l$1 && (c$1 || !e$1.hasIconData() || s$1.get("icon-optional")), c$1 && (l$1 || !e$1.hasTextData() || s$1.get("text-optional")), !0);
					!e$1.collisionArrays && r$1 && (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) && e$1.deserializeCollisionBoxes(r$1);
					const m$1 = (e$2, t$1, i$2) => {
						for (let o$2 = 0; o$2 < t$1 / 4; o$2++) e$2.opacityVertexArray.emplaceBack(i$2);
						e$2.hasVisibleVertices = e$2.hasVisibleVertices || i$2 !== ut$1;
					}, f$1 = this.collisionBoxArrays.get(e$1.bucketInstanceId);
					for (let i$2 = 0; i$2 < e$1.symbolInstances.length; i$2++) {
						const r$2 = e$1.symbolInstances.get(i$2), { numHorizontalGlyphVertices: a$2, numVerticalGlyphVertices: s$2, crossTileID: l$2 } = r$2;
						let c$2 = this.opacities[l$2];
						o$1[l$2] ? c$2 = n$1 : c$2 || (c$2 = p$1, this.opacities[l$2] = c$2), o$1[l$2] = !0;
						const g$2 = r$2.numIconVertices > 0, v$1 = this.placedOrientations[r$2.crossTileID], b$2 = v$1 === t.ao.vertical, x$1 = v$1 === t.ao.horizontal || v$1 === t.ao.horizontalOnly;
						if (a$2 > 0 || s$2 > 0) {
							const t$1 = ht(c$2.text);
							m$1(e$1.text, a$2, b$2 ? ut$1 : t$1), m$1(e$1.text, s$2, x$1 ? ut$1 : t$1);
							const i$3 = c$2.text.isHidden();
							[
								r$2.rightJustifiedTextSymbolIndex,
								r$2.centerJustifiedTextSymbolIndex,
								r$2.leftJustifiedTextSymbolIndex
							].forEach(((t$2) => {
								t$2 >= 0 && (e$1.text.placedSymbolArray.get(t$2).hidden = i$3 || b$2 ? 1 : 0);
							})), r$2.verticalPlacedTextSymbolIndex >= 0 && (e$1.text.placedSymbolArray.get(r$2.verticalPlacedTextSymbolIndex).hidden = i$3 || x$1 ? 1 : 0);
							const o$2 = this.variableOffsets[r$2.crossTileID];
							o$2 && this.markUsedJustification(e$1, o$2.anchor, r$2, v$1);
							const n$2 = this.placedOrientations[r$2.crossTileID];
							n$2 && (this.markUsedJustification(e$1, "left", r$2, n$2), this.markUsedOrientation(e$1, n$2, r$2));
						}
						if (g$2) {
							const t$1 = ht(c$2.icon), i$3 = !(_$2 && r$2.verticalPlacedIconSymbolIndex && b$2);
							r$2.placedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numIconVertices, i$3 ? t$1 : ut$1), e$1.icon.placedSymbolArray.get(r$2.placedIconSymbolIndex).hidden = c$2.icon.isHidden()), r$2.verticalPlacedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numVerticalIconVertices, i$3 ? ut$1 : t$1), e$1.icon.placedSymbolArray.get(r$2.verticalPlacedIconSymbolIndex).hidden = c$2.icon.isHidden());
						}
						const y$1 = f$1 && f$1.has(i$2) ? f$1.get(i$2) : {
							text: null,
							icon: null
						};
						if (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) {
							const o$2 = e$1.collisionArrays[i$2];
							if (o$2) {
								let i$3 = new t.P(0, 0);
								if (o$2.textBox || o$2.verticalTextBox) {
									let t$1 = !0;
									if (h$1) {
										const e$2 = this.variableOffsets[l$2];
										e$2 ? (i$3 = et$1(e$2.anchor, e$2.width, e$2.height, e$2.textOffset, e$2.textBoxScale), u$1 && i$3._rotate(d$1 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t$1 = !1;
									}
									if (o$2.textBox || o$2.verticalTextBox) {
										let r$3;
										o$2.textBox && (r$3 = b$2), o$2.verticalTextBox && (r$3 = x$1), it$1(e$1.textCollisionBox.collisionVertexArray, c$2.text.placed, !t$1 || r$3, y$1.text, i$3.x, i$3.y);
									}
								}
								if (o$2.iconBox || o$2.verticalIconBox) {
									const t$1 = Boolean(!x$1 && o$2.verticalIconBox);
									let r$3;
									o$2.iconBox && (r$3 = t$1), o$2.verticalIconBox && (r$3 = !t$1), it$1(e$1.iconCollisionBox.collisionVertexArray, c$2.icon.placed, r$3, y$1.icon, _$2 ? i$3.x : 0, _$2 ? i$3.y : 0);
								}
							}
						}
					}
					if (e$1.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e$1.bucketInstanceId] && (this.retainedQueryData[e$1.bucketInstanceId].featureSortOrder = e$1.featureSortOrder), e$1.hasTextData() && e$1.text.opacityVertexBuffer && e$1.text.opacityVertexBuffer.updateData(e$1.text.opacityVertexArray), e$1.hasIconData() && e$1.icon.opacityVertexBuffer && e$1.icon.opacityVertexBuffer.updateData(e$1.icon.opacityVertexArray), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexBuffer && e$1.iconCollisionBox.collisionVertexBuffer.updateData(e$1.iconCollisionBox.collisionVertexArray), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexBuffer && e$1.textCollisionBox.collisionVertexBuffer.updateData(e$1.textCollisionBox.collisionVertexArray), e$1.text.opacityVertexArray.length !== e$1.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e$1.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e$1.text.layoutVertexArray.length}) / 4`);
					if (e$1.icon.opacityVertexArray.length !== e$1.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e$1.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e$1.icon.layoutVertexArray.length}) / 4`);
					e$1.bucketInstanceId in this.collisionCircleArrays && (e$1.collisionCircleArray = this.collisionCircleArrays[e$1.bucketInstanceId], delete this.collisionCircleArrays[e$1.bucketInstanceId]);
				}
				symbolFadeChange(e$1) {
					return 0 === this.fadeDuration ? 1 : (e$1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e$1) {
					return Math.max(0, (this.transform.zoom - e$1) / 1.5);
				}
				hasTransitions(e$1) {
					return this.stale || e$1 - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e$1, t$1) {
					const i$1 = this.zoomAtLastRecencyCheck === t$1 ? 1 - this.zoomAdjustment(t$1) : 1;
					return this.zoomAtLastRecencyCheck = t$1, this.commitTime + this.fadeDuration * i$1 > e$1;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function it$1(e$1, t$1, i$1, o$1, r$1, a$1) {
				o$1 && 0 !== o$1.length || (o$1 = [
					0,
					0,
					0,
					0
				]);
				const s$1 = o$1[0] - We$1, n$1 = o$1[1] - We$1, l$1 = o$1[2] - We$1, c$1 = o$1[3] - We$1;
				e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, s$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, l$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, l$1, c$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, s$1, c$1);
			}
			const ot$1 = Math.pow(2, 25), rt$1 = Math.pow(2, 24), at$2 = Math.pow(2, 17), st$1 = Math.pow(2, 16), nt$1 = Math.pow(2, 9), lt$1 = Math.pow(2, 8), ct = Math.pow(2, 1);
			function ht(e$1) {
				if (0 === e$1.opacity && !e$1.placed) return 0;
				if (1 === e$1.opacity && e$1.placed) return 4294967295;
				const t$1 = e$1.placed ? 1 : 0, i$1 = Math.floor(127 * e$1.opacity);
				return i$1 * ot$1 + t$1 * rt$1 + i$1 * at$2 + t$1 * st$1 + i$1 * nt$1 + t$1 * lt$1 + i$1 * ct + t$1;
			}
			const ut$1 = 0;
			class dt$1 {
				constructor(e$1) {
					this._sortAcrossTiles = "viewport-y" !== e$1.layout.get("symbol-z-order") && !e$1.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
				}
				continuePlacement(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = this._bucketParts;
					for (; this._currentTileIndex < e$1.length;) if (t$1.getBucketParts(a$1, o$1, e$1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r$1()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a$1.sort(((e$2, t$2) => e$2.sortKey - t$2.sortKey))); this._currentPartIndex < a$1.length;) if (t$1.placeLayerBucketPart(a$1[this._currentPartIndex], this._seenCrossTileIDs, i$1), this._currentPartIndex++, r$1()) return !0;
					return !1;
				}
			}
			class _t$1 {
				constructor(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					this.placement = new tt$1(e$1, t$1, a$1, s$1, n$1), this._currentPlacementIndex = i$1.length - 1, this._forceFullPlacement = o$1, this._showCollisionBoxes = r$1, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(e$1, t$1, i$1) {
					const o$1 = s.now(), r$1 = () => !this._forceFullPlacement && s.now() - o$1 > 2;
					for (; this._currentPlacementIndex >= 0;) {
						const o$2 = t$1[e$1[this._currentPlacementIndex]], a$1 = this.placement.collisionIndex.transform.zoom;
						if ("symbol" === o$2.type && (!o$2.minzoom || o$2.minzoom <= a$1) && (!o$2.maxzoom || o$2.maxzoom > a$1)) {
							if (this._inProgressLayer || (this._inProgressLayer = new dt$1(o$2)), this._inProgressLayer.continuePlacement(i$1[o$2.source], this.placement, this._showCollisionBoxes, o$2, r$1)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e$1) {
					return this.placement.commit(e$1), this.placement;
				}
			}
			const pt$1 = 512 / t.$ / 2;
			class mt$1 {
				constructor(e$1, i$1, o$1) {
					this.tileID = e$1, this.bucketInstanceId = o$1, this._symbolsByKey = {};
					const r$1 = /* @__PURE__ */ new Map();
					for (let e$2 = 0; e$2 < i$1.length; e$2++) {
						const t$1 = i$1.get(e$2), o$2 = t$1.key, a$1 = r$1.get(o$2);
						a$1 ? a$1.push(t$1) : r$1.set(o$2, [t$1]);
					}
					for (const [e$2, i$2] of r$1) {
						const o$2 = {
							positions: i$2.map(((e$3) => ({
								x: Math.floor(e$3.anchorX * pt$1),
								y: Math.floor(e$3.anchorY * pt$1)
							}))),
							crossTileIDs: i$2.map(((e$3) => e$3.crossTileID))
						};
						if (o$2.positions.length > 128) {
							const e$3 = new t.aI(o$2.positions.length, 16, Uint16Array);
							for (const { x: t$1, y: i$3 } of o$2.positions) e$3.add(t$1, i$3);
							e$3.finish(), delete o$2.positions, o$2.index = e$3;
						}
						this._symbolsByKey[e$2] = o$2;
					}
				}
				getScaledCoordinates(e$1, i$1) {
					const { x: o$1, y: r$1, z: a$1 } = this.tileID.canonical, { x: s$1, y: n$1, z: l$1 } = i$1.canonical, c$1 = pt$1 / Math.pow(2, l$1 - a$1), h$1 = (n$1 * t.$ + e$1.anchorY) * c$1, u$1 = r$1 * t.$ * pt$1;
					return {
						x: Math.floor((s$1 * t.$ + e$1.anchorX) * c$1 - o$1 * t.$ * pt$1),
						y: Math.floor(h$1 - u$1)
					};
				}
				findMatches(e$1, t$1, i$1) {
					const o$1 = this.tileID.canonical.z < t$1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t$1.canonical.z);
					for (let r$1 = 0; r$1 < e$1.length; r$1++) {
						const a$1 = e$1.get(r$1);
						if (a$1.crossTileID) continue;
						const s$1 = this._symbolsByKey[a$1.key];
						if (!s$1) continue;
						const n$1 = this.getScaledCoordinates(a$1, t$1);
						if (s$1.index) {
							const e$2 = s$1.index.range(n$1.x - o$1, n$1.y - o$1, n$1.x + o$1, n$1.y + o$1).sort();
							for (const t$2 of e$2) {
								const e$3 = s$1.crossTileIDs[t$2];
								if (!i$1[e$3]) {
									i$1[e$3] = !0, a$1.crossTileID = e$3;
									break;
								}
							}
						} else if (s$1.positions) for (let e$2 = 0; e$2 < s$1.positions.length; e$2++) {
							const t$2 = s$1.positions[e$2], r$2 = s$1.crossTileIDs[e$2];
							if (Math.abs(t$2.x - n$1.x) <= o$1 && Math.abs(t$2.y - n$1.y) <= o$1 && !i$1[r$2]) {
								i$1[r$2] = !0, a$1.crossTileID = r$2;
								break;
							}
						}
					}
				}
				getCrossTileIDsLists() {
					return Object.values(this._symbolsByKey).map((({ crossTileIDs: e$1 }) => e$1));
				}
			}
			class ft$1 {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class gt$1 {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - this.lng) / 360);
					if (0 !== t$1) for (const e$2 in this.indexes) {
						const i$1 = this.indexes[e$2], o$1 = {};
						for (const e$3 in i$1) {
							const r$1 = i$1[e$3];
							r$1.tileID = r$1.tileID.unwrapTo(r$1.tileID.wrap + t$1), o$1[r$1.tileID.key] = r$1;
						}
						this.indexes[e$2] = o$1;
					}
					this.lng = e$1;
				}
				addBucket(e$1, t$1, i$1) {
					if (this.indexes[e$1.overscaledZ] && this.indexes[e$1.overscaledZ][e$1.key]) {
						if (this.indexes[e$1.overscaledZ][e$1.key].bucketInstanceId === t$1.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e$1.overscaledZ, this.indexes[e$1.overscaledZ][e$1.key]);
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) t$1.symbolInstances.get(e$2).crossTileID = 0;
					this.usedCrossTileIDs[e$1.overscaledZ] || (this.usedCrossTileIDs[e$1.overscaledZ] = {});
					const o$1 = this.usedCrossTileIDs[e$1.overscaledZ];
					for (const i$2 in this.indexes) {
						const r$1 = this.indexes[i$2];
						if (Number(i$2) > e$1.overscaledZ) for (const i$3 in r$1) {
							const a$1 = r$1[i$3];
							a$1.tileID.isChildOf(e$1) && a$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
						else {
							const a$1 = r$1[e$1.scaledTo(Number(i$2)).key];
							a$1 && a$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) {
						const r$1 = t$1.symbolInstances.get(e$2);
						r$1.crossTileID || (r$1.crossTileID = i$1.generate(), o$1[r$1.crossTileID] = !0);
					}
					return void 0 === this.indexes[e$1.overscaledZ] && (this.indexes[e$1.overscaledZ] = {}), this.indexes[e$1.overscaledZ][e$1.key] = new mt$1(e$1, t$1.symbolInstances, t$1.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e$1, t$1) {
					for (const i$1 of t$1.getCrossTileIDsLists()) for (const t$2 of i$1) delete this.usedCrossTileIDs[e$1][t$2];
				}
				removeStaleBuckets(e$1) {
					let t$1 = !1;
					for (const i$1 in this.indexes) {
						const o$1 = this.indexes[i$1];
						for (const r$1 in o$1) e$1[o$1[r$1].bucketInstanceId] || (this.removeBucketCrossTileIDs(i$1, o$1[r$1]), delete o$1[r$1], t$1 = !0);
					}
					return t$1;
				}
			}
			class vt$1 {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new ft$1(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e$1, t$1, i$1) {
					let o$1 = this.layerIndexes[e$1.id];
					void 0 === o$1 && (o$1 = this.layerIndexes[e$1.id] = new gt$1());
					let r$1 = !1;
					const a$1 = {};
					o$1.handleWrapJump(i$1);
					for (const i$2 of t$1) {
						const t$2 = i$2.getBucket(e$1);
						t$2 && e$1.id === t$2.layerIds[0] && (t$2.bucketInstanceId || (t$2.bucketInstanceId = ++this.maxBucketInstanceId), o$1.addBucket(i$2.tileID, t$2, this.crossTileIDs) && (r$1 = !0), a$1[t$2.bucketInstanceId] = !0);
					}
					return o$1.removeStaleBuckets(a$1) && (r$1 = !0), r$1;
				}
				pruneUnusedLayers(e$1) {
					const t$1 = {};
					e$1.forEach(((e$2) => {
						t$1[e$2] = !0;
					}));
					for (const e$2 in this.layerIndexes) t$1[e$2] || delete this.layerIndexes[e$2];
				}
			}
			var bt$1 = "void main() {fragColor=vec4(1.0);}";
			const xt$1 = {
				prelude: yt$1("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"),
				projectionMercator: yt$1("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
				projectionGlobe: yt$1("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"),
				background: yt$1("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				backgroundPattern: yt$1("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
				circle: yt$1("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
				clippingMask: yt$1(bt$1, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				heatmap: yt$1("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"),
				heatmapTexture: yt$1("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
				collisionBox: yt$1("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: yt$1("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				colorRelief: yt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				debug: yt$1("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
				depth: yt$1(bt$1, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"),
				fill: yt$1("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"),
				fillOutline: yt$1("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillOutlinePattern: yt$1("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillPattern: yt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
				fillExtrusion: yt$1("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
				fillExtrusionPattern: yt$1("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
				hillshadePrepare: yt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: yt$1("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				line: yt$1("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				lineGradient: yt$1("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				linePattern: yt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
				lineSDF: yt$1("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),
				raster: yt$1("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				symbolIcon: yt$1("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
				symbolSDF: yt$1("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
				symbolTextAndIcon: yt$1("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
				terrain: yt$1("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
				terrainDepth: yt$1("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
				terrainCoords: yt$1("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
				projectionErrorMeasurement: yt$1("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
				atmosphere: yt$1("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
				sky: yt$1("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
			};
			function yt$1(e$1, t$1) {
				const i$1 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o$1 = t$1.match(/in ([\w]+) ([\w]+)/g), r$1 = e$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a$1 = t$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s$1 = a$1 ? a$1.concat(r$1) : r$1, n$1 = {};
				return {
					fragmentSource: e$1 = e$1.replace(i$1, ((e$2, t$2, i$2, o$2, r$2) => (n$1[r$2] = !0, "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nin ${i$2} ${o$2} ${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n`))),
					vertexSource: t$1 = t$1.replace(i$1, ((e$2, t$2, i$2, o$2, r$2) => {
						const a$2 = "float" === o$2 ? "vec2" : "vec4", s$2 = r$2.match(/color/) ? "color" : a$2;
						return n$1[r$2] ? "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${a$2} a_${r$2};\nout ${i$2} ${o$2} ${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = a_${r$2};\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${a$2} a_${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = a_${r$2};\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n`;
					})),
					staticAttributes: o$1,
					staticUniforms: s$1
				};
			}
			class wt$1 {
				constructor(e$1, t$1, i$1) {
					this.vertexBuffer = e$1, this.indexBuffer = t$1, this.segments = i$1;
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
				}
			}
			var Tt$1 = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			const Pt$1 = "#define PROJECTION_MERCATOR", Ct$1 = "mercator";
			class It$1 {
				constructor() {
					this._cachedMesh = null;
				}
				get name() {
					return "mercator";
				}
				get useSubdivision() {
					return !1;
				}
				get shaderVariantName() {
					return Ct$1;
				}
				get shaderDefine() {
					return Pt$1;
				}
				get shaderPreludeCode() {
					return xt$1.projectionMercator;
				}
				get vertexShaderPreludeCode() {
					return xt$1.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return t.aK.noSubdivision;
				}
				get useGlobeControls() {
					return !1;
				}
				get transitionState() {
					return 0;
				}
				get latitudeErrorCorrectionRadians() {
					return 0;
				}
				destroy() {}
				updateGPUdependent(e$1) {}
				getMeshFromTileID(e$1, i$1, o$1, r$1, a$1) {
					if (this._cachedMesh) return this._cachedMesh;
					const s$1 = new t.aL();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(t.$, 0), s$1.emplaceBack(0, t.$), s$1.emplaceBack(t.$, t.$);
					const n$1 = e$1.createVertexBuffer(s$1, Tt$1.members), l$1 = t.aM.simpleSegment(0, 0, 4, 2), c$1 = new t.aN();
					c$1.emplaceBack(1, 0, 2), c$1.emplaceBack(1, 2, 3);
					return this._cachedMesh = new wt$1(n$1, e$1.createIndexBuffer(c$1), l$1), this._cachedMesh;
				}
				recalculate() {}
				hasTransition() {
					return !1;
				}
				setErrorQueryLatitudeDegrees(e$1) {}
			}
			class Mt$1 {
				constructor(e$1 = 0, t$1 = 0, i$1 = 0, o$1 = 0) {
					if (isNaN(e$1) || e$1 < 0 || isNaN(t$1) || t$1 < 0 || isNaN(i$1) || i$1 < 0 || isNaN(o$1) || o$1 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e$1, this.bottom = t$1, this.left = i$1, this.right = o$1;
				}
				interpolate(e$1, i$1, o$1) {
					return null != i$1.top && null != e$1.top && (this.top = t.C.number(e$1.top, i$1.top, o$1)), null != i$1.bottom && null != e$1.bottom && (this.bottom = t.C.number(e$1.bottom, i$1.bottom, o$1)), null != i$1.left && null != e$1.left && (this.left = t.C.number(e$1.left, i$1.left, o$1)), null != i$1.right && null != e$1.right && (this.right = t.C.number(e$1.right, i$1.right, o$1)), this;
				}
				getCenter(e$1, i$1) {
					const o$1 = t.ah((this.left + e$1 - this.right) / 2, 0, e$1), r$1 = t.ah((this.top + i$1 - this.bottom) / 2, 0, i$1);
					return new t.P(o$1, r$1);
				}
				equals(e$1) {
					return this.top === e$1.top && this.bottom === e$1.bottom && this.left === e$1.left && this.right === e$1.right;
				}
				clone() {
					return new Mt$1(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			function St$1(e$1, t$1) {
				if (!e$1.renderWorldCopies || e$1.lngRange) return;
				const i$1 = t$1.lng - e$1.center.lng;
				t$1.lng += i$1 > 180 ? -360 : i$1 < -180 ? 360 : 0;
			}
			function Et$1(e$1) {
				return Math.max(0, Math.floor(e$1));
			}
			class Rt$1 {
				constructor(e$1, i$1, o$1, r$1, a$1, s$1) {
					this._callbacks = e$1, this._tileSize = 512, this._renderWorldCopies = void 0 === s$1 || !!s$1, this._minZoom = i$1 || 0, this._maxZoom = o$1 || 22, this._minPitch = null == r$1 ? 0 : r$1, this._maxPitch = null == a$1 ? 60 : a$1, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Et$1(this._zoom), this._scale = t.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Mt$1(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
				}
				apply(e$1, i$1, o$1) {
					this._latRange = e$1.latRange, this._lngRange = e$1.lngRange, this._width = e$1.width, this._height = e$1.height, this._center = e$1.center, this._elevation = e$1.elevation, this._minElevationForCurrentTile = e$1.minElevationForCurrentTile, this._zoom = e$1.zoom, this._tileZoom = Et$1(this._zoom), this._scale = t.af(this._zoom), this._bearingInRadians = e$1.bearingInRadians, this._fovInRadians = e$1.fovInRadians, this._pitchInRadians = e$1.pitchInRadians, this._rollInRadians = e$1.rollInRadians, this._unmodified = e$1.unmodified, this._edgeInsets = new Mt$1(e$1.padding.top, e$1.padding.bottom, e$1.padding.left, e$1.padding.right), this._minZoom = e$1.minZoom, this._maxZoom = e$1.maxZoom, this._minPitch = e$1.minPitch, this._maxPitch = e$1.maxPitch, this._renderWorldCopies = e$1.renderWorldCopies, this._cameraToCenterDistance = e$1.cameraToCenterDistance, this._nearZ = e$1.nearZ, this._farZ = e$1.farZ, this._autoCalculateNearFarZ = !o$1 && e$1.autoCalculateNearFarZ, i$1 && this._constrain(), this._calcMatrices();
				}
				get pixelsToClipSpaceMatrix() {
					return this._pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._clipSpaceToPixelsMatrix;
				}
				get minElevationForCurrentTile() {
					return this._minElevationForCurrentTile;
				}
				setMinElevationForCurrentTile(e$1) {
					this._minElevationForCurrentTile = e$1;
				}
				get tileSize() {
					return this._tileSize;
				}
				get tileZoom() {
					return this._tileZoom;
				}
				get scale() {
					return this._scale;
				}
				get width() {
					return this._width;
				}
				get height() {
					return this._height;
				}
				get bearingInRadians() {
					return this._bearingInRadians;
				}
				get lngRange() {
					return this._lngRange;
				}
				get latRange() {
					return this._latRange;
				}
				get pixelsToGLUnits() {
					return this._pixelsToGLUnits;
				}
				get minZoom() {
					return this._minZoom;
				}
				setMinZoom(e$1) {
					this._minZoom !== e$1 && (this._minZoom = e$1, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				setMaxZoom(e$1) {
					this._maxZoom !== e$1 && (this._maxZoom = e$1, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
				}
				get minPitch() {
					return this._minPitch;
				}
				setMinPitch(e$1) {
					this._minPitch !== e$1 && (this._minPitch = e$1, this.setPitch(Math.max(this.pitch, e$1)));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				setMaxPitch(e$1) {
					this._maxPitch !== e$1 && (this._maxPitch = e$1, this.setPitch(Math.min(this.pitch, e$1)));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					void 0 === e$1 ? e$1 = !0 : null === e$1 && (e$1 = !1), this._renderWorldCopies = e$1;
				}
				get worldSize() {
					return this._tileSize * this._scale;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new t.P(this._width, this._height);
				}
				get bearing() {
					return this._bearingInRadians / Math.PI * 180;
				}
				setBearing(e$1) {
					const i$1 = t.aO(e$1, -180, 180) * Math.PI / 180;
					var r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1;
					this._bearingInRadians !== i$1 && (this._unmodified = !1, this._bearingInRadians = i$1, this._calcMatrices(), this._rotationMatrix = o(), r$1 = this._rotationMatrix, s$1 = -this._bearingInRadians, n$1 = (a$1 = this._rotationMatrix)[0], l$1 = a$1[1], c$1 = a$1[2], h$1 = a$1[3], u$1 = Math.sin(s$1), d$1 = Math.cos(s$1), r$1[0] = n$1 * d$1 + c$1 * u$1, r$1[1] = l$1 * d$1 + h$1 * u$1, r$1[2] = n$1 * -u$1 + c$1 * d$1, r$1[3] = l$1 * -u$1 + h$1 * d$1);
				}
				get rotationMatrix() {
					return this._rotationMatrix;
				}
				get pitchInRadians() {
					return this._pitchInRadians;
				}
				get pitch() {
					return this._pitchInRadians / Math.PI * 180;
				}
				setPitch(e$1) {
					const i$1 = t.ah(e$1, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitchInRadians !== i$1 && (this._unmodified = !1, this._pitchInRadians = i$1, this._calcMatrices());
				}
				get rollInRadians() {
					return this._rollInRadians;
				}
				get roll() {
					return this._rollInRadians / Math.PI * 180;
				}
				setRoll(e$1) {
					const t$1 = e$1 / 180 * Math.PI;
					this._rollInRadians !== t$1 && (this._unmodified = !1, this._rollInRadians = t$1, this._calcMatrices());
				}
				get fovInRadians() {
					return this._fovInRadians;
				}
				get fov() {
					return t.aP(this._fovInRadians);
				}
				setFov(e$1) {
					e$1 = t.ah(e$1, .1, 150), this.fov !== e$1 && (this._unmodified = !1, this._fovInRadians = t.ae(e$1), this._calcMatrices());
				}
				get zoom() {
					return this._zoom;
				}
				setZoom(e$1) {
					const i$1 = this.getConstrained(this._center, e$1).zoom;
					this._zoom !== i$1 && (this._unmodified = !1, this._zoom = i$1, this._tileZoom = Math.max(0, Math.floor(i$1)), this._scale = t.af(i$1), this._constrain(), this._calcMatrices());
				}
				get center() {
					return this._center;
				}
				setCenter(e$1) {
					e$1.lat === this._center.lat && e$1.lng === this._center.lng || (this._unmodified = !1, this._center = e$1, this._constrain(), this._calcMatrices());
				}
				get elevation() {
					return this._elevation;
				}
				setElevation(e$1) {
					e$1 !== this._elevation && (this._elevation = e$1, this._constrain(), this._calcMatrices());
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				setPadding(e$1) {
					this._edgeInsets.equals(e$1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e$1, 1), this._calcMatrices());
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this._width, this._height);
				}
				get pixelsPerMeter() {
					return this._pixelPerMeter;
				}
				get unmodified() {
					return this._unmodified;
				}
				get cameraToCenterDistance() {
					return this._cameraToCenterDistance;
				}
				get nearZ() {
					return this._nearZ;
				}
				get farZ() {
					return this._farZ;
				}
				get autoCalculateNearFarZ() {
					return this._autoCalculateNearFarZ;
				}
				overrideNearFarZ(e$1, t$1) {
					this._autoCalculateNearFarZ = !1, this._nearZ = e$1, this._farZ = t$1, this._calcMatrices();
				}
				clearNearFarZOverride() {
					this._autoCalculateNearFarZ = !0, this._calcMatrices();
				}
				isPaddingEqual(e$1) {
					return this._edgeInsets.equals(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					this._unmodified = !1, this._edgeInsets.interpolate(e$1, t$1, i$1), this._constrain(), this._calcMatrices();
				}
				resize(e$1, t$1, i$1 = !0) {
					this._width = e$1, this._height = t$1, i$1 && this._constrain(), this._calcMatrices();
				}
				getMaxBounds() {
					return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new G$1([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
				}
				setMaxBounds(e$1) {
					e$1 ? (this._lngRange = [e$1.getWest(), e$1.getEast()], this._latRange = [e$1.getSouth(), e$1.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-t.ai, t.ai]);
				}
				getConstrained(e$1, t$1) {
					return this._callbacks.getConstrained(e$1, t$1);
				}
				getCameraQueryGeometry(e$1, i$1) {
					if (1 === i$1.length) return [i$1[0], e$1];
					{
						const { minX: o$1, minY: r$1, maxX: a$1, maxY: s$1 } = t.a2.fromPoints(i$1).extend(e$1);
						return [
							new t.P(o$1, r$1),
							new t.P(a$1, r$1),
							new t.P(a$1, s$1),
							new t.P(o$1, s$1),
							new t.P(o$1, r$1)
						];
					}
				}
				_constrain() {
					if (!this.center || !this._width || !this._height || this._constraining) return;
					this._constraining = !0;
					const e$1 = this._unmodified, { center: t$1, zoom: i$1 } = this.getConstrained(this.center, this.zoom);
					this.setCenter(t$1), this.setZoom(i$1), this._unmodified = e$1, this._constraining = !1;
				}
				_calcMatrices() {
					if (this._width && this._height) {
						this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
						let e$1 = t.ag(new Float64Array(16));
						t.N(e$1, e$1, [
							this._width / 2,
							-this._height / 2,
							1
						]), t.M(e$1, e$1, [
							1,
							-1,
							0
						]), this._clipSpaceToPixelsMatrix = e$1, e$1 = t.ag(new Float64Array(16)), t.N(e$1, e$1, [
							1,
							-1,
							1
						]), t.M(e$1, e$1, [
							-1,
							-1,
							0
						]), t.N(e$1, e$1, [
							2 / this._width,
							2 / this._height,
							1
						]), this._pixelsToClipSpaceMatrix = e$1, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height;
					}
					this._callbacks.calcMatrices();
				}
				calculateCenterFromCameraLngLatAlt(e$1, i$1, o$1, r$1) {
					const a$1 = void 0 !== o$1 ? o$1 : this.bearing, s$1 = r$1 = void 0 !== r$1 ? r$1 : this.pitch, n$1 = t.a1.fromLngLat(e$1, i$1), l$1 = -Math.cos(t.ae(s$1)), c$1 = Math.sin(t.ae(s$1)), h$1 = c$1 * Math.sin(t.ae(a$1)), u$1 = -c$1 * Math.cos(t.ae(a$1));
					let d$1 = this.elevation;
					const _$2 = i$1 - d$1;
					let p$1;
					l$1 * _$2 >= 0 || Math.abs(l$1) < .1 ? (p$1 = 1e4, d$1 = i$1 + p$1 * l$1) : p$1 = -_$2 / l$1;
					let m$1, f$1, g$2 = t.aQ(1, n$1.y), v$1 = 0;
					do {
						if (v$1 += 1, v$1 > 10) break;
						f$1 = p$1 / g$2, m$1 = new t.a1(n$1.x + h$1 * f$1, n$1.y + u$1 * f$1), g$2 = 1 / m$1.meterInMercatorCoordinateUnits();
					} while (Math.abs(p$1 - f$1 * g$2) > 1e-12);
					return {
						center: m$1.toLngLat(),
						elevation: d$1,
						zoom: t.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / f$1 / this.tileSize)
					};
				}
				recalculateZoomAndCenter(e$1) {
					if (this.elevation - e$1 == 0) return;
					const i$1 = t.aj(1, this.center.lat) * this.worldSize, o$1 = this.cameraToCenterDistance / i$1, r$1 = t.a1.fromLngLat(this.center, this.elevation), a$1 = de$1(this.center, this.elevation, this.pitch, this.bearing, o$1);
					this._elevation = e$1;
					const s$1 = this.calculateCenterFromCameraLngLatAlt(a$1.toLngLat(), t.aQ(a$1.z, r$1.y), this.bearing, this.pitch);
					this._elevation = s$1.elevation, this._center = s$1.center, this.setZoom(s$1.zoom);
				}
				getCameraPoint() {
					const e$1 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
					return this.centerPoint.add(new t.P(e$1 * Math.sin(this.rollInRadians), e$1 * Math.cos(this.rollInRadians)));
				}
				getCameraAltitude() {
					return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
				}
				getCameraLngLat() {
					const e$1 = t.aj(1, this.center.lat) * this.worldSize;
					return de$1(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e$1).toLngLat();
				}
				getMercatorTileCoordinates(e$1) {
					if (!e$1) return [
						0,
						0,
						1,
						1
					];
					const i$1 = e$1.canonical.z >= 0 ? 1 << e$1.canonical.z : Math.pow(2, e$1.canonical.z);
					return [
						e$1.canonical.x / i$1,
						e$1.canonical.y / i$1,
						1 / i$1 / t.$,
						1 / i$1 / t.$
					];
				}
			}
			class zt {
				constructor(e$1, i$1) {
					this.min = e$1, this.max = i$1, this.center = t.aR([], t.aS([], this.min, this.max), .5);
				}
				quadrant(e$1) {
					const i$1 = [e$1 % 2 == 0, e$1 < 2], o$1 = t.aT(this.min), r$1 = t.aT(this.max);
					for (let e$2 = 0; e$2 < i$1.length; e$2++) o$1[e$2] = i$1[e$2] ? this.min[e$2] : this.center[e$2], r$1[e$2] = i$1[e$2] ? this.center[e$2] : this.max[e$2];
					return r$1[2] = this.max[2], new zt(o$1, r$1);
				}
				distanceX(e$1) {
					return Math.max(Math.min(this.max[0], e$1[0]), this.min[0]) - e$1[0];
				}
				distanceY(e$1) {
					return Math.max(Math.min(this.max[1], e$1[1]), this.min[1]) - e$1[1];
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					for (let i$1 = 0; i$1 < e$1.planes.length; i$1++) {
						const o$1 = this.intersectsPlane(e$1.planes[i$1]);
						if (0 === o$1) return 0;
						1 === o$1 && (t$1 = !1);
					}
					return t$1 ? 2 : e$1.aabb.min[0] > this.max[0] || e$1.aabb.min[1] > this.max[1] || e$1.aabb.min[2] > this.max[2] || e$1.aabb.max[0] < this.min[0] || e$1.aabb.max[1] < this.min[1] || e$1.aabb.max[2] < this.min[2] ? 0 : 1;
				}
				intersectsPlane(e$1) {
					let t$1 = e$1[3], i$1 = e$1[3];
					for (let o$1 = 0; o$1 < 3; o$1++) e$1[o$1] > 0 ? (t$1 += e$1[o$1] * this.min[o$1], i$1 += e$1[o$1] * this.max[o$1]) : (i$1 += e$1[o$1] * this.min[o$1], t$1 += e$1[o$1] * this.max[o$1]);
					return t$1 >= 0 ? 2 : i$1 < 0 ? 0 : 1;
				}
			}
			class Dt {
				distanceToTile2d(e$1, t$1, i$1, o$1) {
					const r$1 = o$1.distanceX([e$1, t$1]), a$1 = o$1.distanceY([e$1, t$1]);
					return Math.hypot(r$1, a$1);
				}
				getWrap(e$1, t$1, i$1) {
					return i$1;
				}
				getTileBoundingVolume(e$1, i$1, o$1, r$1) {
					var a$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$2 = new t.Z(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$2);
						n$1 = null !== (a$1 = h$1.minElevation) && void 0 !== a$1 ? a$1 : Math.min(0, o$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, o$1);
					}
					const c$1 = 1 << e$1.z;
					return new zt([
						i$1 + e$1.x / c$1,
						e$1.y / c$1,
						n$1
					], [
						i$1 + (e$1.x + 1) / c$1,
						(e$1.y + 1) / c$1,
						l$1
					]);
				}
				allowVariableZoom(e$1, i$1) {
					const o$1 = e$1.fov * (Math.abs(Math.cos(e$1.rollInRadians)) * e$1.height + Math.abs(Math.sin(e$1.rollInRadians)) * e$1.width) / e$1.height, r$1 = t.ah(78.5 - o$1 / 2, 0, 60);
					return !!i$1.terrain || e$1.pitch > r$1;
				}
				allowWorldCopies() {
					return !0;
				}
				prepareNextFrame() {}
			}
			class At$1 {
				constructor(e$1, t$1, i$1) {
					this.points = e$1, this.planes = t$1, this.aabb = i$1;
				}
				static fromInvProjectionMatrix(e$1, i$1 = 1, o$1 = 0, r$1, a$1) {
					const s$1 = a$1 ? [
						[
							6,
							5,
							4
						],
						[
							0,
							1,
							2
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					] : [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					], n$1 = Math.pow(2, o$1), l$1 = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((o$2) => function(e$2, i$2, o$3, r$2) {
						const a$2 = t.aw([], e$2, i$2), s$2 = 1 / a$2[3] / o$3 * r$2;
						return t.aY(a$2, a$2, [
							s$2,
							s$2,
							1 / a$2[3],
							s$2
						]);
					}(o$2, e$1, i$1, n$1)));
					r$1 && function(e$2, i$2, o$2, r$2) {
						const a$2 = r$2 ? 4 : 0, s$2 = r$2 ? 0 : 4;
						let n$2 = 0;
						const l$2 = [], c$2 = [];
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const o$3 = t.aU([], e$2[i$3 + s$2], e$2[i$3 + a$2]), r$3 = t.aZ(o$3);
							t.aR(o$3, o$3, 1 / r$3), l$2.push(r$3), c$2.push(o$3);
						}
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const r$3 = t.a_(e$2[i$3 + a$2], c$2[i$3], o$2);
							n$2 = null !== r$3 && r$3 >= 0 ? Math.max(n$2, r$3) : Math.max(n$2, l$2[i$3]);
						}
						const h$2 = function(e$3, i$3) {
							const o$3 = t.aU([], e$3[i$3[0]], e$3[i$3[1]]), r$3 = t.aU([], e$3[i$3[2]], e$3[i$3[1]]), a$3 = [
								0,
								0,
								0,
								0
							];
							return t.aV(a$3, t.aW([], o$3, r$3)), a$3[3] = -t.aX(a$3, e$3[i$3[0]]), a$3;
						}(e$2, i$2), u$2 = function(e$3, i$3) {
							const o$3 = t.a$(e$3), r$3 = t.b0([], e$3, 1 / o$3), a$3 = t.aU([], i$3, t.aR([], r$3, t.aX(i$3, r$3))), s$3 = t.a$(a$3);
							if (s$3 > 0) {
								const e$4 = Math.sqrt(1 - r$3[3] * r$3[3]), o$4 = t.aR([], r$3, -r$3[3]), n$3 = t.aS([], o$4, t.aR([], a$3, e$4 / s$3));
								return t.b1(i$3, n$3);
							}
							return null;
						}(o$2, h$2);
						if (null !== u$2) {
							const e$3 = u$2 / t.aX(c$2[0], h$2);
							n$2 = Math.min(n$2, e$3);
						}
						for (let t$1 = 0; t$1 < 4; t$1++) {
							const i$3 = Math.min(n$2, l$2[t$1]);
							e$2[t$1 + s$2] = [
								e$2[t$1 + a$2][0] + c$2[t$1][0] * i$3,
								e$2[t$1 + a$2][1] + c$2[t$1][1] * i$3,
								e$2[t$1 + a$2][2] + c$2[t$1][2] * i$3,
								1
							];
						}
					}(l$1, s$1[0], r$1, a$1);
					const c$1 = s$1.map(((e$2) => {
						const i$2 = t.aU([], l$1[e$2[0]], l$1[e$2[1]]), o$2 = t.aU([], l$1[e$2[2]], l$1[e$2[1]]), r$2 = t.aV([], t.aW([], i$2, o$2)), a$2 = -t.aX(r$2, l$1[e$2[1]]);
						return r$2.concat(a$2);
					})), h$1 = [
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY
					], u$1 = [
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY
					];
					for (const e$2 of l$1) for (let t$1 = 0; t$1 < 3; t$1++) h$1[t$1] = Math.min(h$1[t$1], e$2[t$1]), u$1[t$1] = Math.max(u$1[t$1], e$2[t$1]);
					return new At$1(l$1, c$1, new zt(h$1, u$1));
				}
			}
			class Lt$1 {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1, t$1) {}
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Rt$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$2, t$2) => this.getConstrained(e$2, t$2)
					}, e$1, t$1, i$1, o$1, r$1), this._coveringTilesDetailsProvider = new Dt();
				}
				clone() {
					const e$1 = new Lt$1();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1, i$1) {
					this._helper.apply(e$1, t$1, i$1);
				}
				get cameraPosition() {
					return this._cameraPosition;
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._viewProjMatrix;
				}
				get inverseProjectionMatrix() {
					return this._invProjMatrix;
				}
				get mercatorMatrix() {
					return this._mercatorMatrix;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					const i$1 = [new t.b2(0, e$1)];
					if (this._helper._renderWorldCopies) {
						const o$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), r$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), a$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s$1 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n$1 = Math.floor(Math.min(o$1.x, r$1.x, a$1.x, s$1.x)), l$1 = Math.floor(Math.max(o$1.x, r$1.x, a$1.x, s$1.x)), c$1 = 1;
						for (let o$2 = n$1 - c$1; o$2 <= l$1 + c$1; o$2++) 0 !== o$2 && i$1.push(new t.b2(o$2, e$1));
					}
					return i$1;
				}
				getCameraFrustum() {
					return At$1.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
				}
				getClippingPlane() {
					return null;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					const t$1 = this.screenPointToLocation(this.centerPoint, e$1), i$1 = e$1 ? e$1.getElevationForLngLatZoom(t$1, this._helper._tileZoom) : 0;
					this._helper.recalculateZoomAndCenter(i$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const o$1 = t.aj(this.elevation, this.center.lat), r$1 = this.screenPointToMercatorCoordinateAtZ(i$1, o$1), a$1 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o$1), s$1 = t.a1.fromLngLat(e$1), n$1 = new t.a1(s$1.x - (r$1.x - a$1.x), s$1.y - (r$1.y - a$1.y));
					this.setCenter(null == n$1 ? void 0 : n$1.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
				}
				locationToScreenPoint(e$1, i$1) {
					return i$1 ? this.coordinatePoint(t.a1.fromLngLat(e$1), i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.a1.fromLngLat(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					if (t$1) {
						const i$1 = t$1.pointCoordinate(e$1);
						if (null != i$1) return i$1;
					}
					return this.screenPointToMercatorCoordinateAtZ(e$1);
				}
				screenPointToMercatorCoordinateAtZ(e$1, i$1) {
					const o$1 = i$1 || 0, r$1 = [
						e$1.x,
						e$1.y,
						0,
						1
					], a$1 = [
						e$1.x,
						e$1.y,
						1,
						1
					];
					t.aw(r$1, r$1, this._pixelMatrixInverse), t.aw(a$1, a$1, this._pixelMatrixInverse);
					const s$1 = r$1[3], n$1 = a$1[3], l$1 = r$1[1] / s$1, c$1 = a$1[1] / n$1, h$1 = r$1[2] / s$1, u$1 = a$1[2] / n$1, d$1 = h$1 === u$1 ? 0 : (o$1 - h$1) / (u$1 - h$1);
					return new t.a1(t.C.number(r$1[0] / s$1, a$1[0] / n$1, d$1) / this.worldSize, t.C.number(l$1, c$1, d$1) / this.worldSize, o$1);
				}
				coordinatePoint(e$1, i$1 = 0, o$1 = this._pixelMatrix) {
					const r$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aw(r$1, r$1, o$1), new t.P(r$1[0] / r$1[3], r$1[1] / r$1[3]);
				}
				getBounds() {
					const e$1 = Math.max(0, this._helper._height / 2 - he$1(this));
					return new G$1().extend(this.screenPointToLocation(new t.P(0, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
				}
				isPointOnMapSurface(e$1, t$1) {
					return t$1 ? null != t$1.pointCoordinate(e$1) : e$1.y > this.height / 2 - he$1(this);
				}
				calculatePosMatrix(e$1, i$1 = !1, o$1) {
					var r$1;
					const a$1 = null !== (r$1 = e$1.key) && void 0 !== r$1 ? r$1 : t.b3(e$1.wrap, e$1.canonical.z, e$1.canonical.z, e$1.canonical.x, e$1.canonical.y), s$1 = i$1 ? this._alignedPosMatrixCache : this._posMatrixCache;
					if (s$1.has(a$1)) {
						const e$2 = s$1.get(a$1);
						return o$1 ? e$2.f32 : e$2.f64;
					}
					const n$1 = ue$1(e$1, this.worldSize);
					t.O(n$1, i$1 ? this._alignedProjMatrix : this._viewProjMatrix, n$1);
					const l$1 = {
						f64: n$1,
						f32: new Float32Array(n$1)
					};
					return s$1.set(a$1, l$1), o$1 ? l$1.f32 : l$1.f64;
				}
				calculateFogMatrix(e$1) {
					const i$1 = e$1.key, o$1 = this._fogMatrixCacheF32;
					if (o$1.has(i$1)) return o$1.get(i$1);
					const r$1 = ue$1(e$1, this.worldSize);
					return t.O(r$1, this._fogMatrix, r$1), o$1.set(i$1, new Float32Array(r$1)), o$1.get(i$1);
				}
				getConstrained(e$1, i$1) {
					i$1 = t.ah(+i$1, this.minZoom, this.maxZoom);
					const o$1 = {
						center: new t.S(e$1.lng, e$1.lat),
						zoom: i$1
					};
					let r$1 = this._helper._lngRange;
					if (!this._helper._renderWorldCopies && null === r$1) {
						const e$2 = 179.9999999999;
						r$1 = [-e$2, e$2];
					}
					const a$1 = this.tileSize * t.af(o$1.zoom);
					let s$1 = 0, n$1 = a$1, l$1 = 0, c$1 = a$1, h$1 = 0, u$1 = 0;
					const { x: d$1, y: _$2 } = this.size;
					if (this._helper._latRange) {
						const e$2 = this._helper._latRange;
						s$1 = t.U(e$2[1]) * a$1, n$1 = t.U(e$2[0]) * a$1, n$1 - s$1 < _$2 && (h$1 = _$2 / (n$1 - s$1));
					}
					r$1 && (l$1 = t.aO(t.V(r$1[0]) * a$1, 0, a$1), c$1 = t.aO(t.V(r$1[1]) * a$1, 0, a$1), c$1 < l$1 && (c$1 += a$1), c$1 - l$1 < d$1 && (u$1 = d$1 / (c$1 - l$1)));
					const { x: p$1, y: m$1 } = le$1(a$1, e$1);
					let f$1, g$2;
					const v$1 = Math.max(u$1 || 0, h$1 || 0);
					if (v$1) return o$1.center = ce$1(a$1, new t.P(u$1 ? (c$1 + l$1) / 2 : p$1, h$1 ? (n$1 + s$1) / 2 : m$1)).wrap(), o$1.zoom += t.ak(v$1), o$1;
					if (this._helper._latRange) {
						const e$2 = _$2 / 2;
						m$1 - e$2 < s$1 && (g$2 = s$1 + e$2), m$1 + e$2 > n$1 && (g$2 = n$1 - e$2);
					}
					if (r$1) {
						const e$2 = (l$1 + c$1) / 2;
						let i$2 = p$1;
						this._helper._renderWorldCopies && (i$2 = t.aO(p$1, e$2 - a$1 / 2, e$2 + a$1 / 2));
						const o$2 = d$1 / 2;
						i$2 - o$2 < l$1 && (f$1 = l$1 + o$2), i$2 + o$2 > c$1 && (f$1 = c$1 - o$2);
					}
					if (void 0 !== f$1 || void 0 !== g$2) o$1.center = ce$1(a$1, new t.P(null != f$1 ? f$1 : p$1, null != g$2 ? g$2 : m$1)).wrap();
					return o$1;
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				_calculateNearFarZIfNeeded(e$1, i$1, o$1) {
					if (!this._helper.autoCalculateNearFarZ) return;
					const r$1 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a$1 = e$1 - r$1 * this._helper._pixelPerMeter / Math.cos(i$1), s$1 = r$1 < 0 ? a$1 : e$1, n$1 = Math.PI / 2 + this.pitchInRadians, l$1 = t.ae(this.fov) * (Math.abs(Math.cos(t.ae(this.roll))) * this.height + Math.abs(Math.sin(t.ae(this.roll))) * this.width) / this.height * (.5 + o$1.y / this.height), c$1 = Math.sin(l$1) * s$1 / Math.sin(t.ah(Math.PI - n$1 - l$1, .01, Math.PI - .01)), h$1 = he$1(this), u$1 = Math.atan(h$1 / this._helper.cameraToCenterDistance), d$1 = t.ae(.75), _$2 = u$1 > d$1 ? 2 * u$1 * (.5 + o$1.y / (2 * h$1)) : d$1, p$1 = Math.sin(_$2) * s$1 / Math.sin(t.ah(Math.PI - n$1 - _$2, .01, Math.PI - .01)), m$1 = Math.min(c$1, p$1);
					this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i$1) * m$1 + s$1), this._helper._nearZ = this._helper._height / 50;
				}
				_calcMatrices() {
					if (!this._helper._height) return;
					const e$1 = this.centerOffset, i$1 = le$1(this.worldSize, this.center), o$1 = i$1.x, r$1 = i$1.y;
					this._helper._pixelPerMeter = t.aj(1, this.center.lat) * this.worldSize;
					const a$1 = t.ae(Math.min(this.pitch, ne$1)), s$1 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a$1));
					let n$1;
					this._calculateNearFarZIfNeeded(s$1, a$1, e$1), n$1 = new Float64Array(16), t.b4(n$1, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aq(this._invProjMatrix, n$1), n$1[8] = 2 * -e$1.x / this._helper._width, n$1[9] = 2 * e$1.y / this._helper._height, this._projectionMatrix = t.b5(n$1), t.N(n$1, n$1, [
						1,
						-1,
						1
					]), t.M(n$1, n$1, [
						0,
						0,
						-this._helper.cameraToCenterDistance
					]), t.b6(n$1, n$1, -this.rollInRadians), t.b7(n$1, n$1, this.pitchInRadians), t.b6(n$1, n$1, -this.bearingInRadians), t.M(n$1, n$1, [
						-o$1,
						-r$1,
						0
					]), this._mercatorMatrix = t.N([], n$1, [
						this.worldSize,
						this.worldSize,
						this.worldSize
					]), t.N(n$1, n$1, [
						1,
						1,
						this._helper._pixelPerMeter
					]), this._pixelMatrix = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1), t.M(n$1, n$1, [
						0,
						0,
						-this.elevation
					]), this._viewProjMatrix = n$1, this._invViewProjMatrix = t.aq([], n$1);
					const l$1 = [
						0,
						0,
						-1,
						1
					];
					t.aw(l$1, l$1, this._invViewProjMatrix), this._cameraPosition = [
						l$1[0] / l$1[3],
						l$1[1] / l$1[3],
						l$1[2] / l$1[3]
					], this._fogMatrix = new Float64Array(16), t.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, s$1, this._helper._farZ), this._fogMatrix[8] = 2 * -e$1.x / this.width, this._fogMatrix[9] = 2 * e$1.y / this.height, t.N(this._fogMatrix, this._fogMatrix, [
						1,
						-1,
						1
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.M(this._fogMatrix, this._fogMatrix, [
						-o$1,
						-r$1,
						0
					]), t.N(this._fogMatrix, this._fogMatrix, [
						1,
						1,
						this._helper._pixelPerMeter
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.elevation
					]), this._pixelMatrix3D = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1);
					const c$1 = this._helper._width % 2 / 2, h$1 = this._helper._height % 2 / 2, u$1 = Math.cos(this.bearingInRadians), d$1 = Math.sin(-this.bearingInRadians), _$2 = o$1 - Math.round(o$1) + u$1 * c$1 + d$1 * h$1, p$1 = r$1 - Math.round(r$1) + u$1 * h$1 + d$1 * c$1, m$1 = new Float64Array(n$1);
					if (t.M(m$1, m$1, [
						_$2 > .5 ? _$2 - 1 : _$2,
						p$1 > .5 ? p$1 - 1 : p$1,
						0
					]), this._alignedProjMatrix = m$1, n$1 = t.aq(new Float64Array(16), this._pixelMatrix), !n$1) throw new Error("failed to invert matrix");
					this._pixelMatrixInverse = n$1, this._clearMatrixCaches();
				}
				_clearMatrixCaches() {
					this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
				}
				maxPitchScaleFactor() {
					if (!this._pixelMatrixInverse) return 1;
					const e$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						0,
						1
					];
					return t.aw(i$1, i$1, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					const e$1 = t.aj(1, this.center.lat) * this.worldSize;
					return de$1(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e$1).toLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1), r$1 = [
						o$1.x * this.worldSize,
						o$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aw(r$1, r$1, this._viewProjMatrix), r$1[2] / r$1[3];
				}
				getProjectionData(e$1) {
					const { overscaledTileID: i$1, aligned: o$1, applyTerrainMatrix: r$1 } = e$1, a$1 = this._helper.getMercatorTileCoordinates(i$1), s$1 = i$1 ? this.calculatePosMatrix(i$1, o$1, !0) : null;
					let n$1;
					return n$1 = i$1 && i$1.terrainRttPosMatrix32f && r$1 ? i$1.terrainRttPosMatrix32f : s$1 || t.b8(), {
						mainMatrix: n$1,
						tileMercatorCoords: a$1,
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: n$1
					};
				}
				isLocationOccluded(e$1) {
					return !1;
				}
				getPixelScale() {
					return 1;
				}
				getCircleRadiusCorrection() {
					return 1;
				}
				getPitchedTextCorrection(e$1, t$1, i$1) {
					return 1;
				}
				transformLightDirection(e$1) {
					return t.aT(e$1);
				}
				getRayDirectionFromPixel(e$1) {
					throw new Error("Not implemented.");
				}
				projectTileCoordinates(e$1, i$1, o$1, r$1) {
					const a$1 = this.calculatePosMatrix(o$1);
					let s$1;
					r$1 ? (s$1 = [
						e$1,
						i$1,
						r$1(e$1, i$1),
						1
					], t.aw(s$1, s$1, a$1)) : (s$1 = [
						e$1,
						i$1,
						0,
						1
					], qe$1(s$1, s$1, a$1));
					const n$1 = s$1[3];
					return {
						point: new t.P(s$1[0] / n$1, s$1[1] / n$1),
						signedDistanceFromCamera: n$1,
						isOccluded: !1
					};
				}
				populateCache(e$1) {
					for (const t$1 of e$1) this.calculatePosMatrix(t$1);
				}
				getMatrixForModel(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1, i$1), r$1 = o$1.meterInMercatorCoordinateUnits(), a$1 = t.b9();
					return t.M(a$1, a$1, [
						o$1.x,
						o$1.y,
						o$1.z
					]), t.b6(a$1, a$1, Math.PI), t.b7(a$1, a$1, Math.PI / 2), t.N(a$1, a$1, [
						-r$1,
						r$1,
						r$1
					]), a$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = new t.Z(0, 0, 0, 0, 0), o$1 = this.getProjectionData({
						overscaledTileID: i$1,
						applyGlobeMatrix: e$1
					}), r$1 = ue$1(i$1, this.worldSize);
					t.O(r$1, this._viewProjMatrix, r$1), o$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					];
					const a$1 = [
						t.$,
						t.$,
						this.worldSize / this._helper.pixelsPerMeter
					], s$1 = t.ba();
					return t.N(s$1, r$1, a$1), o$1.fallbackMatrix = s$1, o$1.mainMatrix = s$1, o$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.calculatePosMatrix(e$1);
				}
			}
			function kt$1() {
				t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
			}
			function Ft(e$1) {
				if (e$1.useSlerp) if (e$1.k < 1) {
					const i$1 = t.bb(e$1.startEulerAngles.roll, e$1.startEulerAngles.pitch, e$1.startEulerAngles.bearing), o$1 = t.bb(e$1.endEulerAngles.roll, e$1.endEulerAngles.pitch, e$1.endEulerAngles.bearing), r$1 = new Float64Array(4);
					t.bc(r$1, i$1, o$1, e$1.k);
					const a$1 = t.bd(r$1);
					e$1.tr.setRoll(a$1.roll), e$1.tr.setPitch(a$1.pitch), e$1.tr.setBearing(a$1.bearing);
				} else e$1.tr.setRoll(e$1.endEulerAngles.roll), e$1.tr.setPitch(e$1.endEulerAngles.pitch), e$1.tr.setBearing(e$1.endEulerAngles.bearing);
				else e$1.tr.setRoll(t.C.number(e$1.startEulerAngles.roll, e$1.endEulerAngles.roll, e$1.k)), e$1.tr.setPitch(t.C.number(e$1.startEulerAngles.pitch, e$1.endEulerAngles.pitch, e$1.k)), e$1.tr.setBearing(t.C.number(e$1.startEulerAngles.bearing, e$1.endEulerAngles.bearing, e$1.k));
			}
			function Bt$1(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = a$1.padding, n$1 = le$1(a$1.worldSize, o$1.getNorthWest()), l$1 = le$1(a$1.worldSize, o$1.getNorthEast()), c$1 = le$1(a$1.worldSize, o$1.getSouthEast()), h$1 = le$1(a$1.worldSize, o$1.getSouthWest()), u$1 = t.ae(-r$1), d$1 = n$1.rotate(u$1), _$2 = l$1.rotate(u$1), p$1 = c$1.rotate(u$1), m$1 = h$1.rotate(u$1), f$1 = new t.P(Math.max(d$1.x, _$2.x, m$1.x, p$1.x), Math.max(d$1.y, _$2.y, m$1.y, p$1.y)), g$2 = new t.P(Math.min(d$1.x, _$2.x, m$1.x, p$1.x), Math.min(d$1.y, _$2.y, m$1.y, p$1.y)), v$1 = f$1.sub(g$2), b$2 = (a$1.width - (s$1.left + s$1.right + i$1.left + i$1.right)) / v$1.x, x$1 = (a$1.height - (s$1.top + s$1.bottom + i$1.top + i$1.bottom)) / v$1.y;
				if (x$1 < 0 || b$2 < 0) return void kt$1();
				const y$1 = Math.min(t.ak(a$1.scale * Math.min(b$2, x$1)), e$1.maxZoom), w$1 = t.P.convert(e$1.offset), T$2 = new t.P((i$1.left - i$1.right) / 2, (i$1.top - i$1.bottom) / 2).rotate(t.ae(r$1)), P$2 = w$1.add(T$2).mult(a$1.scale / t.af(y$1));
				return {
					center: ce$1(a$1.worldSize, n$1.add(c$1).div(2).sub(P$2)),
					zoom: y$1,
					bearing: r$1
				};
			}
			class Ot {
				get useGlobeControls() {
					return !1;
				}
				handlePanInertia(e$1, t$1) {
					return {
						easingOffset: e$1,
						easingCenter: t$1.center
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					e$1.bearingDelta && t$1.setBearing(t$1.bearing + e$1.bearingDelta), e$1.pitchDelta && t$1.setPitch(t$1.pitch + e$1.pitchDelta), e$1.rollDelta && t$1.setRoll(t$1.roll + e$1.rollDelta), e$1.zoomDelta && t$1.setZoom(t$1.zoom + e$1.zoomDelta);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					e$1.around.distSqr(t$1.centerPoint) < .01 || t$1.setLocationAtPoint(i$1, e$1.around);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1) {
					return Bt$1(e$1, t$1, i$1, o$1, r$1);
				}
				handleJumpToCenterZoom(e$1, i$1) {
					e$1.zoom !== (void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom) && e$1.setZoom(+i$1.zoom), void 0 !== i$1.center && e$1.setCenter(t.S.convert(i$1.center));
				}
				handleEaseTo(e$1, i$1) {
					const o$1 = e$1.zoom, r$1 = e$1.padding, a$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, s$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, n$1 = void 0 !== i$1.zoom, l$1 = !e$1.isPaddingEqual(i$1.padding);
					let c$1 = !1;
					const h$1 = n$1 ? +i$1.zoom : e$1.zoom;
					let u$1 = e$1.centerPoint.add(i$1.offsetAsPoint);
					const d$1 = e$1.screenPointToLocation(u$1), { center: _$2, zoom: p$1 } = e$1.getConstrained(t.S.convert(i$1.center || d$1), null != h$1 ? h$1 : o$1);
					St$1(e$1, _$2);
					const m$1 = le$1(e$1.worldSize, d$1), f$1 = le$1(e$1.worldSize, _$2).sub(m$1), g$2 = t.af(p$1 - o$1);
					return c$1 = p$1 !== o$1, {
						easeFunc: (n$2) => {
							if (c$1 && e$1.setZoom(t.C.number(o$1, p$1, n$2)), t.be(a$1, s$1) || Ft({
								startEulerAngles: a$1,
								endEulerAngles: s$1,
								tr: e$1,
								k: n$2,
								useSlerp: a$1.roll != s$1.roll
							}), l$1 && (e$1.interpolatePadding(r$1, i$1.padding, n$2), u$1 = e$1.centerPoint.add(i$1.offsetAsPoint)), i$1.around) e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const i$2 = t.af(e$1.zoom - o$1), r$2 = p$1 > o$1 ? Math.min(2, g$2) : Math.max(.5, g$2), a$2 = Math.pow(r$2, 1 - n$2), s$2 = ce$1(e$1.worldSize, m$1.add(f$1.mult(n$2 * a$2)).mult(i$2));
								e$1.setLocationAtPoint(e$1.renderWorldCopies ? s$2.wrap() : s$2, u$1);
							}
						},
						isZooming: c$1,
						elevationCenter: _$2
					};
				}
				handleFlyTo(e$1, i$1) {
					const o$1 = void 0 !== i$1.zoom, r$1 = e$1.zoom, a$1 = e$1.getConstrained(t.S.convert(i$1.center || i$1.locationAtOffset), o$1 ? +i$1.zoom : r$1), s$1 = a$1.center, n$1 = a$1.zoom;
					St$1(e$1, s$1);
					const l$1 = le$1(e$1.worldSize, i$1.locationAtOffset), c$1 = le$1(e$1.worldSize, s$1).sub(l$1), h$1 = c$1.mag(), u$1 = t.af(n$1 - r$1);
					let d$1;
					if (void 0 !== i$1.minZoom) {
						const o$2 = Math.min(+i$1.minZoom, r$1, n$1), a$2 = e$1.getConstrained(s$1, o$2).zoom;
						d$1 = t.af(a$2 - r$1);
					}
					return {
						easeFunc: (i$2, o$2, a$2, h$2) => {
							e$1.setZoom(1 === i$2 ? n$1 : r$1 + t.ak(o$2));
							const u$2 = 1 === i$2 ? s$1 : ce$1(e$1.worldSize, l$1.add(c$1.mult(a$2)).mult(o$2));
							e$1.setLocationAtPoint(e$1.renderWorldCopies ? u$2.wrap() : u$2, h$2);
						},
						scaleOfZoom: u$1,
						targetCenter: s$1,
						scaleOfMinZoom: d$1,
						pixelPathLength: h$1
					};
				}
			}
			class jt {
				constructor(e$1, t$1, i$1) {
					this.blendFunction = e$1, this.blendColor = t$1, this.mask = i$1;
				}
			}
			jt.Replace = [1, 0], jt.disabled = new jt(jt.Replace, t.bf.transparent, [
				!1,
				!1,
				!1,
				!1
			]), jt.unblended = new jt(jt.Replace, t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]), jt.alphaBlended = new jt([1, 771], t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			const Nt = 2305;
			class Ut$1 {
				constructor(e$1, t$1, i$1) {
					this.enable = e$1, this.mode = t$1, this.frontFace = i$1;
				}
			}
			Ut$1.disabled = new Ut$1(!1, 1029, Nt), Ut$1.backCCW = new Ut$1(!0, 1029, Nt), Ut$1.frontCCW = new Ut$1(!0, 1028, Nt);
			class Zt$1 {
				constructor(e$1, t$1, i$1) {
					this.func = e$1, this.mask = t$1, this.range = i$1;
				}
			}
			Zt$1.ReadOnly = !1, Zt$1.ReadWrite = !0, Zt$1.disabled = new Zt$1(519, Zt$1.ReadOnly, [0, 1]);
			const Gt$1 = 7680;
			class Vt$1 {
				constructor(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.test = e$1, this.ref = t$1, this.mask = i$1, this.fail = o$1, this.depthFail = r$1, this.pass = a$1;
				}
			}
			Vt$1.disabled = new Vt$1({
				func: 519,
				mask: 0
			}, 0, 0, Gt$1, Gt$1, Gt$1);
			const $t = /* @__PURE__ */ new WeakMap();
			function qt$1(e$1) {
				var t$1;
				if ($t.has(e$1)) return $t.get(e$1);
				{
					const i$1 = null === (t$1 = e$1.getParameter(e$1.VERSION)) || void 0 === t$1 ? void 0 : t$1.startsWith("WebGL 2.0");
					return $t.set(e$1, i$1), i$1;
				}
			}
			class Wt$1 {
				get awaitingQuery() {
					return !!this._readbackQueue;
				}
				constructor(e$1) {
					this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e$1;
					const i$1 = e$1.context, o$1 = i$1.gl;
					this._texFormat = o$1.RGBA, this._texType = o$1.UNSIGNED_BYTE;
					const r$1 = new t.aL();
					r$1.emplaceBack(-1, -1), r$1.emplaceBack(2, -1), r$1.emplaceBack(-1, 2);
					const a$1 = new t.aN();
					a$1.emplaceBack(0, 1, 2), this._fullscreenTriangle = new wt$1(i$1.createVertexBuffer(r$1, Tt$1.members), i$1.createIndexBuffer(a$1), t.aM.simpleSegment(0, 0, r$1.length, a$1.length)), this._resultBuffer = new Uint8Array(4), i$1.activeTexture.set(o$1.TEXTURE1);
					const s$1 = o$1.createTexture();
					o$1.bindTexture(o$1.TEXTURE_2D, s$1), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_S, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_T, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MIN_FILTER, o$1.NEAREST), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MAG_FILTER, o$1.NEAREST), o$1.texImage2D(o$1.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i$1.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(s$1), qt$1(o$1) && (this._pbo = o$1.createBuffer(), o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, this._pbo), o$1.bufferData(o$1.PIXEL_PACK_BUFFER, 4, o$1.STREAM_READ), o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, null));
				}
				destroy() {
					const e$1 = this._cachedRenderContext.context.gl;
					this._fullscreenTriangle.destroy(), this._fbo.destroy(), e$1.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
				}
				updateErrorLoop(e$1, t$1) {
					const i$1 = this._updateCount;
					return this._readbackQueue ? i$1 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i$1 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e$1, t$1), this._updateCount++, this._measuredError;
				}
				_bindFramebuffer() {
					const e$1 = this._cachedRenderContext.context, t$1 = e$1.gl;
					e$1.activeTexture.set(t$1.TEXTURE1), t$1.bindTexture(t$1.TEXTURE_2D, this._fbo.colorAttachment.get()), e$1.bindFramebuffer.set(this._fbo.framebuffer);
				}
				_renderErrorTexture(e$1, i$1) {
					const o$1 = this._cachedRenderContext.context, r$1 = o$1.gl;
					if (this._bindFramebuffer(), o$1.viewport.set([
						0,
						0,
						this._texWidth,
						this._texHeight
					]), o$1.clear({ color: t.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o$1, r$1.TRIANGLES, Zt$1.disabled, Vt$1.disabled, jt.unblended, Ut$1.disabled, ((e$2, t$1) => ({
						u_input: e$2,
						u_output_expected: t$1
					}))(e$1, i$1), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && qt$1(r$1)) {
						r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, this._pbo), r$1.readBuffer(r$1.COLOR_ATTACHMENT0), r$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, null);
						const e$2 = r$1.fenceSync(r$1.SYNC_GPU_COMMANDS_COMPLETE, 0);
						r$1.flush(), this._readbackQueue = {
							frameNumberIssued: this._updateCount,
							sync: e$2
						};
					} else this._readbackQueue = {
						frameNumberIssued: this._updateCount,
						sync: null
					};
				}
				_tryReadback() {
					const e$1 = this._cachedRenderContext.context.gl;
					if (this._pbo && this._readbackQueue && qt$1(e$1)) {
						const i$1 = e$1.clientWaitSync(this._readbackQueue.sync, 0, 0);
						if (i$1 === e$1.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
						if (i$1 === e$1.TIMEOUT_EXPIRED) return;
						e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, this._pbo), e$1.getBufferSubData(e$1.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, null);
					} else this._bindFramebuffer(), e$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
					this._readbackQueue = null, this._measuredError = Wt$1._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
				}
				static _parseRGBA8float(e$1) {
					let t$1 = 0;
					return t$1 += e$1[0] / 256, t$1 += e$1[1] / 65536, t$1 += e$1[2] / 16777216, e$1[3] < 127 && (t$1 = -t$1), t$1 / 128;
				}
			}
			const Ht$1 = t.$ / 128;
			function Xt$1(e$1, i$1) {
				const o$1 = void 0 !== e$1.granularity ? Math.max(e$1.granularity, 1) : 1, r$1 = o$1 + (e$1.generateBorders ? 2 : 0), a$1 = o$1 + (e$1.extendToNorthPole || e$1.generateBorders ? 1 : 0) + (e$1.extendToSouthPole || e$1.generateBorders ? 1 : 0), s$1 = r$1 + 1, n$1 = a$1 + 1, l$1 = e$1.generateBorders ? -1 : 0, c$1 = e$1.generateBorders || e$1.extendToNorthPole ? -1 : 0, h$1 = o$1 + (e$1.generateBorders ? 1 : 0), u$1 = o$1 + (e$1.generateBorders || e$1.extendToSouthPole ? 1 : 0), d$1 = s$1 * n$1, _$2 = r$1 * a$1 * 6, p$1 = s$1 * n$1 > 65536;
				if (p$1 && "16bit" === i$1) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
				const m$1 = p$1 || "32bit" === i$1, f$1 = new Int16Array(2 * d$1);
				let g$2 = 0;
				for (let i$2 = c$1; i$2 <= u$1; i$2++) for (let r$2 = l$1; r$2 <= h$1; r$2++) {
					let a$2 = r$2 / o$1 * t.$;
					-1 === r$2 && (a$2 = -Ht$1), r$2 === o$1 + 1 && (a$2 = t.$ + Ht$1);
					let s$2 = i$2 / o$1 * t.$;
					-1 === i$2 && (s$2 = e$1.extendToNorthPole ? t.bh : -Ht$1), i$2 === o$1 + 1 && (s$2 = e$1.extendToSouthPole ? t.bi : t.$ + Ht$1), f$1[g$2++] = a$2, f$1[g$2++] = s$2;
				}
				const v$1 = m$1 ? new Uint32Array(_$2) : new Uint16Array(_$2);
				let b$2 = 0;
				for (let e$2 = 0; e$2 < a$1; e$2++) for (let t$1 = 0; t$1 < r$1; t$1++) {
					const i$2 = t$1 + 1 + e$2 * s$1, o$2 = t$1 + (e$2 + 1) * s$1, r$2 = t$1 + 1 + (e$2 + 1) * s$1;
					v$1[b$2++] = t$1 + e$2 * s$1, v$1[b$2++] = o$2, v$1[b$2++] = i$2, v$1[b$2++] = i$2, v$1[b$2++] = o$2, v$1[b$2++] = r$2;
				}
				return {
					vertices: f$1.buffer.slice(0),
					indices: v$1.buffer.slice(0),
					uses32bitIndices: m$1
				};
			}
			const Kt$1 = new t.aK({
				fill: new t.bj(128, 2),
				line: new t.bj(512, 0),
				tile: new t.bj(128, 32),
				stencil: new t.bj(128, 1),
				circle: 3
			});
			class Yt$1 {
				constructor() {
					this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
				}
				get name() {
					return "vertical-perspective";
				}
				get transitionState() {
					return 1;
				}
				get useSubdivision() {
					return !0;
				}
				get shaderVariantName() {
					return "globe";
				}
				get shaderDefine() {
					return "#define GLOBE";
				}
				get shaderPreludeCode() {
					return xt$1.projectionGlobe;
				}
				get vertexShaderPreludeCode() {
					return xt$1.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return Kt$1;
				}
				get useGlobeControls() {
					return !0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._errorCorrectionUsable;
				}
				destroy() {
					this._errorMeasurement && this._errorMeasurement.destroy();
				}
				updateGPUdependent(e$1) {
					this._errorMeasurement || (this._errorMeasurement = new Wt$1(e$1));
					const i$1 = t.U(this._errorQueryLatitudeDegrees), o$1 = 2 * Math.atan(Math.exp(Math.PI - i$1 * Math.PI * 2)) - .5 * Math.PI, r$1 = this._errorMeasurement.updateErrorLoop(i$1, o$1), a$1 = s.now();
					r$1 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = r$1, this._errorMeasurementLastChangeTime = a$1);
					const n$1 = Math.min(Math.max((a$1 - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
					this._errorCorrectionUsable = t.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bl(n$1));
				}
				_getMeshKey(e$1) {
					return `${e$1.granularity.toString(36)}_${e$1.generateBorders ? "b" : ""}${e$1.extendToNorthPole ? "n" : ""}${e$1.extendToSouthPole ? "s" : ""}`;
				}
				getMeshFromTileID(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = ("stencil" === r$1 ? Kt$1.stencil : Kt$1.tile).getGranularityForZoomLevel(t$1.z);
					return this._getMesh(e$1, {
						granularity: a$1,
						generateBorders: i$1,
						extendToNorthPole: 0 === t$1.y && o$1,
						extendToSouthPole: t$1.y === (1 << t$1.z) - 1 && o$1
					});
				}
				_getMesh(e$1, i$1) {
					const o$1 = this._getMeshKey(i$1);
					if (o$1 in this._tileMeshCache) return this._tileMeshCache[o$1];
					const r$1 = function(e$2, i$2) {
						const o$2 = Xt$1(i$2, "16bit"), r$2 = t.aL.deserialize({
							arrayBuffer: o$2.vertices,
							length: o$2.vertices.byteLength / 2 / 2
						}), a$1 = t.aN.deserialize({
							arrayBuffer: o$2.indices,
							length: o$2.indices.byteLength / 2 / 3
						});
						return new wt$1(e$2.createVertexBuffer(r$2, Tt$1.members), e$2.createIndexBuffer(a$1), t.aM.simpleSegment(0, 0, r$2.length, a$1.length));
					}(e$1, i$1);
					return this._tileMeshCache[o$1] = r$1, r$1;
				}
				recalculate(e$1) {}
				hasTransition() {
					const e$1 = s.now();
					let t$1 = !1;
					return t$1 = t$1 || (e$1 - this._errorMeasurementLastChangeTime) / 1e3 < .7, t$1 = t$1 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t$1;
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._errorQueryLatitudeDegrees = e$1;
				}
			}
			const Qt$1 = new t.r({ type: new t.D(t.v.projection.type) });
			class Jt$1 extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.t(Qt$1), this.setProjection(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0)), this._mercatorProjection = new It$1(), this._verticalPerspectiveProjection = new Yt$1();
				}
				get transitionState() {
					const e$1 = this.properties.get("type");
					if ("string" == typeof e$1 && "mercator" === e$1) return 0;
					if ("string" == typeof e$1 && "vertical-perspective" === e$1) return 1;
					if (e$1 instanceof t.bm) {
						if ("vertical-perspective" === e$1.from && "mercator" === e$1.to) return 1 - e$1.transition;
						if ("mercator" === e$1.from && "vertical-perspective" === e$1.to) return e$1.transition;
					}
					return 1;
				}
				get useGlobeRendering() {
					return this.transitionState > 0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
				}
				get currentProjection() {
					return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
				}
				get name() {
					return "globe";
				}
				get useSubdivision() {
					return this.currentProjection.useSubdivision;
				}
				get shaderVariantName() {
					return this.currentProjection.shaderVariantName;
				}
				get shaderDefine() {
					return this.currentProjection.shaderDefine;
				}
				get shaderPreludeCode() {
					return this.currentProjection.shaderPreludeCode;
				}
				get vertexShaderPreludeCode() {
					return this.currentProjection.vertexShaderPreludeCode;
				}
				get subdivisionGranularity() {
					return this.currentProjection.subdivisionGranularity;
				}
				get useGlobeControls() {
					return this.transitionState > 0;
				}
				destroy() {
					this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
				}
				updateGPUdependent(e$1) {
					this._mercatorProjection.updateGPUdependent(e$1), this._verticalPerspectiveProjection.updateGPUdependent(e$1);
				}
				getMeshFromTileID(e$1, t$1, i$1, o$1, r$1) {
					return this.currentProjection.getMeshFromTileID(e$1, t$1, i$1, o$1, r$1);
				}
				setProjection(e$1) {
					this._transitionable.setValue("type", (null == e$1 ? void 0 : e$1.type) || "mercator");
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e$1), this._mercatorProjection.setErrorQueryLatitudeDegrees(e$1);
				}
			}
			function ei$1(e$1) {
				const t$1 = oi$1(e$1.worldSize, e$1.center.lat);
				return 2 * Math.PI * t$1;
			}
			function ti$1(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = 1 / (1 << a$1), n$1 = i$1 / t.$ * s$1 + r$1 * s$1, l$1 = t.bo((e$1 / t.$ * s$1 + o$1 * s$1) * Math.PI * 2 + Math.PI, 2 * Math.PI), c$1 = 2 * Math.atan(Math.exp(Math.PI - n$1 * Math.PI * 2)) - .5 * Math.PI, h$1 = Math.cos(c$1), u$1 = new Float64Array(3);
				return u$1[0] = Math.sin(l$1) * h$1, u$1[1] = Math.sin(c$1), u$1[2] = Math.cos(l$1) * h$1, u$1;
			}
			function ii$1(e$1) {
				return function(e$2, t$1) {
					const i$1 = Math.cos(t$1), o$1 = new Float64Array(3);
					return o$1[0] = Math.sin(e$2) * i$1, o$1[1] = Math.sin(t$1), o$1[2] = Math.cos(e$2) * i$1, o$1;
				}(e$1.lng * Math.PI / 180, e$1.lat * Math.PI / 180);
			}
			function oi$1(e$1, t$1) {
				return e$1 / (2 * Math.PI) / Math.cos(t$1 * Math.PI / 180);
			}
			function ri$1(e$1) {
				const i$1 = Math.asin(e$1[1]) / Math.PI * 180, o$1 = Math.sqrt(e$1[0] * e$1[0] + e$1[2] * e$1[2]);
				if (o$1 > 1e-6) {
					const r$1 = e$1[0] / o$1, a$1 = Math.acos(e$1[2] / o$1), s$1 = (r$1 > 0 ? a$1 : -a$1) / Math.PI * 180;
					return new t.S(t.aO(s$1, -180, 180), i$1);
				}
				return new t.S(0, i$1);
			}
			function ai$1(e$1) {
				return Math.cos(e$1 * Math.PI / 180);
			}
			function si$1(e$1, i$1) {
				const o$1 = ai$1(e$1), r$1 = ai$1(i$1);
				return t.ak(r$1 / o$1);
			}
			function ni$1(e$1, i$1) {
				const o$1 = e$1.rotate(i$1.bearingInRadians), r$1 = i$1.zoom + si$1(i$1.center.lat, 0), a$1 = t.bk(1 / ai$1(i$1.center.lat), 1 / ai$1(Math.min(Math.abs(i$1.center.lat), 60)), t.bn(r$1, 7, 3, 0, 1)), s$1 = 360 / ei$1({
					worldSize: i$1.worldSize,
					center: { lat: i$1.center.lat }
				});
				return new t.S(i$1.center.lng - o$1.x * s$1 * a$1, t.ah(i$1.center.lat + o$1.y * s$1, -t.ai, t.ai));
			}
			function li$1(e$1) {
				const t$1 = .5 * e$1, i$1 = Math.sin(t$1), o$1 = Math.cos(t$1);
				return Math.log(i$1 + o$1) - Math.log(o$1 - i$1);
			}
			function ci$1(e$1, i$1, o$1, r$1) {
				const a$1 = e$1.lat + o$1 * r$1;
				if (Math.abs(o$1) > 1) {
					const s$1 = (Math.sign(e$1.lat + o$1) !== Math.sign(e$1.lat) ? -Math.abs(e$1.lat) : Math.abs(e$1.lat)) * Math.PI / 180, n$1 = Math.abs(e$1.lat + o$1) * Math.PI / 180, l$1 = li$1(s$1 + r$1 * (n$1 - s$1)), c$1 = li$1(s$1), h$1 = li$1(n$1);
					return new t.S(e$1.lng + i$1 * ((l$1 - c$1) / (h$1 - c$1)), a$1);
				}
				return new t.S(e$1.lng + i$1 * r$1, a$1);
			}
			class hi$1 {
				constructor(e$1) {
					this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e$1;
				}
				swapBuffers() {
					if (!this._hadAnyChanges) return;
					const e$1 = this._cachePrevious;
					this._cachePrevious = this._cache, this._cache = e$1, this._cache.clear(), this._hadAnyChanges = !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, o$1) {
					const r$1 = `${e$1.z}_${e$1.x}_${e$1.y}_${(null == o$1 ? void 0 : o$1.terrain) ? "t" : ""}`, a$1 = this._cache.get(r$1);
					if (a$1) return a$1;
					const s$1 = this._cachePrevious.get(r$1);
					if (s$1) return this._cache.set(r$1, s$1), s$1;
					const n$1 = this._boundingVolumeFactory(e$1, t$1, i$1, o$1);
					return this._cache.set(r$1, n$1), this._hadAnyChanges = !0, n$1;
				}
			}
			class ui$1 {
				constructor(e$1, t$1, i$1, o$1) {
					this.min = i$1, this.max = o$1, this.points = e$1, this.planes = t$1;
				}
				static fromAabb(e$1, t$1) {
					const i$1 = [];
					for (let o$1 = 0; o$1 < 8; o$1++) i$1.push([
						1 & ~o$1 ? e$1[0] : t$1[0],
						1 == (o$1 >> 1 & 1) ? t$1[1] : e$1[1],
						1 == (o$1 >> 2 & 1) ? t$1[2] : e$1[2]
					]);
					return new ui$1(i$1, [
						[
							-1,
							0,
							0,
							t$1[0]
						],
						[
							1,
							0,
							0,
							-e$1[0]
						],
						[
							0,
							-1,
							0,
							t$1[1]
						],
						[
							0,
							1,
							0,
							-e$1[1]
						],
						[
							0,
							0,
							-1,
							t$1[2]
						],
						[
							0,
							0,
							1,
							-e$1[2]
						]
					], e$1, t$1);
				}
				static fromCenterSizeAngles(e$1, i$1, o$1) {
					const r$1 = t.br([], o$1[0], o$1[1], o$1[2]), a$1 = t.bs([], [
						i$1[0],
						0,
						0
					], r$1), s$1 = t.bs([], [
						0,
						i$1[1],
						0
					], r$1), n$1 = t.bs([], [
						0,
						0,
						i$1[2]
					], r$1), l$1 = [...e$1], c$1 = [...e$1];
					for (let t$1 = 0; t$1 < 8; t$1++) for (let i$2 = 0; i$2 < 3; i$2++) {
						const o$2 = e$1[i$2] + a$1[i$2] * (1 & ~t$1 ? -1 : 1) + s$1[i$2] * (1 == (t$1 >> 1 & 1) ? 1 : -1) + n$1[i$2] * (1 == (t$1 >> 2 & 1) ? 1 : -1);
						l$1[i$2] = Math.min(l$1[i$2], o$2), c$1[i$2] = Math.max(c$1[i$2], o$2);
					}
					const h$1 = [];
					for (let i$2 = 0; i$2 < 8; i$2++) {
						const o$2 = [...e$1];
						t.aS(o$2, o$2, t.aR([], a$1, 1 & ~i$2 ? -1 : 1)), t.aS(o$2, o$2, t.aR([], s$1, 1 == (i$2 >> 1 & 1) ? 1 : -1)), t.aS(o$2, o$2, t.aR([], n$1, 1 == (i$2 >> 2 & 1) ? 1 : -1)), h$1.push(o$2);
					}
					return new ui$1(h$1, [
						[...a$1, -t.aX(a$1, h$1[0])],
						[...s$1, -t.aX(s$1, h$1[0])],
						[...n$1, -t.aX(n$1, h$1[0])],
						[
							-a$1[0],
							-a$1[1],
							-a$1[2],
							-t.aX(a$1, h$1[7])
						],
						[
							-s$1[0],
							-s$1[1],
							-s$1[2],
							-t.aX(s$1, h$1[7])
						],
						[
							-n$1[0],
							-n$1[1],
							-n$1[2],
							-t.aX(n$1, h$1[7])
						]
					], l$1, c$1);
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					const i$1 = this.points.length, o$1 = this.planes.length, r$1 = e$1.planes.length, a$1 = e$1.points.length;
					for (let o$2 = 0; o$2 < r$1; o$2++) {
						const r$2 = e$1.planes[o$2];
						let a$2 = 0;
						for (let e$2 = 0; e$2 < i$1; e$2++) {
							const t$2 = this.points[e$2];
							r$2[0] * t$2[0] + r$2[1] * t$2[1] + r$2[2] * t$2[2] + r$2[3] >= 0 && a$2++;
						}
						if (0 === a$2) return 0;
						a$2 < i$1 && (t$1 = !1);
					}
					if (t$1) return 2;
					for (let t$2 = 0; t$2 < o$1; t$2++) {
						const i$2 = this.planes[t$2];
						let o$2 = 0;
						for (let t$3 = 0; t$3 < a$1; t$3++) {
							const r$2 = e$1.points[t$3];
							i$2[0] * r$2[0] + i$2[1] * r$2[1] + i$2[2] * r$2[2] + i$2[3] >= 0 && o$2++;
						}
						if (0 === o$2) return 0;
					}
					return 1;
				}
				intersectsPlane(e$1) {
					const t$1 = this.points.length;
					let i$1 = 0;
					for (let o$1 = 0; o$1 < t$1; o$1++) {
						const t$2 = this.points[o$1];
						e$1[0] * t$2[0] + e$1[1] * t$2[1] + e$1[2] * t$2[2] + e$1[3] >= 0 && i$1++;
					}
					return i$1 === t$1 ? 2 : 0 === i$1 ? 0 : 1;
				}
			}
			function di$1(e$1, t$1, i$1) {
				const o$1 = e$1 - t$1;
				return o$1 < 0 ? -o$1 : Math.max(0, o$1 - i$1);
			}
			function _i(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1 - i$1;
				let s$1;
				return s$1 = a$1 < 0 ? Math.min(-a$1, 1 + a$1 - r$1) : a$1 > 1 ? Math.min(Math.max(a$1 - r$1, 0), 1 - a$1) : 0, Math.max(s$1, di$1(t$1, o$1, r$1));
			}
			class pi$1 {
				constructor() {
					this._boundingVolumeCache = new hi$1(this._computeTileBoundingVolume);
				}
				prepareNextFrame() {
					this._boundingVolumeCache.swapBuffers();
				}
				distanceToTile2d(e$1, t$1, i$1, o$1) {
					const r$1 = 1 << i$1.z, a$1 = 1 / r$1, s$1 = i$1.x / r$1, n$1 = i$1.y / r$1;
					let l$1 = 2;
					return l$1 = Math.min(l$1, _i(e$1, t$1, s$1, n$1, a$1)), l$1 = Math.min(l$1, _i(e$1, t$1, s$1 + .5, -n$1 - a$1, a$1)), l$1 = Math.min(l$1, _i(e$1, t$1, s$1 + .5, 2 - n$1 - a$1, a$1)), l$1;
				}
				getWrap(e$1, t$1, i$1) {
					const o$1 = 1 << t$1.z, r$1 = 1 / o$1, a$1 = t$1.x / o$1, s$1 = di$1(e$1.x, a$1, r$1), n$1 = di$1(e$1.x, a$1 - 1, r$1), l$1 = di$1(e$1.x, a$1 + 1, r$1), c$1 = Math.min(s$1, n$1, l$1);
					return c$1 === l$1 ? 1 : c$1 === n$1 ? -1 : 0;
				}
				allowVariableZoom(e$1, t$1) {
					return ge$1(e$1, t$1) > 4;
				}
				allowWorldCopies() {
					return !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, o$1) {
					return this._boundingVolumeCache.getTileBoundingVolume(e$1, t$1, i$1, o$1);
				}
				_computeTileBoundingVolume(e$1, i$1, o$1, r$1) {
					var a$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$1 = new t.Z(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$1);
						n$1 = null !== (a$1 = h$1.minElevation) && void 0 !== a$1 ? a$1 : Math.min(0, o$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, o$1);
					}
					if (n$1 /= t.bu, l$1 /= t.bu, n$1 += 1, l$1 += 1, e$1.z <= 0) return ui$1.fromAabb([
						-l$1,
						-l$1,
						-l$1
					], [
						l$1,
						l$1,
						l$1
					]);
					if (1 === e$1.z) return ui$1.fromAabb([
						0 === e$1.x ? -l$1 : 0,
						0 === e$1.y ? 0 : -l$1,
						-l$1
					], [
						0 === e$1.x ? 0 : l$1,
						0 === e$1.y ? l$1 : 0,
						l$1
					]);
					{
						const i$2 = [
							ti$1(0, 0, e$1.x, e$1.y, e$1.z),
							ti$1(t.$, 0, e$1.x, e$1.y, e$1.z),
							ti$1(t.$, t.$, e$1.x, e$1.y, e$1.z),
							ti$1(0, t.$, e$1.x, e$1.y, e$1.z)
						], o$2 = [];
						for (const e$2 of i$2) o$2.push(t.aR([], e$2, l$1));
						if (l$1 !== n$1) for (const e$2 of i$2) o$2.push(t.aR([], e$2, n$1));
						0 === e$1.y && o$2.push([
							0,
							1,
							0
						]), e$1.y === (1 << e$1.z) - 1 && o$2.push([
							0,
							-1,
							0
						]);
						const r$2 = [
							1,
							1,
							1
						], a$2 = [
							-1,
							-1,
							-1
						];
						for (const e$2 of o$2) for (let t$1 = 0; t$1 < 3; t$1++) r$2[t$1] = Math.min(r$2[t$1], e$2[t$1]), a$2[t$1] = Math.max(a$2[t$1], e$2[t$1]);
						const s$2 = ti$1(t.$ / 2, t.$ / 2, e$1.x, e$1.y, e$1.z), c$1 = t.aW([], [
							0,
							1,
							0
						], s$2);
						t.aV(c$1, c$1);
						const h$1 = t.aW([], s$2, c$1);
						t.aV(h$1, h$1);
						const u$1 = t.aW([], i$2[2], i$2[1]);
						t.aV(u$1, u$1);
						const d$1 = t.aW([], i$2[0], i$2[3]);
						t.aV(d$1, d$1), o$2.push(t.aR([], s$2, l$1)), e$1.y >= (1 << e$1.z) / 2 && o$2.push(t.aR([], ti$1(t.$ / 2, 0, e$1.x, e$1.y, e$1.z), l$1)), e$1.y < (1 << e$1.z) / 2 && o$2.push(t.aR([], ti$1(t.$ / 2, t.$, e$1.x, e$1.y, e$1.z), l$1));
						const _$2 = mi$1(s$2, o$2), p$1 = mi$1(h$1, o$2), m$1 = [
							-s$2[0],
							-s$2[1],
							-s$2[2],
							_$2.max
						], f$1 = [
							s$2[0],
							s$2[1],
							s$2[2],
							-_$2.min
						], g$2 = [
							-h$1[0],
							-h$1[1],
							-h$1[2],
							p$1.max
						], v$1 = [
							h$1[0],
							h$1[1],
							h$1[2],
							-p$1.min
						], b$2 = [...u$1, 0], x$1 = [...d$1, 0], y$1 = [];
						return 0 === e$1.y ? y$1.push(t.bt(x$1, b$2, m$1), t.bt(x$1, b$2, f$1)) : y$1.push(t.bt(g$2, b$2, m$1), t.bt(g$2, b$2, f$1), t.bt(g$2, x$1, m$1), t.bt(g$2, x$1, f$1)), e$1.y === (1 << e$1.z) - 1 ? y$1.push(t.bt(x$1, b$2, m$1), t.bt(x$1, b$2, f$1)) : y$1.push(t.bt(v$1, b$2, m$1), t.bt(v$1, b$2, f$1), t.bt(v$1, x$1, m$1), t.bt(v$1, x$1, f$1)), new ui$1(y$1, [
							m$1,
							f$1,
							g$2,
							v$1,
							b$2,
							x$1
						], r$2, a$2);
					}
				}
			}
			function mi$1(e$1, i$1) {
				let o$1 = Infinity, r$1 = -Infinity;
				for (const a$1 of i$1) {
					const i$2 = t.aX(e$1, a$1);
					o$1 = Math.min(o$1, i$2), r$1 = Math.max(r$1, i$2);
				}
				return {
					min: o$1,
					max: r$1
				};
			}
			class fi$1 {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1) {
					this._helper.resize(e$1, t$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1) {}
				constructor() {
					this._cachedClippingPlane = t.bv(), this._projectionMatrix = t.b9(), this._globeViewProjMatrix32f = t.b8(), this._globeViewProjMatrixNoCorrection = t.b9(), this._globeViewProjMatrixNoCorrectionInverted = t.b9(), this._globeProjMatrixInverted = t.b9(), this._cameraPosition = t.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Rt$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$1, t$1) => this.getConstrained(e$1, t$1)
					}), this._coveringTilesDetailsProvider = new pi$1();
				}
				clone() {
					const e$1 = new fi$1();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1) {
					this._globeLatitudeErrorCorrectionRadians = t$1 || 0, this._helper.apply(e$1);
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._globeViewProjMatrixNoCorrection;
				}
				get inverseProjectionMatrix() {
					return this._globeProjMatrixInverted;
				}
				get cameraPosition() {
					const e$1 = t.bp();
					return e$1[0] = this._cameraPosition[0], e$1[1] = this._cameraPosition[1], e$1[2] = this._cameraPosition[2], e$1;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				getProjectionData(e$1) {
					const { overscaledTileID: t$1, applyGlobeMatrix: i$1 } = e$1, o$1 = this._helper.getMercatorTileCoordinates(t$1);
					return {
						mainMatrix: this._globeViewProjMatrix32f,
						tileMercatorCoords: o$1,
						clippingPlane: this._cachedClippingPlane,
						projectionTransition: i$1 ? 1 : 0,
						fallbackMatrix: this._globeViewProjMatrix32f
					};
				}
				_computeClippingPlane(e$1) {
					const i$1 = this.pitchInRadians, o$1 = this.cameraToCenterDistance / e$1, r$1 = Math.sin(i$1) * o$1, a$1 = Math.cos(i$1) * o$1 + 1, s$1 = 1 / Math.sqrt(r$1 * r$1 + a$1 * a$1) * 1;
					let n$1 = -r$1, l$1 = a$1;
					const c$1 = Math.sqrt(n$1 * n$1 + l$1 * l$1);
					n$1 /= c$1, l$1 /= c$1;
					const h$1 = [
						0,
						n$1,
						l$1
					];
					t.bw(h$1, h$1, [
						0,
						0,
						0
					], -this.bearingInRadians), t.bx(h$1, h$1, [
						0,
						0,
						0
					], -1 * this.center.lat * Math.PI / 180), t.by(h$1, h$1, [
						0,
						0,
						0
					], this.center.lng * Math.PI / 180);
					const u$1 = 1 / t.aZ(h$1);
					return t.aR(h$1, h$1, u$1), [...h$1, -s$1 * u$1];
				}
				isLocationOccluded(e$1) {
					return !this.isSurfacePointVisible(ii$1(e$1));
				}
				transformLightDirection(e$1) {
					const i$1 = this._helper._center.lng * Math.PI / 180, o$1 = this._helper._center.lat * Math.PI / 180, r$1 = Math.cos(o$1), a$1 = [
						Math.sin(i$1) * r$1,
						Math.sin(o$1),
						Math.cos(i$1) * r$1
					], s$1 = [
						a$1[2],
						0,
						-a$1[0]
					], n$1 = [
						0,
						0,
						0
					];
					t.aW(n$1, s$1, a$1), t.aV(s$1, s$1), t.aV(n$1, n$1);
					const l$1 = [
						0,
						0,
						0
					];
					return t.aV(l$1, [
						s$1[0] * e$1[0] + n$1[0] * e$1[1] + a$1[0] * e$1[2],
						s$1[1] * e$1[0] + n$1[1] * e$1[1] + a$1[1] * e$1[2],
						s$1[2] * e$1[0] + n$1[2] * e$1[1] + a$1[2] * e$1[2]
					]), l$1;
				}
				getPixelScale() {
					return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getCircleRadiusCorrection() {
					return Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getPitchedTextCorrection(e$1, i$1, o$1) {
					const r$1 = function(e$2, i$2, o$2) {
						const r$2 = 1 / (1 << o$2.z);
						return new t.a1(e$2 / t.$ * r$2 + o$2.x * r$2, i$2 / t.$ * r$2 + o$2.y * r$2);
					}(e$1, i$1, o$1.canonical), a$1 = (s$1 = r$1.y, [t.bo(r$1.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s$1 * Math.PI * 2)) - .5 * Math.PI]);
					var s$1;
					return this.getCircleRadiusCorrection() / Math.cos(a$1[1]);
				}
				projectTileCoordinates(e$1, i$1, o$1, r$1) {
					const a$1 = o$1.canonical, s$1 = ti$1(e$1, i$1, a$1.x, a$1.y, a$1.z), n$1 = 1 + (r$1 ? r$1(e$1, i$1) : 0) / t.bu, l$1 = [
						s$1[0] * n$1,
						s$1[1] * n$1,
						s$1[2] * n$1,
						1
					];
					t.aw(l$1, l$1, this._globeViewProjMatrixNoCorrection);
					const c$1 = this._cachedClippingPlane, h$1 = c$1[0] * s$1[0] + c$1[1] * s$1[1] + c$1[2] * s$1[2] + c$1[3] < 0;
					return {
						point: new t.P(l$1[0] / l$1[3], l$1[1] / l$1[3]),
						signedDistanceFromCamera: l$1[3],
						isOccluded: h$1
					};
				}
				_calcMatrices() {
					if (!this._helper._width || !this._helper._height) return;
					const e$1 = oi$1(this.worldSize, this.center.lat), i$1 = t.ba(), o$1 = t.ba();
					this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e$1), t.b4(i$1, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
					const r$1 = this.centerOffset;
					i$1[8] = 2 * -r$1.x / this._helper._width, i$1[9] = 2 * r$1.y / this._helper._height, this._projectionMatrix = t.b5(i$1), this._globeProjMatrixInverted = t.ba(), t.aq(this._globeProjMatrixInverted, i$1), t.M(i$1, i$1, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(i$1, i$1, this.rollInRadians), t.b7(i$1, i$1, -this.pitchInRadians), t.b6(i$1, i$1, this.bearingInRadians), t.M(i$1, i$1, [
						0,
						0,
						-e$1
					]);
					const a$1 = t.bp();
					a$1[0] = e$1, a$1[1] = e$1, a$1[2] = e$1, t.b7(o$1, i$1, this.center.lat * Math.PI / 180), t.bz(o$1, o$1, -this.center.lng * Math.PI / 180), t.N(o$1, o$1, a$1), this._globeViewProjMatrixNoCorrection = o$1, t.b7(i$1, i$1, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bz(i$1, i$1, -this.center.lng * Math.PI / 180), t.N(i$1, i$1, a$1), this._globeViewProjMatrix32f = new Float32Array(i$1), this._globeViewProjMatrixNoCorrectionInverted = t.ba(), t.aq(this._globeViewProjMatrixNoCorrectionInverted, o$1);
					const s$1 = t.bp();
					this._cameraPosition = t.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e$1, t.bw(this._cameraPosition, this._cameraPosition, s$1, -this.rollInRadians), t.bx(this._cameraPosition, this._cameraPosition, s$1, this.pitchInRadians), t.bw(this._cameraPosition, this._cameraPosition, s$1, -this.bearingInRadians), t.aS(this._cameraPosition, this._cameraPosition, [
						0,
						0,
						1
					]), t.bx(this._cameraPosition, this._cameraPosition, s$1, -this.center.lat * Math.PI / 180), t.by(this._cameraPosition, this._cameraPosition, s$1, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e$1);
					const n$1 = t.b5(this._globeViewProjMatrixNoCorrectionInverted);
					t.N(n$1, n$1, [
						1,
						1,
						-1
					]), this._cachedFrustum = At$1.fromInvProjectionMatrix(n$1, 1, 0, this._cachedClippingPlane, !0);
				}
				calculateFogMatrix(e$1) {
					t.w("calculateFogMatrix is not supported on globe projection.");
					const i$1 = t.ba();
					return t.ag(i$1), i$1;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return [new t.b2(0, e$1)];
				}
				getCameraFrustum() {
					return this._cachedFrustum;
				}
				getClippingPlane() {
					return this._cachedClippingPlane;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					e$1 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
				}
				maxPitchScaleFactor() {
					return 1;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					if (!this._globeViewProjMatrixNoCorrection) return 1;
					const o$1 = ii$1(e$1);
					t.aR(o$1, o$1, 1 + i$1 / t.bu);
					const r$1 = t.bv();
					return t.aw(r$1, [
						o$1[0],
						o$1[1],
						o$1[2],
						1
					], this._globeViewProjMatrixNoCorrection), r$1[2] / r$1[3];
				}
				populateCache(e$1) {}
				getBounds() {
					const e$1 = .5 * this.width, i$1 = .5 * this.height, o$1 = [
						new t.P(0, 0),
						new t.P(e$1, 0),
						new t.P(this.width, 0),
						new t.P(this.width, i$1),
						new t.P(this.width, this.height),
						new t.P(e$1, this.height),
						new t.P(0, this.height),
						new t.P(0, i$1)
					], r$1 = [];
					for (const e$2 of o$1) r$1.push(this.unprojectScreenPoint(e$2));
					let a$1 = 0, s$1 = 0, n$1 = 0, l$1 = 0;
					const c$1 = this.center;
					for (const e$2 of r$1) {
						const i$2 = t.bA(c$1.lng, e$2.lng), o$2 = t.bA(c$1.lat, e$2.lat);
						i$2 < s$1 && (s$1 = i$2), i$2 > a$1 && (a$1 = i$2), o$2 < l$1 && (l$1 = o$2), o$2 > n$1 && (n$1 = o$2);
					}
					const h$1 = [
						c$1.lng + s$1,
						c$1.lat + l$1,
						c$1.lng + a$1,
						c$1.lat + n$1
					];
					return this.isSurfacePointOnScreen([
						0,
						1,
						0
					]) && (h$1[3] = 90, h$1[0] = -180, h$1[2] = 180), this.isSurfacePointOnScreen([
						0,
						-1,
						0
					]) && (h$1[1] = -90, h$1[0] = -180, h$1[2] = 180), new G$1(h$1);
				}
				getConstrained(e$1, i$1) {
					const o$1 = t.ah(e$1.lat, -t.ai, t.ai), r$1 = t.ah(+i$1, this.minZoom + si$1(0, o$1), this.maxZoom);
					return {
						center: new t.S(e$1.lng, o$1),
						zoom: r$1
					};
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const o$1 = ii$1(this.unprojectScreenPoint(i$1)), r$1 = ii$1(e$1), a$1 = t.bp();
					t.bB(a$1);
					const s$1 = t.bp();
					t.by(s$1, o$1, a$1, -this.center.lng * Math.PI / 180), t.bx(s$1, s$1, a$1, this.center.lat * Math.PI / 180);
					const n$1 = r$1[0] * r$1[0] + r$1[2] * r$1[2], l$1 = s$1[0] * s$1[0];
					if (n$1 < l$1) return;
					const c$1 = Math.sqrt(n$1 - l$1), h$1 = -c$1, u$1 = t.bC(r$1[0], r$1[2], s$1[0], c$1), d$1 = t.bC(r$1[0], r$1[2], s$1[0], h$1), _$2 = t.bp();
					t.by(_$2, r$1, a$1, -u$1);
					const p$1 = t.bC(_$2[1], _$2[2], s$1[1], s$1[2]), m$1 = t.bp();
					t.by(m$1, r$1, a$1, -d$1);
					const f$1 = t.bC(m$1[1], m$1[2], s$1[1], s$1[2]), g$2 = .5 * Math.PI, v$1 = p$1 >= -g$2 && p$1 <= g$2, b$2 = f$1 >= -g$2 && f$1 <= g$2;
					let x$1, y$1;
					if (v$1 && b$2) {
						const e$2 = this.center.lng * Math.PI / 180, i$2 = this.center.lat * Math.PI / 180;
						t.bD(u$1, e$2) + t.bD(p$1, i$2) < t.bD(d$1, e$2) + t.bD(f$1, i$2) ? (x$1 = u$1, y$1 = p$1) : (x$1 = d$1, y$1 = f$1);
					} else if (v$1) x$1 = u$1, y$1 = p$1;
					else {
						if (!b$2) return;
						x$1 = d$1, y$1 = f$1;
					}
					const w$1 = x$1 / Math.PI * 180, T$2 = y$1 / Math.PI * 180, P$2 = this.center.lat;
					this.setCenter(new t.S(w$1, t.ah(T$2, -90, 90))), this.setZoom(this.zoom + si$1(P$2, this.center.lat));
				}
				locationToScreenPoint(e$1, i$1) {
					const o$1 = ii$1(e$1);
					if (i$1) {
						const r$1 = i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom);
						t.aR(o$1, o$1, 1 + r$1 / t.bu);
					}
					return this._projectSurfacePointToScreen(o$1);
				}
				_projectSurfacePointToScreen(e$1) {
					const i$1 = t.bv();
					return t.aw(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], new t.P((.5 * i$1[0] + .5) * this.width, (.5 * -i$1[1] + .5) * this.height);
				}
				screenPointToMercatorCoordinate(e$1, i$1) {
					if (i$1) {
						const t$1 = i$1.pointCoordinate(e$1);
						if (t$1) return t$1;
					}
					return t.a1.fromLngLat(this.unprojectScreenPoint(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				isPointOnMapSurface(e$1, t$1) {
					const i$1 = this._cameraPosition, o$1 = this.getRayDirectionFromPixel(e$1);
					return !!this.rayPlanetIntersection(i$1, o$1);
				}
				getRayDirectionFromPixel(e$1) {
					const i$1 = t.bv();
					i$1[0] = e$1.x / this.width * 2 - 1, i$1[1] = -1 * (e$1.y / this.height * 2 - 1), i$1[2] = 1, i$1[3] = 1, t.aw(i$1, i$1, this._globeViewProjMatrixNoCorrectionInverted), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3];
					const o$1 = t.bp();
					o$1[0] = i$1[0] - this._cameraPosition[0], o$1[1] = i$1[1] - this._cameraPosition[1], o$1[2] = i$1[2] - this._cameraPosition[2];
					const r$1 = t.bp();
					return t.aV(r$1, o$1), r$1;
				}
				isSurfacePointVisible(e$1) {
					const t$1 = this._cachedClippingPlane;
					return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3] >= 0;
				}
				isSurfacePointOnScreen(e$1) {
					if (!this.isSurfacePointVisible(e$1)) return !1;
					const i$1 = t.bv();
					return t.aw(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3], i$1[0] > -1 && i$1[0] < 1 && i$1[1] > -1 && i$1[1] < 1 && i$1[2] > -1 && i$1[2] < 1;
				}
				rayPlanetIntersection(e$1, i$1) {
					const o$1 = t.aX(e$1, i$1), r$1 = t.bp(), a$1 = t.bp();
					t.aR(a$1, i$1, o$1), t.aU(r$1, e$1, a$1);
					const s$1 = 1 - t.aX(r$1, r$1);
					if (s$1 < 0) return null;
					const n$1 = t.aX(e$1, e$1) - 1, l$1 = -o$1 + (o$1 < 0 ? 1 : -1) * Math.sqrt(s$1), c$1 = n$1 / l$1, h$1 = l$1;
					return {
						tMin: Math.min(c$1, h$1),
						tMax: Math.max(c$1, h$1)
					};
				}
				unprojectScreenPoint(e$1) {
					const i$1 = this._cameraPosition, o$1 = this.getRayDirectionFromPixel(e$1), r$1 = this.rayPlanetIntersection(i$1, o$1);
					if (r$1) {
						const e$2 = t.bp();
						t.aS(e$2, i$1, [
							o$1[0] * r$1.tMin,
							o$1[1] * r$1.tMin,
							o$1[2] * r$1.tMin
						]);
						const a$2 = t.bp();
						return t.aV(a$2, e$2), ri$1(a$2);
					}
					const a$1 = this._cachedClippingPlane, s$1 = a$1[0] * o$1[0] + a$1[1] * o$1[1] + a$1[2] * o$1[2], n$1 = -t.b1(a$1, i$1) / s$1, l$1 = t.bp();
					if (n$1 > 0) t.aS(l$1, i$1, [
						o$1[0] * n$1,
						o$1[1] * n$1,
						o$1[2] * n$1
					]);
					else {
						const e$2 = t.bp();
						t.aS(e$2, i$1, [
							2 * o$1[0],
							2 * o$1[1],
							2 * o$1[2]
						]);
						const r$2 = t.b1(this._cachedClippingPlane, e$2);
						t.aU(l$1, e$2, [
							this._cachedClippingPlane[0] * r$2,
							this._cachedClippingPlane[1] * r$2,
							this._cachedClippingPlane[2] * r$2
						]);
					}
					const c$1 = function(e$2) {
						const i$2 = t.bp();
						return i$2[0] = e$2[0] * -e$2[3], i$2[1] = e$2[1] * -e$2[3], i$2[2] = e$2[2] * -e$2[3], {
							center: i$2,
							radius: Math.sqrt(1 - e$2[3] * e$2[3])
						};
					}(a$1);
					return ri$1(function(e$2, i$2, o$2) {
						const r$2 = t.bp();
						t.aU(r$2, o$2, e$2);
						const a$2 = t.bp();
						return t.bq(a$2, e$2, r$2, i$2 / t.a$(r$2)), a$2;
					}(c$1.center, c$1.radius, l$1));
				}
				getMatrixForModel(e$1, i$1) {
					const o$1 = t.S.convert(e$1), r$1 = 1 / t.bu, a$1 = t.b9();
					return t.bz(a$1, a$1, o$1.lng / 180 * Math.PI), t.b7(a$1, a$1, -o$1.lat / 180 * Math.PI), t.M(a$1, a$1, [
						0,
						0,
						1 + i$1 / t.bu
					]), t.b7(a$1, a$1, .5 * Math.PI), t.N(a$1, a$1, [
						r$1,
						r$1,
						r$1
					]), a$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = this.getProjectionData({
						overscaledTileID: new t.Z(0, 0, 0, 0, 0),
						applyGlobeMatrix: e$1
					});
					return i$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					], i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {}
			}
			class gi$1 {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				get isGlobeRendering() {
					return this._globeness > 0;
				}
				setTransitionState(e$1, t$1) {
					this._globeness = e$1, this._globeLatitudeErrorCorrectionRadians = t$1, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
				}
				get currentTransform() {
					return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
				}
				constructor() {
					this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Rt$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$1, t$1) => this.getConstrained(e$1, t$1)
					}), this._globeness = 1, this._mercatorTransform = new Lt$1(), this._verticalPerspectiveTransform = new fi$1();
				}
				clone() {
					const e$1 = new gi$1();
					return e$1._globeness = this._globeness, e$1._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e$1.apply(this), e$1;
				}
				apply(e$1) {
					this._helper.apply(e$1), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
				}
				get projectionMatrix() {
					return this.currentTransform.projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this.currentTransform.modelViewProjectionMatrix;
				}
				get inverseProjectionMatrix() {
					return this.currentTransform.inverseProjectionMatrix;
				}
				get cameraPosition() {
					return this.currentTransform.cameraPosition;
				}
				getProjectionData(e$1) {
					const t$1 = this._mercatorTransform.getProjectionData(e$1), i$1 = this._verticalPerspectiveTransform.getProjectionData(e$1);
					return {
						mainMatrix: this.isGlobeRendering ? i$1.mainMatrix : t$1.mainMatrix,
						clippingPlane: i$1.clippingPlane,
						tileMercatorCoords: i$1.tileMercatorCoords,
						projectionTransition: e$1.applyGlobeMatrix ? this._globeness : 0,
						fallbackMatrix: t$1.fallbackMatrix
					};
				}
				isLocationOccluded(e$1) {
					return this.currentTransform.isLocationOccluded(e$1);
				}
				transformLightDirection(e$1) {
					return this.currentTransform.transformLightDirection(e$1);
				}
				getPixelScale() {
					return t.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
				}
				getCircleRadiusCorrection() {
					return t.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
				}
				getPitchedTextCorrection(e$1, i$1, o$1) {
					const r$1 = this._mercatorTransform.getPitchedTextCorrection(e$1, i$1, o$1), a$1 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e$1, i$1, o$1);
					return t.bk(r$1, a$1, this._globeness);
				}
				projectTileCoordinates(e$1, t$1, i$1, o$1) {
					return this.currentTransform.projectTileCoordinates(e$1, t$1, i$1, o$1);
				}
				_calcMatrices() {
					this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
				}
				calculateFogMatrix(e$1) {
					return this.currentTransform.calculateFogMatrix(e$1);
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return this.currentTransform.getVisibleUnwrappedCoordinates(e$1);
				}
				getCameraFrustum() {
					return this.currentTransform.getCameraFrustum();
				}
				getClippingPlane() {
					return this.currentTransform.getClippingPlane();
				}
				getCoveringTilesDetailsProvider() {
					return this.currentTransform.getCoveringTilesDetailsProvider();
				}
				recalculateZoomAndCenter(e$1) {
					this._mercatorTransform.recalculateZoomAndCenter(e$1), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e$1);
				}
				maxPitchScaleFactor() {
					return this._mercatorTransform.maxPitchScaleFactor();
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, t$1) {
					return this.currentTransform.lngLatToCameraDepth(e$1, t$1);
				}
				populateCache(e$1) {
					this._mercatorTransform.populateCache(e$1), this._verticalPerspectiveTransform.populateCache(e$1);
				}
				getBounds() {
					return this.currentTransform.getBounds();
				}
				getConstrained(e$1, t$1) {
					return this.currentTransform.getConstrained(e$1, t$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				setLocationAtPoint(e$1, t$1) {
					if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e$1, t$1), void this.apply(this._mercatorTransform);
					this._verticalPerspectiveTransform.setLocationAtPoint(e$1, t$1), this.apply(this._verticalPerspectiveTransform);
				}
				locationToScreenPoint(e$1, t$1) {
					return this.currentTransform.locationToScreenPoint(e$1, t$1);
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					return this.currentTransform.screenPointToMercatorCoordinate(e$1, t$1);
				}
				screenPointToLocation(e$1, t$1) {
					return this.currentTransform.screenPointToLocation(e$1, t$1);
				}
				isPointOnMapSurface(e$1, t$1) {
					return this.currentTransform.isPointOnMapSurface(e$1, t$1);
				}
				getRayDirectionFromPixel(e$1) {
					return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e$1);
				}
				getMatrixForModel(e$1, t$1) {
					return this.currentTransform.getMatrixForModel(e$1, t$1);
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const t$1 = this._mercatorTransform.getProjectionDataForCustomLayer(e$1);
					if (!this.isGlobeRendering) return t$1;
					const i$1 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e$1);
					return i$1.fallbackMatrix = t$1.mainMatrix, i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.currentTransform.getFastPathSimpleProjectionMatrix(e$1);
				}
			}
			class vi$1 {
				get useGlobeControls() {
					return !0;
				}
				handlePanInertia(e$1, i$1) {
					const o$1 = ni$1(e$1, i$1);
					return Math.abs(o$1.lng - i$1.center.lng) > 180 && (o$1.lng = i$1.center.lng + 179.5 * Math.sign(o$1.lng - i$1.center.lng)), {
						easingCenter: o$1,
						easingOffset: new t.P(0, 0)
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, i$1) {
					const o$1 = e$1.around, r$1 = i$1.screenPointToLocation(o$1);
					e$1.bearingDelta && i$1.setBearing(i$1.bearing + e$1.bearingDelta), e$1.pitchDelta && i$1.setPitch(i$1.pitch + e$1.pitchDelta), e$1.rollDelta && i$1.setRoll(i$1.roll + e$1.rollDelta);
					const a$1 = i$1.zoom;
					e$1.zoomDelta && i$1.setZoom(i$1.zoom + e$1.zoomDelta);
					const s$1 = i$1.zoom - a$1;
					if (0 === s$1) return;
					const n$1 = t.bA(i$1.center.lng, r$1.lng), l$1 = n$1 / (Math.abs(n$1 / 180) + 1), c$1 = t.bA(i$1.center.lat, r$1.lat), h$1 = i$1.getRayDirectionFromPixel(o$1), u$1 = i$1.cameraPosition, d$1 = -1 * t.aX(u$1, h$1), _$2 = t.bp();
					t.aS(_$2, u$1, [
						h$1[0] * d$1,
						h$1[1] * d$1,
						h$1[2] * d$1
					]);
					const p$1 = t.aZ(_$2) - 1, m$1 = Math.exp(.5 * -Math.max(p$1 - .3, 0)), f$1 = oi$1(i$1.worldSize, i$1.center.lat) / Math.min(i$1.width, i$1.height), g$2 = t.bn(f$1, .9, .5, 1, .25), v$1 = (1 - t.af(-s$1)) * Math.min(m$1, g$2), b$2 = i$1.center.lat, x$1 = i$1.zoom, y$1 = new t.S(i$1.center.lng + l$1 * v$1, t.ah(i$1.center.lat + c$1 * v$1, -t.ai, t.ai));
					i$1.setLocationAtPoint(r$1, o$1);
					const w$1 = i$1.center, T$2 = t.bn(Math.abs(n$1), 45, 85, 0, 1), P$2 = t.bn(f$1, .75, .35, 0, 1), C$1 = Math.pow(Math.max(T$2, P$2), .25), I$2 = t.bA(w$1.lng, y$1.lng), M$2 = t.bA(w$1.lat, y$1.lat);
					i$1.setCenter(new t.S(w$1.lng + I$2 * C$1, w$1.lat + M$2 * C$1).wrap()), i$1.setZoom(x$1 + si$1(b$2, i$1.center.lat));
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					if (!e$1.panDelta) return;
					const o$1 = t$1.center.lat, r$1 = t$1.zoom;
					t$1.setCenter(ni$1(e$1.panDelta, t$1).wrap()), t$1.setZoom(r$1 + si$1(o$1, t$1.center.lat));
				}
				cameraForBoxAndBearing(e$1, i$1, o$1, r$1, a$1) {
					const s$1 = Bt$1(e$1, i$1, o$1, r$1, a$1), n$1 = i$1.left / a$1.width * 2 - 1, l$1 = (a$1.width - i$1.right) / a$1.width * 2 - 1, c$1 = i$1.top / a$1.height * -2 + 1, h$1 = (a$1.height - i$1.bottom) / a$1.height * -2 + 1, u$1 = t.bA(o$1.getWest(), o$1.getEast()) < 0, d$1 = u$1 ? o$1.getEast() : o$1.getWest(), _$2 = u$1 ? o$1.getWest() : o$1.getEast(), p$1 = Math.max(o$1.getNorth(), o$1.getSouth()), m$1 = Math.min(o$1.getNorth(), o$1.getSouth()), f$1 = d$1 + .5 * t.bA(d$1, _$2), g$2 = p$1 + .5 * t.bA(p$1, m$1), v$1 = a$1.clone();
					v$1.setCenter(s$1.center), v$1.setBearing(s$1.bearing), v$1.setPitch(0), v$1.setRoll(0), v$1.setZoom(s$1.zoom);
					const b$2 = v$1.modelViewProjectionMatrix, x$1 = [
						ii$1(o$1.getNorthWest()),
						ii$1(o$1.getNorthEast()),
						ii$1(o$1.getSouthWest()),
						ii$1(o$1.getSouthEast()),
						ii$1(new t.S(_$2, g$2)),
						ii$1(new t.S(d$1, g$2)),
						ii$1(new t.S(f$1, p$1)),
						ii$1(new t.S(f$1, m$1))
					], y$1 = ii$1(s$1.center);
					let w$1 = Number.POSITIVE_INFINITY;
					for (const e$2 of x$1) n$1 < 0 && (w$1 = vi$1.getLesserNonNegativeNonNull(w$1, vi$1.solveVectorScale(e$2, y$1, b$2, "x", n$1))), l$1 > 0 && (w$1 = vi$1.getLesserNonNegativeNonNull(w$1, vi$1.solveVectorScale(e$2, y$1, b$2, "x", l$1))), c$1 > 0 && (w$1 = vi$1.getLesserNonNegativeNonNull(w$1, vi$1.solveVectorScale(e$2, y$1, b$2, "y", c$1))), h$1 < 0 && (w$1 = vi$1.getLesserNonNegativeNonNull(w$1, vi$1.solveVectorScale(e$2, y$1, b$2, "y", h$1)));
					if (Number.isFinite(w$1) && 0 !== w$1) return s$1.zoom = v$1.zoom + t.ak(w$1), s$1;
					kt$1();
				}
				handleJumpToCenterZoom(e$1, i$1) {
					const o$1 = e$1.center.lat, r$1 = e$1.getConstrained(i$1.center ? t.S.convert(i$1.center) : e$1.center, e$1.zoom).center;
					e$1.setCenter(r$1.wrap());
					const a$1 = void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom + si$1(o$1, r$1.lat);
					e$1.zoom !== a$1 && e$1.setZoom(a$1);
				}
				handleEaseTo(e$1, i$1) {
					const o$1 = e$1.zoom, r$1 = e$1.center, a$1 = e$1.padding, s$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, n$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, l$1 = void 0 !== i$1.zoom, c$1 = !e$1.isPaddingEqual(i$1.padding);
					let h$1 = !1;
					const u$1 = i$1.center ? t.S.convert(i$1.center) : r$1, d$1 = e$1.getConstrained(u$1, o$1).center;
					St$1(e$1, d$1);
					const _$2 = e$1.clone();
					_$2.setCenter(d$1), _$2.setZoom(l$1 ? +i$1.zoom : o$1 + si$1(r$1.lat, u$1.lat)), _$2.setBearing(i$1.bearing);
					const p$1 = new t.P(t.ah(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ah(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					_$2.setLocationAtPoint(d$1, p$1);
					const m$1 = (i$1.offset && i$1.offsetAsPoint.mag()) > 0 ? _$2.center : d$1, f$1 = l$1 ? +i$1.zoom : o$1 + si$1(r$1.lat, m$1.lat), g$2 = o$1 + si$1(r$1.lat, 0), v$1 = f$1 + si$1(m$1.lat, 0), b$2 = t.bA(r$1.lng, m$1.lng), x$1 = t.bA(r$1.lat, m$1.lat), y$1 = t.af(v$1 - g$2);
					return h$1 = f$1 !== o$1, {
						easeFunc: (o$2) => {
							if (t.be(s$1, n$1) || Ft({
								startEulerAngles: s$1,
								endEulerAngles: n$1,
								tr: e$1,
								k: o$2,
								useSlerp: s$1.roll != n$1.roll
							}), c$1 && e$1.interpolatePadding(a$1, i$1.padding, o$2), i$1.around) t.w("Easing around a point is not supported under globe projection."), e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const t$1 = v$1 > g$2 ? Math.min(2, y$1) : Math.max(.5, y$1), a$2 = ci$1(r$1, b$2, x$1, o$2 * Math.pow(t$1, 1 - o$2));
								e$1.setCenter(a$2.wrap());
							}
							if (h$1) {
								const i$2 = t.C.number(g$2, v$1, o$2) + si$1(0, e$1.center.lat);
								e$1.setZoom(i$2);
							}
						},
						isZooming: h$1,
						elevationCenter: m$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const o$1 = void 0 !== i$1.zoom, r$1 = e$1.center, a$1 = e$1.zoom, s$1 = e$1.padding, n$1 = !e$1.isPaddingEqual(i$1.padding), l$1 = e$1.getConstrained(t.S.convert(i$1.center || i$1.locationAtOffset), a$1).center, c$1 = o$1 ? +i$1.zoom : e$1.zoom + si$1(e$1.center.lat, l$1.lat), h$1 = e$1.clone();
					h$1.setCenter(l$1), h$1.setZoom(c$1), h$1.setBearing(i$1.bearing);
					const u$1 = new t.P(t.ah(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ah(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					h$1.setLocationAtPoint(l$1, u$1);
					const d$1 = h$1.center;
					St$1(e$1, d$1);
					const _$2 = function(e$2, i$2, o$2) {
						const r$2 = ii$1(i$2), a$2 = ii$1(o$2), s$2 = t.aX(r$2, a$2), n$2 = Math.acos(s$2), l$2 = ei$1(e$2);
						return n$2 / (2 * Math.PI) * l$2;
					}(e$1, r$1, d$1), p$1 = a$1 + si$1(r$1.lat, 0), m$1 = c$1 + si$1(d$1.lat, 0), f$1 = t.af(m$1 - p$1);
					let g$2;
					if ("number" == typeof i$1.minZoom) {
						const o$2 = +i$1.minZoom + si$1(d$1.lat, 0), r$2 = Math.min(o$2, p$1, m$1) + si$1(0, d$1.lat), a$2 = e$1.getConstrained(d$1, r$2).zoom + si$1(d$1.lat, 0);
						g$2 = t.af(a$2 - p$1);
					}
					const v$1 = t.bA(r$1.lng, d$1.lng), b$2 = t.bA(r$1.lat, d$1.lat);
					return {
						easeFunc: (o$2, a$2, l$2, h$2) => {
							const u$2 = ci$1(r$1, v$1, b$2, l$2);
							n$1 && e$1.interpolatePadding(s$1, i$1.padding, o$2);
							const _$3 = 1 === o$2 ? d$1 : u$2;
							e$1.setCenter(_$3.wrap());
							const m$2 = p$1 + t.ak(a$2);
							e$1.setZoom(1 === o$2 ? c$1 : m$2 + si$1(0, _$3.lat));
						},
						scaleOfZoom: f$1,
						targetCenter: d$1,
						scaleOfMinZoom: g$2,
						pixelPathLength: _$2
					};
				}
				static solveVectorScale(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = "x" === o$1 ? [
						i$1[0],
						i$1[4],
						i$1[8],
						i$1[12]
					] : [
						i$1[1],
						i$1[5],
						i$1[9],
						i$1[13]
					], s$1 = [
						i$1[3],
						i$1[7],
						i$1[11],
						i$1[15]
					], n$1 = e$1[0] * a$1[0] + e$1[1] * a$1[1] + e$1[2] * a$1[2], l$1 = e$1[0] * s$1[0] + e$1[1] * s$1[1] + e$1[2] * s$1[2], c$1 = t$1[0] * a$1[0] + t$1[1] * a$1[1] + t$1[2] * a$1[2], h$1 = t$1[0] * s$1[0] + t$1[1] * s$1[1] + t$1[2] * s$1[2];
					return c$1 + r$1 * l$1 === n$1 + r$1 * h$1 || s$1[3] * (n$1 - c$1) + a$1[3] * (h$1 - l$1) + n$1 * h$1 == c$1 * l$1 ? null : (c$1 + a$1[3] - r$1 * h$1 - r$1 * s$1[3]) / (c$1 - n$1 - r$1 * h$1 + r$1 * l$1);
				}
				static getLesserNonNegativeNonNull(e$1, t$1) {
					return null !== t$1 && t$1 >= 0 && t$1 < e$1 ? t$1 : e$1;
				}
			}
			class bi$1 {
				constructor(e$1) {
					this._globe = e$1, this._mercatorCameraHelper = new Ot(), this._verticalPerspectiveCameraHelper = new vi$1();
				}
				get useGlobeControls() {
					return this._globe.useGlobeRendering;
				}
				get currentHelper() {
					return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
				}
				handlePanInertia(e$1, t$1) {
					return this.currentHelper.handlePanInertia(e$1, t$1);
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					return this.currentHelper.handleMapControlsRollPitchBearingZoom(e$1, t$1);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					this.currentHelper.handleMapControlsPan(e$1, t$1, i$1);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1) {
					return this.currentHelper.cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1);
				}
				handleJumpToCenterZoom(e$1, t$1) {
					this.currentHelper.handleJumpToCenterZoom(e$1, t$1);
				}
				handleEaseTo(e$1, t$1) {
					return this.currentHelper.handleEaseTo(e$1, t$1);
				}
				handleFlyTo(e$1, t$1) {
					return this.currentHelper.handleFlyTo(e$1, t$1);
				}
			}
			const xi$1 = (e$1, i$1) => t.y(e$1, i$1 && i$1.filter(((e$2) => "source.canvas" !== e$2.identifier))), yi$1 = t.bE();
			class wi extends t.E {
				constructor(e$1, i$1 = {}) {
					super(), this._rtlPluginLoaded = () => {
						for (const e$2 in this.sourceCaches) {
							const t$1 = this.sourceCaches[e$2].getSource().type;
							"vector" !== t$1 && "geojson" !== t$1 || this.sourceCaches[e$2].reload();
						}
					}, this.map = e$1, this.dispatcher = new F$1(k$1(), e$1._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e$2, t$1) => this.getGlyphs(e$2, t$1))), this.dispatcher.registerMessageHandler("GI", ((e$2, t$1) => this.getImages(e$2, t$1))), this.imageManager = new b$1(), this.imageManager.setEventedParent(this), this.glyphManager = new T$1(e$1._requestManager, i$1.localIdeographFontFamily), this.lineAtlas = new E(256, 512), this.crossTileSymbolIndex = new vt$1(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", t.bG()), oe$1().on(ee, this._rtlPluginLoaded), this.on("data", ((e$2) => {
						if ("source" !== e$2.dataType || "metadata" !== e$2.sourceDataType) return;
						const t$1 = this.sourceCaches[e$2.sourceId];
						if (!t$1) return;
						const i$2 = t$1.getSource();
						if (i$2 && i$2.vectorLayerIds) for (const e$3 in this._layers) {
							const t$2 = this._layers[e$3];
							t$2.source === i$2.id && this._validateLayer(t$2);
						}
					}));
				}
				setGlobalStateProperty(e$1, i$1) {
					var o$1, r$1, a$1;
					this._checkLoaded();
					const s$1 = null === i$1 ? null !== (a$1 = null === (r$1 = null === (o$1 = this.stylesheet.state) || void 0 === o$1 ? void 0 : o$1[e$1]) || void 0 === r$1 ? void 0 : r$1.default) && void 0 !== a$1 ? a$1 : null : i$1;
					if (t.bH(s$1, this._globalState[e$1])) return this;
					this._globalState[e$1] = s$1;
					const n$1 = this._findGlobalStateAffectedSources([e$1]);
					for (const e$2 in this.sourceCaches) n$1.has(e$2) && (this._reloadSource(e$2), this._changed = !0);
				}
				getGlobalState() {
					return this._globalState;
				}
				setGlobalState(e$1) {
					this._checkLoaded();
					const i$1 = [];
					for (const o$2 in e$1) !t.bH(this._globalState[o$2], e$1[o$2].default) && (i$1.push(o$2), this._globalState[o$2] = e$1[o$2].default);
					const o$1 = this._findGlobalStateAffectedSources(i$1);
					for (const e$2 in this.sourceCaches) o$1.has(e$2) && (this._reloadSource(e$2), this._changed = !0);
				}
				_findGlobalStateAffectedSources(e$1) {
					if (0 === e$1.length) return /* @__PURE__ */ new Set();
					const t$1 = /* @__PURE__ */ new Set();
					for (const i$1 in this._layers) {
						const o$1 = this._layers[i$1], r$1 = o$1.getLayoutAffectingGlobalStateRefs();
						for (const i$2 of e$1) r$1.has(i$2) && t$1.add(o$1.source);
					}
					return t$1;
				}
				loadURL(e$1, i$1 = {}, o$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), i$1.validate = "boolean" != typeof i$1.validate || i$1.validate;
					const r$1 = this.map._requestManager.transformRequest(e$1, "Style");
					this._loadStyleRequest = new AbortController();
					const a$1 = this._loadStyleRequest;
					t.j(r$1, this._loadStyleRequest).then(((e$2) => {
						this._loadStyleRequest = null, this._load(e$2.data, i$1, o$1);
					})).catch(((e$2) => {
						this._loadStyleRequest = null, e$2 && !a$1.signal.aborted && this.fire(new t.k(e$2));
					}));
				}
				loadJSON(e$1, i$1 = {}, o$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s.frameAsync(this._frameRequest).then((() => {
						this._frameRequest = null, i$1.validate = !1 !== i$1.validate, this._load(e$1, i$1, o$1);
					})).catch((() => {}));
				}
				loadEmpty() {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._load(yi$1, { validate: !1 });
				}
				_load(e$1, i$1, o$1) {
					var r$1, a$1, s$1;
					const n$1 = i$1.transformStyle ? i$1.transformStyle(o$1, e$1) : e$1;
					if (!i$1.validate || !xi$1(this, t.z(n$1))) {
						this._loaded = !0, this.stylesheet = n$1;
						for (const e$2 in n$1.sources) this.addSource(e$2, n$1.sources[e$2], { validate: !1 });
						n$1.sprite ? this._loadSprite(n$1.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(n$1.glyphs), this._createLayers(), this.light = new I$1(this.stylesheet.light), this._setProjectionInternal((null === (r$1 = this.stylesheet.projection) || void 0 === r$1 ? void 0 : r$1.type) || "mercator"), this.sky = new S$1(this.stylesheet.sky), this.map.setTerrain(null !== (a$1 = this.stylesheet.terrain) && void 0 !== a$1 ? a$1 : null), this.setGlobalState(null !== (s$1 = this.stylesheet.state) && void 0 !== s$1 ? s$1 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
					}
				}
				_createLayers() {
					const e$1 = t.bI(this.stylesheet.layers);
					this.dispatcher.broadcast("SL", e$1), this._order = e$1.map(((e$2) => e$2.id)), this._layers = {}, this._serializedLayers = null;
					for (const i$1 of e$1) {
						const e$2 = t.bJ(i$1);
						e$2.setEventedParent(this, { layer: { id: i$1.id } }), this._layers[i$1.id] = e$2;
					}
				}
				_loadSprite(e$1, i$1 = !1, o$1 = void 0) {
					let r$1;
					this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(e$2, i$2, o$2, r$2) {
						return t._(this, void 0, void 0, (function* () {
							const a$1 = f(e$2), n$1 = o$2 > 1 ? "@2x" : "", l$1 = {}, c$1 = {};
							for (const { id: e$3, url: o$3 } of a$1) {
								const a$2 = i$2.transformRequest(g$1(o$3, n$1, ".json"), "SpriteJSON");
								l$1[e$3] = t.j(a$2, r$2);
								const s$1 = i$2.transformRequest(g$1(o$3, n$1, ".png"), "SpriteImage");
								c$1[e$3] = p.getImage(s$1, r$2);
							}
							return yield Promise.all([...Object.values(l$1), ...Object.values(c$1)]), function(e$3, i$3) {
								return t._(this, void 0, void 0, (function* () {
									const t$1 = {};
									for (const o$3 in e$3) {
										t$1[o$3] = {};
										const r$3 = s.getImageCanvasContext((yield i$3[o$3]).data), a$2 = (yield e$3[o$3]).data;
										for (const e$4 in a$2) {
											const { width: i$4, height: s$1, x: n$2, y: l$2, sdf: c$2, pixelRatio: h$1, stretchX: u$1, stretchY: d$1, content: _$2, textFitWidth: p$1, textFitHeight: m$1 } = a$2[e$4];
											t$1[o$3][e$4] = {
												data: null,
												pixelRatio: h$1,
												sdf: c$2,
												stretchX: u$1,
												stretchY: d$1,
												content: _$2,
												textFitWidth: p$1,
												textFitHeight: m$1,
												spriteData: {
													width: i$4,
													height: s$1,
													x: n$2,
													y: l$2,
													context: r$3
												}
											};
										}
									}
									return t$1;
								}));
							}(l$1, c$1);
						}));
					}(e$1, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e$2) => {
						if (this._spriteRequest = null, e$2) for (const t$1 in e$2) {
							this._spritesImagesIds[t$1] = [];
							const o$2 = this._spritesImagesIds[t$1] ? this._spritesImagesIds[t$1].filter(((t$2) => !(t$2 in e$2))) : [];
							for (const e$3 of o$2) this.imageManager.removeImage(e$3), this._changedImages[e$3] = !0;
							for (const o$3 in e$2[t$1]) {
								const r$2 = "default" === t$1 ? o$3 : `${t$1}:${o$3}`;
								this._spritesImagesIds[t$1].push(r$2), r$2 in this.imageManager.images ? this.imageManager.updateImage(r$2, e$2[t$1][o$3], !1) : this.imageManager.addImage(r$2, e$2[t$1][o$3]), i$1 && (this._changedImages[r$2] = !0);
							}
						}
					})).catch(((e$2) => {
						this._spriteRequest = null, r$1 = e$2, this.fire(new t.k(r$1));
					})).finally((() => {
						this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i$1 && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), o$1 && o$1(r$1);
					}));
				}
				_unloadSprite() {
					for (const e$1 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e$1), this._changedImages[e$1] = !0;
					this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				_validateLayer(e$1) {
					const i$1 = this.sourceCaches[e$1.source];
					if (!i$1) return;
					const o$1 = e$1.sourceLayer;
					if (!o$1) return;
					const r$1 = i$1.getSource();
					("geojson" === r$1.type || r$1.vectorLayerIds && -1 === r$1.vectorLayerIds.indexOf(o$1)) && this.fire(new t.k(/* @__PURE__ */ new Error(`Source layer "${o$1}" does not exist on source "${r$1.id}" as specified by style layer "${e$1.id}".`)));
				}
				loaded() {
					if (!this._loaded) return !1;
					if (Object.keys(this._updatedSources).length) return !1;
					for (const e$1 in this.sourceCaches) if (!this.sourceCaches[e$1].loaded()) return !1;
					return !!this.imageManager.isLoaded();
				}
				_serializeByIds(e$1, i$1 = !1) {
					const o$1 = this._serializedAllLayers();
					if (!e$1 || 0 === e$1.length) return Object.values(i$1 ? t.bK(o$1) : o$1);
					const r$1 = [];
					for (const a$1 of e$1) if (o$1[a$1]) {
						const e$2 = i$1 ? t.bK(o$1[a$1]) : o$1[a$1];
						r$1.push(e$2);
					}
					return r$1;
				}
				_serializedAllLayers() {
					let e$1 = this._serializedLayers;
					if (e$1) return e$1;
					e$1 = this._serializedLayers = {};
					const t$1 = Object.keys(this._layers);
					for (const i$1 of t$1) {
						const t$2 = this._layers[i$1];
						"custom" !== t$2.type && (e$1[i$1] = t$2.serialize());
					}
					return e$1;
				}
				hasTransitions() {
					var e$1, t$1, i$1;
					if (null === (e$1 = this.light) || void 0 === e$1 ? void 0 : e$1.hasTransition()) return !0;
					if (null === (t$1 = this.sky) || void 0 === t$1 ? void 0 : t$1.hasTransition()) return !0;
					if (null === (i$1 = this.projection) || void 0 === i$1 ? void 0 : i$1.hasTransition()) return !0;
					for (const e$2 in this.sourceCaches) if (this.sourceCaches[e$2].hasTransition()) return !0;
					for (const e$2 in this._layers) if (this._layers[e$2].hasTransition()) return !0;
					return !1;
				}
				_checkLoaded() {
					if (!this._loaded) throw new Error("Style is not done loading.");
				}
				update(e$1) {
					if (!this._loaded) return;
					const i$1 = this._changed;
					if (i$1) {
						const t$1 = Object.keys(this._updatedLayers), i$2 = Object.keys(this._removedLayers);
						(t$1.length || i$2.length) && this._updateWorkerLayers(t$1, i$2);
						for (const e$2 in this._updatedSources) {
							const t$2 = this._updatedSources[e$2];
							if ("reload" === t$2) this._reloadSource(e$2);
							else {
								if ("clear" !== t$2) throw new Error(`Invalid action ${t$2}`);
								this._clearSource(e$2);
							}
						}
						this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
						for (const t$2 in this._updatedPaintProps) this._layers[t$2].updateTransitions(e$1);
						this.light.updateTransitions(e$1), this.sky.updateTransitions(e$1), this._resetUpdates();
					}
					const o$1 = {};
					for (const e$2 in this.sourceCaches) {
						const t$1 = this.sourceCaches[e$2];
						o$1[e$2] = t$1.used, t$1.used = !1;
					}
					for (const t$1 of this._order) {
						const i$2 = this._layers[t$1];
						i$2.recalculate(e$1, this._availableImages), !i$2.isHidden(e$1.zoom) && i$2.source && (this.sourceCaches[i$2.source].used = !0);
					}
					for (const e$2 in o$1) {
						const i$2 = this.sourceCaches[e$2];
						!!o$1[e$2] != !!i$2.used && i$2.fire(new t.l("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: e$2
						}));
					}
					this.light.recalculate(e$1), this.sky.recalculate(e$1), this.projection.recalculate(e$1), this.z = e$1.zoom, i$1 && this.fire(new t.l("data", { dataType: "style" }));
				}
				_updateTilesForChangedImages() {
					const e$1 = Object.keys(this._changedImages);
					if (e$1.length) {
						for (const t$1 in this.sourceCaches) this.sourceCaches[t$1].reloadTilesForDependencies(["icons", "patterns"], e$1);
						this._changedImages = {};
					}
				}
				_updateTilesForChangedGlyphs() {
					if (this._glyphsDidChange) {
						for (const e$1 in this.sourceCaches) this.sourceCaches[e$1].reloadTilesForDependencies(["glyphs"], [""]);
						this._glyphsDidChange = !1;
					}
				}
				_updateWorkerLayers(e$1, t$1) {
					this.dispatcher.broadcast("UL", {
						layers: this._serializeByIds(e$1, !1),
						removedIds: t$1
					});
				}
				_resetUpdates() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
				}
				setState(e$1, i$1 = {}) {
					var o$1;
					this._checkLoaded();
					const r$1 = this.serialize();
					if (e$1 = i$1.transformStyle ? i$1.transformStyle(r$1, e$1) : e$1, (null === (o$1 = i$1.validate) || void 0 === o$1 || o$1) && xi$1(this, t.z(e$1))) return !1;
					(e$1 = t.bK(e$1)).layers = t.bI(e$1.layers);
					const a$1 = t.bL(r$1, e$1), s$1 = this._getOperationsToPerform(a$1);
					if (s$1.unimplemented.length > 0) throw new Error(`Unimplemented: ${s$1.unimplemented.join(", ")}.`);
					if (0 === s$1.operations.length) return !1;
					for (const e$2 of s$1.operations) e$2();
					return this.stylesheet = e$1, this._serializedLayers = null, !0;
				}
				_getOperationsToPerform(e$1) {
					const t$1 = [], i$1 = [];
					for (const o$1 of e$1) switch (o$1.command) {
						case "setCenter":
						case "setZoom":
						case "setBearing":
						case "setPitch":
						case "setRoll": continue;
						case "addLayer":
							t$1.push((() => this.addLayer.apply(this, o$1.args)));
							break;
						case "removeLayer":
							t$1.push((() => this.removeLayer.apply(this, o$1.args)));
							break;
						case "setPaintProperty":
							t$1.push((() => this.setPaintProperty.apply(this, o$1.args)));
							break;
						case "setLayoutProperty":
							t$1.push((() => this.setLayoutProperty.apply(this, o$1.args)));
							break;
						case "setFilter":
							t$1.push((() => this.setFilter.apply(this, o$1.args)));
							break;
						case "addSource":
							t$1.push((() => this.addSource.apply(this, o$1.args)));
							break;
						case "removeSource":
							t$1.push((() => this.removeSource.apply(this, o$1.args)));
							break;
						case "setLayerZoomRange":
							t$1.push((() => this.setLayerZoomRange.apply(this, o$1.args)));
							break;
						case "setLight":
							t$1.push((() => this.setLight.apply(this, o$1.args)));
							break;
						case "setGeoJSONSourceData":
							t$1.push((() => this.setGeoJSONSourceData.apply(this, o$1.args)));
							break;
						case "setGlyphs":
							t$1.push((() => this.setGlyphs.apply(this, o$1.args)));
							break;
						case "setSprite":
							t$1.push((() => this.setSprite.apply(this, o$1.args)));
							break;
						case "setTerrain":
							t$1.push((() => this.map.setTerrain.apply(this, o$1.args)));
							break;
						case "setSky":
							t$1.push((() => this.setSky.apply(this, o$1.args)));
							break;
						case "setProjection":
							this.setProjection.apply(this, o$1.args);
							break;
						case "setGlobalState":
							t$1.push((() => this.setGlobalState.apply(this, o$1.args)));
							break;
						case "setTransition":
							t$1.push((() => {}));
							break;
						default: i$1.push(o$1.command);
					}
					return {
						operations: t$1,
						unimplemented: i$1
					};
				}
				addImage(e$1, i$1) {
					if (this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" already exists.`)));
					this.imageManager.addImage(e$1, i$1), this._afterImageUpdated(e$1);
				}
				updateImage(e$1, t$1) {
					this.imageManager.updateImage(e$1, t$1);
				}
				getImage(e$1) {
					return this.imageManager.getImage(e$1);
				}
				removeImage(e$1) {
					if (!this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" does not exist.`)));
					this.imageManager.removeImage(e$1), this._afterImageUpdated(e$1);
				}
				_afterImageUpdated(e$1) {
					this._availableImages = this.imageManager.listImages(), this._changedImages[e$1] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				listImages() {
					return this._checkLoaded(), this.imageManager.listImages();
				}
				addSource(e$1, i$1, o$1 = {}) {
					if (this._checkLoaded(), void 0 !== this.sourceCaches[e$1]) throw new Error(`Source "${e$1}" already exists.`);
					if (!i$1.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i$1).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(i$1.type) >= 0 && this._validate(t.z.source, `sources.${e$1}`, i$1, null, o$1)) return;
					this.map && this.map._collectResourceTiming && (i$1.collectResourceTiming = !0);
					const r$1 = this.sourceCaches[e$1] = new xe$1(e$1, i$1, this.dispatcher);
					r$1.style = this, r$1.setEventedParent(this, (() => ({
						isSourceLoaded: r$1.loaded(),
						source: r$1.serialize(),
						sourceId: e$1
					}))), r$1.onAdd(this.map), this._changed = !0;
				}
				removeSource(e$1) {
					if (this._checkLoaded(), void 0 === this.sourceCaches[e$1]) throw new Error("There is no source with this ID");
					for (const i$2 in this._layers) if (this._layers[i$2].source === e$1) return this.fire(new t.k(/* @__PURE__ */ new Error(`Source "${e$1}" cannot be removed while layer "${i$2}" is using it.`)));
					const i$1 = this.sourceCaches[e$1];
					delete this.sourceCaches[e$1], delete this._updatedSources[e$1], i$1.fire(new t.l("data", {
						sourceDataType: "metadata",
						dataType: "source",
						sourceId: e$1
					})), i$1.setEventedParent(null), i$1.onRemove(this.map), this._changed = !0;
				}
				setGeoJSONSourceData(e$1, t$1) {
					if (this._checkLoaded(), void 0 === this.sourceCaches[e$1]) throw new Error(`There is no source with this ID=${e$1}`);
					const i$1 = this.sourceCaches[e$1].getSource();
					if ("geojson" !== i$1.type) throw new Error(`geojsonSource.type is ${i$1.type}, which is !== 'geojson`);
					i$1.setData(t$1), this._changed = !0;
				}
				getSource(e$1) {
					return this.sourceCaches[e$1] && this.sourceCaches[e$1].getSource();
				}
				addLayer(e$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = e$1.id;
					if (this.getLayer(r$1)) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Layer "${r$1}" already exists on this map.`)));
					let a$1;
					if ("custom" === e$1.type) {
						if (xi$1(this, t.bM(e$1))) return;
						a$1 = t.bJ(e$1);
					} else {
						if ("source" in e$1 && "object" == typeof e$1.source && (this.addSource(r$1, e$1.source), e$1 = t.bK(e$1), e$1 = t.e(e$1, { source: r$1 })), this._validate(t.z.layer, `layers.${r$1}`, e$1, { arrayIndex: -1 }, o$1)) return;
						a$1 = t.bJ(e$1), this._validateLayer(a$1), a$1.setEventedParent(this, { layer: { id: r$1 } });
					}
					const s$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					if (i$1 && -1 === s$1) this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot add layer "${r$1}" before non-existing layer "${i$1}".`)));
					else {
						if (this._order.splice(s$1, 0, r$1), this._layerOrderChanged = !0, this._layers[r$1] = a$1, this._removedLayers[r$1] && a$1.source && "custom" !== a$1.type) {
							const e$2 = this._removedLayers[r$1];
							delete this._removedLayers[r$1], e$2.type !== a$1.type ? this._updatedSources[a$1.source] = "clear" : (this._updatedSources[a$1.source] = "reload", this.sourceCaches[a$1.source].pause());
						}
						this._updateLayer(a$1), a$1.onAdd && a$1.onAdd(this.map);
					}
				}
				moveLayer(e$1, i$1) {
					if (this._checkLoaded(), this._changed = !0, !this._layers[e$1]) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$1}' does not exist in the map's style and cannot be moved.`)));
					if (e$1 === i$1) return;
					const o$1 = this._order.indexOf(e$1);
					this._order.splice(o$1, 1);
					const r$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					i$1 && -1 === r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot move layer "${e$1}" before non-existing layer "${i$1}".`))) : (this._order.splice(r$1, 0, e$1), this._layerOrderChanged = !0);
				}
				removeLayer(e$1) {
					this._checkLoaded();
					const i$1 = this._layers[e$1];
					if (!i$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot remove non-existing layer "${e$1}".`)));
					i$1.setEventedParent(null);
					const o$1 = this._order.indexOf(e$1);
					this._order.splice(o$1, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e$1] = i$1, delete this._layers[e$1], this._serializedLayers && delete this._serializedLayers[e$1], delete this._updatedLayers[e$1], delete this._updatedPaintProps[e$1], i$1.onRemove && i$1.onRemove(this.map);
				}
				getLayer(e$1) {
					return this._layers[e$1];
				}
				getLayersOrder() {
					return [...this._order];
				}
				hasLayer(e$1) {
					return e$1 in this._layers;
				}
				setLayerZoomRange(e$1, i$1, o$1) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					r$1 ? r$1.minzoom === i$1 && r$1.maxzoom === o$1 || (null != i$1 && (r$1.minzoom = i$1), null != o$1 && (r$1.maxzoom = o$1), this._updateLayer(r$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot set the zoom range of non-existing layer "${e$1}".`)));
				}
				setFilter(e$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					if (r$1) {
						if (!t.bH(r$1.filter, i$1)) return null == i$1 ? (r$1.setFilter(void 0), void this._updateLayer(r$1)) : void (this._validate(t.z.filter, `layers.${r$1.id}.filter`, i$1, null, o$1) || (r$1.setFilter(t.bK(i$1)), this._updateLayer(r$1)));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot filter non-existing layer "${e$1}".`)));
				}
				getFilter(e$1) {
					return t.bK(this.getLayer(e$1).filter);
				}
				setLayoutProperty(e$1, i$1, o$1, r$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getLayer(e$1);
					a$1 ? t.bH(a$1.getLayoutProperty(i$1), o$1) || (a$1.setLayoutProperty(i$1, o$1, r$1), this._updateLayer(a$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				getLayoutProperty(e$1, i$1) {
					const o$1 = this.getLayer(e$1);
					if (o$1) return o$1.getLayoutProperty(i$1);
					this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot get style of non-existing layer "${e$1}".`)));
				}
				setPaintProperty(e$1, i$1, o$1, r$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getLayer(e$1);
					a$1 ? t.bH(a$1.getPaintProperty(i$1), o$1) || (a$1.setPaintProperty(i$1, o$1, r$1) && this._updateLayer(a$1), this._changed = !0, this._updatedPaintProps[e$1] = !0, this._serializedLayers = null) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				getPaintProperty(e$1, t$1) {
					return this.getLayer(e$1).getPaintProperty(t$1);
				}
				setFeatureState(e$1, i$1) {
					this._checkLoaded();
					const o$1 = e$1.source, r$1 = e$1.sourceLayer, a$1 = this.sourceCaches[o$1];
					if (void 0 === a$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${o$1}' does not exist in the map's style.`)));
					const s$1 = a$1.getSource().type;
					"geojson" === s$1 && r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s$1 || r$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), a$1.setFeatureState(r$1, e$1.id, i$1)) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				removeFeatureState(e$1, i$1) {
					this._checkLoaded();
					const o$1 = e$1.source, r$1 = this.sourceCaches[o$1];
					if (void 0 === r$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${o$1}' does not exist in the map's style.`)));
					const a$1 = r$1.getSource().type, s$1 = "vector" === a$1 ? e$1.sourceLayer : void 0;
					"vector" !== a$1 || s$1 ? i$1 && "string" != typeof e$1.id && "number" != typeof e$1.id ? this.fire(new t.k(/* @__PURE__ */ new Error("A feature id is required to remove its specific state property."))) : r$1.removeFeatureState(s$1, e$1.id, i$1) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				getFeatureState(e$1) {
					this._checkLoaded();
					const i$1 = e$1.source, o$1 = e$1.sourceLayer, r$1 = this.sourceCaches[i$1];
					if (void 0 !== r$1) return "vector" !== r$1.getSource().type || o$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), r$1.getFeatureState(o$1, e$1.id)) : void this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${i$1}' does not exist in the map's style.`)));
				}
				getTransition() {
					return t.e({
						duration: 300,
						delay: 0
					}, this.stylesheet && this.stylesheet.transition);
				}
				serialize() {
					if (!this._loaded) return;
					const e$1 = t.bN(this.sourceCaches, ((e$2) => e$2.serialize())), i$1 = this._serializeByIds(this._order, !0), o$1 = this.map.getTerrain() || void 0, r$1 = this.stylesheet;
					return t.bO({
						version: r$1.version,
						name: r$1.name,
						metadata: r$1.metadata,
						light: r$1.light,
						sky: r$1.sky,
						center: r$1.center,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						sprite: r$1.sprite,
						glyphs: r$1.glyphs,
						transition: r$1.transition,
						projection: r$1.projection,
						sources: e$1,
						layers: i$1,
						terrain: o$1
					}, ((e$2) => void 0 !== e$2));
				}
				_updateLayer(e$1) {
					this._updatedLayers[e$1.id] = !0, e$1.source && !this._updatedSources[e$1.source] && "raster" !== this.sourceCaches[e$1.source].getSource().type && (this._updatedSources[e$1.source] = "reload", this.sourceCaches[e$1.source].pause()), this._serializedLayers = null, this._changed = !0;
				}
				_flattenAndSortRenderedFeatures(e$1) {
					const t$1 = (e$2) => "fill-extrusion" === this._layers[e$2].type, i$1 = {}, o$1 = [];
					for (let r$2 = this._order.length - 1; r$2 >= 0; r$2--) {
						const a$1 = this._order[r$2];
						if (t$1(a$1)) {
							i$1[a$1] = r$2;
							for (const t$2 of e$1) {
								const e$2 = t$2[a$1];
								if (e$2) for (const t$3 of e$2) o$1.push(t$3);
							}
						}
					}
					o$1.sort(((e$2, t$2) => t$2.intersectionZ - e$2.intersectionZ));
					const r$1 = [];
					for (let a$1 = this._order.length - 1; a$1 >= 0; a$1--) {
						const s$1 = this._order[a$1];
						if (t$1(s$1)) for (let e$2 = o$1.length - 1; e$2 >= 0; e$2--) {
							const t$2 = o$1[e$2].feature;
							if (i$1[t$2.layer.id] < a$1) break;
							r$1.push(t$2), o$1.pop();
						}
						else for (const t$2 of e$1) {
							const e$2 = t$2[s$1];
							if (e$2) for (const t$3 of e$2) r$1.push(t$3.feature);
						}
					}
					return r$1;
				}
				queryRenderedFeatures(e$1, i$1, o$1) {
					i$1 && i$1.filter && this._validate(t.z.filter, "queryRenderedFeatures.filter", i$1.filter, null, i$1);
					const r$1 = {};
					if (i$1 && i$1.layers) {
						if (!(Array.isArray(i$1.layers) || i$1.layers instanceof Set)) return this.fire(new t.k(/* @__PURE__ */ new Error("parameters.layers must be an Array or a Set of strings"))), [];
						for (const e$2 of i$1.layers) {
							const i$2 = this._layers[e$2];
							if (!i$2) return this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$2}' does not exist in the map's style and cannot be queried for features.`))), [];
							r$1[i$2.source] = !0;
						}
					}
					const a$1 = [];
					i$1.availableImages = this._availableImages;
					const s$1 = this._serializedAllLayers(), n$1 = i$1.layers instanceof Set ? i$1.layers : Array.isArray(i$1.layers) ? new Set(i$1.layers) : null, l$1 = Object.assign(Object.assign({}, i$1), { layers: n$1 });
					for (const t$1 in this.sourceCaches) i$1.layers && !r$1[t$1] || a$1.push(j$1(this.sourceCaches[t$1], this._layers, s$1, e$1, l$1, o$1, this.map.terrain ? (e$2, t$2, i$2) => this.map.terrain.getElevation(e$2, t$2, i$2) : void 0));
					return this.placement && a$1.push(function(e$2, t$1, i$2, o$2, r$2, a$2, s$2) {
						const n$2 = {}, l$2 = a$2.queryRenderedSymbols(o$2), c$1 = [];
						for (const e$3 of Object.keys(l$2).map(Number)) c$1.push(s$2[e$3]);
						c$1.sort(N);
						for (const i$3 of c$1) {
							const o$3 = i$3.featureIndex.lookupSymbolFeatures(l$2[i$3.bucketInstanceId], t$1, i$3.bucketIndex, i$3.sourceLayerIndex, r$2.filter, r$2.layers, r$2.availableImages, e$2);
							for (const e$3 in o$3) {
								const t$2 = n$2[e$3] = n$2[e$3] || [], r$3 = o$3[e$3];
								r$3.sort(((e$4, t$3) => {
									const o$4 = i$3.featureSortOrder;
									if (o$4) {
										const i$4 = o$4.indexOf(e$4.featureIndex);
										return o$4.indexOf(t$3.featureIndex) - i$4;
									}
									return t$3.featureIndex - e$4.featureIndex;
								}));
								for (const e$4 of r$3) t$2.push(e$4);
							}
						}
						return function(e$3, t$2, i$3) {
							for (const o$3 in e$3) for (const r$3 of e$3[o$3]) U$1(r$3, i$3[t$2[o$3].source]);
							return e$3;
						}(n$2, e$2, i$2);
					}(this._layers, s$1, this.sourceCaches, e$1, l$1, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a$1);
				}
				querySourceFeatures(e$1, i$1) {
					i$1 && i$1.filter && this._validate(t.z.filter, "querySourceFeatures.filter", i$1.filter, null, i$1);
					const o$1 = this.sourceCaches[e$1];
					return o$1 ? function(e$2, t$1) {
						const i$2 = e$2.getRenderableIds().map(((t$2) => e$2.getTileByID(t$2))), o$2 = [], r$1 = {};
						for (let e$3 = 0; e$3 < i$2.length; e$3++) {
							const a$1 = i$2[e$3], s$1 = a$1.tileID.canonical.key;
							r$1[s$1] || (r$1[s$1] = !0, a$1.querySourceFeatures(o$2, t$1));
						}
						return o$2;
					}(o$1, i$1) : [];
				}
				getLight() {
					return this.light.getLight();
				}
				setLight(e$1, i$1 = {}) {
					this._checkLoaded();
					const o$1 = this.light.getLight();
					let r$1 = !1;
					for (const i$2 in e$1) if (!t.bH(e$1[i$2], o$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const a$1 = {
						now: s.now(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.light.setLight(e$1, i$1), this.light.updateTransitions(a$1);
				}
				getProjection() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.projection;
				}
				setProjection(e$1) {
					if (this._checkLoaded(), this.projection) {
						if (this.projection.name === e$1.type) return;
						this.projection.destroy(), delete this.projection;
					}
					this.stylesheet.projection = e$1, this._setProjectionInternal(e$1.type);
				}
				getSky() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.sky;
				}
				setSky(e$1, i$1 = {}) {
					this._checkLoaded();
					const o$1 = this.getSky();
					let r$1 = !1;
					if (!e$1 && !o$1) return;
					if (e$1 && !o$1) r$1 = !0;
					else if (!e$1 && o$1) r$1 = !0;
					else for (const i$2 in e$1) if (!t.bH(e$1[i$2], o$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const a$1 = {
						now: s.now(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.stylesheet.sky = e$1, this.sky.setSky(e$1, i$1), this.sky.updateTransitions(a$1);
				}
				_setProjectionInternal(e$1) {
					const i$1 = function(e$2) {
						if (Array.isArray(e$2)) {
							const t$1 = new Jt$1({ type: e$2 });
							return {
								projection: t$1,
								transform: new gi$1(),
								cameraHelper: new bi$1(t$1)
							};
						}
						switch (e$2) {
							case "mercator": return {
								projection: new It$1(),
								transform: new Lt$1(),
								cameraHelper: new Ot()
							};
							case "globe": {
								const e$3 = new Jt$1({ type: [
									"interpolate",
									["linear"],
									["zoom"],
									11,
									"vertical-perspective",
									12,
									"mercator"
								] });
								return {
									projection: e$3,
									transform: new gi$1(),
									cameraHelper: new bi$1(e$3)
								};
							}
							case "vertical-perspective": return {
								projection: new Yt$1(),
								transform: new fi$1(),
								cameraHelper: new vi$1()
							};
							default: return t.w(`Unknown projection name: ${e$2}. Falling back to mercator projection.`), {
								projection: new It$1(),
								transform: new Lt$1(),
								cameraHelper: new Ot()
							};
						}
					}(e$1);
					this.projection = i$1.projection, this.map.migrateProjection(i$1.transform, i$1.cameraHelper);
					for (const e$2 in this.sourceCaches) this.sourceCaches[e$2].reload();
				}
				_validate(e$1, i$1, o$1, r$1, a$1 = {}) {
					return (!a$1 || !1 !== a$1.validate) && xi$1(this, e$1.call(t.z, t.e({
						key: i$1,
						style: this.serialize(),
						value: o$1,
						styleSpec: t.v
					}, r$1)));
				}
				_remove(e$1 = !0) {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe$1().off(ee, this._rtlPluginLoaded);
					for (const e$2 in this._layers) this._layers[e$2].setEventedParent(null);
					for (const e$2 in this.sourceCaches) {
						const t$1 = this.sourceCaches[e$2];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.imageManager.setEventedParent(null), this.setEventedParent(null), e$1 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e$1);
				}
				_clearSource(e$1) {
					this.sourceCaches[e$1].clearTiles();
				}
				_reloadSource(e$1) {
					this.sourceCaches[e$1].resume(), this.sourceCaches[e$1].reload();
				}
				_updateSources(e$1) {
					for (const t$1 in this.sourceCaches) this.sourceCaches[t$1].update(e$1, this.map.terrain);
				}
				_generateCollisionBoxes() {
					for (const e$1 in this.sourceCaches) this._reloadSource(e$1);
				}
				_updatePlacement(e$1, t$1, i$1, o$1, r$1 = !1) {
					let a$1 = !1, n$1 = !1;
					const l$1 = {};
					for (const t$2 of this._order) {
						const i$2 = this._layers[t$2];
						if ("symbol" !== i$2.type) continue;
						if (!l$1[i$2.source]) {
							const e$2 = this.sourceCaches[i$2.source];
							l$1[i$2.source] = e$2.getRenderableIds(!0).map(((t$3) => e$2.getTileByID(t$3))).sort(((e$3, t$3) => t$3.tileID.overscaledZ - e$3.tileID.overscaledZ || (e$3.tileID.isLessThan(t$3.tileID) ? -1 : 1)));
						}
						const o$2 = this.crossTileSymbolIndex.addLayer(i$2, l$1[i$2.source], e$1.center.lng);
						a$1 = a$1 || o$2;
					}
					if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r$1 = r$1 || this._layerOrderChanged || 0 === i$1) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.now(), e$1.zoom)) && (this.pauseablePlacement = new _t$1(e$1, this.map.terrain, this._order, r$1, t$1, i$1, o$1, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l$1), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.now()), n$1 = !0), a$1 && this.pauseablePlacement.placement.setStale()), n$1 || a$1) for (const e$2 of this._order) {
						const t$2 = this._layers[e$2];
						"symbol" === t$2.type && this.placement.updateLayerOpacities(t$2, l$1[t$2.source]);
					}
					return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.now());
				}
				_releaseSymbolFadeTiles() {
					for (const e$1 in this.sourceCaches) this.sourceCaches[e$1].releaseSymbolFadeTiles();
				}
				getImages(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.imageManager.getImages(i$1.icons);
						this._updateTilesForChangedImages();
						const t$1 = this.sourceCaches[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, i$1.icons), e$2;
					}));
				}
				getGlyphs(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.glyphManager.getGlyphs(i$1.stacks), t$1 = this.sourceCaches[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, [""]), e$2;
					}));
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs || null;
				}
				setGlyphs(e$1, i$1 = {}) {
					this._checkLoaded(), e$1 && this._validate(t.z.glyphs, "glyphs", e$1, null, i$1) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e$1, this.glyphManager.entries = {}, this.glyphManager.setURL(e$1));
				}
				addSprite(e$1, i$1, o$1 = {}, r$1) {
					this._checkLoaded();
					const a$1 = [{
						id: e$1,
						url: i$1
					}], s$1 = [...f(this.stylesheet.sprite), ...a$1];
					this._validate(t.z.sprite, "sprite", s$1, null, o$1) || (this.stylesheet.sprite = s$1, this._loadSprite(a$1, !0, r$1));
				}
				removeSprite(e$1) {
					this._checkLoaded();
					const i$1 = f(this.stylesheet.sprite);
					if (i$1.find(((t$1) => t$1.id === e$1))) {
						if (this._spritesImagesIds[e$1]) for (const t$1 of this._spritesImagesIds[e$1]) this.imageManager.removeImage(t$1), this._changedImages[t$1] = !0;
						i$1.splice(i$1.findIndex(((t$1) => t$1.id === e$1)), 1), this.stylesheet.sprite = i$1.length > 0 ? i$1 : void 0, delete this._spritesImagesIds[e$1], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Sprite "${e$1}" doesn't exists on this map.`)));
				}
				getSprite() {
					return f(this.stylesheet.sprite);
				}
				setSprite(e$1, i$1 = {}, o$1) {
					this._checkLoaded(), e$1 && this._validate(t.z.sprite, "sprite", e$1, null, i$1) || (this.stylesheet.sprite = e$1, e$1 ? this._loadSprite(e$1, !0, o$1) : (this._unloadSprite(), o$1 && o$1(null)));
				}
			}
			var Ti = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			class Pi$1 {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
				}
				bind(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
					this.context = e$1;
					let c$1 = this.boundPaintVertexBuffers.length !== o$1.length;
					for (let e$2 = 0; !c$1 && e$2 < o$1.length; e$2++) this.boundPaintVertexBuffers[e$2] !== o$1[e$2] && (c$1 = !0);
					!this.vao || this.boundProgram !== t$1 || this.boundLayoutVertexBuffer !== i$1 || c$1 || this.boundIndexBuffer !== r$1 || this.boundVertexOffset !== a$1 || this.boundDynamicVertexBuffer !== s$1 || this.boundDynamicVertexBuffer2 !== n$1 || this.boundDynamicVertexBuffer3 !== l$1 ? this.freshBind(t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) : (e$1.bindVertexArray.set(this.vao), s$1 && s$1.bind(), r$1 && r$1.dynamicDraw && r$1.bind(), n$1 && n$1.bind(), l$1 && l$1.bind());
				}
				freshBind(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const l$1 = e$1.numAttributes, c$1 = this.context, h$1 = c$1.gl;
					this.vao && this.destroy(), this.vao = c$1.createVertexArray(), c$1.bindVertexArray.set(this.vao), this.boundProgram = e$1, this.boundLayoutVertexBuffer = t$1, this.boundPaintVertexBuffers = i$1, this.boundIndexBuffer = o$1, this.boundVertexOffset = r$1, this.boundDynamicVertexBuffer = a$1, this.boundDynamicVertexBuffer2 = s$1, this.boundDynamicVertexBuffer3 = n$1, t$1.enableAttributes(h$1, e$1);
					for (const t$2 of i$1) t$2.enableAttributes(h$1, e$1);
					a$1 && a$1.enableAttributes(h$1, e$1), s$1 && s$1.enableAttributes(h$1, e$1), n$1 && n$1.enableAttributes(h$1, e$1), t$1.bind(), t$1.setVertexAttribPointers(h$1, e$1, r$1);
					for (const t$2 of i$1) t$2.bind(), t$2.setVertexAttribPointers(h$1, e$1, r$1);
					a$1 && (a$1.bind(), a$1.setVertexAttribPointers(h$1, e$1, r$1)), o$1 && o$1.bind(), s$1 && (s$1.bind(), s$1.setVertexAttribPointers(h$1, e$1, r$1)), n$1 && (n$1.bind(), n$1.setVertexAttribPointers(h$1, e$1, r$1)), c$1.currentNumAttributes = l$1;
				}
				destroy() {
					this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
				}
			}
			const Ci = (e$1, i$1, o$1, r$1, a$1) => ({
				u_texture: 0,
				u_ele_delta: e$1,
				u_fog_matrix: i$1,
				u_fog_color: o$1 ? o$1.properties.get("fog-color") : t.bf.white,
				u_fog_ground_blend: o$1 ? o$1.properties.get("fog-ground-blend") : 1,
				u_fog_ground_blend_opacity: a$1 ? 0 : o$1 ? o$1.calculateFogBlendOpacity(r$1) : 0,
				u_horizon_color: o$1 ? o$1.properties.get("horizon-color") : t.bf.white,
				u_horizon_fog_blend: o$1 ? o$1.properties.get("horizon-fog-blend") : 1,
				u_is_globe_mode: a$1 ? 1 : 0
			}), Ii = {
				mainMatrix: "u_projection_matrix",
				tileMercatorCoords: "u_projection_tile_mercator_coords",
				clippingPlane: "u_projection_clipping_plane",
				projectionTransition: "u_projection_transition",
				fallbackMatrix: "u_projection_fallback_matrix"
			};
			function Mi$1(e$1) {
				const t$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					if (null === e$1[i$1]) continue;
					const o$1 = e$1[i$1].split(" ");
					t$1.push(o$1.pop());
				}
				return t$1;
			}
			class Si$1 {
				constructor(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1 = []) {
					const h$1 = e$1.gl;
					this.program = h$1.createProgram();
					const u$1 = Mi$1(i$1.staticAttributes), d$1 = o$1 ? o$1.getBinderAttributes() : [], _$2 = u$1.concat(d$1), p$1 = xt$1.prelude.staticUniforms ? Mi$1(xt$1.prelude.staticUniforms) : [], m$1 = n$1.staticUniforms ? Mi$1(n$1.staticUniforms) : [], f$1 = i$1.staticUniforms ? Mi$1(i$1.staticUniforms) : [], g$2 = o$1 ? o$1.getBinderUniforms() : [], v$1 = p$1.concat(m$1).concat(f$1).concat(g$2), b$2 = [];
					for (const e$2 of v$1) b$2.indexOf(e$2) < 0 && b$2.push(e$2);
					const x$1 = o$1 ? o$1.defines() : [];
					qt$1(h$1) && x$1.unshift("#version 300 es"), a$1 && x$1.push("#define OVERDRAW_INSPECTOR;"), s$1 && x$1.push("#define TERRAIN3D;"), l$1 && x$1.push(l$1), c$1 && x$1.push(...c$1);
					let y$1 = x$1.concat(xt$1.prelude.fragmentSource, n$1.fragmentSource, i$1.fragmentSource).join("\n"), w$1 = x$1.concat(xt$1.prelude.vertexSource, n$1.vertexSource, i$1.vertexSource).join("\n");
					qt$1(h$1) || (y$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
					}(y$1), w$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
					}(w$1));
					const T$2 = h$1.createShader(h$1.FRAGMENT_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(T$2, y$1), h$1.compileShader(T$2), !h$1.getShaderParameter(T$2, h$1.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h$1.getShaderInfoLog(T$2)}`);
					h$1.attachShader(this.program, T$2);
					const P$2 = h$1.createShader(h$1.VERTEX_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(P$2, w$1), h$1.compileShader(P$2), !h$1.getShaderParameter(P$2, h$1.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h$1.getShaderInfoLog(P$2)}`);
					h$1.attachShader(this.program, P$2), this.attributes = {};
					const C$1 = {};
					this.numAttributes = _$2.length;
					for (let e$2 = 0; e$2 < this.numAttributes; e$2++) _$2[e$2] && (h$1.bindAttribLocation(this.program, e$2, _$2[e$2]), this.attributes[_$2[e$2]] = e$2);
					if (h$1.linkProgram(this.program), !h$1.getProgramParameter(this.program, h$1.LINK_STATUS)) throw new Error(`Program failed to link: ${h$1.getProgramInfoLog(this.program)}`);
					h$1.deleteShader(P$2), h$1.deleteShader(T$2);
					for (let e$2 = 0; e$2 < b$2.length; e$2++) {
						const t$1 = b$2[e$2];
						if (t$1 && !C$1[t$1]) {
							const e$3 = h$1.getUniformLocation(this.program, t$1);
							e$3 && (C$1[t$1] = e$3);
						}
					}
					this.fixedUniforms = r$1(e$1, C$1), this.terrainUniforms = ((e$2, i$2) => ({
						u_depth: new t.bP(e$2, i$2.u_depth),
						u_terrain: new t.bP(e$2, i$2.u_terrain),
						u_terrain_dim: new t.bg(e$2, i$2.u_terrain_dim),
						u_terrain_matrix: new t.bR(e$2, i$2.u_terrain_matrix),
						u_terrain_unpack: new t.bS(e$2, i$2.u_terrain_unpack),
						u_terrain_exaggeration: new t.bg(e$2, i$2.u_terrain_exaggeration)
					}))(e$1, C$1), this.projectionUniforms = ((e$2, i$2) => ({
						u_projection_matrix: new t.bR(e$2, i$2.u_projection_matrix),
						u_projection_tile_mercator_coords: new t.bS(e$2, i$2.u_projection_tile_mercator_coords),
						u_projection_clipping_plane: new t.bS(e$2, i$2.u_projection_clipping_plane),
						u_projection_transition: new t.bg(e$2, i$2.u_projection_transition),
						u_projection_fallback_matrix: new t.bR(e$2, i$2.u_projection_fallback_matrix)
					}))(e$1, C$1), this.binderUniforms = o$1 ? o$1.getUniforms(e$1, C$1) : [];
				}
				draw(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1, m$1, f$1, g$2, v$1) {
					const b$2 = e$1.gl;
					if (this.failedToCreate) return;
					if (e$1.program.set(this.program), e$1.setDepthMode(i$1), e$1.setStencilMode(o$1), e$1.setColorMode(r$1), e$1.setCullFace(a$1), n$1) {
						e$1.activeTexture.set(b$2.TEXTURE2), b$2.bindTexture(b$2.TEXTURE_2D, n$1.depthTexture), e$1.activeTexture.set(b$2.TEXTURE3), b$2.bindTexture(b$2.TEXTURE_2D, n$1.texture);
						for (const e$2 in this.terrainUniforms) this.terrainUniforms[e$2].set(n$1[e$2]);
					}
					if (l$1) for (const e$2 in l$1) this.projectionUniforms[Ii[e$2]].set(l$1[e$2]);
					if (s$1) for (const e$2 in this.fixedUniforms) this.fixedUniforms[e$2].set(s$1[e$2]);
					m$1 && m$1.setUniforms(e$1, this.binderUniforms, _$2, { zoom: p$1 });
					let x$1 = 0;
					switch (t$1) {
						case b$2.LINES:
							x$1 = 2;
							break;
						case b$2.TRIANGLES:
							x$1 = 3;
							break;
						case b$2.LINE_STRIP: x$1 = 1;
					}
					for (const i$2 of d$1.get()) {
						const o$2 = i$2.vaos || (i$2.vaos = {});
						(o$2[c$1] || (o$2[c$1] = new Pi$1())).bind(e$1, this, h$1, m$1 ? m$1.getPaintVertexBuffers() : [], u$1, i$2.vertexOffset, f$1, g$2, v$1), b$2.drawElements(t$1, i$2.primitiveLength * x$1, b$2.UNSIGNED_SHORT, i$2.primitiveOffset * x$1 * 2);
					}
				}
			}
			function Ei(e$1, i$1, o$1) {
				const r$1 = 1 / t.aC(o$1, 1, i$1.transform.tileZoom), a$1 = Math.pow(2, o$1.tileID.overscaledZ), s$1 = o$1.tileSize * Math.pow(2, i$1.transform.tileZoom) / a$1, n$1 = s$1 * (o$1.tileID.canonical.x + o$1.tileID.wrap * a$1), l$1 = s$1 * o$1.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: o$1.imageAtlasTexture.size,
					u_scale: [
						r$1,
						e$1.fromScale,
						e$1.toScale
					],
					u_fade: e$1.t,
					u_pixel_coord_upper: [n$1 >> 16, l$1 >> 16],
					u_pixel_coord_lower: [65535 & n$1, 65535 & l$1]
				};
			}
			const Ri$1 = (e$1, i$1, o$1, r$1) => {
				const a$1 = e$1.style.light, s$1 = a$1.properties.get("position"), n$1 = [
					s$1.x,
					s$1.y,
					s$1.z
				], l$1 = t.bV();
				"viewport" === a$1.properties.get("anchor") && t.bW(l$1, e$1.transform.bearingInRadians), t.bX(n$1, n$1, l$1);
				const c$1 = e$1.transform.transformLightDirection(n$1), h$1 = a$1.properties.get("color");
				return {
					u_lightpos: n$1,
					u_lightpos_globe: c$1,
					u_lightintensity: a$1.properties.get("intensity"),
					u_lightcolor: [
						h$1.r,
						h$1.g,
						h$1.b
					],
					u_vertical_gradient: +i$1,
					u_opacity: o$1,
					u_fill_translate: r$1
				};
			}, zi$1 = (e$1, i$1, o$1, r$1, a$1, s$1, n$1) => t.e(Ri$1(e$1, i$1, o$1, r$1), Ei(s$1, e$1, n$1), { u_height_factor: -Math.pow(2, a$1.overscaledZ) / n$1.tileSize / 8 }), Di$1 = (e$1, i$1, o$1, r$1) => t.e(Ei(i$1, e$1, o$1), { u_fill_translate: r$1 }), Ai = (e$1, t$1) => ({
				u_world: e$1,
				u_fill_translate: t$1
			}), Li$1 = (e$1, i$1, o$1, r$1, a$1) => t.e(Di$1(e$1, i$1, o$1, a$1), { u_world: r$1 }), ki = (e$1, i$1, o$1, r$1, a$1) => {
				const s$1 = e$1.transform;
				let n$1, l$1, c$1 = 0;
				if ("map" === o$1.paint.get("circle-pitch-alignment")) {
					const e$2 = t.aC(i$1, 1, s$1.zoom);
					n$1 = !0, l$1 = [e$2, e$2], c$1 = e$2 / (t.$ * Math.pow(2, i$1.tileID.overscaledZ)) * 2 * Math.PI * a$1;
				} else n$1 = !1, l$1 = s$1.pixelsToGLUnits;
				return {
					u_camera_to_center_distance: s$1.cameraToCenterDistance,
					u_scale_with_map: +("map" === o$1.paint.get("circle-pitch-scale")),
					u_pitch_with_map: +n$1,
					u_device_pixel_ratio: e$1.pixelRatio,
					u_extrude_scale: l$1,
					u_globe_extrude_scale: c$1,
					u_translate: r$1
				};
			}, Fi$1 = (e$1) => ({ u_pixel_extrude_scale: [1 / e$1.width, 1 / e$1.height] }), Bi$1 = (e$1) => ({ u_viewport_size: [e$1.width, e$1.height] }), Oi$1 = (e$1, t$1 = 1) => ({
				u_color: e$1,
				u_overlay: 0,
				u_overlay_scale: t$1
			}), ji$1 = (e$1, i$1, o$1, r$1) => {
				const a$1 = t.aC(e$1, 1, i$1) / (t.$ * Math.pow(2, e$1.tileID.overscaledZ)) * 2 * Math.PI * r$1;
				return {
					u_extrude_scale: t.aC(e$1, 1, i$1),
					u_intensity: o$1,
					u_globe_extrude_scale: a$1
				};
			}, Ni$1 = (e$1, i$1, o$1, r$1) => {
				const a$1 = t.L();
				t.bY(a$1, 0, e$1.width, e$1.height, 0, 0, 1);
				const s$1 = e$1.context.gl;
				return {
					u_matrix: a$1,
					u_world: [s$1.drawingBufferWidth, s$1.drawingBufferHeight],
					u_image: o$1,
					u_color_ramp: r$1,
					u_opacity: i$1.paint.get("heatmap-opacity")
				};
			}, Ui$1 = (e$1, t$1, i$1) => {
				const o$1 = i$1.paint.get("hillshade-accent-color");
				let r$1;
				switch (i$1.paint.get("hillshade-method")) {
					case "basic":
						r$1 = 4;
						break;
					case "combined":
						r$1 = 1;
						break;
					case "igor":
						r$1 = 2;
						break;
					case "multidirectional":
						r$1 = 3;
						break;
					default: r$1 = 0;
				}
				const a$1 = i$1.getIlluminationProperties();
				for (let t$2 = 0; t$2 < a$1.directionRadians.length; t$2++) "viewport" === i$1.paint.get("hillshade-illumination-anchor") && (a$1.directionRadians[t$2] += e$1.transform.bearingInRadians);
				return {
					u_image: 0,
					u_latrange: Gi$1(0, t$1.tileID),
					u_exaggeration: i$1.paint.get("hillshade-exaggeration"),
					u_altitudes: a$1.altitudeRadians,
					u_azimuths: a$1.directionRadians,
					u_accent: o$1,
					u_method: r$1,
					u_highlights: a$1.highlightColor,
					u_shadows: a$1.shadowColor
				};
			}, Zi$1 = (e$1, i$1) => {
				const o$1 = i$1.stride, r$1 = t.L();
				return t.bY(r$1, 0, t.$, -t.$, 0, 0, 1), t.M(r$1, r$1, [
					0,
					-t.$,
					0
				]), {
					u_matrix: r$1,
					u_image: 1,
					u_dimension: [o$1, o$1],
					u_zoom: e$1.overscaledZ,
					u_unpack: i$1.getUnpackVector()
				};
			};
			function Gi$1(e$1, i$1) {
				const o$1 = Math.pow(2, i$1.canonical.z), r$1 = i$1.canonical.y;
				return [new t.a1(0, r$1 / o$1).toLngLat().lat, new t.a1(0, (r$1 + 1) / o$1).toLngLat().lat];
			}
			const Vi$1 = (e$1, t$1, i$1 = 0) => ({
				u_image: 0,
				u_unpack: t$1.getUnpackVector(),
				u_dimension: [t$1.stride, t$1.stride],
				u_elevation_stops: 1,
				u_color_stops: 4,
				u_color_ramp_size: i$1,
				u_opacity: e$1.paint.get("color-relief-opacity")
			}), $i$1 = (e$1, i$1, o$1, r$1) => {
				const a$1 = e$1.transform;
				return {
					u_translation: Ki$1(e$1, i$1, o$1),
					u_ratio: r$1 / t.aC(i$1, 1, a$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_units_to_pixels: [1 / a$1.pixelsToGLUnits[0], 1 / a$1.pixelsToGLUnits[1]]
				};
			}, qi$1 = (e$1, i$1, o$1, r$1, a$1) => t.e($i$1(e$1, i$1, o$1, r$1), {
				u_image: 0,
				u_image_height: a$1
			}), Wi$1 = (e$1, i$1, o$1, r$1, a$1) => {
				const s$1 = e$1.transform, n$1 = Xi$1(i$1, s$1);
				return {
					u_translation: Ki$1(e$1, i$1, o$1),
					u_texsize: i$1.imageAtlasTexture.size,
					u_ratio: r$1 / t.aC(i$1, 1, s$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_image: 0,
					u_scale: [
						n$1,
						a$1.fromScale,
						a$1.toScale
					],
					u_fade: a$1.t,
					u_units_to_pixels: [1 / s$1.pixelsToGLUnits[0], 1 / s$1.pixelsToGLUnits[1]]
				};
			}, Hi$1 = (e$1, i$1, o$1, r$1, a$1, s$1) => {
				const n$1 = e$1.lineAtlas, l$1 = Xi$1(i$1, e$1.transform), c$1 = "round" === o$1.layout.get("line-cap"), h$1 = n$1.getDash(a$1.from, c$1), u$1 = n$1.getDash(a$1.to, c$1), d$1 = h$1.width * s$1.fromScale, _$2 = u$1.width * s$1.toScale;
				return t.e($i$1(e$1, i$1, o$1, r$1), {
					u_patternscale_a: [l$1 / d$1, -h$1.height / 2],
					u_patternscale_b: [l$1 / _$2, -u$1.height / 2],
					u_sdfgamma: n$1.width / (256 * Math.min(d$1, _$2) * e$1.pixelRatio) / 2,
					u_image: 0,
					u_tex_y_a: h$1.y,
					u_tex_y_b: u$1.y,
					u_mix: s$1.t
				});
			};
			function Xi$1(e$1, i$1) {
				return 1 / t.aC(e$1, 1, i$1.tileZoom);
			}
			function Ki$1(e$1, i$1, o$1) {
				return t.aD(e$1.transform, i$1, o$1.paint.get("line-translate"), o$1.paint.get("line-translate-anchor"));
			}
			const Yi$1 = (e$1, t$1, i$1, o$1, r$1) => {
				return {
					u_tl_parent: e$1,
					u_scale_parent: t$1,
					u_buffer_scale: 1,
					u_fade_t: i$1.mix,
					u_opacity: i$1.opacity * o$1.paint.get("raster-opacity"),
					u_image0: 0,
					u_image1: 1,
					u_brightness_low: o$1.paint.get("raster-brightness-min"),
					u_brightness_high: o$1.paint.get("raster-brightness-max"),
					u_saturation_factor: (s$1 = o$1.paint.get("raster-saturation"), s$1 > 0 ? 1 - 1 / (1.001 - s$1) : -s$1),
					u_contrast_factor: (a$1 = o$1.paint.get("raster-contrast"), a$1 > 0 ? 1 / (1 - a$1) : 1 + a$1),
					u_spin_weights: Qi$1(o$1.paint.get("raster-hue-rotate")),
					u_coords_top: [
						r$1[0].x,
						r$1[0].y,
						r$1[1].x,
						r$1[1].y
					],
					u_coords_bottom: [
						r$1[3].x,
						r$1[3].y,
						r$1[2].x,
						r$1[2].y
					]
				};
				var a$1, s$1;
			};
			function Qi$1(e$1) {
				e$1 *= Math.PI / 180;
				const t$1 = Math.sin(e$1), i$1 = Math.cos(e$1);
				return [
					(2 * i$1 + 1) / 3,
					(-Math.sqrt(3) * t$1 - i$1 + 1) / 3,
					(Math.sqrt(3) * t$1 - i$1 + 1) / 3
				];
			}
			const Ji$1 = (e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) => {
				const _$2 = s$1.transform;
				return {
					u_is_size_zoom_constant: +("constant" === e$1 || "source" === e$1),
					u_is_size_feature_constant: +("constant" === e$1 || "camera" === e$1),
					u_size_t: t$1 ? t$1.uSizeT : 0,
					u_size: t$1 ? t$1.uSize : 0,
					u_camera_to_center_distance: _$2.cameraToCenterDistance,
					u_pitch: _$2.pitch / 360 * 2 * Math.PI,
					u_rotate_symbol: +i$1,
					u_aspect_ratio: _$2.width / _$2.height,
					u_fade_change: s$1.options.fadeDuration ? s$1.symbolFadeChange : 1,
					u_label_plane_matrix: n$1,
					u_coord_matrix: l$1,
					u_is_text: +h$1,
					u_pitch_with_map: +o$1,
					u_is_along_line: r$1,
					u_is_variable_anchor: a$1,
					u_texsize: u$1,
					u_texture: 0,
					u_translation: c$1,
					u_pitched_scale: d$1
				};
			}, eo$1 = (e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1) => {
				const m$1 = n$1.transform;
				return t.e(Ji$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, p$1), {
					u_gamma_scale: r$1 ? Math.cos(m$1.pitch * Math.PI / 180) * m$1.cameraToCenterDistance : 1,
					u_device_pixel_ratio: n$1.pixelRatio,
					u_is_halo: 1
				});
			}, to$1 = (e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) => t.e(eo$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, !0, u$1, 0, _$2), {
				u_texsize_icon: d$1,
				u_texture_icon: 1
			}), io$1 = (e$1, t$1) => ({
				u_opacity: e$1,
				u_color: t$1
			}), oo$1 = (e$1, i$1, o$1, r$1, a$1) => t.e(function(e$2, i$2, o$2, r$2) {
				const a$2 = o$2.imageManager.getPattern(e$2.from.toString()), s$1 = o$2.imageManager.getPattern(e$2.to.toString()), { width: n$1, height: l$1 } = o$2.imageManager.getPixelSize(), c$1 = Math.pow(2, r$2.tileID.overscaledZ), h$1 = r$2.tileSize * Math.pow(2, o$2.transform.tileZoom) / c$1, u$1 = h$1 * (r$2.tileID.canonical.x + r$2.tileID.wrap * c$1), d$1 = h$1 * r$2.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl_a: a$2.tl,
					u_pattern_br_a: a$2.br,
					u_pattern_tl_b: s$1.tl,
					u_pattern_br_b: s$1.br,
					u_texsize: [n$1, l$1],
					u_mix: i$2.t,
					u_pattern_size_a: a$2.displaySize,
					u_pattern_size_b: s$1.displaySize,
					u_scale_a: i$2.fromScale,
					u_scale_b: i$2.toScale,
					u_tile_units_to_pixels: 1 / t.aC(r$2, 1, o$2.transform.tileZoom),
					u_pixel_coord_upper: [u$1 >> 16, d$1 >> 16],
					u_pixel_coord_lower: [65535 & u$1, 65535 & d$1]
				};
			}(o$1, a$1, i$1, r$1), { u_opacity: e$1 }), ro$1 = (e$1, t$1) => {}, ao$1 = {
				fillExtrusion: (e$1, i$1) => ({
					u_lightpos: new t.bT(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.bT(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bg(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.bT(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bg(e$1, i$1.u_vertical_gradient),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillExtrusionPattern: (e$1, i$1) => ({
					u_lightpos: new t.bT(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.bT(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bg(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.bT(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bg(e$1, i$1.u_vertical_gradient),
					u_height_factor: new t.bg(e$1, i$1.u_height_factor),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate),
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade)
				}),
				fill: (e$1, i$1) => ({ u_fill_translate: new t.bU(e$1, i$1.u_fill_translate) }),
				fillPattern: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillOutline: (e$1, i$1) => ({
					u_world: new t.bU(e$1, i$1.u_world),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillOutlinePattern: (e$1, i$1) => ({
					u_world: new t.bU(e$1, i$1.u_world),
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				circle: (e$1, i$1) => ({
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_scale_with_map: new t.bP(e$1, i$1.u_scale_with_map),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_extrude_scale: new t.bU(e$1, i$1.u_extrude_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_globe_extrude_scale: new t.bg(e$1, i$1.u_globe_extrude_scale),
					u_translate: new t.bU(e$1, i$1.u_translate)
				}),
				collisionBox: (e$1, i$1) => ({ u_pixel_extrude_scale: new t.bU(e$1, i$1.u_pixel_extrude_scale) }),
				collisionCircle: (e$1, i$1) => ({ u_viewport_size: new t.bU(e$1, i$1.u_viewport_size) }),
				debug: (e$1, i$1) => ({
					u_color: new t.bQ(e$1, i$1.u_color),
					u_overlay: new t.bP(e$1, i$1.u_overlay),
					u_overlay_scale: new t.bg(e$1, i$1.u_overlay_scale)
				}),
				depth: ro$1,
				clippingMask: ro$1,
				heatmap: (e$1, i$1) => ({
					u_extrude_scale: new t.bg(e$1, i$1.u_extrude_scale),
					u_intensity: new t.bg(e$1, i$1.u_intensity),
					u_globe_extrude_scale: new t.bg(e$1, i$1.u_globe_extrude_scale)
				}),
				heatmapTexture: (e$1, i$1) => ({
					u_matrix: new t.bR(e$1, i$1.u_matrix),
					u_world: new t.bU(e$1, i$1.u_world),
					u_image: new t.bP(e$1, i$1.u_image),
					u_color_ramp: new t.bP(e$1, i$1.u_color_ramp),
					u_opacity: new t.bg(e$1, i$1.u_opacity)
				}),
				hillshade: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_latrange: new t.bU(e$1, i$1.u_latrange),
					u_exaggeration: new t.bg(e$1, i$1.u_exaggeration),
					u_altitudes: new t.b_(e$1, i$1.u_altitudes),
					u_azimuths: new t.b_(e$1, i$1.u_azimuths),
					u_accent: new t.bQ(e$1, i$1.u_accent),
					u_method: new t.bP(e$1, i$1.u_method),
					u_shadows: new t.bZ(e$1, i$1.u_shadows),
					u_highlights: new t.bZ(e$1, i$1.u_highlights)
				}),
				hillshadePrepare: (e$1, i$1) => ({
					u_matrix: new t.bR(e$1, i$1.u_matrix),
					u_image: new t.bP(e$1, i$1.u_image),
					u_dimension: new t.bU(e$1, i$1.u_dimension),
					u_zoom: new t.bg(e$1, i$1.u_zoom),
					u_unpack: new t.bS(e$1, i$1.u_unpack)
				}),
				colorRelief: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_unpack: new t.bS(e$1, i$1.u_unpack),
					u_dimension: new t.bU(e$1, i$1.u_dimension),
					u_elevation_stops: new t.bP(e$1, i$1.u_elevation_stops),
					u_color_stops: new t.bP(e$1, i$1.u_color_stops),
					u_color_ramp_size: new t.bP(e$1, i$1.u_color_ramp_size),
					u_opacity: new t.bg(e$1, i$1.u_opacity)
				}),
				line: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels)
				}),
				lineGradient: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_image: new t.bP(e$1, i$1.u_image),
					u_image_height: new t.bg(e$1, i$1.u_image_height)
				}),
				linePattern: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_image: new t.bP(e$1, i$1.u_image),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade)
				}),
				lineSDF: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_patternscale_a: new t.bU(e$1, i$1.u_patternscale_a),
					u_patternscale_b: new t.bU(e$1, i$1.u_patternscale_b),
					u_sdfgamma: new t.bg(e$1, i$1.u_sdfgamma),
					u_image: new t.bP(e$1, i$1.u_image),
					u_tex_y_a: new t.bg(e$1, i$1.u_tex_y_a),
					u_tex_y_b: new t.bg(e$1, i$1.u_tex_y_b),
					u_mix: new t.bg(e$1, i$1.u_mix)
				}),
				raster: (e$1, i$1) => ({
					u_tl_parent: new t.bU(e$1, i$1.u_tl_parent),
					u_scale_parent: new t.bg(e$1, i$1.u_scale_parent),
					u_buffer_scale: new t.bg(e$1, i$1.u_buffer_scale),
					u_fade_t: new t.bg(e$1, i$1.u_fade_t),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_image0: new t.bP(e$1, i$1.u_image0),
					u_image1: new t.bP(e$1, i$1.u_image1),
					u_brightness_low: new t.bg(e$1, i$1.u_brightness_low),
					u_brightness_high: new t.bg(e$1, i$1.u_brightness_high),
					u_saturation_factor: new t.bg(e$1, i$1.u_saturation_factor),
					u_contrast_factor: new t.bg(e$1, i$1.u_contrast_factor),
					u_spin_weights: new t.bT(e$1, i$1.u_spin_weights),
					u_coords_top: new t.bS(e$1, i$1.u_coords_top),
					u_coords_bottom: new t.bS(e$1, i$1.u_coords_bottom)
				}),
				symbolIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				symbolSDF: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_gamma_scale: new t.bg(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.bP(e$1, i$1.u_is_halo),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				symbolTextAndIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texsize_icon: new t.bU(e$1, i$1.u_texsize_icon),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_texture_icon: new t.bP(e$1, i$1.u_texture_icon),
					u_gamma_scale: new t.bg(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.bP(e$1, i$1.u_is_halo),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				background: (e$1, i$1) => ({
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_color: new t.bQ(e$1, i$1.u_color)
				}),
				backgroundPattern: (e$1, i$1) => ({
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_image: new t.bP(e$1, i$1.u_image),
					u_pattern_tl_a: new t.bU(e$1, i$1.u_pattern_tl_a),
					u_pattern_br_a: new t.bU(e$1, i$1.u_pattern_br_a),
					u_pattern_tl_b: new t.bU(e$1, i$1.u_pattern_tl_b),
					u_pattern_br_b: new t.bU(e$1, i$1.u_pattern_br_b),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_mix: new t.bg(e$1, i$1.u_mix),
					u_pattern_size_a: new t.bU(e$1, i$1.u_pattern_size_a),
					u_pattern_size_b: new t.bU(e$1, i$1.u_pattern_size_b),
					u_scale_a: new t.bg(e$1, i$1.u_scale_a),
					u_scale_b: new t.bg(e$1, i$1.u_scale_b),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_tile_units_to_pixels: new t.bg(e$1, i$1.u_tile_units_to_pixels)
				}),
				terrain: (e$1, i$1) => ({
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_ele_delta: new t.bg(e$1, i$1.u_ele_delta),
					u_fog_matrix: new t.bR(e$1, i$1.u_fog_matrix),
					u_fog_color: new t.bQ(e$1, i$1.u_fog_color),
					u_fog_ground_blend: new t.bg(e$1, i$1.u_fog_ground_blend),
					u_fog_ground_blend_opacity: new t.bg(e$1, i$1.u_fog_ground_blend_opacity),
					u_horizon_color: new t.bQ(e$1, i$1.u_horizon_color),
					u_horizon_fog_blend: new t.bg(e$1, i$1.u_horizon_fog_blend),
					u_is_globe_mode: new t.bg(e$1, i$1.u_is_globe_mode)
				}),
				terrainDepth: (e$1, i$1) => ({ u_ele_delta: new t.bg(e$1, i$1.u_ele_delta) }),
				terrainCoords: (e$1, i$1) => ({
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_terrain_coords_id: new t.bg(e$1, i$1.u_terrain_coords_id),
					u_ele_delta: new t.bg(e$1, i$1.u_ele_delta)
				}),
				projectionErrorMeasurement: (e$1, i$1) => ({
					u_input: new t.bg(e$1, i$1.u_input),
					u_output_expected: new t.bg(e$1, i$1.u_output_expected)
				}),
				atmosphere: (e$1, i$1) => ({
					u_sun_pos: new t.bT(e$1, i$1.u_sun_pos),
					u_atmosphere_blend: new t.bg(e$1, i$1.u_atmosphere_blend),
					u_globe_position: new t.bT(e$1, i$1.u_globe_position),
					u_globe_radius: new t.bg(e$1, i$1.u_globe_radius),
					u_inv_proj_matrix: new t.bR(e$1, i$1.u_inv_proj_matrix)
				}),
				sky: (e$1, i$1) => ({
					u_sky_color: new t.bQ(e$1, i$1.u_sky_color),
					u_horizon_color: new t.bQ(e$1, i$1.u_horizon_color),
					u_horizon: new t.bU(e$1, i$1.u_horizon),
					u_horizon_normal: new t.bU(e$1, i$1.u_horizon_normal),
					u_sky_horizon_blend: new t.bg(e$1, i$1.u_sky_horizon_blend),
					u_sky_blend: new t.bg(e$1, i$1.u_sky_blend)
				})
			};
			class so$1 {
				constructor(e$1, t$1, i$1) {
					this.context = e$1;
					const o$1 = e$1.gl;
					this.buffer = o$1.createBuffer(), this.dynamicDraw = Boolean(i$1), this.context.unbindVAO(), e$1.bindElementBuffer.set(this.buffer), o$1.bufferData(o$1.ELEMENT_ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? o$1.DYNAMIC_DRAW : o$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e$1) {
					const t$1 = this.context.gl;
					if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
					this.context.unbindVAO(), this.bind(), t$1.bufferSubData(t$1.ELEMENT_ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			const no$1 = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class lo$1 {
				constructor(e$1, t$1, i$1, o$1) {
					this.length = t$1.length, this.attributes = i$1, this.itemSize = t$1.bytesPerElement, this.dynamicDraw = o$1, this.context = e$1;
					const r$1 = e$1.gl;
					this.buffer = r$1.createBuffer(), e$1.bindVertexBuffer.set(this.buffer), r$1.bufferData(r$1.ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? r$1.DYNAMIC_DRAW : r$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e$1) {
					if (e$1.length !== this.length) throw new Error(`Length of new data is ${e$1.length}, which doesn't match current length of ${this.length}`);
					const t$1 = this.context.gl;
					this.bind(), t$1.bufferSubData(t$1.ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				enableAttributes(e$1, t$1) {
					for (let i$1 = 0; i$1 < this.attributes.length; i$1++) {
						const o$1 = t$1.attributes[this.attributes[i$1].name];
						void 0 !== o$1 && e$1.enableVertexAttribArray(o$1);
					}
				}
				setVertexAttribPointers(e$1, t$1, i$1) {
					for (let o$1 = 0; o$1 < this.attributes.length; o$1++) {
						const r$1 = this.attributes[o$1], a$1 = t$1.attributes[r$1.name];
						void 0 !== a$1 && e$1.vertexAttribPointer(a$1, r$1.components, e$1[no$1[r$1.type]], !1, this.itemSize, r$1.offset + this.itemSize * (i$1 || 0));
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class co$1 {
				constructor(e$1) {
					this.gl = e$1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e$1) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class ho$1 extends co$1 {
				getDefault() {
					return t.bf.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.clearColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class uo$1 extends co$1 {
				getDefault() {
					return 1;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearDepth(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class _o$1 extends co$1 {
				getDefault() {
					return 0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearStencil(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class po$1 extends co$1 {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.colorMask(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class mo$1 extends co$1 {
				getDefault() {
					return !0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class fo extends co$1 {
				getDefault() {
					return 255;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.stencilMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class go$1 extends co$1 {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.func !== t$1.func || e$1.ref !== t$1.ref || e$1.mask !== t$1.mask || this.dirty) && (this.gl.stencilFunc(e$1.func, e$1.ref, e$1.mask), this.current = e$1, this.dirty = !1);
				}
			}
			class vo$1 extends co$1 {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.KEEP,
						e$1.KEEP,
						e$1.KEEP
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || this.dirty) && (this.gl.stencilOp(e$1[0], e$1[1], e$1[2]), this.current = e$1, this.dirty = !1);
				}
			}
			class bo$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.STENCIL_TEST) : t$1.disable(t$1.STENCIL_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class xo$1 extends co$1 {
				getDefault() {
					return [0, 1];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.depthRange(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class yo$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.DEPTH_TEST) : t$1.disable(t$1.DEPTH_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class wo$1 extends co$1 {
				getDefault() {
					return this.gl.LESS;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthFunc(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class To$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.BLEND) : t$1.disable(t$1.BLEND), this.current = e$1, this.dirty = !1;
				}
			}
			class Po$1 extends co$1 {
				getDefault() {
					const e$1 = this.gl;
					return [e$1.ONE, e$1.ZERO];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.blendFunc(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class Co$1 extends co$1 {
				getDefault() {
					return t.bf.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.blendColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class Io$1 extends co$1 {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.blendEquation(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Mo$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.CULL_FACE) : t$1.disable(t$1.CULL_FACE), this.current = e$1, this.dirty = !1;
				}
			}
			class So$1 extends co$1 {
				getDefault() {
					return this.gl.BACK;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.cullFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Eo$1 extends co$1 {
				getDefault() {
					return this.gl.CCW;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.frontFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ro$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.useProgram(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class zo$1 extends co$1 {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.activeTexture(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Do$1 extends co$1 {
				getDefault() {
					const e$1 = this.gl;
					return [
						0,
						0,
						e$1.drawingBufferWidth,
						e$1.drawingBufferHeight
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.viewport(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Ao$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindFramebuffer(t$1.FRAMEBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Lo$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindRenderbuffer(t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class ko$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindTexture(t$1.TEXTURE_2D, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Fo$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Bo$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ELEMENT_ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Oo$1 extends co$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					var t$1;
					if (e$1 === this.current && !this.dirty) return;
					const i$1 = this.gl;
					qt$1(i$1) ? i$1.bindVertexArray(e$1) : null === (t$1 = i$1.getExtension("OES_vertex_array_object")) || void 0 === t$1 || t$1.bindVertexArrayOES(e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class jo$1 extends co$1 {
				getDefault() {
					return 4;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_ALIGNMENT, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class No$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Uo$1 extends co$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_FLIP_Y_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Zo$1 extends co$1 {
				constructor(e$1, t$1) {
					super(e$1), this.context = e$1, this.parent = t$1;
				}
				getDefault() {
					return null;
				}
			}
			class Go$1 extends Zo$1 {
				setDirty() {
					this.dirty = !0;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, t$1.COLOR_ATTACHMENT0, t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class Vo$1 extends Zo$1 {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class $o$1 extends Zo$1 {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_STENCIL_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			const qo$1 = "Framebuffer is not complete";
			class Wo$1 {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.context = e$1, this.width = t$1, this.height = i$1;
					const a$1 = e$1.gl, s$1 = this.framebuffer = a$1.createFramebuffer();
					if (this.colorAttachment = new Go$1(e$1, s$1), o$1) this.depthAttachment = r$1 ? new $o$1(e$1, s$1) : new Vo$1(e$1, s$1);
					else if (r$1) throw new Error("Stencil cannot be set without depth");
					if (a$1.checkFramebufferStatus(a$1.FRAMEBUFFER) !== a$1.FRAMEBUFFER_COMPLETE) throw new Error(qo$1);
				}
				destroy() {
					const e$1 = this.context.gl, t$1 = this.colorAttachment.get();
					if (t$1 && e$1.deleteTexture(t$1), this.depthAttachment) {
						const t$2 = this.depthAttachment.get();
						t$2 && e$1.deleteRenderbuffer(t$2);
					}
					e$1.deleteFramebuffer(this.framebuffer);
				}
			}
			class Ho {
				constructor(e$1) {
					var t$1, i$1;
					if (this.gl = e$1, this.clearColor = new ho$1(this), this.clearDepth = new uo$1(this), this.clearStencil = new _o$1(this), this.colorMask = new po$1(this), this.depthMask = new mo$1(this), this.stencilMask = new fo(this), this.stencilFunc = new go$1(this), this.stencilOp = new vo$1(this), this.stencilTest = new bo$1(this), this.depthRange = new xo$1(this), this.depthTest = new yo$1(this), this.depthFunc = new wo$1(this), this.blend = new To$1(this), this.blendFunc = new Po$1(this), this.blendColor = new Co$1(this), this.blendEquation = new Io$1(this), this.cullFace = new Mo$1(this), this.cullFaceSide = new So$1(this), this.frontFace = new Eo$1(this), this.program = new Ro$1(this), this.activeTexture = new zo$1(this), this.viewport = new Do$1(this), this.bindFramebuffer = new Ao$1(this), this.bindRenderbuffer = new Lo$1(this), this.bindTexture = new ko$1(this), this.bindVertexBuffer = new Fo$1(this), this.bindElementBuffer = new Bo$1(this), this.bindVertexArray = new Oo$1(this), this.pixelStoreUnpack = new jo$1(this), this.pixelStoreUnpackPremultiplyAlpha = new No$1(this), this.pixelStoreUnpackFlipY = new Uo$1(this), this.extTextureFilterAnisotropic = e$1.getExtension("EXT_texture_filter_anisotropic") || e$1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e$1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e$1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e$1.getParameter(e$1.MAX_TEXTURE_SIZE), qt$1(e$1)) {
						this.HALF_FLOAT = e$1.HALF_FLOAT;
						const o$1 = e$1.getExtension("EXT_color_buffer_half_float");
						this.RGBA16F = null !== (t$1 = e$1.RGBA16F) && void 0 !== t$1 ? t$1 : null == o$1 ? void 0 : o$1.RGBA16F_EXT, this.RGB16F = null !== (i$1 = e$1.RGB16F) && void 0 !== i$1 ? i$1 : null == o$1 ? void 0 : o$1.RGB16F_EXT, e$1.getExtension("EXT_color_buffer_float");
					} else {
						e$1.getExtension("EXT_color_buffer_half_float"), e$1.getExtension("OES_texture_half_float_linear");
						const t$2 = e$1.getExtension("OES_texture_half_float");
						this.HALF_FLOAT = null == t$2 ? void 0 : t$2.HALF_FLOAT_OES;
					}
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e$1, t$1) {
					return new so$1(this, e$1, t$1);
				}
				createVertexBuffer(e$1, t$1, i$1) {
					return new lo$1(this, e$1, t$1, i$1);
				}
				createRenderbuffer(e$1, t$1, i$1) {
					const o$1 = this.gl, r$1 = o$1.createRenderbuffer();
					return this.bindRenderbuffer.set(r$1), o$1.renderbufferStorage(o$1.RENDERBUFFER, e$1, t$1, i$1), this.bindRenderbuffer.set(null), r$1;
				}
				createFramebuffer(e$1, t$1, i$1, o$1) {
					return new Wo$1(this, e$1, t$1, i$1, o$1);
				}
				clear({ color: e$1, depth: t$1, stencil: i$1 }) {
					const o$1 = this.gl;
					let r$1 = 0;
					e$1 && (r$1 |= o$1.COLOR_BUFFER_BIT, this.clearColor.set(e$1), this.colorMask.set([
						!0,
						!0,
						!0,
						!0
					])), void 0 !== t$1 && (r$1 |= o$1.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t$1), this.depthMask.set(!0)), void 0 !== i$1 && (r$1 |= o$1.STENCIL_BUFFER_BIT, this.clearStencil.set(i$1), this.stencilMask.set(255)), o$1.clear(r$1);
				}
				setCullFace(e$1) {
					!1 === e$1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e$1.mode), this.frontFace.set(e$1.frontFace));
				}
				setDepthMode(e$1) {
					e$1.func !== this.gl.ALWAYS || e$1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e$1.func), this.depthMask.set(e$1.mask), this.depthRange.set(e$1.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e$1) {
					e$1.test.func !== this.gl.ALWAYS || e$1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e$1.mask), this.stencilOp.set([
						e$1.fail,
						e$1.depthFail,
						e$1.pass
					]), this.stencilFunc.set({
						func: e$1.test.func,
						ref: e$1.ref,
						mask: e$1.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(e$1) {
					t.bH(e$1.blendFunction, jt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e$1.blendFunction), this.blendColor.set(e$1.blendColor)), this.colorMask.set(e$1.mask);
				}
				createVertexArray() {
					var e$1;
					return qt$1(this.gl) ? this.gl.createVertexArray() : null === (e$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e$1 ? void 0 : e$1.createVertexArrayOES();
				}
				deleteVertexArray(e$1) {
					var t$1;
					return qt$1(this.gl) ? this.gl.deleteVertexArray(e$1) : null === (t$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t$1 ? void 0 : t$1.deleteVertexArrayOES(e$1);
				}
				unbindVAO() {
					this.bindVertexArray.set(null);
				}
			}
			let Xo$1;
			function Ko$1(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = e$1.transform, l$1 = s$1.gl, c$1 = e$1.useProgram("collisionBox"), h$1 = [];
				let u$1 = 0, d$1 = 0;
				for (let t$1 = 0; t$1 < r$1.length; t$1++) {
					const _$3 = r$1[t$1], p$2 = i$1.getTile(_$3).getBucket(o$1);
					if (!p$2) continue;
					const m$2 = a$1 ? p$2.textCollisionBox : p$2.iconCollisionBox, f$2 = p$2.collisionCircleArray;
					f$2.length > 0 && (h$1.push({
						circleArray: f$2,
						circleOffset: d$1,
						coord: _$3
					}), u$1 += f$2.length / 4, d$1 = u$1), m$2 && c$1.draw(s$1, l$1.LINES, Zt$1.disabled, Vt$1.disabled, e$1.colorModeForRenderPass(), Ut$1.disabled, Fi$1(e$1.transform), e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(_$3), n$1.getProjectionData({
						overscaledTileID: _$3,
						applyGlobeMatrix: !0,
						applyTerrainMatrix: !0
					}), o$1.id, m$2.layoutVertexBuffer, m$2.indexBuffer, m$2.segments, null, e$1.transform.zoom, null, null, m$2.collisionVertexBuffer);
				}
				if (!a$1 || !h$1.length) return;
				const _$2 = e$1.useProgram("collisionCircle"), p$1 = new t.b$();
				p$1.resize(4 * u$1), p$1._trim();
				let m$1 = 0;
				for (const e$2 of h$1) for (let t$1 = 0; t$1 < e$2.circleArray.length / 4; t$1++) {
					const i$2 = 4 * t$1, o$2 = e$2.circleArray[i$2 + 0], r$2 = e$2.circleArray[i$2 + 1], a$2 = e$2.circleArray[i$2 + 2], s$2 = e$2.circleArray[i$2 + 3];
					p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 0), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 1), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 2), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 3);
				}
				(!Xo$1 || Xo$1.length < 2 * u$1) && (Xo$1 = function(e$2) {
					const i$2 = 2 * e$2, o$2 = new t.c1();
					o$2.resize(i$2), o$2._trim();
					for (let e$3 = 0; e$3 < i$2; e$3++) {
						const t$1 = 6 * e$3;
						o$2.uint16[t$1 + 0] = 4 * e$3 + 0, o$2.uint16[t$1 + 1] = 4 * e$3 + 1, o$2.uint16[t$1 + 2] = 4 * e$3 + 2, o$2.uint16[t$1 + 3] = 4 * e$3 + 2, o$2.uint16[t$1 + 4] = 4 * e$3 + 3, o$2.uint16[t$1 + 5] = 4 * e$3 + 0;
					}
					return o$2;
				}(u$1));
				const f$1 = s$1.createIndexBuffer(Xo$1, !0), g$2 = s$1.createVertexBuffer(p$1, t.c0.members, !0);
				for (const i$2 of h$1) {
					const r$2 = Bi$1(e$1.transform);
					_$2.draw(s$1, l$1.TRIANGLES, Zt$1.disabled, Vt$1.disabled, e$1.colorModeForRenderPass(), Ut$1.disabled, r$2, e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(i$2.coord), null, o$1.id, g$2, f$1, t.aM.simpleSegment(0, 2 * i$2.circleOffset, i$2.circleArray.length, i$2.circleArray.length / 2), null, e$1.transform.zoom, null, null, null);
				}
				g$2.destroy(), f$1.destroy();
			}
			const Yo$1 = t.ag(new Float32Array(16));
			function Qo$1(e$1, i$1, o$1, r$1, a$1, s$1) {
				const { horizontalAlign: n$1, verticalAlign: l$1 } = t.aH(e$1);
				return new t.P((-(n$1 - .5) * i$1 / a$1 + r$1[0]) * s$1, (-(l$1 - .5) * o$1 / a$1 + r$1[1]) * s$1);
			}
			function Jo$1(e$1, i$1, o$1, r$1, a$1, s$1) {
				const n$1 = i$1.tileAnchorPoint.add(new t.P(i$1.translation[0], i$1.translation[1]));
				if (i$1.pitchWithMap) {
					let e$2 = r$1.mult(s$1);
					o$1 || (e$2 = e$2.rotate(-a$1));
					const t$1 = n$1.add(e$2);
					return Ee(t$1.x, t$1.y, i$1.pitchedLabelPlaneMatrix, i$1.getElevation).point;
				}
				if (o$1) {
					const t$1 = Oe$1(i$1.tileAnchorPoint.x + 1, i$1.tileAnchorPoint.y, i$1).point.sub(e$1), o$2 = Math.atan(t$1.y / t$1.x) + (t$1.x < 0 ? Math.PI : 0);
					return e$1.add(r$1.rotate(o$2));
				}
				return e$1.add(r$1);
			}
			function er$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) {
				const _$2 = e$1.text.placedSymbolArray, p$1 = e$1.text.dynamicLayoutVertexArray, m$1 = e$1.icon.dynamicLayoutVertexArray, f$1 = {};
				p$1.clear();
				for (let m$2 = 0; m$2 < _$2.length; m$2++) {
					const g$2 = _$2.get(m$2), v$1 = g$2.hidden || !g$2.crossTileID || e$1.allowVerticalPlacement && !g$2.placedOrientation ? null : r$1[g$2.crossTileID];
					if (v$1) {
						const r$2 = new t.P(g$2.anchorX, g$2.anchorY), _$3 = {
							getElevation: d$1,
							width: a$1.width,
							height: a$1.height,
							pitchedLabelPlaneMatrix: s$1,
							pitchWithMap: o$1,
							transform: a$1,
							tileAnchorPoint: r$2,
							translation: h$1,
							unwrappedTileID: u$1
						}, m$3 = o$1 ? Ne$1(r$2.x, r$2.y, _$3) : Oe$1(r$2.x, r$2.y, _$3), b$2 = Re$1(a$1.cameraToCenterDistance, m$3.signedDistanceFromCamera);
						let x$1 = t.ap(e$1.textSizeData, l$1, g$2) * b$2 / t.aB;
						o$1 && (x$1 *= e$1.tilePixelRatio / n$1);
						const { width: y$1, height: w$1, anchor: T$2, textOffset: P$2, textBoxScale: C$1 } = v$1, I$2 = Qo$1(T$2, y$1, w$1, P$2, C$1, x$1), M$2 = a$1.getPitchedTextCorrection(r$2.x + h$1[0], r$2.y + h$1[1], u$1), S$2 = Jo$1(m$3.point, _$3, i$1, I$2, -a$1.bearingInRadians, M$2), E$1 = e$1.allowVerticalPlacement && g$2.placedOrientation === t.ao.vertical ? Math.PI / 2 : 0;
						for (let e$2 = 0; e$2 < g$2.numGlyphs; e$2++) t.av(p$1, S$2, E$1);
						c$1 && g$2.associatedIconIndex >= 0 && (f$1[g$2.associatedIconIndex] = {
							shiftedAnchor: S$2,
							angle: E$1
						});
					} else $e$1(g$2.numGlyphs, p$1);
				}
				if (c$1) {
					m$1.clear();
					const i$2 = e$1.icon.placedSymbolArray;
					for (let e$2 = 0; e$2 < i$2.length; e$2++) {
						const o$2 = i$2.get(e$2);
						if (o$2.hidden) $e$1(o$2.numGlyphs, m$1);
						else {
							const i$3 = f$1[e$2];
							if (i$3) for (let e$3 = 0; e$3 < o$2.numGlyphs; e$3++) t.av(m$1, i$3.shiftedAnchor, i$3.angle);
							else $e$1(o$2.numGlyphs, m$1);
						}
					}
					e$1.icon.dynamicLayoutVertexBuffer.updateData(m$1);
				}
				e$1.text.dynamicLayoutVertexBuffer.updateData(p$1);
			}
			function tr$1(e$1, t$1, i$1) {
				return i$1.iconsInText && t$1 ? "symbolTextAndIcon" : e$1 ? "symbolSDF" : "symbolIcon";
			}
			function ir$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) {
				const p$1 = e$1.context, m$1 = p$1.gl, f$1 = e$1.transform, g$2 = "map" === l$1, v$1 = "map" === c$1, b$2 = "viewport" !== l$1 && "point" !== o$1.layout.get("symbol-placement"), x$1 = g$2 && !v$1 && !b$2, y$1 = !o$1.layout.get("symbol-sort-key").isConstant();
				let w$1 = !1;
				const T$2 = e$1.getDepthModeForSublayer(0, Zt$1.ReadOnly), P$2 = o$1._unevaluatedLayout.hasValue("text-variable-anchor") || o$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C$1 = [], I$2 = f$1.getCircleRadiusCorrection();
				for (const l$2 of r$1) {
					const r$2 = i$1.getTile(l$2), c$2 = r$2.getBucket(o$1);
					if (!c$2) continue;
					const u$2 = a$1 ? c$2.text : c$2.icon;
					if (!u$2 || !u$2.segments.get().length || !u$2.hasVisibleVertices) continue;
					const d$2 = u$2.programConfigurations.get(o$1.id), p$2 = a$1 || c$2.sdfIcons, T$3 = a$1 ? c$2.textSizeData : c$2.iconSizeData, M$2 = v$1 || 0 !== f$1.pitch, S$2 = e$1.useProgram(tr$1(p$2, a$1, c$2), d$2), E$1 = t.an(T$3, f$1.zoom), R$3 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(l$2);
					let z$2, D$2, A$1, L$2, k$2 = [0, 0], F$2 = null;
					if (a$1) D$2 = r$2.glyphAtlasTexture, A$1 = m$1.LINEAR, z$2 = r$2.glyphAtlasTexture.size, c$2.iconsInText && (k$2 = r$2.imageAtlasTexture.size, F$2 = r$2.imageAtlasTexture, L$2 = M$2 || e$1.options.rotating || e$1.options.zooming || "composite" === T$3.kind || "camera" === T$3.kind ? m$1.LINEAR : m$1.NEAREST);
					else {
						const t$1 = 1 !== o$1.layout.get("icon-size").constantOr(0) || c$2.iconsNeedLinear;
						D$2 = r$2.imageAtlasTexture, A$1 = p$2 || e$1.options.rotating || e$1.options.zooming || t$1 || M$2 ? m$1.LINEAR : m$1.NEAREST, z$2 = r$2.imageAtlasTexture.size;
					}
					const B$2 = t.aC(r$2, 1, e$1.transform.zoom), O$2 = Ie$1(g$2, e$1.transform, B$2), j$2 = t.L();
					t.aq(j$2, O$2);
					const N$1 = Me$1(v$1, g$2, e$1.transform, B$2), U$2 = t.aD(f$1, r$2, s$1, n$1), Z$2 = f$1.getProjectionData({
						overscaledTileID: l$2,
						applyGlobeMatrix: !_$2,
						applyTerrainMatrix: !0
					}), G$2 = P$2 && c$2.hasTextData(), V$1 = "none" !== o$1.layout.get("icon-text-fit") && G$2 && c$2.hasIconData();
					if (b$2) {
						const t$1 = e$1.style.map.terrain ? (t$2, i$2) => e$1.style.map.terrain.getElevation(l$2, t$2, i$2) : null;
						De$1(c$2, e$1, a$1, O$2, j$2, v$1, h$1, "map" === o$1.layout.get("text-rotation-alignment"), l$2.toUnwrapped(), f$1.width, f$1.height, U$2, t$1);
					}
					const $$2 = a$1 && P$2 || V$1, q$2 = b$2 || $$2 ? Yo$1 : v$1 ? O$2 : e$1.transform.clipSpaceToPixelsMatrix, W$2 = p$2 && 0 !== o$1.paint.get(a$1 ? "text-halo-width" : "icon-halo-width").constantOr(1);
					let H$2;
					H$2 = p$2 ? c$2.iconsInText ? to$1(T$3.kind, E$1, x$1, v$1, b$2, $$2, e$1, q$2, N$1, U$2, z$2, k$2, I$2) : eo$1(T$3.kind, E$1, x$1, v$1, b$2, $$2, e$1, q$2, N$1, U$2, a$1, z$2, 0, I$2) : Ji$1(T$3.kind, E$1, x$1, v$1, b$2, $$2, e$1, q$2, N$1, U$2, a$1, z$2, I$2);
					const X$2 = {
						program: S$2,
						buffers: u$2,
						uniformValues: H$2,
						projectionData: Z$2,
						atlasTexture: D$2,
						atlasTextureIcon: F$2,
						atlasInterpolation: A$1,
						atlasInterpolationIcon: L$2,
						isSDF: p$2,
						hasHalo: W$2
					};
					if (y$1 && c$2.canOverlap) {
						w$1 = !0;
						const e$2 = u$2.segments.get();
						for (const i$2 of e$2) C$1.push({
							segments: new t.aM([i$2]),
							sortKey: i$2.sortKey,
							state: X$2,
							terrainData: R$3
						});
					} else C$1.push({
						segments: u$2.segments,
						sortKey: 0,
						state: X$2,
						terrainData: R$3
					});
				}
				w$1 && C$1.sort(((e$2, t$1) => e$2.sortKey - t$1.sortKey));
				for (const t$1 of C$1) {
					const i$2 = t$1.state;
					if (p$1.activeTexture.set(m$1.TEXTURE0), i$2.atlasTexture.bind(i$2.atlasInterpolation, m$1.CLAMP_TO_EDGE), i$2.atlasTextureIcon && (p$1.activeTexture.set(m$1.TEXTURE1), i$2.atlasTextureIcon && i$2.atlasTextureIcon.bind(i$2.atlasInterpolationIcon, m$1.CLAMP_TO_EDGE)), i$2.isSDF) {
						const r$2 = i$2.uniformValues;
						i$2.hasHalo && (r$2.u_is_halo = 1, or$1(i$2.buffers, t$1.segments, o$1, e$1, i$2.program, T$2, u$1, d$1, r$2, i$2.projectionData, t$1.terrainData)), r$2.u_is_halo = 0;
					}
					or$1(i$2.buffers, t$1.segments, o$1, e$1, i$2.program, T$2, u$1, d$1, i$2.uniformValues, i$2.projectionData, t$1.terrainData);
				}
			}
			function or$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1) {
				const u$1 = o$1.context;
				r$1.draw(u$1, u$1.gl.TRIANGLES, a$1, s$1, n$1, Ut$1.backCCW, l$1, h$1, c$1, i$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, t$1, i$1.paint, o$1.transform.zoom, e$1.programConfigurations.get(i$1.id), e$1.dynamicLayoutVertexBuffer, e$1.opacityVertexBuffer);
			}
			function rr$1(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = s$1.gl, l$1 = Vt$1.disabled, c$1 = new jt([n$1.ONE, n$1.ONE], t.bf.transparent, [
					!0,
					!0,
					!0,
					!0
				]), h$1 = i$1.getBucket(o$1);
				if (!h$1) return;
				const u$1 = r$1.key;
				let d$1 = o$1.heatmapFbos.get(u$1);
				d$1 || (d$1 = sr$1(s$1, i$1.tileSize, i$1.tileSize), o$1.heatmapFbos.set(u$1, d$1)), s$1.bindFramebuffer.set(d$1.framebuffer), s$1.viewport.set([
					0,
					0,
					i$1.tileSize,
					i$1.tileSize
				]), s$1.clear({ color: t.bf.transparent });
				const _$2 = h$1.programConfigurations.get(o$1.id), p$1 = e$1.useProgram("heatmap", _$2, !a$1), m$1 = e$1.transform.getProjectionData({
					overscaledTileID: i$1.tileID,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				}), f$1 = e$1.style.map.terrain.getTerrainData(r$1);
				p$1.draw(s$1, n$1.TRIANGLES, Zt$1.disabled, l$1, c$1, Ut$1.disabled, ji$1(i$1, e$1.transform.zoom, o$1.paint.get("heatmap-intensity"), 1), f$1, m$1, o$1.id, h$1.layoutVertexBuffer, h$1.indexBuffer, h$1.segments, o$1.paint, e$1.transform.zoom, _$2);
			}
			function ar$1(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1.context, s$1 = a$1.gl, n$1 = e$1.transform;
				a$1.setColorMode(e$1.colorModeForRenderPass());
				const l$1 = nr$1(a$1, t$1), c$1 = i$1.key, h$1 = t$1.heatmapFbos.get(c$1);
				if (!h$1) return;
				a$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, h$1.colorAttachment.get()), a$1.activeTexture.set(s$1.TEXTURE1), l$1.bind(s$1.LINEAR, s$1.CLAMP_TO_EDGE);
				const u$1 = n$1.getProjectionData({
					overscaledTileID: i$1,
					applyTerrainMatrix: r$1,
					applyGlobeMatrix: !o$1
				});
				e$1.useProgram("heatmapTexture").draw(a$1, s$1.TRIANGLES, Zt$1.disabled, Vt$1.disabled, e$1.colorModeForRenderPass(), Ut$1.disabled, Ni$1(e$1, t$1, 0, 1), null, u$1, t$1.id, e$1.rasterBoundsBuffer, e$1.quadTriangleIndexBuffer, e$1.rasterBoundsSegments, t$1.paint, n$1.zoom), h$1.destroy(), t$1.heatmapFbos.delete(c$1);
			}
			function sr$1(e$1, t$1, i$1) {
				var o$1, r$1;
				const a$1 = e$1.gl, s$1 = a$1.createTexture();
				a$1.bindTexture(a$1.TEXTURE_2D, s$1), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_S, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_T, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MIN_FILTER, a$1.LINEAR), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MAG_FILTER, a$1.LINEAR);
				const n$1 = null !== (o$1 = e$1.HALF_FLOAT) && void 0 !== o$1 ? o$1 : a$1.UNSIGNED_BYTE, l$1 = null !== (r$1 = e$1.RGBA16F) && void 0 !== r$1 ? r$1 : a$1.RGBA;
				a$1.texImage2D(a$1.TEXTURE_2D, 0, l$1, t$1, i$1, 0, a$1.RGBA, n$1, null);
				const c$1 = e$1.createFramebuffer(t$1, i$1, !1, !1);
				return c$1.colorAttachment.set(s$1), c$1;
			}
			function nr$1(e$1, i$1) {
				return i$1.colorRampTexture || (i$1.colorRampTexture = new t.T(e$1, i$1.colorRamp, e$1.gl.RGBA)), i$1.colorRampTexture;
			}
			function lr$1(e$1, t$1, i$1, o$1, r$1) {
				if (!i$1 || !o$1 || !o$1.imageAtlas) return;
				const a$1 = o$1.imageAtlas.patternPositions;
				let s$1 = a$1[i$1.to.toString()], n$1 = a$1[i$1.from.toString()];
				if (!s$1 && n$1 && (s$1 = n$1), !n$1 && s$1 && (n$1 = s$1), !s$1 || !n$1) {
					const e$2 = r$1.getPaintProperty(t$1);
					s$1 = a$1[e$2], n$1 = a$1[e$2];
				}
				s$1 && n$1 && e$1.setConstantPatternPositions(s$1, n$1);
			}
			function cr$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = e$1.context.gl, h$1 = "fill-pattern", u$1 = o$1.paint.get(h$1), d$1 = u$1 && u$1.constantOr(1), _$2 = o$1.getCrossfadeParameters();
				let p$1, m$1, f$1, g$2, v$1;
				const b$2 = e$1.transform, x$1 = o$1.paint.get("fill-translate"), y$1 = o$1.paint.get("fill-translate-anchor");
				n$1 ? (m$1 = d$1 && !o$1.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p$1 = c$1.LINES) : (m$1 = d$1 ? "fillPattern" : "fill", p$1 = c$1.TRIANGLES);
				const w$1 = u$1.constantOr(null);
				for (const u$2 of r$1) {
					const r$2 = i$1.getTile(u$2);
					if (d$1 && !r$2.patternsLoaded()) continue;
					const T$2 = r$2.getBucket(o$1);
					if (!T$2) continue;
					const P$2 = T$2.programConfigurations.get(o$1.id), C$1 = e$1.useProgram(m$1, P$2), I$2 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(u$2);
					d$1 && (e$1.context.activeTexture.set(c$1.TEXTURE0), r$2.imageAtlasTexture.bind(c$1.LINEAR, c$1.CLAMP_TO_EDGE), P$2.updatePaintBuffers(_$2)), lr$1(P$2, h$1, w$1, r$2, o$1);
					const M$2 = b$2.getProjectionData({
						overscaledTileID: u$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					}), S$2 = t.aD(b$2, r$2, x$1, y$1);
					if (n$1) {
						g$2 = T$2.indexBuffer2, v$1 = T$2.segments2;
						const t$1 = [c$1.drawingBufferWidth, c$1.drawingBufferHeight];
						f$1 = "fillOutlinePattern" === m$1 && d$1 ? Li$1(e$1, _$2, r$2, t$1, S$2) : Ai(t$1, S$2);
					} else g$2 = T$2.indexBuffer, v$1 = T$2.segments, f$1 = d$1 ? Di$1(e$1, _$2, r$2, S$2) : { u_fill_translate: S$2 };
					const E$1 = e$1.stencilModeForClipping(u$2);
					C$1.draw(e$1.context, p$1, a$1, E$1, s$1, Ut$1.backCCW, f$1, I$2, M$2, o$1.id, T$2.layoutVertexBuffer, g$2, v$1, o$1.paint, e$1.transform.zoom, P$2);
				}
			}
			function hr$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = e$1.context, h$1 = c$1.gl, u$1 = "fill-extrusion-pattern", d$1 = o$1.paint.get(u$1), _$2 = d$1.constantOr(1), p$1 = o$1.getCrossfadeParameters(), m$1 = o$1.paint.get("fill-extrusion-opacity"), f$1 = d$1.constantOr(null), g$2 = e$1.transform;
				for (const d$2 of r$1) {
					const r$2 = i$1.getTile(d$2), v$1 = r$2.getBucket(o$1);
					if (!v$1) continue;
					const b$2 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(d$2), x$1 = v$1.programConfigurations.get(o$1.id), y$1 = e$1.useProgram(_$2 ? "fillExtrusionPattern" : "fillExtrusion", x$1);
					_$2 && (e$1.context.activeTexture.set(h$1.TEXTURE0), r$2.imageAtlasTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), x$1.updatePaintBuffers(p$1));
					const w$1 = g$2.getProjectionData({
						overscaledTileID: d$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					lr$1(x$1, u$1, f$1, r$2, o$1);
					const T$2 = t.aD(g$2, r$2, o$1.paint.get("fill-extrusion-translate"), o$1.paint.get("fill-extrusion-translate-anchor")), P$2 = o$1.paint.get("fill-extrusion-vertical-gradient"), C$1 = _$2 ? zi$1(e$1, P$2, m$1, T$2, d$2, p$1, r$2) : Ri$1(e$1, P$2, m$1, T$2);
					y$1.draw(c$1, c$1.gl.TRIANGLES, a$1, s$1, n$1, Ut$1.backCCW, C$1, b$2, w$1, o$1.id, v$1.layoutVertexBuffer, v$1.indexBuffer, v$1.segments, o$1.paint, e$1.transform.zoom, x$1, e$1.style.map.terrain && v$1.centroidVertexBuffer);
				}
			}
			function ur$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				var c$1;
				const h$1 = e$1.style.projection, u$1 = e$1.context, d$1 = e$1.transform, _$2 = u$1.gl, p$1 = [`#define NUM_ILLUMINATION_SOURCES ${i$1.paint.get("hillshade-highlight-color").values.length}`], m$1 = e$1.useProgram("hillshade", null, !1, p$1), f$1 = !e$1.options.moving;
				for (const p$2 of o$1) {
					const o$2 = t$1.getTile(p$2), g$2 = o$2.fbo;
					if (!g$2) continue;
					const v$1 = h$1.getMeshFromTileID(u$1, p$2.canonical, n$1, !0, "raster"), b$2 = null === (c$1 = e$1.style.map.terrain) || void 0 === c$1 ? void 0 : c$1.getTerrainData(p$2);
					u$1.activeTexture.set(_$2.TEXTURE0), _$2.bindTexture(_$2.TEXTURE_2D, g$2.colorAttachment.get());
					const x$1 = d$1.getProjectionData({
						overscaledTileID: p$2,
						aligned: f$1,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(u$1, _$2.TRIANGLES, a$1, r$1[p$2.overscaledZ], s$1, Ut$1.backCCW, Ui$1(e$1, o$2, i$1), b$2, x$1, i$1.id, v$1.vertexBuffer, v$1.indexBuffer, v$1.segments);
				}
			}
			function dr$1(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1) {
				var h$1;
				const u$1 = e$1.style.projection, d$1 = e$1.context, _$2 = e$1.transform, p$1 = d$1.gl, m$1 = e$1.useProgram("colorRelief"), f$1 = !e$1.options.moving;
				let g$2 = !0, v$1 = 0;
				for (const b$2 of r$1) {
					const r$2 = i$1.getTile(b$2), x$1 = r$2.dem;
					if (g$2) {
						const e$2 = p$1.getParameter(p$1.MAX_TEXTURE_SIZE), { elevationTexture: t$1, colorTexture: i$2 } = o$1.getColorRampTextures(d$1, e$2, x$1.getUnpackVector());
						d$1.activeTexture.set(p$1.TEXTURE1), t$1.bind(p$1.NEAREST, p$1.CLAMP_TO_EDGE), d$1.activeTexture.set(p$1.TEXTURE4), i$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE), g$2 = !1, v$1 = t$1.size[0];
					}
					if (!x$1 || !x$1.data) continue;
					const y$1 = x$1.stride, w$1 = x$1.getPixels();
					if (d$1.activeTexture.set(p$1.TEXTURE0), d$1.pixelStoreUnpackPremultiplyAlpha.set(!1), r$2.demTexture = r$2.demTexture || e$1.getTileTexture(y$1), r$2.demTexture) {
						const e$2 = r$2.demTexture;
						e$2.update(w$1, { premultiply: !1 }), e$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					} else r$2.demTexture = new t.T(d$1, w$1, p$1.RGBA, { premultiply: !1 }), r$2.demTexture.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					const T$2 = u$1.getMeshFromTileID(d$1, b$2.canonical, l$1, !0, "raster"), P$2 = null === (h$1 = e$1.style.map.terrain) || void 0 === h$1 ? void 0 : h$1.getTerrainData(b$2), C$1 = _$2.getProjectionData({
						overscaledTileID: b$2,
						aligned: f$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(d$1, p$1.TRIANGLES, s$1, a$1[b$2.overscaledZ], n$1, Ut$1.backCCW, Vi$1(o$1, r$2.dem, v$1), P$2, C$1, o$1.id, T$2.vertexBuffer, T$2.indexBuffer, T$2.segments);
				}
			}
			const _r$1 = [
				new t.P(0, 0),
				new t.P(t.$, 0),
				new t.P(t.$, t.$),
				new t.P(0, t.$)
			];
			function pr$1(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1 = !1, c$1 = !1) {
				const h$1 = o$1[o$1.length - 1].overscaledZ, u$1 = e$1.context, d$1 = u$1.gl, _$2 = e$1.useProgram("raster"), p$1 = e$1.transform, m$1 = e$1.style.projection, f$1 = e$1.colorModeForRenderPass(), g$2 = !e$1.options.moving;
				for (const v$1 of o$1) {
					const o$2 = e$1.getDepthModeForSublayer(v$1.overscaledZ - h$1, 1 === i$1.paint.get("raster-opacity") ? Zt$1.ReadWrite : Zt$1.ReadOnly, d$1.LESS), b$2 = t$1.getTile(v$1);
					b$2.registerFadeDuration(i$1.paint.get("raster-fade-duration"));
					const x$1 = t$1.findLoadedParent(v$1, 0), y$1 = t$1.findLoadedSibling(v$1), w$1 = mr$1(b$2, x$1 || y$1 || null, t$1, i$1, e$1.transform, e$1.style.map.terrain);
					let T$2, P$2;
					const C$1 = "nearest" === i$1.paint.get("raster-resampling") ? d$1.NEAREST : d$1.LINEAR;
					u$1.activeTexture.set(d$1.TEXTURE0), b$2.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), u$1.activeTexture.set(d$1.TEXTURE1), x$1 ? (x$1.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), T$2 = Math.pow(2, x$1.tileID.overscaledZ - b$2.tileID.overscaledZ), P$2 = [b$2.tileID.canonical.x * T$2 % 1, b$2.tileID.canonical.y * T$2 % 1]) : b$2.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), b$2.texture.useMipmap && u$1.extTextureFilterAnisotropic && e$1.transform.pitch > 20 && d$1.texParameterf(d$1.TEXTURE_2D, u$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u$1.extTextureFilterAnisotropicMax);
					const I$2 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(v$1), M$2 = p$1.getProjectionData({
						overscaledTileID: v$1,
						aligned: g$2,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					}), S$2 = Yi$1(P$2 || [0, 0], T$2 || 1, w$1, i$1, n$1), E$1 = m$1.getMeshFromTileID(u$1, v$1.canonical, a$1, s$1, "raster");
					_$2.draw(u$1, d$1.TRIANGLES, o$2, r$1 ? r$1[v$1.overscaledZ] : Vt$1.disabled, f$1, l$1 ? Ut$1.frontCCW : Ut$1.backCCW, S$2, I$2, M$2, i$1.id, E$1.vertexBuffer, E$1.indexBuffer, E$1.segments);
				}
			}
			function mr$1(e$1, i$1, o$1, r$1, a$1, n$1) {
				const l$1 = r$1.paint.get("raster-fade-duration");
				if (!n$1 && l$1 > 0) {
					const r$2 = s.now(), n$2 = (r$2 - e$1.timeAdded) / l$1, c$1 = i$1 ? (r$2 - i$1.timeAdded) / l$1 : -1, h$1 = o$1.getSource(), u$1 = ge$1(a$1, {
						tileSize: h$1.tileSize,
						roundZoom: h$1.roundZoom
					}), d$1 = !i$1 || Math.abs(i$1.tileID.overscaledZ - u$1) > Math.abs(e$1.tileID.overscaledZ - u$1), _$2 = d$1 && e$1.refreshedUponExpiration ? 1 : t.ah(d$1 ? n$2 : 1 - c$1, 0, 1);
					return e$1.refreshedUponExpiration && n$2 >= 1 && (e$1.refreshedUponExpiration = !1), i$1 ? {
						opacity: 1,
						mix: 1 - _$2
					} : {
						opacity: _$2,
						mix: 0
					};
				}
				return {
					opacity: 1,
					mix: 0
				};
			}
			const fr$1 = new t.bf(1, 0, 0, 1), gr$1 = new t.bf(0, 1, 0, 1), vr$1 = new t.bf(0, 0, 1, 1), br$1 = new t.bf(1, 0, 1, 1), xr$1 = new t.bf(0, 1, 1, 1);
			function yr$1(e$1, t$1, i$1, o$1) {
				Tr$1(e$1, 0, t$1 + i$1 / 2, e$1.transform.width, i$1, o$1);
			}
			function wr$1(e$1, t$1, i$1, o$1) {
				Tr$1(e$1, t$1 - i$1 / 2, 0, i$1, e$1.transform.height, o$1);
			}
			function Tr$1(e$1, t$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = s$1.gl;
				n$1.enable(n$1.SCISSOR_TEST), n$1.scissor(t$1 * e$1.pixelRatio, i$1 * e$1.pixelRatio, o$1 * e$1.pixelRatio, r$1 * e$1.pixelRatio), s$1.clear({ color: a$1 }), n$1.disable(n$1.SCISSOR_TEST);
			}
			function Pr$1(e$1, i$1, o$1) {
				const r$1 = e$1.context, a$1 = r$1.gl, s$1 = e$1.useProgram("debug"), n$1 = Zt$1.disabled, l$1 = Vt$1.disabled, c$1 = e$1.colorModeForRenderPass(), h$1 = "$debug", u$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(o$1);
				r$1.activeTexture.set(a$1.TEXTURE0);
				const d$1 = i$1.getTileByID(o$1.key).latestRawTileData, _$2 = Math.floor((d$1 && d$1.byteLength || 0) / 1024), p$1 = i$1.getTile(o$1).tileSize, m$1 = 512 / Math.min(p$1, 512) * (o$1.overscaledZ / e$1.transform.zoom) * .5;
				let f$1 = o$1.canonical.toString();
				o$1.overscaledZ !== o$1.canonical.z && (f$1 += ` => ${o$1.overscaledZ}`), function(e$2, t$1) {
					e$2.initDebugOverlayCanvas();
					const i$2 = e$2.debugOverlayCanvas, o$2 = e$2.context.gl, r$2 = e$2.debugOverlayCanvas.getContext("2d");
					r$2.clearRect(0, 0, i$2.width, i$2.height), r$2.shadowColor = "white", r$2.shadowBlur = 2, r$2.lineWidth = 1.5, r$2.strokeStyle = "white", r$2.textBaseline = "top", r$2.font = "bold 36px Open Sans, sans-serif", r$2.fillText(t$1, 5, 5), r$2.strokeText(t$1, 5, 5), e$2.debugOverlayTexture.update(i$2), e$2.debugOverlayTexture.bind(o$2.LINEAR, o$2.CLAMP_TO_EDGE);
				}(e$1, `${f$1} ${_$2}kB`);
				const g$2 = e$1.transform.getProjectionData({
					overscaledTileID: o$1,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				});
				s$1.draw(r$1, a$1.TRIANGLES, n$1, l$1, jt.alphaBlended, Ut$1.disabled, Oi$1(t.bf.transparent, m$1), null, g$2, h$1, e$1.debugBuffer, e$1.quadTriangleIndexBuffer, e$1.debugSegments), s$1.draw(r$1, a$1.LINE_STRIP, n$1, l$1, c$1, Ut$1.disabled, Oi$1(t.bf.red), u$1, g$2, h$1, e$1.debugBuffer, e$1.tileBorderIndexBuffer, e$1.debugSegments);
			}
			function Cr(e$1, t$1, i$1, o$1) {
				const { isRenderingGlobe: r$1 } = o$1, a$1 = e$1.context, s$1 = a$1.gl, n$1 = e$1.transform, l$1 = e$1.colorModeForRenderPass(), c$1 = e$1.getDepthModeFor3D(), h$1 = e$1.useProgram("terrain");
				a$1.bindFramebuffer.set(null), a$1.viewport.set([
					0,
					0,
					e$1.width,
					e$1.height
				]);
				for (const o$2 of i$1) {
					const i$2 = t$1.getTerrainMesh(o$2.tileID), u$1 = e$1.renderToTexture.getTexture(o$2), d$1 = t$1.getTerrainData(o$2.tileID);
					a$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, u$1.texture);
					const m$1 = Ci(t$1.getMeshFrameDelta(n$1.zoom), n$1.calculateFogMatrix(o$2.tileID.toUnwrapped()), e$1.style.sky, n$1.pitch, r$1), f$1 = n$1.getProjectionData({
						overscaledTileID: o$2.tileID,
						applyTerrainMatrix: !1,
						applyGlobeMatrix: !0
					});
					h$1.draw(a$1, s$1.TRIANGLES, c$1, Vt$1.disabled, l$1, Ut$1.backCCW, m$1, d$1, f$1, "terrain", i$2.vertexBuffer, i$2.indexBuffer, i$2.segments);
				}
			}
			function Ir$1(e$1, i$1) {
				if (!i$1.mesh) {
					const o$1 = new t.aL();
					o$1.emplaceBack(-1, -1), o$1.emplaceBack(1, -1), o$1.emplaceBack(1, 1), o$1.emplaceBack(-1, 1);
					const r$1 = new t.aN();
					r$1.emplaceBack(0, 1, 2), r$1.emplaceBack(0, 2, 3), i$1.mesh = new wt$1(e$1.createVertexBuffer(o$1, Tt$1.members), e$1.createIndexBuffer(r$1), t.aM.simpleSegment(0, 0, o$1.length, r$1.length));
				}
				return i$1.mesh;
			}
			class Mr$1 {
				constructor(e$1, i$1) {
					this.context = new Ho(e$1), this.transform = i$1, this._tileTextures = {}, this.terrainFacilitator = {
						dirty: !0,
						matrix: t.ag(new Float64Array(16)),
						renderTime: 0
					}, this.setup(), this.numSublayers = xe$1.maxUnderzooming + xe$1.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vt$1();
				}
				resize(e$1, t$1, i$1) {
					if (this.width = Math.floor(e$1 * i$1), this.height = Math.floor(t$1 * i$1), this.pixelRatio = i$1, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (const e$2 of this.style._order) this.style._layers[e$2].resize();
				}
				setup() {
					const e$1 = this.context, i$1 = new t.aL();
					i$1.emplaceBack(0, 0), i$1.emplaceBack(t.$, 0), i$1.emplaceBack(0, t.$), i$1.emplaceBack(t.$, t.$), this.tileExtentBuffer = e$1.createVertexBuffer(i$1, Tt$1.members), this.tileExtentSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const o$1 = new t.aL();
					o$1.emplaceBack(0, 0), o$1.emplaceBack(t.$, 0), o$1.emplaceBack(0, t.$), o$1.emplaceBack(t.$, t.$), this.debugBuffer = e$1.createVertexBuffer(o$1, Tt$1.members), this.debugSegments = t.aM.simpleSegment(0, 0, 4, 5);
					const r$1 = new t.c6();
					r$1.emplaceBack(0, 0, 0, 0), r$1.emplaceBack(t.$, 0, t.$, 0), r$1.emplaceBack(0, t.$, 0, t.$), r$1.emplaceBack(t.$, t.$, t.$, t.$), this.rasterBoundsBuffer = e$1.createVertexBuffer(r$1, Ti.members), this.rasterBoundsSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const a$1 = new t.aL();
					a$1.emplaceBack(0, 0), a$1.emplaceBack(t.$, 0), a$1.emplaceBack(0, t.$), a$1.emplaceBack(t.$, t.$), this.rasterBoundsBufferPosOnly = e$1.createVertexBuffer(a$1, Tt$1.members), this.rasterBoundsSegmentsPosOnly = t.aM.simpleSegment(0, 0, 4, 5);
					const s$1 = new t.aL();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(1, 0), s$1.emplaceBack(0, 1), s$1.emplaceBack(1, 1), this.viewportBuffer = e$1.createVertexBuffer(s$1, Tt$1.members), this.viewportSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const n$1 = new t.c7();
					n$1.emplaceBack(0), n$1.emplaceBack(1), n$1.emplaceBack(3), n$1.emplaceBack(2), n$1.emplaceBack(0), this.tileBorderIndexBuffer = e$1.createIndexBuffer(n$1);
					const l$1 = new t.aN();
					l$1.emplaceBack(1, 0, 2), l$1.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e$1.createIndexBuffer(l$1);
					const c$1 = this.context.gl;
					this.stencilClearMode = new Vt$1({
						func: c$1.ALWAYS,
						mask: 0
					}, 0, 255, c$1.ZERO, c$1.ZERO, c$1.ZERO), this.tileExtentMesh = new wt$1(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
				}
				clearStencil() {
					const e$1 = this.context, i$1 = e$1.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0;
					const o$1 = t.L();
					t.bY(o$1, 0, this.width, this.height, 0, 0, 1), t.N(o$1, o$1, [
						i$1.drawingBufferWidth,
						i$1.drawingBufferHeight,
						0
					]);
					const r$1 = {
						mainMatrix: o$1,
						tileMercatorCoords: [
							0,
							0,
							1,
							1
						],
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: o$1
					};
					this.useProgram("clippingMask", null, !0).draw(e$1, i$1.TRIANGLES, Zt$1.disabled, this.stencilClearMode, jt.disabled, Ut$1.disabled, null, null, r$1, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				_renderTileClippingMasks(e$1, t$1, i$1) {
					if (this.currentStencilSource === e$1.source || !e$1.isTileClipped() || !t$1 || !t$1.length) return;
					this.currentStencilSource = e$1.source, this.nextStencilID + t$1.length > 256 && this.clearStencil();
					const o$1 = this.context;
					o$1.setColorMode(jt.disabled), o$1.setDepthMode(Zt$1.disabled);
					const r$1 = {};
					for (const e$2 of t$1) r$1[e$2.key] = this.nextStencilID++;
					this._renderTileMasks(r$1, t$1, i$1, !0), this._renderTileMasks(r$1, t$1, i$1, !1), this._tileClippingMaskIDs = r$1;
				}
				_renderTileMasks(e$1, t$1, i$1, o$1) {
					const r$1 = this.context, a$1 = r$1.gl, s$1 = this.style.projection, n$1 = this.transform, l$1 = this.useProgram("clippingMask");
					for (const c$1 of t$1) {
						const t$2 = e$1[c$1.key], h$1 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c$1), u$1 = s$1.getMeshFromTileID(this.context, c$1.canonical, o$1, !0, "stencil"), d$1 = n$1.getProjectionData({
							overscaledTileID: c$1,
							applyGlobeMatrix: !i$1,
							applyTerrainMatrix: !0
						});
						l$1.draw(r$1, a$1.TRIANGLES, Zt$1.disabled, new Vt$1({
							func: a$1.ALWAYS,
							mask: 0
						}, t$2, 255, a$1.KEEP, a$1.KEEP, a$1.REPLACE), jt.disabled, i$1 ? Ut$1.disabled : Ut$1.backCCW, null, h$1, d$1, "$clipping", u$1.vertexBuffer, u$1.indexBuffer, u$1.segments);
					}
				}
				_renderTilesDepthBuffer() {
					const e$1 = this.context, t$1 = e$1.gl, i$1 = this.style.projection, o$1 = this.transform, r$1 = this.useProgram("depth"), a$1 = this.getDepthModeFor3D(), s$1 = ve$1(o$1, { tileSize: o$1.tileSize });
					for (const n$1 of s$1) {
						const s$2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n$1), l$1 = i$1.getMeshFromTileID(this.context, n$1.canonical, !0, !0, "raster"), c$1 = o$1.getProjectionData({
							overscaledTileID: n$1,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						});
						r$1.draw(e$1, t$1.TRIANGLES, a$1, Vt$1.disabled, jt.disabled, Ut$1.backCCW, null, s$2, c$1, "$clipping", l$1.vertexBuffer, l$1.indexBuffer, l$1.segments);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					const e$1 = this.nextStencilID++, t$1 = this.context.gl;
					return new Vt$1({
						func: t$1.NOTEQUAL,
						mask: 255
					}, e$1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilModeForClipping(e$1) {
					const t$1 = this.context.gl;
					return new Vt$1({
						func: t$1.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e$1.key], 0, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				getStencilConfigForOverlapAndUpdateStencilID(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), o$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - o$1 + 1;
					if (r$1 > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + r$1 > 256 && this.clearStencil();
						const e$2 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + o$1] = new Vt$1({
							func: t$1.GEQUAL,
							mask: 255
						}, i$2 + this.nextStencilID, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID += r$1, [e$2, i$1];
					}
					return [{ [o$1]: Vt$1.disabled }, i$1];
				}
				stencilConfigForOverlapTwoPass(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), o$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - o$1 + 1;
					if (this.clearStencil(), r$1 > 1) {
						const e$2 = {}, a$1 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + o$1] = new Vt$1({
							func: t$1.GREATER,
							mask: 255
						}, r$1 + 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE), a$1[i$2 + o$1] = new Vt$1({
							func: t$1.GREATER,
							mask: 255
						}, 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID = 2 * r$1 + 1, [
							e$2,
							a$1,
							i$1
						];
					}
					return this.nextStencilID = 3, [
						{ [o$1]: new Vt$1({
							func: t$1.GREATER,
							mask: 255
						}, 2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						{ [o$1]: new Vt$1({
							func: t$1.GREATER,
							mask: 255
						}, 1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						i$1
					];
				}
				colorModeForRenderPass() {
					const e$1 = this.context.gl;
					if (this._showOverdrawInspector) {
						const i$1 = 1 / 8;
						return new jt([e$1.CONSTANT_COLOR, e$1.ONE], new t.bf(i$1, i$1, i$1, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return "opaque" === this.renderPass ? jt.unblended : jt.alphaBlended;
				}
				getDepthModeForSublayer(e$1, t$1, i$1) {
					if (!this.opaquePassEnabledForLayer()) return Zt$1.disabled;
					const o$1 = 1 - ((1 + this.currentLayer) * this.numSublayers + e$1) * this.depthEpsilon;
					return new Zt$1(i$1 || this.context.gl.LEQUAL, t$1, [o$1, o$1]);
				}
				getDepthModeFor3D() {
					return new Zt$1(this.context.gl.LEQUAL, Zt$1.ReadWrite, this.depthRangeFor3D);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				render(e$1, i$1) {
					var o$1, r$1;
					this.style = e$1, this.options = i$1, this.lineAtlas = e$1.lineAtlas, this.imageManager = e$1.imageManager, this.glyphManager = e$1.glyphManager, this.symbolFadeChange = e$1.placement.symbolFadeChange(s.now()), this.imageManager.beginFrame();
					const a$1 = this.style._order, n$1 = this.style.sourceCaches, l$1 = {}, c$1 = {}, h$1 = {}, u$1 = {
						isRenderingToTexture: !1,
						isRenderingGlobe: (null === (o$1 = e$1.projection) || void 0 === o$1 ? void 0 : o$1.transitionState) > 0
					};
					for (const e$2 in n$1) {
						const t$1 = n$1[e$2];
						t$1.used && t$1.prepare(this.context), l$1[e$2] = t$1.getVisibleCoordinates(!1), c$1[e$2] = l$1[e$2].slice().reverse(), h$1[e$2] = t$1.getVisibleCoordinates(!0).reverse();
					}
					this.opaquePassCutoff = Infinity;
					for (let e$2 = 0; e$2 < a$1.length; e$2++) if (this.style._layers[a$1[e$2]].is3D()) {
						this.opaquePassCutoff = e$2;
						break;
					}
					this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
					for (const e$2 of a$1) {
						const t$1 = this.style._layers[e$2];
						if (!t$1.hasOffscreenPass() || t$1.isHidden(this.transform.zoom)) continue;
						const i$2 = c$1[t$1.source];
						("custom" === t$1.type || i$2.length) && this.renderLayer(this, n$1[t$1.source], t$1, i$2, u$1);
					}
					if (null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.updateGPUdependent({
						context: this.context,
						useProgram: (e$2) => this.useProgram(e$2)
					}), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.bindFramebuffer.set(null), this.context.clear({
						color: i$1.showOverdrawInspector ? t.bf.black : t.bf.transparent,
						depth: 1
					}), this.clearStencil(), this.style.sky && function(e$2, t$1) {
						const i$2 = e$2.context, o$2 = i$2.gl, r$2 = ((e$3, t$2, i$3) => {
							const o$3 = Math.cos(t$2.rollInRadians), r$3 = Math.sin(t$2.rollInRadians), a$3 = he$1(t$2), s$2 = t$2.getProjectionData({
								overscaledTileID: null,
								applyGlobeMatrix: !0,
								applyTerrainMatrix: !0
							}).projectionTransition;
							return {
								u_sky_color: e$3.properties.get("sky-color"),
								u_horizon_color: e$3.properties.get("horizon-color"),
								u_horizon: [(t$2.width / 2 - a$3 * r$3) * i$3, (t$2.height / 2 + a$3 * o$3) * i$3],
								u_horizon_normal: [-r$3, o$3],
								u_sky_horizon_blend: e$3.properties.get("sky-horizon-blend") * t$2.height / 2 * i$3,
								u_sky_blend: s$2
							};
						})(t$1, e$2.style.map.transform, e$2.pixelRatio), a$2 = new Zt$1(o$2.LEQUAL, Zt$1.ReadWrite, [0, 1]), s$1 = Vt$1.disabled, n$2 = e$2.colorModeForRenderPass(), l$2 = e$2.useProgram("sky"), c$2 = Ir$1(i$2, t$1);
						l$2.draw(i$2, o$2.TRIANGLES, a$2, s$1, n$2, Ut$1.disabled, r$2, null, void 0, "sky", c$2.vertexBuffer, c$2.indexBuffer, c$2.segments);
					}(this, this.style.sky), this._showOverdrawInspector = i$1.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e$1._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a$1.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						const e$2 = this.style._layers[a$1[this.currentLayer]], t$1 = n$1[e$2.source], i$2 = l$1[e$2.source];
						this._renderTileClippingMasks(e$2, i$2, !1), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					this.renderPass = "translucent";
					let d$1 = !1;
					for (this.currentLayer = 0; this.currentLayer < a$1.length; this.currentLayer++) {
						const e$2 = this.style._layers[a$1[this.currentLayer]], t$1 = n$1[e$2.source];
						if (this.renderToTexture && this.renderToTexture.renderLayer(e$2, u$1)) continue;
						this.opaquePassEnabledForLayer() || d$1 || (d$1 = !0, u$1.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
						const i$2 = ("symbol" === e$2.type ? h$1 : c$1)[e$2.source];
						this._renderTileClippingMasks(e$2, l$1[e$2.source], !!this.renderToTexture), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					if (u$1.isRenderingGlobe && function(e$2, i$2, o$2) {
						const r$2 = e$2.context, a$2 = r$2.gl, s$1 = e$2.useProgram("atmosphere"), n$2 = new Zt$1(a$2.LEQUAL, Zt$1.ReadOnly, [0, 1]), l$2 = e$2.transform, c$2 = function(e$3, i$3) {
							const o$3 = e$3.properties.get("position"), r$3 = [
								-o$3.x,
								-o$3.y,
								-o$3.z
							], a$3 = t.ag(new Float64Array(16));
							return "map" === e$3.properties.get("anchor") && (t.b6(a$3, a$3, i$3.rollInRadians), t.b7(a$3, a$3, -i$3.pitchInRadians), t.b6(a$3, a$3, i$3.bearingInRadians), t.b7(a$3, a$3, i$3.center.lat * Math.PI / 180), t.bz(a$3, a$3, -i$3.center.lng * Math.PI / 180)), t.c5(r$3, r$3, a$3), r$3;
						}(o$2, e$2.transform), h$2 = l$2.getProjectionData({
							overscaledTileID: null,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						}), u$2 = i$2.properties.get("atmosphere-blend") * h$2.projectionTransition;
						if (0 === u$2) return;
						const d$2 = oi$1(l$2.worldSize, l$2.center.lat), _$2 = l$2.inverseProjectionMatrix, p$1 = new Float64Array(4);
						p$1[3] = 1, t.aw(p$1, p$1, l$2.modelViewProjectionMatrix), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1, t.aw(p$1, p$1, _$2), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1;
						const m$1 = ((e$3, t$1, i$3, o$3, r$3) => ({
							u_sun_pos: e$3,
							u_atmosphere_blend: t$1,
							u_globe_position: i$3,
							u_globe_radius: o$3,
							u_inv_proj_matrix: r$3
						}))(c$2, u$2, [
							p$1[0],
							p$1[1],
							p$1[2]
						], d$2, _$2), f$1 = Ir$1(r$2, i$2);
						s$1.draw(r$2, a$2.TRIANGLES, n$2, Vt$1.disabled, jt.alphaBlended, Ut$1.disabled, m$1, null, null, "atmosphere", f$1.vertexBuffer, f$1.indexBuffer, f$1.segments);
					}(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
						const e$2 = function(e$3, t$1) {
							let i$2 = null;
							const o$2 = Object.values(e$3._layers).flatMap(((i$3) => i$3.source && !i$3.isHidden(t$1) ? [e$3.sourceCaches[i$3.source]] : [])), r$2 = o$2.filter(((e$4) => "vector" === e$4.getSource().type)), a$2 = o$2.filter(((e$4) => "vector" !== e$4.getSource().type)), s$1 = (e$4) => {
								(!i$2 || i$2.getSource().maxzoom < e$4.getSource().maxzoom) && (i$2 = e$4);
							};
							return r$2.forEach(((e$4) => s$1(e$4))), i$2 || a$2.forEach(((e$4) => s$1(e$4))), i$2;
						}(this.style, this.transform.zoom);
						e$2 && function(e$3, t$1, i$2) {
							for (let o$2 = 0; o$2 < i$2.length; o$2++) Pr$1(e$3, t$1, i$2[o$2]);
						}(this, e$2, e$2.getVisibleCoordinates());
					}
					this.options.showPadding && function(e$2) {
						const t$1 = e$2.transform.padding;
						yr$1(e$2, e$2.transform.height - (t$1.top || 0), 3, fr$1), yr$1(e$2, t$1.bottom || 0, 3, gr$1), wr$1(e$2, t$1.left || 0, 3, vr$1), wr$1(e$2, e$2.transform.width - (t$1.right || 0), 3, br$1);
						const i$2 = e$2.transform.centerPoint;
						(function(e$3, t$2, i$3, o$2) {
							Tr$1(e$3, t$2 - 1, i$3 - 10, 2, 20, o$2), Tr$1(e$3, t$2 - 10, i$3 - 1, 20, 2, o$2);
						})(e$2, i$2.x, e$2.transform.height - i$2.y, xr$1);
					}(this), this.context.setDefault();
				}
				maybeDrawDepthAndCoords(e$1) {
					if (!this.style || !this.style.map || !this.style.map.terrain) return;
					const i$1 = this.terrainFacilitator.matrix, o$1 = this.transform.modelViewProjectionMatrix;
					let r$1 = this.terrainFacilitator.dirty;
					r$1 || (r$1 = e$1 ? !t.c8(i$1, o$1) : !t.c9(i$1, o$1)), r$1 || (r$1 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), r$1 && (t.ca(i$1, o$1), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e$2, i$2) {
						const o$2 = e$2.context, r$2 = o$2.gl, a$1 = e$2.transform, s$1 = jt.unblended, n$1 = new Zt$1(r$2.LEQUAL, Zt$1.ReadWrite, [0, 1]), l$1 = i$2.sourceCache.getRenderableTiles(), c$1 = e$2.useProgram("terrainDepth");
						o$2.bindFramebuffer.set(i$2.getFramebuffer("depth").framebuffer), o$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), o$2.clear({
							color: t.bf.transparent,
							depth: 1
						});
						for (const e$3 of l$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), l$2 = i$2.getTerrainData(e$3.tileID), h$1 = a$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							}), u$1 = { u_ele_delta: i$2.getMeshFrameDelta(a$1.zoom) };
							c$1.draw(o$2, r$2.TRIANGLES, n$1, Vt$1.disabled, s$1, Ut$1.backCCW, u$1, l$2, h$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments);
						}
						o$2.bindFramebuffer.set(null), o$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain), function(e$2, i$2) {
						const o$2 = e$2.context, r$2 = o$2.gl, a$1 = e$2.transform, s$1 = jt.unblended, n$1 = new Zt$1(r$2.LEQUAL, Zt$1.ReadWrite, [0, 1]), l$1 = i$2.getCoordsTexture(), c$1 = i$2.sourceCache.getRenderableTiles(), h$1 = e$2.useProgram("terrainCoords");
						o$2.bindFramebuffer.set(i$2.getFramebuffer("coords").framebuffer), o$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), o$2.clear({
							color: t.bf.transparent,
							depth: 1
						}), i$2.coordsIndex = [];
						for (const e$3 of c$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), c$2 = i$2.getTerrainData(e$3.tileID);
							o$2.activeTexture.set(r$2.TEXTURE0), r$2.bindTexture(r$2.TEXTURE_2D, l$1.texture);
							const u$1 = {
								u_terrain_coords_id: (255 - i$2.coordsIndex.length) / 255,
								u_texture: 0,
								u_ele_delta: i$2.getMeshFrameDelta(a$1.zoom)
							}, d$1 = a$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							});
							h$1.draw(o$2, r$2.TRIANGLES, n$1, Vt$1.disabled, s$1, Ut$1.backCCW, u$1, c$2, d$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments), i$2.coordsIndex.push(e$3.tileID.key);
						}
						o$2.bindFramebuffer.set(null), o$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain));
				}
				renderLayer(e$1, i$1, o$1, r$1, a$1) {
					o$1.isHidden(this.transform.zoom) || ("background" === o$1.type || "custom" === o$1.type || (r$1 || []).length) && (this.id = o$1.id, t.cb(o$1) ? function(e$2, i$2, o$2, r$2, a$2, s$1) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: n$1 } = s$1, l$1 = Vt$1.disabled, c$1 = e$2.colorModeForRenderPass();
						(o$2._unevaluatedLayout.hasValue("text-variable-anchor") || o$2._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e$3, i$3, o$3, r$3, a$3, s$2, n$2, l$2, c$2) {
							const h$1 = i$3.transform, u$1 = i$3.style.map.terrain, d$1 = "map" === a$3, _$2 = "map" === s$2;
							for (const a$4 of e$3) {
								const e$4 = r$3.getTile(a$4), s$3 = e$4.getBucket(o$3);
								if (!s$3 || !s$3.text || !s$3.text.segments.get().length) continue;
								const p$1 = t.an(s$3.textSizeData, h$1.zoom), m$1 = t.aC(e$4, 1, i$3.transform.zoom), f$1 = Ie$1(d$1, i$3.transform, m$1), g$2 = "none" !== o$3.layout.get("icon-text-fit") && s$3.hasIconData();
								if (p$1) {
									const i$4 = Math.pow(2, h$1.zoom - e$4.tileID.overscaledZ), o$4 = u$1 ? (e$5, t$1) => u$1.getElevation(a$4, e$5, t$1) : null;
									er$1(s$3, d$1, _$2, c$2, h$1, f$1, i$4, p$1, g$2, t.aD(h$1, e$4, n$2, l$2), a$4.toUnwrapped(), o$4);
								}
							}
						}(r$2, e$2, o$2, i$2, o$2.layout.get("text-rotation-alignment"), o$2.layout.get("text-pitch-alignment"), o$2.paint.get("text-translate"), o$2.paint.get("text-translate-anchor"), a$2), 0 !== o$2.paint.get("icon-opacity").constantOr(1) && ir$1(e$2, i$2, o$2, r$2, !1, o$2.paint.get("icon-translate"), o$2.paint.get("icon-translate-anchor"), o$2.layout.get("icon-rotation-alignment"), o$2.layout.get("icon-pitch-alignment"), o$2.layout.get("icon-keep-upright"), l$1, c$1, n$1), 0 !== o$2.paint.get("text-opacity").constantOr(1) && ir$1(e$2, i$2, o$2, r$2, !0, o$2.paint.get("text-translate"), o$2.paint.get("text-translate-anchor"), o$2.layout.get("text-rotation-alignment"), o$2.layout.get("text-pitch-alignment"), o$2.layout.get("text-keep-upright"), l$1, c$1, n$1), i$2.map.showCollisionBoxes && (Ko$1(e$2, i$2, o$2, r$2, !0), Ko$1(e$2, i$2, o$2, r$2, !1));
					}(e$1, i$1, o$1, r$1, this.style.placement.variableOffsets, a$1) : t.cc(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = o$2.paint.get("circle-opacity"), l$1 = o$2.paint.get("circle-stroke-width"), c$1 = o$2.paint.get("circle-stroke-opacity"), h$1 = !o$2.layout.get("circle-sort-key").isConstant();
						if (0 === n$1.constantOr(1) && (0 === l$1.constantOr(1) || 0 === c$1.constantOr(1))) return;
						const u$1 = e$2.context, d$1 = u$1.gl, _$2 = e$2.transform, p$1 = e$2.getDepthModeForSublayer(0, Zt$1.ReadOnly), m$1 = Vt$1.disabled, f$1 = e$2.colorModeForRenderPass(), g$2 = [], v$1 = _$2.getCircleRadiusCorrection();
						for (let a$3 = 0; a$3 < r$2.length; a$3++) {
							const n$2 = r$2[a$3], l$2 = i$2.getTile(n$2), c$2 = l$2.getBucket(o$2);
							if (!c$2) continue;
							const u$2 = o$2.paint.get("circle-translate"), d$2 = o$2.paint.get("circle-translate-anchor"), p$2 = t.aD(_$2, l$2, u$2, d$2), m$2 = c$2.programConfigurations.get(o$2.id), f$2 = e$2.useProgram("circle", m$2), b$2 = c$2.layoutVertexBuffer, x$1 = c$2.indexBuffer, y$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(n$2), w$1 = {
								programConfiguration: m$2,
								program: f$2,
								layoutVertexBuffer: b$2,
								indexBuffer: x$1,
								uniformValues: ki(e$2, l$2, o$2, p$2, v$1),
								terrainData: y$1,
								projectionData: _$2.getProjectionData({
									overscaledTileID: n$2,
									applyGlobeMatrix: !s$1,
									applyTerrainMatrix: !0
								})
							};
							if (h$1) {
								const e$3 = c$2.segments.get();
								for (const i$3 of e$3) g$2.push({
									segments: new t.aM([i$3]),
									sortKey: i$3.sortKey,
									state: w$1
								});
							} else g$2.push({
								segments: c$2.segments,
								sortKey: 0,
								state: w$1
							});
						}
						h$1 && g$2.sort(((e$3, t$1) => e$3.sortKey - t$1.sortKey));
						for (const t$1 of g$2) {
							const { programConfiguration: i$3, program: r$3, layoutVertexBuffer: a$3, indexBuffer: s$2, uniformValues: n$2, terrainData: l$2, projectionData: c$2 } = t$1.state;
							r$3.draw(u$1, d$1.TRIANGLES, p$1, m$1, f$1, Ut$1.backCCW, n$2, l$2, c$2, o$2.id, a$3, s$2, t$1.segments, o$2.paint, e$2.transform.zoom, i$3);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cd(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if (0 === o$2.paint.get("heatmap-opacity")) return;
						const s$1 = e$2.context, { isRenderingToTexture: n$1, isRenderingGlobe: l$1 } = a$2;
						if (e$2.style.map.terrain) {
							for (const t$1 of r$2) {
								const r$3 = i$2.getTile(t$1);
								i$2.hasRenderableParent(t$1) || ("offscreen" === e$2.renderPass ? rr$1(e$2, r$3, o$2, t$1, l$1) : "translucent" === e$2.renderPass && ar$1(e$2, o$2, t$1, n$1, l$1));
							}
							s$1.viewport.set([
								0,
								0,
								e$2.width,
								e$2.height
							]);
						} else "offscreen" === e$2.renderPass ? function(e$3, i$3, o$3, r$3) {
							const a$3 = e$3.context, s$2 = a$3.gl, n$2 = e$3.transform, l$2 = Vt$1.disabled, c$1 = new jt([s$2.ONE, s$2.ONE], t.bf.transparent, [
								!0,
								!0,
								!0,
								!0
							]);
							(function(e$4, i$4, o$4) {
								const r$4 = e$4.gl;
								e$4.activeTexture.set(r$4.TEXTURE1), e$4.viewport.set([
									0,
									0,
									i$4.width / 4,
									i$4.height / 4
								]);
								let a$4 = o$4.heatmapFbos.get(t.c2);
								a$4 ? (r$4.bindTexture(r$4.TEXTURE_2D, a$4.colorAttachment.get()), e$4.bindFramebuffer.set(a$4.framebuffer)) : (a$4 = sr$1(e$4, i$4.width / 4, i$4.height / 4), o$4.heatmapFbos.set(t.c2, a$4));
							})(a$3, e$3, o$3), a$3.clear({ color: t.bf.transparent });
							for (let t$1 = 0; t$1 < r$3.length; t$1++) {
								const h$1 = r$3[t$1];
								if (i$3.hasRenderableParent(h$1)) continue;
								const u$1 = i$3.getTile(h$1), d$1 = u$1.getBucket(o$3);
								if (!d$1) continue;
								const _$2 = d$1.programConfigurations.get(o$3.id), p$1 = e$3.useProgram("heatmap", _$2), m$1 = n$2.getProjectionData({
									overscaledTileID: h$1,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !1
								}), f$1 = n$2.getCircleRadiusCorrection();
								p$1.draw(a$3, s$2.TRIANGLES, Zt$1.disabled, l$2, c$1, Ut$1.backCCW, ji$1(u$1, n$2.zoom, o$3.paint.get("heatmap-intensity"), f$1), null, m$1, o$3.id, d$1.layoutVertexBuffer, d$1.indexBuffer, d$1.segments, o$3.paint, n$2.zoom, _$2);
							}
							a$3.viewport.set([
								0,
								0,
								e$3.width,
								e$3.height
							]);
						}(e$2, i$2, o$2, r$2) : "translucent" === e$2.renderPass && function(e$3, i$3) {
							const o$3 = e$3.context, r$3 = o$3.gl;
							o$3.setColorMode(e$3.colorModeForRenderPass());
							const a$3 = i$3.heatmapFbos.get(t.c2);
							a$3 && (o$3.activeTexture.set(r$3.TEXTURE0), r$3.bindTexture(r$3.TEXTURE_2D, a$3.colorAttachment.get()), o$3.activeTexture.set(r$3.TEXTURE1), nr$1(o$3, i$3).bind(r$3.LINEAR, r$3.CLAMP_TO_EDGE), e$3.useProgram("heatmapTexture").draw(o$3, r$3.TRIANGLES, Zt$1.disabled, Vt$1.disabled, e$3.colorModeForRenderPass(), Ut$1.disabled, Ni$1(e$3, i$3, 0, 1), null, null, i$3.id, e$3.viewportBuffer, e$3.quadTriangleIndexBuffer, e$3.viewportSegments, i$3.paint, e$3.transform.zoom));
						}(e$2, o$2);
					}(e$1, i$1, o$1, r$1, a$1) : t.ce(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = o$2.paint.get("line-opacity"), l$1 = o$2.paint.get("line-width");
						if (0 === n$1.constantOr(1) || 0 === l$1.constantOr(1)) return;
						const c$1 = e$2.getDepthModeForSublayer(0, Zt$1.ReadOnly), h$1 = e$2.colorModeForRenderPass(), u$1 = o$2.paint.get("line-dasharray"), d$1 = o$2.paint.get("line-pattern"), _$2 = d$1.constantOr(1), p$1 = o$2.paint.get("line-gradient"), m$1 = o$2.getCrossfadeParameters(), f$1 = _$2 ? "linePattern" : u$1 ? "lineSDF" : p$1 ? "lineGradient" : "line", g$2 = e$2.context, v$1 = g$2.gl, b$2 = e$2.transform;
						let x$1 = !0;
						for (const a$3 of r$2) {
							const r$3 = i$2.getTile(a$3);
							if (_$2 && !r$3.patternsLoaded()) continue;
							const n$2 = r$3.getBucket(o$2);
							if (!n$2) continue;
							const l$2 = n$2.programConfigurations.get(o$2.id), y$1 = e$2.context.program.get(), w$1 = e$2.useProgram(f$1, l$2), T$2 = x$1 || w$1.program !== y$1, P$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(a$3), C$1 = d$1.constantOr(null);
							if (C$1 && r$3.imageAtlas) {
								const e$3 = r$3.imageAtlas, t$1 = e$3.patternPositions[C$1.to.toString()], i$3 = e$3.patternPositions[C$1.from.toString()];
								t$1 && i$3 && l$2.setConstantPatternPositions(t$1, i$3);
							}
							const I$2 = b$2.getProjectionData({
								overscaledTileID: a$3,
								applyGlobeMatrix: !s$1,
								applyTerrainMatrix: !0
							}), M$2 = b$2.getPixelScale(), S$2 = _$2 ? Wi$1(e$2, r$3, o$2, M$2, m$1) : u$1 ? Hi$1(e$2, r$3, o$2, M$2, u$1, m$1) : p$1 ? qi$1(e$2, r$3, o$2, M$2, n$2.lineClipsArray.length) : $i$1(e$2, r$3, o$2, M$2);
							if (_$2) g$2.activeTexture.set(v$1.TEXTURE0), r$3.imageAtlasTexture.bind(v$1.LINEAR, v$1.CLAMP_TO_EDGE), l$2.updatePaintBuffers(m$1);
							else if (u$1 && (T$2 || e$2.lineAtlas.dirty)) g$2.activeTexture.set(v$1.TEXTURE0), e$2.lineAtlas.bind(g$2);
							else if (p$1) {
								const r$4 = n$2.gradients[o$2.id];
								let s$2 = r$4.texture;
								if (o$2.gradientVersion !== r$4.version) {
									let l$3 = 256;
									if (o$2.stepInterpolant) {
										const o$3 = i$2.getSource().maxzoom, r$5 = a$3.canonical.z === o$3 ? Math.ceil(1 << e$2.transform.maxZoom - a$3.canonical.z) : 1;
										l$3 = t.ah(t.c3(n$2.maxLineLength / t.$ * 1024 * r$5), 256, g$2.maxTextureSize);
									}
									r$4.gradient = t.c4({
										expression: o$2.gradientExpression(),
										evaluationKey: "lineProgress",
										resolution: l$3,
										image: r$4.gradient || void 0,
										clips: n$2.lineClipsArray
									}), r$4.texture ? r$4.texture.update(r$4.gradient) : r$4.texture = new t.T(g$2, r$4.gradient, v$1.RGBA), r$4.version = o$2.gradientVersion, s$2 = r$4.texture;
								}
								g$2.activeTexture.set(v$1.TEXTURE0), s$2.bind(o$2.stepInterpolant ? v$1.NEAREST : v$1.LINEAR, v$1.CLAMP_TO_EDGE);
							}
							const E$1 = e$2.stencilModeForClipping(a$3);
							w$1.draw(g$2, v$1.TRIANGLES, c$1, E$1, h$1, Ut$1.disabled, S$2, P$2, I$2, o$2.id, n$2.layoutVertexBuffer, n$2.indexBuffer, n$2.segments, o$2.paint, e$2.transform.zoom, l$2, n$2.layoutVertexBuffer2), x$1 = !1;
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cf(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						const s$1 = o$2.paint.get("fill-color"), n$1 = o$2.paint.get("fill-opacity");
						if (0 === n$1.constantOr(1)) return;
						const { isRenderingToTexture: l$1 } = a$2, c$1 = e$2.colorModeForRenderPass(), h$1 = o$2.paint.get("fill-pattern"), u$1 = e$2.opaquePassEnabledForLayer() && !h$1.constantOr(1) && 1 === s$1.constantOr(t.bf.transparent).a && 1 === n$1.constantOr(0) ? "opaque" : "translucent";
						if (e$2.renderPass === u$1) cr$1(e$2, i$2, o$2, r$2, e$2.getDepthModeForSublayer(1, "opaque" === e$2.renderPass ? Zt$1.ReadWrite : Zt$1.ReadOnly), c$1, !1, l$1);
						if ("translucent" === e$2.renderPass && o$2.paint.get("fill-antialias")) cr$1(e$2, i$2, o$2, r$2, e$2.getDepthModeForSublayer(o$2.getPaintProperty("fill-outline-color") ? 2 : 0, Zt$1.ReadOnly), c$1, !0, l$1);
					}(e$1, i$1, o$1, r$1, a$1) : t.cg(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						const a$2 = i$2.paint.get("fill-extrusion-opacity");
						if (0 === a$2) return;
						const { isRenderingToTexture: s$1 } = r$2;
						if ("translucent" === e$2.renderPass) {
							const r$3 = new Zt$1(e$2.context.gl.LEQUAL, Zt$1.ReadWrite, e$2.depthRangeFor3D);
							if (1 !== a$2 || i$2.paint.get("fill-extrusion-pattern").constantOr(1)) hr$1(e$2, t$1, i$2, o$2, r$3, Vt$1.disabled, jt.disabled, s$1), hr$1(e$2, t$1, i$2, o$2, r$3, e$2.stencilModeFor3D(), e$2.colorModeForRenderPass(), s$1);
							else {
								const a$3 = e$2.colorModeForRenderPass();
								hr$1(e$2, t$1, i$2, o$2, r$3, Vt$1.disabled, a$3, s$1);
							}
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ch(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("offscreen" !== e$2.renderPass && "translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = e$2.context, l$1 = e$2.style.projection.useSubdivision, c$1 = e$2.getDepthModeForSublayer(0, Zt$1.ReadOnly), h$1 = e$2.colorModeForRenderPass();
						if ("offscreen" === e$2.renderPass) (function(e$3, i$3, o$3, r$3, a$3, s$2, n$2) {
							const l$2 = e$3.context, c$2 = l$2.gl;
							for (const h$2 of o$3) {
								const o$4 = i$3.getTile(h$2), u$1 = o$4.dem;
								if (!u$1 || !u$1.data) continue;
								if (!o$4.needsHillshadePrepare) continue;
								const d$1 = u$1.dim, _$2 = u$1.stride, p$1 = u$1.getPixels();
								if (l$2.activeTexture.set(c$2.TEXTURE1), l$2.pixelStoreUnpackPremultiplyAlpha.set(!1), o$4.demTexture = o$4.demTexture || e$3.getTileTexture(_$2), o$4.demTexture) {
									const e$4 = o$4.demTexture;
									e$4.update(p$1, { premultiply: !1 }), e$4.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								} else o$4.demTexture = new t.T(l$2, p$1, c$2.RGBA, { premultiply: !1 }), o$4.demTexture.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								l$2.activeTexture.set(c$2.TEXTURE0);
								let m$1 = o$4.fbo;
								if (!m$1) {
									const e$4 = new t.T(l$2, {
										width: d$1,
										height: d$1,
										data: null
									}, c$2.RGBA);
									e$4.bind(c$2.LINEAR, c$2.CLAMP_TO_EDGE), m$1 = o$4.fbo = l$2.createFramebuffer(d$1, d$1, !0, !1), m$1.colorAttachment.set(e$4.texture);
								}
								l$2.bindFramebuffer.set(m$1.framebuffer), l$2.viewport.set([
									0,
									0,
									d$1,
									d$1
								]), e$3.useProgram("hillshadePrepare").draw(l$2, c$2.TRIANGLES, a$3, s$2, n$2, Ut$1.disabled, Zi$1(o$4.tileID, u$1), null, null, r$3.id, e$3.rasterBoundsBuffer, e$3.quadTriangleIndexBuffer, e$3.rasterBoundsSegments), o$4.needsHillshadePrepare = !1;
							}
						})(e$2, i$2, r$2, o$2, c$1, Vt$1.disabled, h$1), n$1.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
						else if ("translucent" === e$2.renderPass) if (l$1) {
							const [t$1, a$3, n$2] = e$2.stencilConfigForOverlapTwoPass(r$2);
							ur$1(e$2, i$2, o$2, n$2, t$1, c$1, h$1, !1, s$1), ur$1(e$2, i$2, o$2, n$2, a$3, c$1, h$1, !0, s$1);
						} else {
							const [t$1, a$3] = e$2.getStencilConfigForOverlapAndUpdateStencilID(r$2);
							ur$1(e$2, i$2, o$2, a$3, t$1, c$1, h$1, !1, s$1);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ci(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (!o$2.length) return;
						const { isRenderingToTexture: a$2 } = r$2, s$1 = e$2.style.projection.useSubdivision, n$1 = e$2.getDepthModeForSublayer(0, Zt$1.ReadOnly), l$1 = e$2.colorModeForRenderPass();
						if (s$1) {
							const [r$3, s$2, c$1] = e$2.stencilConfigForOverlapTwoPass(o$2);
							dr$1(e$2, t$1, i$2, c$1, r$3, n$1, l$1, !1, a$2), dr$1(e$2, t$1, i$2, c$1, s$2, n$1, l$1, !0, a$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(o$2);
							dr$1(e$2, t$1, i$2, s$2, r$3, n$1, l$1, !1, a$2);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cj(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (0 === i$2.paint.get("raster-opacity")) return;
						if (!o$2.length) return;
						const { isRenderingToTexture: a$2 } = r$2, s$1 = t$1.getSource(), n$1 = e$2.style.projection.useSubdivision;
						if (s$1 instanceof X$1) pr$1(e$2, t$1, i$2, o$2, null, !1, !1, s$1.tileCoords, s$1.flippedWindingOrder, a$2);
						else if (n$1) {
							const [r$3, s$2, n$2] = e$2.stencilConfigForOverlapTwoPass(o$2);
							pr$1(e$2, t$1, i$2, n$2, r$3, !1, !0, _r$1, !1, a$2), pr$1(e$2, t$1, i$2, n$2, s$2, !0, !0, _r$1, !1, a$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(o$2);
							pr$1(e$2, t$1, i$2, s$2, r$3, !1, !0, _r$1, !1, a$2);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ck(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						const a$2 = i$2.paint.get("background-color"), s$1 = i$2.paint.get("background-opacity");
						if (0 === s$1) return;
						const { isRenderingToTexture: n$1 } = r$2, l$1 = e$2.context, c$1 = l$1.gl, h$1 = e$2.style.projection, u$1 = e$2.transform, d$1 = u$1.tileSize, _$2 = i$2.paint.get("background-pattern");
						if (e$2.isPatternMissing(_$2)) return;
						const p$1 = !_$2 && 1 === a$2.a && 1 === s$1 && e$2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
						if (e$2.renderPass !== p$1) return;
						const m$1 = Vt$1.disabled, f$1 = e$2.getDepthModeForSublayer(0, "opaque" === p$1 ? Zt$1.ReadWrite : Zt$1.ReadOnly), g$2 = e$2.colorModeForRenderPass(), v$1 = e$2.useProgram(_$2 ? "backgroundPattern" : "background"), b$2 = o$2 || ve$1(u$1, {
							tileSize: d$1,
							terrain: e$2.style.map.terrain
						});
						_$2 && (l$1.activeTexture.set(c$1.TEXTURE0), e$2.imageManager.bind(e$2.context));
						const x$1 = i$2.getCrossfadeParameters();
						for (const t$2 of b$2) {
							const o$3 = u$1.getProjectionData({
								overscaledTileID: t$2,
								applyGlobeMatrix: !n$1,
								applyTerrainMatrix: !0
							}), r$3 = _$2 ? oo$1(s$1, e$2, _$2, {
								tileID: t$2,
								tileSize: d$1
							}, x$1) : io$1(s$1, a$2), p$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(t$2), b$3 = h$1.getMeshFromTileID(l$1, t$2.canonical, !1, !0, "raster");
							v$1.draw(l$1, c$1.TRIANGLES, f$1, m$1, g$2, Ut$1.backCCW, r$3, p$2, o$3, i$2.id, b$3.vertexBuffer, b$3.indexBuffer, b$3.segments);
						}
					}(e$1, 0, o$1, r$1, a$1) : t.cl(o$1) && function(e$2, t$1, i$2, o$2) {
						const { isRenderingGlobe: r$2 } = o$2, a$2 = e$2.context, s$1 = i$2.implementation, n$1 = e$2.style.projection, l$1 = e$2.transform, c$1 = l$1.getProjectionDataForCustomLayer(r$2), h$1 = {
							farZ: l$1.farZ,
							nearZ: l$1.nearZ,
							fov: l$1.fov * Math.PI / 180,
							modelViewProjectionMatrix: l$1.modelViewProjectionMatrix,
							projectionMatrix: l$1.projectionMatrix,
							shaderData: {
								variantName: n$1.shaderVariantName,
								vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${n$1.shaderPreludeCode.vertexSource}`,
								define: n$1.shaderDefine
							},
							defaultProjectionData: c$1
						}, u$1 = s$1.renderingMode ? s$1.renderingMode : "2d";
						if ("offscreen" === e$2.renderPass) {
							const t$2 = s$1.prerender;
							t$2 && (e$2.setCustomLayerDefaults(), a$2.setColorMode(e$2.colorModeForRenderPass()), t$2.call(s$1, a$2.gl, h$1), a$2.setDirty(), e$2.setBaseState());
						} else if ("translucent" === e$2.renderPass) {
							e$2.setCustomLayerDefaults(), a$2.setColorMode(e$2.colorModeForRenderPass()), a$2.setStencilMode(Vt$1.disabled);
							const t$2 = "3d" === u$1 ? e$2.getDepthModeFor3D() : e$2.getDepthModeForSublayer(0, Zt$1.ReadOnly);
							a$2.setDepthMode(t$2), s$1.render(a$2.gl, h$1), a$2.setDirty(), e$2.setBaseState(), a$2.bindFramebuffer.set(null);
						}
					}(e$1, 0, o$1, a$1));
				}
				saveTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1.size[0]];
					t$1 ? t$1.push(e$1) : this._tileTextures[e$1.size[0]] = [e$1];
				}
				getTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1];
					return t$1 && t$1.length > 0 ? t$1.pop() : null;
				}
				isPatternMissing(e$1) {
					if (!e$1) return !1;
					if (!e$1.from || !e$1.to) return !0;
					const t$1 = this.imageManager.getPattern(e$1.from.toString()), i$1 = this.imageManager.getPattern(e$1.to.toString());
					return !t$1 || !i$1;
				}
				useProgram(e$1, t$1, i$1 = !1, o$1 = []) {
					this.cache = this.cache || {};
					const r$1 = !!this.style.map.terrain, a$1 = this.style.projection, s$1 = i$1 ? xt$1.projectionMercator : a$1.shaderPreludeCode, n$1 = i$1 ? Pt$1 : a$1.shaderDefine, l$1 = e$1 + (t$1 ? t$1.cacheKey : "") + `/${i$1 ? Ct$1 : a$1.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r$1 ? "/terrain" : "") + (o$1 ? `/${o$1.join("/")}` : "");
					return this.cache[l$1] || (this.cache[l$1] = new Si$1(this.context, xt$1[e$1], t$1, ao$1[e$1], this._showOverdrawInspector, r$1, s$1, n$1, o$1)), this.cache[l$1];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					const e$1 = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e$1.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
				}
				destroy() {
					this.debugOverlayTexture && this.debugOverlayTexture.destroy();
				}
				overLimit() {
					const { drawingBufferWidth: e$1, drawingBufferHeight: t$1 } = this.context.gl;
					return this.width !== e$1 || this.height !== t$1;
				}
			}
			function Sr$1(e$1, t$1) {
				let i$1, o$1 = !1, r$1 = null, a$1 = null;
				const s$1 = () => {
					r$1 = null, o$1 && (e$1.apply(a$1, i$1), r$1 = setTimeout(s$1, t$1), o$1 = !1);
				};
				return (...e$2) => (o$1 = !0, a$1 = this, i$1 = e$2, r$1 || s$1(), r$1);
			}
			class Er {
				constructor(e$1) {
					this._getCurrentHash = () => {
						const e$2 = window.location.hash.replace("#", "");
						if (this._hashName) {
							let t$1;
							return e$2.split("&").map(((e$3) => e$3.split("="))).forEach(((e$3) => {
								e$3[0] === this._hashName && (t$1 = e$3);
							})), (t$1 && t$1[1] || "").split("/");
						}
						return e$2.split("/");
					}, this._onHashChange = () => {
						const e$2 = this._getCurrentHash();
						if (!this._isValidHash(e$2)) return !1;
						const t$1 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e$2[3] || 0) : this._map.getBearing();
						return this._map.jumpTo({
							center: [+e$2[2], +e$2[1]],
							zoom: +e$2[0],
							bearing: t$1,
							pitch: +(e$2[4] || 0)
						}), !0;
					}, this._updateHashUnthrottled = () => {
						const e$2 = window.location.href.replace(/(#.*)?$/, this.getHashString());
						window.history.replaceState(window.history.state, null, e$2);
					}, this._removeHash = () => {
						const e$2 = this._getCurrentHash();
						if (0 === e$2.length) return;
						const t$1 = e$2.join("/");
						let i$1 = t$1;
						i$1.split("&").length > 0 && (i$1 = i$1.split("&")[0]), this._hashName && (i$1 = `${this._hashName}=${t$1}`);
						let o$1 = window.location.hash.replace(i$1, "");
						o$1.startsWith("#&") ? o$1 = o$1.slice(0, 1) + o$1.slice(2) : "#" === o$1 && (o$1 = "");
						let r$1 = window.location.href.replace(/(#.+)?$/, o$1);
						r$1 = r$1.replace("&&", "&"), window.history.replaceState(window.history.state, null, r$1);
					}, this._updateHash = Sr$1(this._updateHashUnthrottled, 300), this._hashName = e$1 && encodeURIComponent(e$1);
				}
				addTo(e$1) {
					return this._map = e$1, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
				}
				remove() {
					return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
				}
				getHashString(e$1) {
					const t$1 = this._map.getCenter(), i$1 = Math.round(100 * this._map.getZoom()) / 100, o$1 = Math.ceil((i$1 * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r$1 = Math.pow(10, o$1), a$1 = Math.round(t$1.lng * r$1) / r$1, s$1 = Math.round(t$1.lat * r$1) / r$1, n$1 = this._map.getBearing(), l$1 = this._map.getPitch();
					let c$1 = "";
					if (c$1 += e$1 ? `/${a$1}/${s$1}/${i$1}` : `${i$1}/${s$1}/${a$1}`, (n$1 || l$1) && (c$1 += "/" + Math.round(10 * n$1) / 10), l$1 && (c$1 += `/${Math.round(l$1)}`), this._hashName) {
						const e$2 = this._hashName;
						let t$2 = !1;
						const i$2 = window.location.hash.slice(1).split("&").map(((i$3) => {
							const o$2 = i$3.split("=")[0];
							return o$2 === e$2 ? (t$2 = !0, `${o$2}=${c$1}`) : i$3;
						})).filter(((e$3) => e$3));
						return t$2 || i$2.push(`${e$2}=${c$1}`), `#${i$2.join("&")}`;
					}
					return `#${c$1}`;
				}
				_isValidHash(e$1) {
					if (e$1.length < 3 || e$1.some(isNaN)) return !1;
					try {
						new t.S(+e$1[2], +e$1[1]);
					} catch (e$2) {
						return !1;
					}
					const i$1 = +e$1[0], o$1 = +(e$1[3] || 0), r$1 = +(e$1[4] || 0);
					return i$1 >= this._map.getMinZoom() && i$1 <= this._map.getMaxZoom() && o$1 >= -180 && o$1 <= 180 && r$1 >= this._map.getMinPitch() && r$1 <= this._map.getMaxPitch();
				}
			}
			const Rr$1 = {
				linearity: .3,
				easing: t.cm(0, 0, .3, 1)
			}, zr$1 = t.e({
				deceleration: 2500,
				maxSpeed: 1400
			}, Rr$1), Dr$1 = t.e({
				deceleration: 20,
				maxSpeed: 1400
			}, Rr$1), Ar$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Rr$1), Lr$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 90
			}, Rr$1), kr$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Rr$1);
			class Fr$1 {
				constructor(e$1) {
					this._map = e$1, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(e$1) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: s.now(),
						settings: e$1
					});
				}
				_drainInertiaBuffer() {
					const e$1 = this._inertiaBuffer, t$1 = s.now();
					for (; e$1.length > 0 && t$1 - e$1[0].time > 160;) e$1.shift();
				}
				_onMoveEnd(e$1) {
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					const i$1 = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						roll: 0,
						pan: new t.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (const { settings: e$2 } of this._inertiaBuffer) i$1.zoom += e$2.zoomDelta || 0, i$1.bearing += e$2.bearingDelta || 0, i$1.pitch += e$2.pitchDelta || 0, i$1.roll += e$2.rollDelta || 0, e$2.panDelta && i$1.pan._add(e$2.panDelta), e$2.around && (i$1.around = e$2.around), e$2.pinchAround && (i$1.pinchAround = e$2.pinchAround);
					const o$1 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r$1 = {};
					if (i$1.pan.mag()) {
						const a$1 = Or$1(i$1.pan.mag(), o$1, t.e({}, zr$1, e$1 || {})), s$1 = i$1.pan.mult(a$1.amount / i$1.pan.mag()), n$1 = this._map.cameraHelper.handlePanInertia(s$1, this._map.transform);
						r$1.center = n$1.easingCenter, r$1.offset = n$1.easingOffset, Br$1(r$1, a$1);
					}
					if (i$1.zoom) {
						const e$2 = Or$1(i$1.zoom, o$1, Dr$1);
						r$1.zoom = this._map.transform.zoom + e$2.amount, Br$1(r$1, e$2);
					}
					if (i$1.bearing) {
						const e$2 = Or$1(i$1.bearing, o$1, Ar$1);
						r$1.bearing = this._map.transform.bearing + t.ah(e$2.amount, -179, 179), Br$1(r$1, e$2);
					}
					if (i$1.pitch) {
						const e$2 = Or$1(i$1.pitch, o$1, Lr$1);
						r$1.pitch = this._map.transform.pitch + e$2.amount, Br$1(r$1, e$2);
					}
					if (i$1.roll) {
						const e$2 = Or$1(i$1.roll, o$1, kr$1);
						r$1.roll = this._map.transform.roll + t.ah(e$2.amount, -179, 179), Br$1(r$1, e$2);
					}
					if (r$1.zoom || r$1.bearing) {
						const e$2 = void 0 === i$1.pinchAround ? i$1.around : i$1.pinchAround;
						r$1.around = e$2 ? this._map.unproject(e$2) : this._map.getCenter();
					}
					return this.clear(), t.e(r$1, { noMoveStart: !0 });
				}
			}
			function Br$1(e$1, t$1) {
				(!e$1.duration || e$1.duration < t$1.duration) && (e$1.duration = t$1.duration, e$1.easing = t$1.easing);
			}
			function Or$1(e$1, i$1, o$1) {
				const { maxSpeed: r$1, linearity: a$1, deceleration: s$1 } = o$1, n$1 = t.ah(e$1 * a$1 / (i$1 / 1e3), -r$1, r$1), l$1 = Math.abs(n$1) / (s$1 * a$1);
				return {
					easing: o$1.easing,
					duration: 1e3 * l$1,
					amount: n$1 * (l$1 / 2)
				};
			}
			class jr$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, o$1, r$1 = {}) {
					o$1 = o$1 instanceof MouseEvent ? o$1 : new MouseEvent(e$1, o$1);
					const a$1 = n.mousePos(i$1.getCanvas(), o$1), s$1 = i$1.unproject(a$1);
					super(e$1, t.e({
						point: a$1,
						lngLat: s$1,
						originalEvent: o$1
					}, r$1)), this._defaultPrevented = !1, this.target = i$1;
				}
			}
			class Nr$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, o$1) {
					const r$1 = "touchend" === e$1 ? o$1.changedTouches : o$1.touches, a$1 = n.touchPos(i$1.getCanvasContainer(), r$1), s$1 = a$1.map(((e$2) => i$1.unproject(e$2))), l$1 = a$1.reduce(((e$2, t$1, i$2, o$2) => e$2.add(t$1.div(o$2.length))), new t.P(0, 0));
					super(e$1, {
						points: a$1,
						point: l$1,
						lngLats: s$1,
						lngLat: i$1.unproject(l$1),
						originalEvent: o$1
					}), this._defaultPrevented = !1;
				}
			}
			class Ur$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1, i$1) {
					super(e$1, { originalEvent: i$1 }), this._defaultPrevented = !1;
				}
			}
			class Zr$1 {
				constructor(e$1, t$1) {
					this._map = e$1, this._clickTolerance = t$1.clickTolerance;
				}
				reset() {
					delete this._mousedownPos;
				}
				wheel(e$1) {
					return this._firePreventable(new Ur$1(e$1.type, this._map, e$1));
				}
				mousedown(e$1, t$1) {
					return this._mousedownPos = t$1, this._firePreventable(new jr$1(e$1.type, this._map, e$1));
				}
				mouseup(e$1) {
					this._map.fire(new jr$1(e$1.type, this._map, e$1));
				}
				click(e$1, t$1) {
					this._mousedownPos && this._mousedownPos.dist(t$1) >= this._clickTolerance || this._map.fire(new jr$1(e$1.type, this._map, e$1));
				}
				dblclick(e$1) {
					return this._firePreventable(new jr$1(e$1.type, this._map, e$1));
				}
				mouseover(e$1) {
					this._map.fire(new jr$1(e$1.type, this._map, e$1));
				}
				mouseout(e$1) {
					this._map.fire(new jr$1(e$1.type, this._map, e$1));
				}
				touchstart(e$1) {
					return this._firePreventable(new Nr$1(e$1.type, this._map, e$1));
				}
				touchmove(e$1) {
					this._map.fire(new Nr$1(e$1.type, this._map, e$1));
				}
				touchend(e$1) {
					this._map.fire(new Nr$1(e$1.type, this._map, e$1));
				}
				touchcancel(e$1) {
					this._map.fire(new Nr$1(e$1.type, this._map, e$1));
				}
				_firePreventable(e$1) {
					if (this._map.fire(e$1), e$1.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class Gr$1 {
				constructor(e$1) {
					this._map = e$1;
				}
				reset() {
					this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
				}
				mousemove(e$1) {
					this._map.fire(new jr$1(e$1.type, this._map, e$1));
				}
				mousedown() {
					this._delayContextMenu = !0, this._ignoreContextMenu = !1;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new jr$1("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e$1) {
					this._delayContextMenu ? this._contextMenuEvent = e$1 : this._ignoreContextMenu || this._map.fire(new jr$1(e$1.type, this._map, e$1)), this._map.listens("contextmenu") && e$1.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class Vr$1 {
				constructor(e$1) {
					this._map = e$1;
				}
				get transform() {
					return this._map._requestedCameraState || this._map.transform;
				}
				get center() {
					return {
						lng: this.transform.center.lng,
						lat: this.transform.center.lat
					};
				}
				get zoom() {
					return this.transform.zoom;
				}
				get pitch() {
					return this.transform.pitch;
				}
				get bearing() {
					return this.transform.bearing;
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this._map.terrain);
				}
			}
			class $r$1 {
				constructor(e$1, t$1) {
					this._map = e$1, this._tr = new Vr$1(e$1), this._el = e$1.getCanvasContainer(), this._container = e$1.getContainer(), this._clickTolerance = t$1.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e$1, t$1) {
					this.isEnabled() && e$1.shiftKey && 0 === e$1.button && (n.disableDrag(), this._startPos = this._lastPos = t$1, this._active = !0);
				}
				mousemoveWindow(e$1, t$1) {
					if (!this._active) return;
					const i$1 = t$1;
					if (this._lastPos.equals(i$1) || !this._box && i$1.dist(this._startPos) < this._clickTolerance) return;
					const o$1 = this._startPos;
					this._lastPos = i$1, this._box || (this._box = n.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e$1));
					const r$1 = Math.min(o$1.x, i$1.x), a$1 = Math.max(o$1.x, i$1.x), s$1 = Math.min(o$1.y, i$1.y), l$1 = Math.max(o$1.y, i$1.y);
					n.setTransform(this._box, `translate(${r$1}px,${s$1}px)`), this._box.style.width = a$1 - r$1 + "px", this._box.style.height = l$1 - s$1 + "px";
				}
				mouseupWindow(e$1, i$1) {
					if (!this._active) return;
					if (0 !== e$1.button) return;
					const o$1 = this._startPos, r$1 = i$1;
					if (this.reset(), n.suppressClick(), o$1.x !== r$1.x || o$1.y !== r$1.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e$1 })), { cameraAnimation: (e$2) => e$2.fitScreenCoordinates(o$1, r$1, this._tr.bearing, { linear: !0 }) };
					this._fireEvent("boxzoomcancel", e$1);
				}
				keydown(e$1) {
					this._active && 27 === e$1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e$1));
				}
				reset() {
					this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(e$1, i$1) {
					return this._map.fire(new t.l(e$1, { originalEvent: i$1 }));
				}
			}
			function qr$1(e$1, t$1) {
				if (e$1.length !== t$1.length) throw new Error(`The number of touches and points are not equal - touches ${e$1.length}, points ${t$1.length}`);
				const i$1 = {};
				for (let o$1 = 0; o$1 < e$1.length; o$1++) i$1[e$1[o$1].identifier] = t$1[o$1];
				return i$1;
			}
			class Wr$1 {
				constructor(e$1) {
					this.reset(), this.numTouches = e$1.numTouches;
				}
				reset() {
					delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
				}
				touchstart(e$1, i$1, o$1) {
					(this.centroid || o$1.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e$1.timeStamp), o$1.length === this.numTouches && (this.centroid = function(e$2) {
						const i$2 = new t.P(0, 0);
						for (const t$1 of e$2) i$2._add(t$1);
						return i$2.div(e$2.length);
					}(i$1), this.touches = qr$1(o$1, i$1)));
				}
				touchmove(e$1, t$1, i$1) {
					if (this.aborted || !this.centroid) return;
					const o$1 = qr$1(i$1, t$1);
					for (const e$2 in this.touches) {
						const t$2 = o$1[e$2];
						(!t$2 || t$2.dist(this.touches[e$2]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e$1, t$1, i$1) {
					if ((!this.centroid || e$1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i$1.length) {
						const e$2 = !this.aborted && this.centroid;
						if (this.reset(), e$2) return e$2;
					}
				}
			}
			class Hr$1 {
				constructor(e$1) {
					this.singleTap = new Wr$1(e$1), this.numTaps = e$1.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, delete this.lastTap, this.count = 0, this.singleTap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this.singleTap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this.singleTap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this.singleTap.touchend(e$1, t$1, i$1);
					if (o$1) {
						const t$2 = e$1.timeStamp - this.lastTime < 500, i$2 = !this.lastTap || this.lastTap.dist(o$1) < 30;
						if (t$2 && i$2 || this.reset(), this.count++, this.lastTime = e$1.timeStamp, this.lastTap = o$1, this.count === this.numTaps) return this.reset(), o$1;
					}
				}
			}
			class Xr$1 {
				constructor(e$1) {
					this._tr = new Vr$1(e$1), this._zoomIn = new Hr$1({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new Hr$1({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._zoomIn.touchstart(e$1, t$1, i$1), this._zoomOut.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this._zoomIn.touchmove(e$1, t$1, i$1), this._zoomOut.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this._zoomIn.touchend(e$1, t$1, i$1), r$1 = this._zoomOut.touchend(e$1, t$1, i$1), a$1 = this._tr;
					return o$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: a$1.zoom + 1,
						around: a$1.unproject(o$1)
					}, { originalEvent: e$1 }) }) : r$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: a$1.zoom - 1,
						around: a$1.unproject(r$1)
					}, { originalEvent: e$1 }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Kr$1 {
				constructor(e$1) {
					this._enabled = !!e$1.enable, this._moveStateManager = e$1.moveStateManager, this._clickTolerance = e$1.clickTolerance || 1, this._moveFunction = e$1.move, this._activateOnStart = !!e$1.activateOnStart, e$1.assignEvents(this), this.reset();
				}
				reset(e$1) {
					this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e$1);
				}
				_move(...e$1) {
					const t$1 = this._moveFunction(...e$1);
					if (t$1.bearingDelta || t$1.pitchDelta || t$1.rollDelta || t$1.around || t$1.panDelta) return this._active = !0, t$1;
				}
				dragStart(e$1, t$1) {
					this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e$1) && (this._moveStateManager.startMove(e$1), this._lastPoint = Array.isArray(t$1) ? t$1[0] : t$1, this._activateOnStart && this._lastPoint && (this._active = !0));
				}
				dragMove(e$1, t$1) {
					if (!this.isEnabled()) return;
					const i$1 = this._lastPoint;
					if (!i$1) return;
					if (e$1.preventDefault(), !this._moveStateManager.isValidMoveEvent(e$1)) return void this.reset(e$1);
					const o$1 = Array.isArray(t$1) ? t$1[0] : t$1;
					return !this._moved && o$1.dist(i$1) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = o$1, this._move(i$1, o$1));
				}
				dragEnd(e$1) {
					this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e$1) && (this._moved && n.suppressClick(), this.reset(e$1));
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				getClickTolerance() {
					return this._clickTolerance;
				}
			}
			const Yr$1 = 0, Qr$1 = 2, Jr$1 = {
				[Yr$1]: 1,
				[Qr$1]: 2
			};
			class ea$1 {
				constructor(e$1) {
					this._correctEvent = e$1.checkCorrectEvent;
				}
				startMove(e$1) {
					this._eventButton = n.mouseButton(e$1);
				}
				endMove(e$1) {
					delete this._eventButton;
				}
				isValidStartEvent(e$1) {
					return this._correctEvent(e$1);
				}
				isValidMoveEvent(e$1) {
					return !function(e$2, t$1) {
						const i$1 = Jr$1[t$1];
						return void 0 === e$2.buttons || (e$2.buttons & i$1) !== i$1;
					}(e$1, this._eventButton);
				}
				isValidEndEvent(e$1) {
					return n.mouseButton(e$1) === this._eventButton;
				}
			}
			class ta$1 {
				constructor() {
					this._firstTouch = void 0;
				}
				_isOneFingerTouch(e$1) {
					return 1 === e$1.targetTouches.length;
				}
				_isSameTouchEvent(e$1) {
					return e$1.targetTouches[0].identifier === this._firstTouch;
				}
				startMove(e$1) {
					this._firstTouch = e$1.targetTouches[0].identifier;
				}
				endMove(e$1) {
					delete this._firstTouch;
				}
				isValidStartEvent(e$1) {
					return this._isOneFingerTouch(e$1);
				}
				isValidMoveEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
				isValidEndEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
			}
			class ia$1 {
				constructor(e$1 = new ea$1({ checkCorrectEvent: () => !0 }), t$1 = new ta$1()) {
					this.mouseMoveStateManager = e$1, this.oneFingerTouchMoveStateManager = t$1;
				}
				_executeRelevantHandler(e$1, t$1, i$1) {
					return e$1 instanceof MouseEvent ? t$1(e$1) : "undefined" != typeof TouchEvent && e$1 instanceof TouchEvent ? i$1(e$1) : void 0;
				}
				startMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.startMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.startMove(e$2)));
				}
				endMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.endMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.endMove(e$2)));
				}
				isValidStartEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidStartEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e$2)));
				}
				isValidMoveEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidMoveEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e$2)));
				}
				isValidEndEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidEndEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e$2)));
				}
			}
			const oa$1 = (e$1) => {
				e$1.mousedown = e$1.dragStart, e$1.mousemoveWindow = e$1.dragMove, e$1.mouseup = e$1.dragEnd, e$1.contextmenu = (e$2) => {
					e$2.preventDefault();
				};
			};
			class ra$1 {
				constructor(e$1, t$1) {
					this._clickTolerance = e$1.clickTolerance || 1, this._map = t$1, this.reset();
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new t.P(0, 0);
				}
				_shouldBePrevented(e$1) {
					return e$1 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
				}
				touchstart(e$1, t$1, i$1) {
					return this._calculateTransform(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._active) {
						if (!this._shouldBePrevented(i$1.length)) return e$1.preventDefault(), this._calculateTransform(e$1, t$1, i$1);
						this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e$1);
					}
				}
				touchend(e$1, t$1, i$1) {
					this._calculateTransform(e$1, t$1, i$1), this._active && this._shouldBePrevented(i$1.length) && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(e$1, i$1, o$1) {
					o$1.length > 0 && (this._active = !0);
					const r$1 = qr$1(o$1, i$1), a$1 = new t.P(0, 0), s$1 = new t.P(0, 0);
					let n$1 = 0;
					for (const e$2 in r$1) {
						const t$1 = r$1[e$2], i$2 = this._touches[e$2];
						i$2 && (a$1._add(t$1), s$1._add(t$1.sub(i$2)), n$1++, r$1[e$2] = t$1);
					}
					if (this._touches = r$1, this._shouldBePrevented(n$1) || !s$1.mag()) return;
					const l$1 = s$1.div(n$1);
					return this._sum._add(l$1), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: a$1.div(n$1),
						panDelta: l$1
					};
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class aa$1 {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, delete this._firstTwoTouches;
				}
				touchstart(e$1, t$1, i$1) {
					this._firstTwoTouches || i$1.length < 2 || (this._firstTwoTouches = [i$1[0].identifier, i$1[1].identifier], this._start([t$1[0], t$1[1]]));
				}
				touchmove(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					e$1.preventDefault();
					const [o$1, r$1] = this._firstTwoTouches, a$1 = sa$1(i$1, t$1, o$1), s$1 = sa$1(i$1, t$1, r$1);
					if (!a$1 || !s$1) return;
					const n$1 = this._aroundCenter ? null : a$1.add(s$1).div(2);
					return this._move([a$1, s$1], n$1, e$1);
				}
				touchend(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					const [o$1, r$1] = this._firstTwoTouches, a$1 = sa$1(i$1, t$1, o$1), s$1 = sa$1(i$1, t$1, r$1);
					a$1 && s$1 || (this._active && n.suppressClick(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e$1) {
					this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
			}
			function sa$1(e$1, t$1, i$1) {
				for (let o$1 = 0; o$1 < e$1.length; o$1++) if (e$1[o$1].identifier === i$1) return t$1[o$1];
			}
			function na$1(e$1, t$1) {
				return Math.log(e$1 / t$1) / Math.LN2;
			}
			class la$1 extends aa$1 {
				reset() {
					super.reset(), delete this._distance, delete this._startDistance;
				}
				_start(e$1) {
					this._startDistance = this._distance = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._distance;
					if (this._distance = e$1[0].dist(e$1[1]), this._active || !(Math.abs(na$1(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: na$1(this._distance, i$1),
						pinchAround: t$1
					};
				}
			}
			function ca$1(e$1, t$1) {
				return 180 * e$1.angleWith(t$1) / Math.PI;
			}
			class ha$1 extends aa$1 {
				reset() {
					super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
				}
				_start(e$1) {
					this._startVector = this._vector = e$1[0].sub(e$1[1]), this._minDiameter = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1, i$1) {
					const o$1 = this._vector;
					if (this._vector = e$1[0].sub(e$1[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
						bearingDelta: ca$1(this._vector, o$1),
						pinchAround: t$1
					};
				}
				_isBelowThreshold(e$1) {
					this._minDiameter = Math.min(this._minDiameter, e$1.mag());
					const t$1 = 25 / (Math.PI * this._minDiameter) * 360, i$1 = ca$1(e$1, this._startVector);
					return Math.abs(i$1) < t$1;
				}
			}
			function ua$1(e$1) {
				return Math.abs(e$1.y) > Math.abs(e$1.x);
			}
			class da$1 extends aa$1 {
				constructor(e$1) {
					super(), this._currentTouchCount = 0, this._map = e$1;
				}
				reset() {
					super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
				}
				touchstart(e$1, t$1, i$1) {
					super.touchstart(e$1, t$1, i$1), this._currentTouchCount = i$1.length;
				}
				_start(e$1) {
					this._lastPoints = e$1, ua$1(e$1[0].sub(e$1[1])) && (this._valid = !1);
				}
				_move(e$1, t$1, i$1) {
					if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
					const o$1 = e$1[0].sub(this._lastPoints[0]), r$1 = e$1[1].sub(this._lastPoints[1]);
					return this._valid = this.gestureBeginsVertically(o$1, r$1, i$1.timeStamp), this._valid ? (this._lastPoints = e$1, this._active = !0, { pitchDelta: (o$1.y + r$1.y) / 2 * -.5 }) : void 0;
				}
				gestureBeginsVertically(e$1, t$1, i$1) {
					if (void 0 !== this._valid) return this._valid;
					const o$1 = e$1.mag() >= 2, r$1 = t$1.mag() >= 2;
					if (!o$1 && !r$1) return;
					if (!o$1 || !r$1) return void 0 === this._firstMove && (this._firstMove = i$1), i$1 - this._firstMove < 100 && void 0;
					const a$1 = e$1.y > 0 == t$1.y > 0;
					return ua$1(e$1) && ua$1(t$1) && a$1;
				}
			}
			const _a$1 = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class pa$1 {
				constructor(e$1) {
					this._tr = new Vr$1(e$1);
					const t$1 = _a$1;
					this._panStep = t$1.panStep, this._bearingStep = t$1.bearingStep, this._pitchStep = t$1.pitchStep, this._rotationDisabled = !1;
				}
				reset() {
					this._active = !1;
				}
				keydown(e$1) {
					if (e$1.altKey || e$1.ctrlKey || e$1.metaKey) return;
					let t$1 = 0, i$1 = 0, o$1 = 0, r$1 = 0, a$1 = 0;
					switch (e$1.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							t$1 = 1;
							break;
						case 189:
						case 109:
						case 173:
							t$1 = -1;
							break;
						case 37:
							e$1.shiftKey ? i$1 = -1 : (e$1.preventDefault(), r$1 = -1);
							break;
						case 39:
							e$1.shiftKey ? i$1 = 1 : (e$1.preventDefault(), r$1 = 1);
							break;
						case 38:
							e$1.shiftKey ? o$1 = 1 : (e$1.preventDefault(), a$1 = -1);
							break;
						case 40:
							e$1.shiftKey ? o$1 = -1 : (e$1.preventDefault(), a$1 = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (i$1 = 0, o$1 = 0), { cameraAnimation: (s$1) => {
						const n$1 = this._tr;
						s$1.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: ma$1,
							zoom: t$1 ? Math.round(n$1.zoom) + t$1 * (e$1.shiftKey ? 2 : 1) : n$1.zoom,
							bearing: n$1.bearing + i$1 * this._bearingStep,
							pitch: n$1.pitch + o$1 * this._pitchStep,
							offset: [-r$1 * this._panStep, -a$1 * this._panStep],
							center: n$1.center
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function ma$1(e$1) {
				return e$1 * (2 - e$1);
			}
			const fa$1 = 4.000244140625, ga$1 = 1 / 450;
			class va$1 {
				constructor(e$1, t$1) {
					this._onTimeout = (e$2) => {
						this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e$2);
					}, this._map = e$1, this._tr = new Vr$1(e$1), this._triggerRenderFrame = t$1, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ga$1;
				}
				setZoomRate(e$1) {
					this._defaultZoomRate = e$1;
				}
				setWheelZoomRate(e$1) {
					this._wheelZoomRate = e$1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active || void 0 !== this._finishTimeout;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e$1) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				_shouldBePrevented(e$1) {
					return !!this._map.cooperativeGestures.isEnabled() && !(e$1.ctrlKey || this._map.cooperativeGestures.isBypassed(e$1));
				}
				wheel(e$1) {
					if (!this.isEnabled()) return;
					if (this._shouldBePrevented(e$1)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e$1);
					let t$1 = e$1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e$1.deltaY : e$1.deltaY;
					const i$1 = s.now(), o$1 = i$1 - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = i$1, 0 !== t$1 && t$1 % fa$1 == 0 ? this._type = "wheel" : 0 !== t$1 && Math.abs(t$1) < 4 ? this._type = "trackpad" : o$1 > 400 ? (this._type = null, this._lastValue = t$1, this._timeout = setTimeout(this._onTimeout, 40, e$1)) : this._type || (this._type = Math.abs(o$1 * t$1) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t$1 += this._lastValue)), e$1.shiftKey && t$1 && (t$1 /= 4), this._type && (this._lastWheelEvent = e$1, this._delta -= t$1, this._active || this._start(e$1)), e$1.preventDefault();
				}
				_start(e$1) {
					if (!this._delta) return;
					this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					const i$1 = n.mousePos(this._map.getCanvas(), e$1), o$1 = this._tr;
					this._aroundPoint = this._aroundCenter ? o$1.transform.locationToScreenPoint(t.S.convert(o$1.center)) : i$1, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId) return;
					if (this._frameId = null, !this.isActive()) return;
					const e$1 = this._tr.transform;
					if ("number" == typeof this._lastExpectedZoom) {
						const t$1 = e$1.zoom - this._lastExpectedZoom;
						"number" == typeof this._startZoom && (this._startZoom += t$1), "number" == typeof this._targetZoom && (this._targetZoom += t$1);
					}
					if (0 !== this._delta) {
						const i$2 = "wheel" === this._type && Math.abs(this._delta) > fa$1 ? this._wheelZoomRate : this._defaultZoomRate;
						let o$2 = 2 / (1 + Math.exp(-Math.abs(this._delta * i$2)));
						this._delta < 0 && 0 !== o$2 && (o$2 = 1 / o$2);
						const r$2 = "number" != typeof this._targetZoom ? e$1.scale : t.af(this._targetZoom);
						this._targetZoom = e$1.getConstrained(e$1.getCameraLngLat(), t.ak(r$2 * o$2)).zoom, "wheel" === this._type && (this._startZoom = e$1.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
					}
					const i$1 = "number" != typeof this._targetZoom ? e$1.zoom : this._targetZoom, o$1 = this._startZoom, r$1 = this._easing;
					let a$1, n$1 = !1;
					if ("wheel" === this._type && o$1 && r$1) {
						const e$2 = s.now() - this._lastWheelEventTime, l$1 = Math.min((e$2 + 5) / 200, 1), c$1 = r$1(l$1);
						a$1 = t.C.number(o$1, i$1, c$1), l$1 < 1 ? this._frameId || (this._frameId = !0) : n$1 = !0;
					} else a$1 = i$1, n$1 = !0;
					return this._active = !0, n$1 && (this._active = !1, this._finishTimeout = setTimeout((() => {
						this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
					}), 200)), this._lastExpectedZoom = a$1, {
						noInertia: !0,
						needsRenderFrame: !n$1,
						zoomDelta: a$1 - e$1.zoom,
						around: this._aroundPoint,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(e$1) {
					let i$1 = t.co;
					if (this._prevEase) {
						const e$2 = this._prevEase, o$1 = (s.now() - e$2.start) / e$2.duration, r$1 = e$2.easing(o$1 + .01) - e$2.easing(o$1), a$1 = .27 / Math.sqrt(r$1 * r$1 + 1e-4) * .01, n$1 = Math.sqrt(.0729 - a$1 * a$1);
						i$1 = t.cm(a$1, n$1, .25, 1);
					}
					return this._prevEase = {
						start: s.now(),
						duration: e$1,
						easing: i$1
					}, i$1;
				}
				reset() {
					this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
				}
			}
			class ba$1 {
				constructor(e$1, t$1) {
					this._clickZoom = e$1, this._tapZoom = t$1;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class xa$1 {
				constructor(e$1) {
					this._tr = new Vr$1(e$1), this.reset();
				}
				reset() {
					this._active = !1;
				}
				dblclick(e$1, t$1) {
					return e$1.preventDefault(), { cameraAnimation: (i$1) => {
						i$1.easeTo({
							duration: 300,
							zoom: this._tr.zoom + (e$1.shiftKey ? -1 : 1),
							around: this._tr.unproject(t$1)
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class ya$1 {
				constructor() {
					this._tap = new Hr$1({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					if (!this._swipePoint) if (this._tapTime) {
						const o$1 = t$1[0], r$1 = e$1.timeStamp - this._tapTime < 500, a$1 = this._tapPoint.dist(o$1) < 30;
						r$1 && a$1 ? i$1.length > 0 && (this._swipePoint = o$1, this._swipeTouch = i$1[0].identifier) : this.reset();
					} else this._tap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (i$1[0].identifier !== this._swipeTouch) return;
							const o$1 = t$1[0], r$1 = o$1.y - this._swipePoint.y;
							return this._swipePoint = o$1, e$1.preventDefault(), this._active = !0, { zoomDelta: r$1 / 128 };
						}
					} else this._tap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					if (this._tapTime) this._swipePoint && 0 === i$1.length && this.reset();
					else {
						const o$1 = this._tap.touchend(e$1, t$1, i$1);
						o$1 && (this._tapTime = e$1.timeStamp, this._tapPoint = o$1);
					}
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class wa$1 {
				constructor(e$1, t$1, i$1) {
					this._el = e$1, this._mousePan = t$1, this._touchPan = i$1;
				}
				enable(e$1) {
					this._inertiaOptions = e$1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class Ta$1 {
				constructor(e$1, t$1, i$1, o$1) {
					this._pitchWithRotate = e$1.pitchWithRotate, this._rollEnabled = e$1.rollEnabled, this._mouseRotate = t$1, this._mousePitch = i$1, this._mouseRoll = o$1;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
				}
			}
			class Pa$1 {
				constructor(e$1, t$1, i$1, o$1) {
					this._el = e$1, this._touchZoom = t$1, this._touchRotate = i$1, this._tapDragZoom = o$1, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e$1) {
					this._touchZoom.enable(e$1), this._rotationDisabled || this._touchRotate.enable(e$1), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			class Ca$1 {
				constructor(e$1, t$1) {
					this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e$1, this._options = t$1, this._enabled = !1;
				}
				isActive() {
					return !1;
				}
				reset() {}
				_setupUI() {
					if (this._container) return;
					const e$1 = this._map.getCanvasContainer();
					e$1.classList.add("maplibregl-cooperative-gestures"), this._container = n.create("div", "maplibregl-cooperative-gesture-screen", e$1);
					let t$1 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
					"metaKey" === this._bypassKey && (t$1 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
					const i$1 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), o$1 = document.createElement("div");
					o$1.className = "maplibregl-desktop-message", o$1.textContent = t$1, this._container.appendChild(o$1);
					const r$1 = document.createElement("div");
					r$1.className = "maplibregl-mobile-message", r$1.textContent = i$1, this._container.appendChild(r$1), this._container.setAttribute("aria-hidden", "true");
				}
				_destroyUI() {
					this._container && (n.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
				}
				enable() {
					this._setupUI(), this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this._destroyUI();
				}
				isEnabled() {
					return this._enabled;
				}
				isBypassed(e$1) {
					return e$1[this._bypassKey];
				}
				notifyGestureBlocked(e$1, i$1) {
					this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", {
						gestureType: e$1,
						originalEvent: i$1
					})), this._container.classList.add("maplibregl-show"), setTimeout((() => {
						this._container.classList.remove("maplibregl-show");
					}), 100));
				}
			}
			const Ia$1 = (e$1) => e$1.zoom || e$1.drag || e$1.roll || e$1.pitch || e$1.rotate;
			class Ma$1 extends t.l {}
			function Sa$1(e$1) {
				return e$1.panDelta && e$1.panDelta.mag() || e$1.zoomDelta || e$1.bearingDelta || e$1.pitchDelta || e$1.rollDelta;
			}
			class Ea$1 {
				constructor(e$1, i$1) {
					this.handleWindowEvent = (e$2) => {
						this.handleEvent(e$2, `${e$2.type}Window`);
					}, this.handleEvent = (e$2, i$2) => {
						if ("blur" === e$2.type) return void this.stop(!0);
						this._updatingCamera = !0;
						const o$2 = "renderFrame" === e$2.type ? void 0 : e$2, r$1 = { needsRenderFrame: !1 }, a$1 = {}, s$1 = {};
						for (const { handlerName: l$2, handler: c$2, allowed: h$1 } of this._handlers) {
							if (!c$2.isEnabled()) continue;
							let u$1;
							if (this._blockedByActive(s$1, h$1, l$2)) c$2.reset();
							else if (c$2[i$2 || e$2.type]) {
								if (t.cp(e$2, i$2 || e$2.type)) {
									const t$1 = n.mousePos(this._map.getCanvas(), e$2);
									u$1 = c$2[i$2 || e$2.type](e$2, t$1);
								} else if (t.cq(e$2, i$2 || e$2.type)) {
									const t$1 = this._getMapTouches(e$2.touches), o$3 = n.touchPos(this._map.getCanvas(), t$1);
									u$1 = c$2[i$2 || e$2.type](e$2, o$3, t$1);
								} else t.cr(i$2 || e$2.type) || (u$1 = c$2[i$2 || e$2.type](e$2));
								this.mergeHandlerResult(r$1, a$1, u$1, l$2, o$2), u$1 && u$1.needsRenderFrame && this._triggerRenderFrame();
							}
							(u$1 || c$2.isActive()) && (s$1[l$2] = c$2);
						}
						const l$1 = {};
						for (const e$3 in this._previousActiveHandlers) s$1[e$3] || (l$1[e$3] = o$2);
						this._previousActiveHandlers = s$1, (Object.keys(l$1).length || Sa$1(r$1)) && (this._changes.push([
							r$1,
							a$1,
							l$1
						]), this._triggerRenderFrame()), (Object.keys(s$1).length || Sa$1(r$1)) && this._map._stop(!0), this._updatingCamera = !1;
						const { cameraAnimation: c$1 } = r$1;
						c$1 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], c$1(this._map));
					}, this._map = e$1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Fr$1(e$1), this._bearingSnap = i$1.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i$1);
					const o$1 = this._el;
					this._listeners = [
						[
							o$1,
							"touchstart",
							{ passive: !0 }
						],
						[
							o$1,
							"touchmove",
							{ passive: !1 }
						],
						[
							o$1,
							"touchend",
							void 0
						],
						[
							o$1,
							"touchcancel",
							void 0
						],
						[
							o$1,
							"mousedown",
							void 0
						],
						[
							o$1,
							"mousemove",
							void 0
						],
						[
							o$1,
							"mouseup",
							void 0
						],
						[
							document,
							"mousemove",
							{ capture: !0 }
						],
						[
							document,
							"mouseup",
							void 0
						],
						[
							o$1,
							"mouseover",
							void 0
						],
						[
							o$1,
							"mouseout",
							void 0
						],
						[
							o$1,
							"dblclick",
							void 0
						],
						[
							o$1,
							"click",
							void 0
						],
						[
							o$1,
							"keydown",
							{ capture: !1 }
						],
						[
							o$1,
							"keyup",
							void 0
						],
						[
							o$1,
							"wheel",
							{ passive: !1 }
						],
						[
							o$1,
							"contextmenu",
							void 0
						],
						[
							window,
							"blur",
							void 0
						]
					];
					for (const [e$2, t$1, i$2] of this._listeners) n.addEventListener(e$2, t$1, e$2 === document ? this.handleWindowEvent : this.handleEvent, i$2);
				}
				destroy() {
					for (const [e$1, t$1, i$1] of this._listeners) n.removeEventListener(e$1, t$1, e$1 === document ? this.handleWindowEvent : this.handleEvent, i$1);
				}
				_addDefaultHandlers(e$1) {
					const i$1 = this._map, o$1 = i$1.getCanvasContainer();
					this._add("mapEvent", new Zr$1(i$1, e$1));
					const r$1 = i$1.boxZoom = new $r$1(i$1, e$1);
					this._add("boxZoom", r$1), e$1.interactive && e$1.boxZoom && r$1.enable();
					const a$1 = i$1.cooperativeGestures = new Ca$1(i$1, e$1.cooperativeGestures);
					this._add("cooperativeGestures", a$1), e$1.cooperativeGestures && a$1.enable();
					const s$1 = new Xr$1(i$1), l$1 = new xa$1(i$1);
					i$1.doubleClickZoom = new ba$1(l$1, s$1), this._add("tapZoom", s$1), this._add("clickZoom", l$1), e$1.interactive && e$1.doubleClickZoom && i$1.doubleClickZoom.enable();
					const c$1 = new ya$1();
					this._add("tapDragZoom", c$1);
					const h$1 = i$1.touchPitch = new da$1(i$1);
					this._add("touchPitch", h$1), e$1.interactive && e$1.touchPitch && i$1.touchPitch.enable(e$1.touchPitch);
					const u$1 = () => i$1.project(i$1.getCenter()), d$1 = function({ enable: e$2, clickTolerance: i$2, aroundCenter: o$2 = !0, minPixelCenterThreshold: r$2 = 100, rotateDegreesPerPixelMoved: a$2 = .8 }, s$2) {
						return new Kr$1({
							clickTolerance: i$2,
							move: (e$3, i$3) => {
								const n$1 = s$2();
								if (o$2 && Math.abs(n$1.y - e$3.y) > r$2) return { bearingDelta: t.cn(new t.P(e$3.x, i$3.y), i$3, n$1) };
								let l$2 = (i$3.x - e$3.x) * a$2;
								return o$2 && i$3.y < n$1.y && (l$2 = -l$2), { bearingDelta: l$2 };
							},
							moveStateManager: new ea$1({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && e$3.ctrlKey || 2 === n.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: oa$1
						});
					}(e$1, u$1), _$2 = function({ enable: e$2, clickTolerance: t$1, pitchDegreesPerPixelMoved: i$2 = -.5 }) {
						return new Kr$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({ pitchDelta: (t$2.y - e$3.y) * i$2 }),
							moveStateManager: new ea$1({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && e$3.ctrlKey || 2 === n.mouseButton(e$3) }),
							enable: e$2,
							assignEvents: oa$1
						});
					}(e$1), p$1 = function({ enable: e$2, clickTolerance: t$1, rollDegreesPerPixelMoved: i$2 = .3 }, o$2) {
						return new Kr$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => {
								const r$2 = o$2();
								let a$2 = (t$2.x - e$3.x) * i$2;
								return t$2.y < r$2.y && (a$2 = -a$2), { rollDelta: a$2 };
							},
							moveStateManager: new ea$1({ checkCorrectEvent: (e$3) => 2 === n.mouseButton(e$3) && e$3.ctrlKey }),
							enable: e$2,
							assignEvents: oa$1
						});
					}(e$1, u$1);
					i$1.dragRotate = new Ta$1(e$1, d$1, _$2, p$1), this._add("mouseRotate", d$1, ["mousePitch"]), this._add("mousePitch", _$2, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p$1, ["mousePitch"]), e$1.interactive && e$1.dragRotate && i$1.dragRotate.enable();
					const m$1 = function({ enable: e$2, clickTolerance: t$1 }) {
						return new Kr$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({
								around: t$2,
								panDelta: t$2.sub(e$3)
							}),
							activateOnStart: !0,
							moveStateManager: new ea$1({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: oa$1
						});
					}(e$1), f$1 = new ra$1(e$1, i$1);
					i$1.dragPan = new wa$1(o$1, m$1, f$1), this._add("mousePan", m$1), this._add("touchPan", f$1, ["touchZoom", "touchRotate"]), e$1.interactive && e$1.dragPan && i$1.dragPan.enable(e$1.dragPan);
					const g$2 = new ha$1(), v$1 = new la$1();
					i$1.touchZoomRotate = new Pa$1(o$1, v$1, g$2, c$1), this._add("touchRotate", g$2, ["touchPan", "touchZoom"]), this._add("touchZoom", v$1, ["touchPan", "touchRotate"]), e$1.interactive && e$1.touchZoomRotate && i$1.touchZoomRotate.enable(e$1.touchZoomRotate);
					const b$2 = i$1.scrollZoom = new va$1(i$1, (() => this._triggerRenderFrame()));
					this._add("scrollZoom", b$2, ["mousePan"]), e$1.interactive && e$1.scrollZoom && i$1.scrollZoom.enable(e$1.scrollZoom);
					const x$1 = i$1.keyboard = new pa$1(i$1);
					this._add("keyboard", x$1), e$1.interactive && e$1.keyboard && i$1.keyboard.enable(), this._add("blockableMapEvent", new Gr$1(i$1));
				}
				_add(e$1, t$1, i$1) {
					this._handlers.push({
						handlerName: e$1,
						handler: t$1,
						allowed: i$1
					}), this._handlersById[e$1] = t$1;
				}
				stop(e$1) {
					if (!this._updatingCamera) {
						for (const { handler: e$2 } of this._handlers) e$2.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e$1), this._changes = [];
					}
				}
				isActive() {
					for (const { handler: e$1 } of this._handlers) if (e$1.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return Boolean(Ia$1(this._eventsInProgress)) || this.isZooming();
				}
				_blockedByActive(e$1, t$1, i$1) {
					for (const o$1 in e$1) if (o$1 !== i$1 && (!t$1 || t$1.indexOf(o$1) < 0)) return !0;
					return !1;
				}
				_getMapTouches(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) this._el.contains(i$1.target) && t$1.push(i$1);
					return t$1;
				}
				mergeHandlerResult(e$1, i$1, o$1, r$1, a$1) {
					if (!o$1) return;
					t.e(e$1, o$1);
					const s$1 = {
						handlerName: r$1,
						originalEvent: o$1.originalEvent || a$1
					};
					void 0 !== o$1.zoomDelta && (i$1.zoom = s$1), void 0 !== o$1.panDelta && (i$1.drag = s$1), void 0 !== o$1.rollDelta && (i$1.roll = s$1), void 0 !== o$1.pitchDelta && (i$1.pitch = s$1), void 0 !== o$1.bearingDelta && (i$1.rotate = s$1);
				}
				_applyChanges() {
					const e$1 = {}, i$1 = {}, o$1 = {};
					for (const [r$1, a$1, s$1] of this._changes) r$1.panDelta && (e$1.panDelta = (e$1.panDelta || new t.P(0, 0))._add(r$1.panDelta)), r$1.zoomDelta && (e$1.zoomDelta = (e$1.zoomDelta || 0) + r$1.zoomDelta), r$1.bearingDelta && (e$1.bearingDelta = (e$1.bearingDelta || 0) + r$1.bearingDelta), r$1.pitchDelta && (e$1.pitchDelta = (e$1.pitchDelta || 0) + r$1.pitchDelta), r$1.rollDelta && (e$1.rollDelta = (e$1.rollDelta || 0) + r$1.rollDelta), void 0 !== r$1.around && (e$1.around = r$1.around), void 0 !== r$1.pinchAround && (e$1.pinchAround = r$1.pinchAround), r$1.noInertia && (e$1.noInertia = r$1.noInertia), t.e(i$1, a$1), t.e(o$1, s$1);
					this._updateMapTransform(e$1, i$1, o$1), this._changes = [];
				}
				_updateMapTransform(e$1, t$1, i$1) {
					const o$1 = this._map, r$1 = o$1._getTransformForUpdate(), a$1 = o$1.terrain;
					if (!(Sa$1(e$1) || a$1 && this._terrainMovement)) return this._fireEvents(t$1, i$1, !0);
					o$1._stop(!0);
					let { panDelta: s$1, zoomDelta: n$1, bearingDelta: l$1, pitchDelta: c$1, rollDelta: h$1, around: u$1, pinchAround: d$1 } = e$1;
					void 0 !== d$1 && (u$1 = d$1), u$1 = u$1 || o$1.transform.centerPoint, a$1 && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const _$2 = {
						panDelta: s$1,
						zoomDelta: n$1,
						rollDelta: h$1,
						pitchDelta: c$1,
						bearingDelta: l$1,
						around: u$1
					};
					this._map.cameraHelper.useGlobeControls && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const p$1 = u$1.distSqr(r$1.centerPoint) < .01 ? r$1.center : r$1.screenPointToLocation(s$1 ? u$1.sub(s$1) : u$1);
					a$1 ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_$2, r$1), this._terrainMovement || !t$1.drag && !t$1.zoom ? t$1.drag && this._terrainMovement ? r$1.setCenter(r$1.screenPointToLocation(r$1.centerPoint.sub(s$1))) : this._map.cameraHelper.handleMapControlsPan(_$2, r$1, p$1) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(_$2, r$1, p$1))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_$2, r$1), this._map.cameraHelper.handleMapControlsPan(_$2, r$1, p$1)), o$1._applyUpdatedTransform(r$1), this._map._update(), e$1.noInertia || this._inertia.record(e$1), this._fireEvents(t$1, i$1, !0);
				}
				_fireEvents(e$1, i$1, o$1) {
					const r$1 = Ia$1(this._eventsInProgress), a$1 = Ia$1(e$1), n$1 = {};
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._eventsInProgress[t$1] || (n$1[`${t$1}start`] = i$2), this._eventsInProgress[t$1] = e$1[t$1];
					}
					!r$1 && a$1 && this._fireEvent("movestart", a$1.originalEvent);
					for (const e$2 in n$1) this._fireEvent(e$2, n$1[e$2]);
					a$1 && this._fireEvent("move", a$1.originalEvent);
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._fireEvent(t$1, i$2);
					}
					const l$1 = {};
					let c$1;
					for (const e$2 in this._eventsInProgress) {
						const { handlerName: t$1, originalEvent: o$2 } = this._eventsInProgress[e$2];
						this._handlersById[t$1].isActive() || (delete this._eventsInProgress[e$2], c$1 = i$1[t$1] || o$2, l$1[`${e$2}end`] = c$1);
					}
					for (const e$2 in l$1) this._fireEvent(e$2, l$1[e$2]);
					const h$1 = Ia$1(this._eventsInProgress), u$1 = (r$1 || a$1) && !h$1;
					if (u$1 && this._terrainMovement) {
						this._map._elevationFreeze = !1, this._terrainMovement = !1;
						const e$2 = this._map._getTransformForUpdate();
						this._map.getCenterClampedToGround() && e$2.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e$2);
					}
					if (o$1 && u$1) {
						this._updatingCamera = !0;
						const e$2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i$2 = (e$3) => 0 !== e$3 && -this._bearingSnap < e$3 && e$3 < this._bearingSnap;
						!e$2 || !e$2.essential && s.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c$1 })), i$2(this._map.getBearing()) && this._map.resetNorth()) : (i$2(e$2.bearing || this._map.getBearing()) && (e$2.bearing = 0), e$2.freezeElevation = !0, this._map.easeTo(e$2, { originalEvent: c$1 })), this._updatingCamera = !1;
					}
				}
				_fireEvent(e$1, i$1) {
					this._map.fire(new t.l(e$1, i$1 ? { originalEvent: i$1 } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e$1) => {
						delete this._frameId, this.handleEvent(new Ma$1("renderFrame", { timeStamp: e$1 })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					void 0 === this._frameId && (this._frameId = this._requestFrame());
				}
			}
			class Ra$1 extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this._renderFrameCallback = () => {
						const e$2 = Math.min((s.now() - this._easeStart) / this._easeOptions.duration, 1);
						this._onEaseFrame(this._easeOptions.easing(e$2)), e$2 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
					}, this._moving = !1, this._zooming = !1, this.transform = e$1, this._bearingSnap = i$1.bearingSnap, this.cameraHelper = t$1, this.on("moveend", (() => {
						delete this._requestedCameraState;
					}));
				}
				migrateProjection(e$1, t$1) {
					e$1.apply(this.transform), this.transform = e$1, this.cameraHelper = t$1;
				}
				getCenter() {
					return new t.S(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e$1, t$1) {
					return this.jumpTo({ center: e$1 }, t$1);
				}
				getCenterElevation() {
					return this.transform.elevation;
				}
				setCenterElevation(e$1, t$1) {
					return this.jumpTo({ elevation: e$1 }, t$1), this;
				}
				getCenterClampedToGround() {
					return this._centerClampedToGround;
				}
				setCenterClampedToGround(e$1) {
					this._centerClampedToGround = e$1;
				}
				panBy(e$1, i$1, o$1) {
					return e$1 = t.P.convert(e$1).mult(-1), this.panTo(this.transform.center, t.e({ offset: e$1 }, i$1), o$1);
				}
				panTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ center: e$1 }, i$1), o$1);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e$1, t$1) {
					return this.jumpTo({ zoom: e$1 }, t$1), this;
				}
				zoomTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ zoom: e$1 }, i$1), o$1);
				}
				zoomIn(e$1, t$1) {
					return this.zoomTo(this.getZoom() + 1, e$1, t$1), this;
				}
				zoomOut(e$1, t$1) {
					return this.zoomTo(this.getZoom() - 1, e$1, t$1), this;
				}
				getVerticalFieldOfView() {
					return this.transform.fov;
				}
				setVerticalFieldOfView(e$1, i$1) {
					return e$1 != this.transform.fov && (this.transform.setFov(e$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)).fire(new t.l("moveend", i$1))), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setBearing(e$1, t$1) {
					return this.jumpTo({ bearing: e$1 }, t$1), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e$1, t$1) {
					return this.jumpTo({ padding: e$1 }, t$1), this;
				}
				rotateTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ bearing: e$1 }, i$1), o$1);
				}
				resetNorth(e$1, i$1) {
					return this.rotateTo(0, t.e({ duration: 1e3 }, e$1), i$1), this;
				}
				resetNorthPitch(e$1, i$1) {
					return this.easeTo(t.e({
						bearing: 0,
						pitch: 0,
						roll: 0,
						duration: 1e3
					}, e$1), i$1), this;
				}
				snapToNorth(e$1, t$1) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e$1, t$1) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e$1, t$1) {
					return this.jumpTo({ pitch: e$1 }, t$1), this;
				}
				getRoll() {
					return this.transform.roll;
				}
				setRoll(e$1, t$1) {
					return this.jumpTo({ roll: e$1 }, t$1), this;
				}
				cameraForBounds(e$1, t$1) {
					e$1 = G$1.convert(e$1).adjustAntiMeridian();
					const i$1 = t$1 && t$1.bearing || 0;
					return this._cameraForBoxAndBearing(e$1.getNorthWest(), e$1.getSouthEast(), i$1, t$1);
				}
				_cameraForBoxAndBearing(e$1, i$1, o$1, r$1) {
					const a$1 = {
						top: 0,
						bottom: 0,
						right: 0,
						left: 0
					};
					if ("number" == typeof (r$1 = t.e({
						padding: a$1,
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, r$1)).padding) {
						const e$2 = r$1.padding;
						r$1.padding = {
							top: e$2,
							bottom: e$2,
							right: e$2,
							left: e$2
						};
					}
					const s$1 = t.e(a$1, r$1.padding);
					r$1.padding = s$1;
					const n$1 = this.transform, l$1 = new G$1(e$1, i$1);
					return this.cameraHelper.cameraForBoxAndBearing(r$1, s$1, l$1, o$1, n$1);
				}
				fitBounds(e$1, t$1, i$1) {
					return this._fitInternal(this.cameraForBounds(e$1, t$1), t$1, i$1);
				}
				fitScreenCoordinates(e$1, i$1, o$1, r$1, a$1) {
					return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e$1)), this.transform.screenPointToLocation(t.P.convert(i$1)), o$1, r$1), r$1, a$1);
				}
				_fitInternal(e$1, i$1, o$1) {
					return e$1 ? (delete (i$1 = t.e(e$1, i$1)).padding, i$1.linear ? this.easeTo(i$1, o$1) : this.flyTo(i$1, o$1)) : this;
				}
				jumpTo(e$1, i$1) {
					this.stop();
					const o$1 = this._getTransformForUpdate();
					let r$1 = !1, a$1 = !1, s$1 = !1;
					const n$1 = o$1.zoom;
					this.cameraHelper.handleJumpToCenterZoom(o$1, e$1);
					const l$1 = o$1.zoom !== n$1;
					return "elevation" in e$1 && o$1.elevation !== +e$1.elevation && o$1.setElevation(+e$1.elevation), "bearing" in e$1 && o$1.bearing !== +e$1.bearing && (r$1 = !0, o$1.setBearing(+e$1.bearing)), "pitch" in e$1 && o$1.pitch !== +e$1.pitch && (a$1 = !0, o$1.setPitch(+e$1.pitch)), "roll" in e$1 && o$1.roll !== +e$1.roll && (s$1 = !0, o$1.setRoll(+e$1.roll)), null == e$1.padding || o$1.isPaddingEqual(e$1.padding) || o$1.setPadding(e$1.padding), this._applyUpdatedTransform(o$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)), l$1 && this.fire(new t.l("zoomstart", i$1)).fire(new t.l("zoom", i$1)).fire(new t.l("zoomend", i$1)), r$1 && this.fire(new t.l("rotatestart", i$1)).fire(new t.l("rotate", i$1)).fire(new t.l("rotateend", i$1)), a$1 && this.fire(new t.l("pitchstart", i$1)).fire(new t.l("pitch", i$1)).fire(new t.l("pitchend", i$1)), s$1 && this.fire(new t.l("rollstart", i$1)).fire(new t.l("roll", i$1)).fire(new t.l("rollend", i$1)), this.fire(new t.l("moveend", i$1));
				}
				calculateCameraOptionsFromTo(e$1, i$1, o$1, r$1 = 0) {
					const a$1 = t.a1.fromLngLat(e$1, i$1), s$1 = t.a1.fromLngLat(o$1, r$1), n$1 = s$1.x - a$1.x, l$1 = s$1.y - a$1.y, c$1 = s$1.z - a$1.z, h$1 = Math.hypot(n$1, l$1, c$1);
					if (0 === h$1) throw new Error("Can't calculate camera options with same From and To");
					const u$1 = Math.hypot(n$1, l$1), d$1 = t.ak(this.transform.cameraToCenterDistance / h$1 / this.transform.tileSize), _$2 = 180 * Math.atan2(n$1, -l$1) / Math.PI;
					let p$1 = 180 * Math.acos(u$1 / h$1) / Math.PI;
					return p$1 = c$1 < 0 ? 90 - p$1 : 90 + p$1, {
						center: s$1.toLngLat(),
						elevation: r$1,
						zoom: d$1,
						pitch: p$1,
						bearing: _$2
					};
				}
				calculateCameraOptionsFromCameraLngLatAltRotation(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = this.transform.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
					return {
						center: a$1.center,
						elevation: a$1.elevation,
						zoom: a$1.zoom,
						bearing: i$1,
						pitch: o$1,
						roll: r$1
					};
				}
				easeTo(e$1, i$1) {
					this._stop(!1, e$1.easeId), (!1 === (e$1 = t.e({
						offset: [0, 0],
						duration: 500,
						easing: t.co
					}, e$1)).animate || !e$1.essential && s.prefersReducedMotion) && (e$1.duration = 0);
					const o$1 = this._getTransformForUpdate(), r$1 = this.getBearing(), a$1 = o$1.pitch, n$1 = o$1.roll, l$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, c$1 = "pitch" in e$1 ? +e$1.pitch : a$1, h$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, n$1) : n$1, u$1 = "padding" in e$1 ? e$1.padding : o$1.padding, d$1 = t.P.convert(e$1.offset);
					let _$2, p$1;
					e$1.around && (_$2 = t.S.convert(e$1.around), p$1 = o$1.locationToScreenPoint(_$2));
					const m$1 = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching,
						rolling: this._rolling
					}, f$1 = this.cameraHelper.handleEaseTo(o$1, {
						bearing: l$1,
						pitch: c$1,
						roll: h$1,
						padding: u$1,
						around: _$2,
						aroundPoint: p$1,
						offsetAsPoint: d$1,
						offset: e$1.offset,
						zoom: e$1.zoom,
						center: e$1.center
					});
					return this._rotating = this._rotating || r$1 !== l$1, this._pitching = this._pitching || c$1 !== a$1, this._rolling = this._rolling || h$1 !== n$1, this._padding = !o$1.isPaddingEqual(u$1), this._zooming = this._zooming || f$1.isZooming, this._easeId = e$1.easeId, this._prepareEase(i$1, e$1.noMoveStart, m$1), this.terrain && this._prepareElevation(f$1.elevationCenter), this._ease(((t$1) => {
						f$1.easeFunc(t$1), this.terrain && !e$1.freezeElevation && this._updateElevation(t$1), this._applyUpdatedTransform(o$1), this._fireMoveEvents(i$1);
					}), ((t$1) => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1, t$1);
					}), e$1), this;
				}
				_prepareEase(e$1, i$1, o$1 = {}) {
					this._moving = !0, i$1 || o$1.moving || this.fire(new t.l("movestart", e$1)), this._zooming && !o$1.zooming && this.fire(new t.l("zoomstart", e$1)), this._rotating && !o$1.rotating && this.fire(new t.l("rotatestart", e$1)), this._pitching && !o$1.pitching && this.fire(new t.l("pitchstart", e$1)), this._rolling && !o$1.rolling && this.fire(new t.l("rollstart", e$1));
				}
				_prepareElevation(e$1) {
					this._elevationCenter = e$1, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e$1, this.transform.tileZoom), this._elevationFreeze = !0;
				}
				_updateElevation(e$1) {
					this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
					const i$1 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
					if (e$1 < 1 && i$1 !== this._elevationTarget) {
						const t$1 = this._elevationTarget - this._elevationStart;
						this._elevationStart += e$1 * (t$1 - (i$1 - (t$1 * e$1 + this._elevationStart)) / (1 - e$1)), this._elevationTarget = i$1;
					}
					this.transform.setElevation(t.C.number(this._elevationStart, this._elevationTarget, e$1));
				}
				_finalizeElevation() {
					this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
				}
				_getTransformForUpdate() {
					return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
				}
				_elevateCameraIfInsideTerrain(e$1) {
					if (!this.terrain && e$1.elevation >= 0 && e$1.pitch <= 90) return {};
					const t$1 = e$1.getCameraLngLat(), i$1 = e$1.getCameraAltitude(), o$1 = this.terrain ? this.terrain.getElevationForLngLatZoom(t$1, e$1.zoom) : 0;
					if (i$1 < o$1) {
						const i$2 = this.calculateCameraOptionsFromTo(t$1, o$1, e$1.center, e$1.elevation);
						return {
							pitch: i$2.pitch,
							zoom: i$2.zoom
						};
					}
					return {};
				}
				_applyUpdatedTransform(e$1) {
					const t$1 = [];
					if (t$1.push(((e$2) => this._elevateCameraIfInsideTerrain(e$2))), this.transformCameraUpdate && t$1.push(((e$2) => this.transformCameraUpdate(e$2))), !t$1.length) return;
					const i$1 = e$1.clone();
					for (const e$2 of t$1) {
						const t$2 = i$1.clone(), { center: o$1, zoom: r$1, roll: a$1, pitch: s$1, bearing: n$1, elevation: l$1 } = e$2(t$2);
						o$1 && t$2.setCenter(o$1), void 0 !== l$1 && t$2.setElevation(l$1), void 0 !== r$1 && t$2.setZoom(r$1), void 0 !== a$1 && t$2.setRoll(a$1), void 0 !== s$1 && t$2.setPitch(s$1), void 0 !== n$1 && t$2.setBearing(n$1), i$1.apply(t$2);
					}
					this.transform.apply(i$1);
				}
				_fireMoveEvents(e$1) {
					this.fire(new t.l("move", e$1)), this._zooming && this.fire(new t.l("zoom", e$1)), this._rotating && this.fire(new t.l("rotate", e$1)), this._pitching && this.fire(new t.l("pitch", e$1)), this._rolling && this.fire(new t.l("roll", e$1));
				}
				_afterEase(e$1, i$1) {
					if (this._easeId && i$1 && this._easeId === i$1) return;
					delete this._easeId;
					const o$1 = this._zooming, r$1 = this._rotating, a$1 = this._pitching, s$1 = this._rolling;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o$1 && this.fire(new t.l("zoomend", e$1)), r$1 && this.fire(new t.l("rotateend", e$1)), a$1 && this.fire(new t.l("pitchend", e$1)), s$1 && this.fire(new t.l("rollend", e$1)), this.fire(new t.l("moveend", e$1));
				}
				flyTo(e$1, i$1) {
					if (!e$1.essential && s.prefersReducedMotion) {
						const o$2 = t.Q(e$1, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"roll",
							"elevation"
						]);
						return this.jumpTo(o$2, i$1);
					}
					this.stop(), e$1 = t.e({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: t.co
					}, e$1);
					const o$1 = this._getTransformForUpdate(), r$1 = o$1.bearing, a$1 = o$1.pitch, n$1 = o$1.roll, l$1 = o$1.padding, c$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, h$1 = "pitch" in e$1 ? +e$1.pitch : a$1, u$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, n$1) : n$1, d$1 = "padding" in e$1 ? e$1.padding : o$1.padding, _$2 = t.P.convert(e$1.offset);
					let p$1 = o$1.centerPoint.add(_$2);
					const m$1 = o$1.screenPointToLocation(p$1), f$1 = this.cameraHelper.handleFlyTo(o$1, {
						bearing: c$1,
						pitch: h$1,
						roll: u$1,
						padding: d$1,
						locationAtOffset: m$1,
						offsetAsPoint: _$2,
						center: e$1.center,
						minZoom: e$1.minZoom,
						zoom: e$1.zoom
					});
					let g$2 = e$1.curve;
					const v$1 = Math.max(o$1.width, o$1.height), b$2 = v$1 / f$1.scaleOfZoom, x$1 = f$1.pixelPathLength;
					"number" == typeof f$1.scaleOfMinZoom && (g$2 = Math.sqrt(v$1 / f$1.scaleOfMinZoom / x$1 * 2));
					const y$1 = g$2 * g$2;
					function w$1(e$2) {
						const t$1 = (b$2 * b$2 - v$1 * v$1 + (e$2 ? -1 : 1) * y$1 * y$1 * x$1 * x$1) / (2 * (e$2 ? b$2 : v$1) * y$1 * x$1);
						return Math.log(Math.sqrt(t$1 * t$1 + 1) - t$1);
					}
					function T$2(e$2) {
						return (Math.exp(e$2) - Math.exp(-e$2)) / 2;
					}
					function P$2(e$2) {
						return (Math.exp(e$2) + Math.exp(-e$2)) / 2;
					}
					const C$1 = w$1(!1);
					let I$2 = function(e$2) {
						return P$2(C$1) / P$2(C$1 + g$2 * e$2);
					}, M$2 = function(e$2) {
						return v$1 * ((P$2(C$1) * (T$2(t$1 = C$1 + g$2 * e$2) / P$2(t$1)) - T$2(C$1)) / y$1) / x$1;
						var t$1;
					}, S$2 = (w$1(!0) - C$1) / g$2;
					if (Math.abs(x$1) < 2e-6 || !isFinite(S$2)) {
						if (Math.abs(v$1 - b$2) < 1e-6) return this.easeTo(e$1, i$1);
						const t$1 = b$2 < v$1 ? -1 : 1;
						S$2 = Math.abs(Math.log(b$2 / v$1)) / g$2, M$2 = () => 0, I$2 = (e$2) => Math.exp(t$1 * g$2 * e$2);
					}
					return e$1.duration = "duration" in e$1 ? +e$1.duration : 1e3 * S$2 / ("screenSpeed" in e$1 ? +e$1.screenSpeed / g$2 : +e$1.speed), e$1.maxDuration && e$1.duration > e$1.maxDuration && (e$1.duration = 0), this._zooming = !0, this._rotating = r$1 !== c$1, this._pitching = h$1 !== a$1, this._rolling = u$1 !== n$1, this._padding = !o$1.isPaddingEqual(d$1), this._prepareEase(i$1, !1), this.terrain && this._prepareElevation(f$1.targetCenter), this._ease(((s$1) => {
						const m$2 = s$1 * S$2, g$3 = 1 / I$2(m$2), v$2 = M$2(m$2);
						this._rotating && o$1.setBearing(t.C.number(r$1, c$1, s$1)), this._pitching && o$1.setPitch(t.C.number(a$1, h$1, s$1)), this._rolling && o$1.setRoll(t.C.number(n$1, u$1, s$1)), this._padding && (o$1.interpolatePadding(l$1, d$1, s$1), p$1 = o$1.centerPoint.add(_$2)), f$1.easeFunc(s$1, g$3, v$2, p$1), this.terrain && !e$1.freezeElevation && this._updateElevation(s$1), this._applyUpdatedTransform(o$1), this._fireMoveEvents(i$1);
					}), (() => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1);
					}), e$1), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_stop(e$1, t$1) {
					var i$1;
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
						const e$2 = this._onEaseEnd;
						delete this._onEaseEnd, e$2.call(this, t$1);
					}
					return e$1 || null === (i$1 = this.handlers) || void 0 === i$1 || i$1.stop(!1), this;
				}
				_ease(e$1, t$1, i$1) {
					!1 === i$1.animate || 0 === i$1.duration ? (e$1(1), t$1()) : (this._easeStart = s.now(), this._easeOptions = i$1, this._onEaseFrame = e$1, this._onEaseEnd = t$1, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_normalizeBearing(e$1, i$1) {
					e$1 = t.aO(e$1, -180, 180);
					const o$1 = Math.abs(e$1 - i$1);
					return Math.abs(e$1 - 360 - i$1) < o$1 && (e$1 -= 360), Math.abs(e$1 + 360 - i$1) < o$1 && (e$1 += 360), e$1;
				}
				queryTerrainElevation(e$1) {
					return this.terrain ? this.terrain.getElevationForLngLatZoom(t.S.convert(e$1), this.transform.tileZoom) : null;
				}
			}
			const za$1 = {
				compact: !0,
				customAttribution: "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>"
			};
			class Da$1 {
				constructor(e$1 = za$1) {
					this._toggleAttribution = () => {
						this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
					}, this._updateData = (e$2) => {
						!e$2 || "metadata" !== e$2.sourceDataType && "visibility" !== e$2.sourceDataType && "style" !== e$2.dataType && "terrain" !== e$2.type || this._updateAttributions();
					}, this._updateCompact = () => {
						this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
					}, this._updateCompactMinimize = () => {
						this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e$1) {
					return this._map = e$1, this._compact = this.options.compact, this._container = n.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
				}
				_setElementTitle(e$1, t$1) {
					const i$1 = this._map._getUIString(`AttributionControl.${t$1}`);
					e$1.title = i$1, e$1.setAttribute("aria-label", i$1);
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e$1 = [];
					if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e$1 = e$1.concat(this.options.customAttribution.map(((e$2) => "string" != typeof e$2 ? "" : e$2))) : "string" == typeof this.options.customAttribution && e$1.push(this.options.customAttribution)), this._map.style.stylesheet) {
						const e$2 = this._map.style.stylesheet;
						this.styleOwner = e$2.owner, this.styleId = e$2.id;
					}
					const t$1 = this._map.style.sourceCaches;
					for (const i$2 in t$1) {
						const o$1 = t$1[i$2];
						if (o$1.used || o$1.usedForTerrain) {
							const t$2 = o$1.getSource();
							t$2.attribution && e$1.indexOf(t$2.attribution) < 0 && e$1.push(t$2.attribution);
						}
					}
					e$1 = e$1.filter(((e$2) => String(e$2).trim())), e$1.sort(((e$2, t$2) => e$2.length - t$2.length)), e$1 = e$1.filter(((t$2, i$2) => {
						for (let o$1 = i$2 + 1; o$1 < e$1.length; o$1++) if (e$1[o$1].indexOf(t$2) >= 0) return !1;
						return !0;
					}));
					const i$1 = e$1.join(" | ");
					i$1 !== this._attribHTML && (this._attribHTML = i$1, e$1.length ? (this._innerContainer.innerHTML = n.sanitize(i$1), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
				}
			}
			class Aa$1 {
				constructor(e$1 = {}) {
					this._updateCompact = () => {
						const e$2 = this._container.children;
						if (e$2.length) {
							const t$1 = e$2[0];
							this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t$1.classList.add("maplibregl-compact") : t$1.classList.remove("maplibregl-compact");
						}
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					this._map = e$1, this._compact = this.options && this.options.compact, this._container = n.create("div", "maplibregl-ctrl");
					const t$1 = n.create("a", "maplibregl-ctrl-logo");
					return t$1.target = "_blank", t$1.rel = "noopener nofollow", t$1.href = "https://maplibre.org/", t$1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t$1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t$1), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
				}
			}
			class La$1 {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e$1) {
					const t$1 = ++this._id;
					return this._queue.push({
						callback: e$1,
						id: t$1,
						cancelled: !1
					}), t$1;
				}
				remove(e$1) {
					const t$1 = this._currentlyRunning, i$1 = t$1 ? this._queue.concat(t$1) : this._queue;
					for (const t$2 of i$1) if (t$2.id === e$1) return void (t$2.cancelled = !0);
				}
				run(e$1 = 0) {
					if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
					const t$1 = this._currentlyRunning = this._queue;
					this._queue = [];
					for (const i$1 of t$1) if (!i$1.cancelled && (i$1.callback(e$1), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			var ka$1 = t.aJ([{
				name: "a_pos3d",
				type: "Int16",
				components: 3
			}]);
			class Fa$1 extends t.E {
				constructor(e$1) {
					super(), this._lastTilesetChange = s.now(), this.sourceCache = e$1, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e$1._source.tileSize * 2 ** this.deltaZoom, e$1.usedForTerrain = !0, e$1.tileSize = this.tileSize;
				}
				destruct() {
					this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
				}
				update(e$1, i$1) {
					this.sourceCache.update(e$1, i$1), this._renderableTilesKeys = [];
					const o$1 = {};
					for (const r$1 of ve$1(e$1, {
						tileSize: this.tileSize,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						reparseOverscaled: !1,
						terrain: i$1,
						calculateTileZoom: this.sourceCache._source.calculateTileZoom
					})) o$1[r$1.key] = !0, this._renderableTilesKeys.push(r$1.key), this._tiles[r$1.key] || (r$1.terrainRttPosMatrix32f = new Float64Array(16), t.bY(r$1.terrainRttPosMatrix32f, 0, t.$, t.$, 0, 0, 1), this._tiles[r$1.key] = new re$1(r$1, this.tileSize), this._lastTilesetChange = s.now());
					for (const e$2 in this._tiles) o$1[e$2] || delete this._tiles[e$2];
				}
				freeRtt(e$1) {
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						(!e$1 || i$1.tileID.equals(e$1) || i$1.tileID.isChildOf(e$1) || e$1.isChildOf(i$1.tileID)) && (i$1.rtt = []);
					}
				}
				getRenderableTiles() {
					return this._renderableTilesKeys.map(((e$1) => this.getTileByID(e$1)));
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				getTerrainCoords(e$1, t$1) {
					return t$1 ? this._getTerrainCoordsForTileRanges(e$1, t$1) : this._getTerrainCoordsForRegularTile(e$1);
				}
				_getTerrainCoordsForRegularTile(e$1) {
					const i$1 = {};
					for (const o$1 of this._renderableTilesKeys) {
						const r$1 = this._tiles[o$1].tileID, a$1 = e$1.clone(), s$1 = t.ba();
						if (r$1.canonical.equals(e$1.canonical)) t.bY(s$1, 0, t.$, t.$, 0, 0, 1);
						else if (r$1.canonical.isChildOf(e$1.canonical)) {
							const i$2 = r$1.canonical.z - e$1.canonical.z, o$2 = r$1.canonical.x - (r$1.canonical.x >> i$2 << i$2), a$2 = r$1.canonical.y - (r$1.canonical.y >> i$2 << i$2), n$1 = t.$ >> i$2;
							t.bY(s$1, 0, n$1, n$1, 0, 0, 1), t.M(s$1, s$1, [
								-o$2 * n$1,
								-a$2 * n$1,
								0
							]);
						} else {
							if (!e$1.canonical.isChildOf(r$1.canonical)) continue;
							{
								const i$2 = e$1.canonical.z - r$1.canonical.z, o$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), a$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), n$1 = t.$ >> i$2;
								t.bY(s$1, 0, t.$, t.$, 0, 0, 1), t.M(s$1, s$1, [
									o$2 * n$1,
									a$2 * n$1,
									0
								]), t.N(s$1, s$1, [
									1 / 2 ** i$2,
									1 / 2 ** i$2,
									0
								]);
							}
						}
						a$1.terrainRttPosMatrix32f = new Float32Array(s$1), i$1[o$1] = a$1;
					}
					return i$1;
				}
				_getTerrainCoordsForTileRanges(e$1, i$1) {
					const o$1 = {};
					for (const r$1 of this._renderableTilesKeys) {
						const a$1 = this._tiles[r$1].tileID;
						if (!this._isWithinTileRanges(a$1, i$1)) continue;
						const s$1 = e$1.clone(), n$1 = t.ba();
						if (a$1.canonical.z === e$1.canonical.z) {
							const i$2 = e$1.canonical.x - a$1.canonical.x, o$2 = e$1.canonical.y - a$1.canonical.y;
							t.bY(n$1, 0, t.$, t.$, 0, 0, 1), t.M(n$1, n$1, [
								i$2 * t.$,
								o$2 * t.$,
								0
							]);
						} else if (a$1.canonical.z > e$1.canonical.z) {
							const i$2 = a$1.canonical.z - e$1.canonical.z, o$2 = a$1.canonical.x - (a$1.canonical.x >> i$2 << i$2), r$2 = a$1.canonical.y - (a$1.canonical.y >> i$2 << i$2), s$2 = e$1.canonical.x - (a$1.canonical.x >> i$2), l$1 = e$1.canonical.y - (a$1.canonical.y >> i$2), c$1 = t.$ >> i$2;
							t.bY(n$1, 0, c$1, c$1, 0, 0, 1), t.M(n$1, n$1, [
								-o$2 * c$1 + s$2 * t.$,
								-r$2 * c$1 + l$1 * t.$,
								0
							]);
						} else {
							const i$2 = e$1.canonical.z - a$1.canonical.z, o$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), r$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), s$2 = (e$1.canonical.x >> i$2) - a$1.canonical.x, l$1 = (e$1.canonical.y >> i$2) - a$1.canonical.y, c$1 = t.$ << i$2;
							t.bY(n$1, 0, c$1, c$1, 0, 0, 1), t.M(n$1, n$1, [
								o$2 * t.$ + s$2 * c$1,
								r$2 * t.$ + l$1 * c$1,
								0
							]);
						}
						s$1.terrainRttPosMatrix32f = new Float32Array(n$1), o$1[r$1] = s$1;
					}
					return o$1;
				}
				getSourceTile(e$1, t$1) {
					const i$1 = this.sourceCache._source;
					let o$1 = e$1.overscaledZ - this.deltaZoom;
					if (o$1 > i$1.maxzoom && (o$1 = i$1.maxzoom), o$1 < i$1.minzoom) return null;
					this._sourceTileCache[e$1.key] || (this._sourceTileCache[e$1.key] = e$1.scaledTo(o$1).key);
					let r$1 = this.sourceCache.getTileByID(this._sourceTileCache[e$1.key]);
					if ((!r$1 || !r$1.dem) && t$1) for (; o$1 >= i$1.minzoom && (!r$1 || !r$1.dem);) r$1 = this.sourceCache.getTileByID(e$1.scaledTo(o$1--).key);
					return r$1;
				}
				anyTilesAfterTime(e$1 = Date.now()) {
					return this._lastTilesetChange >= e$1;
				}
				_isWithinTileRanges(e$1, t$1) {
					return t$1[e$1.canonical.z] && e$1.canonical.x >= t$1[e$1.canonical.z].minTileX && e$1.canonical.x <= t$1[e$1.canonical.z].maxTileX && e$1.canonical.y >= t$1[e$1.canonical.z].minTileY && e$1.canonical.y <= t$1[e$1.canonical.z].maxTileY;
				}
			}
			class Ba$1 {
				constructor(e$1, t$1, i$1) {
					this._meshCache = {}, this.painter = e$1, this.sourceCache = new Fa$1(t$1), this.options = i$1, this.exaggeration = "number" == typeof i$1.exaggeration ? i$1.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
				}
				getDEMElevation(e$1, i$1, o$1, r$1 = t.$) {
					var a$1;
					if (!(i$1 >= 0 && i$1 < r$1 && o$1 >= 0 && o$1 < r$1)) return 0;
					const s$1 = this.getTerrainData(e$1), n$1 = null === (a$1 = s$1.tile) || void 0 === a$1 ? void 0 : a$1.dem;
					if (!n$1) return 0;
					const l$1 = t.cs([], [i$1 / r$1 * t.$, o$1 / r$1 * t.$], s$1.u_terrain_matrix), c$1 = [l$1[0] * n$1.dim, l$1[1] * n$1.dim], h$1 = Math.floor(c$1[0]), u$1 = Math.floor(c$1[1]), d$1 = c$1[0] - h$1, _$2 = c$1[1] - u$1;
					return n$1.get(h$1, u$1) * (1 - d$1) * (1 - _$2) + n$1.get(h$1 + 1, u$1) * d$1 * (1 - _$2) + n$1.get(h$1, u$1 + 1) * (1 - d$1) * _$2 + n$1.get(h$1 + 1, u$1 + 1) * d$1 * _$2;
				}
				getElevationForLngLatZoom(e$1, i$1) {
					if (!t.ct(i$1, e$1.wrap())) return 0;
					const { tileID: o$1, mercatorX: r$1, mercatorY: a$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return this.getElevation(o$1, r$1 % t.$, a$1 % t.$, t.$);
				}
				getElevation(e$1, i$1, o$1, r$1 = t.$) {
					return this.getDEMElevation(e$1, i$1, o$1, r$1) * this.exaggeration;
				}
				getTerrainData(e$1) {
					if (!this._emptyDemTexture) {
						const e$2 = this.painter.context, i$2 = new t.R({
							width: 1,
							height: 1
						}, new Uint8Array(4));
						this._emptyDepthTexture = new t.T(e$2, i$2, e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [
							0,
							0,
							0,
							0
						], this._emptyDemTexture = new t.T(e$2, new t.R({
							width: 1,
							height: 1
						}), e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ag([]);
					}
					const i$1 = this.sourceCache.getSourceTile(e$1, !0);
					if (i$1 && i$1.dem && (!i$1.demTexture || i$1.needsTerrainPrepare)) {
						const e$2 = this.painter.context;
						i$1.demTexture = this.painter.getTileTexture(i$1.dem.stride), i$1.demTexture ? i$1.demTexture.update(i$1.dem.getPixels(), { premultiply: !1 }) : i$1.demTexture = new t.T(e$2, i$1.dem.getPixels(), e$2.gl.RGBA, { premultiply: !1 }), i$1.demTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), i$1.needsTerrainPrepare = !1;
					}
					const o$1 = i$1 && i$1 + i$1.tileID.key + e$1.key;
					if (o$1 && !this._demMatrixCache[o$1]) {
						const o$2 = this.sourceCache.sourceCache._source.maxzoom;
						let r$1 = e$1.canonical.z - i$1.tileID.canonical.z;
						e$1.overscaledZ > e$1.canonical.z && (e$1.canonical.z >= o$2 ? r$1 = e$1.canonical.z - o$2 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
						const a$1 = e$1.canonical.x - (e$1.canonical.x >> r$1 << r$1), s$1 = e$1.canonical.y - (e$1.canonical.y >> r$1 << r$1), n$1 = t.cu(new Float64Array(16), [
							1 / (t.$ << r$1),
							1 / (t.$ << r$1),
							0
						]);
						t.M(n$1, n$1, [
							a$1 * t.$,
							s$1 * t.$,
							0
						]), this._demMatrixCache[e$1.key] = {
							matrix: n$1,
							coord: e$1
						};
					}
					return {
						u_depth: 2,
						u_terrain: 3,
						u_terrain_dim: i$1 && i$1.dem && i$1.dem.dim || 1,
						u_terrain_matrix: o$1 ? this._demMatrixCache[e$1.key].matrix : this._emptyDemMatrix,
						u_terrain_unpack: i$1 && i$1.dem && i$1.dem.getUnpackVector() || this._emptyDemUnpack,
						u_terrain_exaggeration: this.exaggeration,
						texture: (i$1 && i$1.demTexture || this._emptyDemTexture).texture,
						depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
						tile: i$1
					};
				}
				getFramebuffer(e$1) {
					const i$1 = this.painter, o$1 = i$1.width / devicePixelRatio, r$1 = i$1.height / devicePixelRatio;
					return !this._fbo || this._fbo.width === o$1 && this._fbo.height === r$1 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i$1.context, {
						width: o$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i$1.context, {
						width: o$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i$1.context.createFramebuffer(o$1, r$1, !0, !1), this._fbo.depthAttachment.set(i$1.context.createRenderbuffer(i$1.context.gl.DEPTH_COMPONENT16, o$1, r$1))), this._fbo.colorAttachment.set("coords" === e$1 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
				}
				getCoordsTexture() {
					const e$1 = this.painter.context;
					if (this._coordsTexture) return this._coordsTexture;
					const i$1 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
					for (let e$2 = 0, t$1 = 0; e$2 < this._coordsTextureSize; e$2++) for (let o$2 = 0; o$2 < this._coordsTextureSize; o$2++, t$1 += 4) i$1[t$1 + 0] = 255 & o$2, i$1[t$1 + 1] = 255 & e$2, i$1[t$1 + 2] = o$2 >> 8 << 4 | e$2 >> 8, i$1[t$1 + 3] = 0;
					const o$1 = new t.R({
						width: this._coordsTextureSize,
						height: this._coordsTextureSize
					}, new Uint8Array(i$1.buffer)), r$1 = new t.T(e$1, o$1, e$1.gl.RGBA, { premultiply: !1 });
					return r$1.bind(e$1.gl.NEAREST, e$1.gl.CLAMP_TO_EDGE), this._coordsTexture = r$1, r$1;
				}
				pointCoordinate(e$1) {
					this.painter.maybeDrawDepthAndCoords(!0);
					const i$1 = new Uint8Array(4), o$1 = this.painter.context, r$1 = o$1.gl, a$1 = Math.round(e$1.x * this.painter.pixelRatio / devicePixelRatio), s$1 = Math.round(e$1.y * this.painter.pixelRatio / devicePixelRatio), n$1 = Math.round(this.painter.height / devicePixelRatio);
					o$1.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r$1.readPixels(a$1, n$1 - s$1 - 1, 1, 1, r$1.RGBA, r$1.UNSIGNED_BYTE, i$1), o$1.bindFramebuffer.set(null);
					const l$1 = i$1[0] + (i$1[2] >> 4 << 8), c$1 = i$1[1] + ((15 & i$1[2]) << 8), h$1 = this.coordsIndex[255 - i$1[3]], u$1 = h$1 && this.sourceCache.getTileByID(h$1);
					if (!u$1) return null;
					const d$1 = this._coordsTextureSize, _$2 = (1 << u$1.tileID.canonical.z) * d$1;
					return new t.a1((u$1.tileID.canonical.x * d$1 + l$1) / _$2 + u$1.tileID.wrap, (u$1.tileID.canonical.y * d$1 + c$1) / _$2, this.getElevation(u$1.tileID, l$1, c$1, d$1));
				}
				depthAtPoint(e$1) {
					const t$1 = new Uint8Array(4), i$1 = this.painter.context, o$1 = i$1.gl;
					return i$1.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), o$1.readPixels(e$1.x, this.painter.height / devicePixelRatio - e$1.y - 1, 1, 1, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1), i$1.bindFramebuffer.set(null), (t$1[0] / 16777216 + t$1[1] / 65536 + t$1[2] / 256 + t$1[3]) / 256;
				}
				getTerrainMesh(e$1) {
					var i$1;
					const o$1 = (null === (i$1 = this.painter.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0, r$1 = o$1 && 0 === e$1.canonical.y, a$1 = o$1 && e$1.canonical.y === (1 << e$1.canonical.z) - 1, s$1 = `m_${r$1 ? "n" : ""}_${a$1 ? "s" : ""}`;
					if (this._meshCache[s$1]) return this._meshCache[s$1];
					const n$1 = this.painter.context, l$1 = new t.cv(), c$1 = new t.aN(), h$1 = this.meshSize, u$1 = t.$ / h$1, d$1 = h$1 * h$1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) for (let t$1 = 0; t$1 <= h$1; t$1++) l$1.emplaceBack(t$1 * u$1, e$2 * u$1, 0);
					for (let e$2 = 0; e$2 < d$1; e$2 += h$1 + 1) for (let t$1 = 0; t$1 < h$1; t$1++) c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 1, h$1 + t$1 + e$2 + 2), c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 2, t$1 + e$2 + 1);
					const _$2 = l$1.length, p$1 = _$2 + (h$1 + 1), m$1 = (h$1 + 1) * h$1, f$1 = r$1 ? t.bh : 0, g$2 = r$1 ? 0 : 1, v$1 = a$1 ? t.bi : t.$, b$2 = a$1 ? 0 : 1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, f$1, g$2);
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, v$1, b$2);
					for (let e$2 = 0; e$2 < h$1; e$2++) c$1.emplaceBack(m$1 + e$2, p$1 + e$2, p$1 + e$2 + 1), c$1.emplaceBack(m$1 + e$2, p$1 + e$2 + 1, m$1 + e$2 + 1), c$1.emplaceBack(0 + e$2, _$2 + e$2 + 1, _$2 + e$2), c$1.emplaceBack(0 + e$2, 0 + e$2 + 1, _$2 + e$2 + 1);
					const x$1 = l$1.length, y$1 = x$1 + 2 * (h$1 + 1);
					for (const e$2 of [0, 1]) for (let i$2 = 0; i$2 <= h$1; i$2++) for (const o$2 of [0, 1]) l$1.emplaceBack(e$2 * t.$, i$2 * u$1, o$2);
					for (let e$2 = 0; e$2 < 2 * h$1; e$2 += 2) c$1.emplaceBack(x$1 + e$2, x$1 + e$2 + 1, x$1 + e$2 + 3), c$1.emplaceBack(x$1 + e$2, x$1 + e$2 + 3, x$1 + e$2 + 2), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 3, y$1 + e$2 + 1), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 2, y$1 + e$2 + 3);
					const w$1 = new wt$1(n$1.createVertexBuffer(l$1, ka$1.members), n$1.createIndexBuffer(c$1), t.aM.simpleSegment(0, 0, l$1.length, c$1.length));
					return this._meshCache[s$1] = w$1, w$1;
				}
				getMeshFrameDelta(e$1) {
					return 2 * Math.PI * t.bu / Math.pow(2, Math.max(e$1, 0)) / 5;
				}
				getMinTileElevationForLngLatZoom(e$1, t$1) {
					var i$1;
					const { tileID: o$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, t$1);
					return null !== (i$1 = this.getMinMaxElevation(o$1).minElevation) && void 0 !== i$1 ? i$1 : 0;
				}
				getMinMaxElevation(e$1) {
					const t$1 = this.getTerrainData(e$1).tile, i$1 = {
						minElevation: null,
						maxElevation: null
					};
					return t$1 && t$1.dem && (i$1.minElevation = t$1.dem.min * this.exaggeration, i$1.maxElevation = t$1.dem.max * this.exaggeration), i$1;
				}
				_getOverscaledTileIDFromLngLatZoom(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1.wrap()), r$1 = (1 << i$1) * t.$, a$1 = o$1.x * r$1, s$1 = o$1.y * r$1, n$1 = Math.floor(a$1 / t.$), l$1 = Math.floor(s$1 / t.$);
					return {
						tileID: new t.Z(i$1, 0, i$1, n$1, l$1),
						mercatorX: a$1,
						mercatorY: s$1
					};
				}
			}
			class Oa$1 {
				constructor(e$1, t$1, i$1) {
					this._context = e$1, this._size = t$1, this._tileSize = i$1, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
				}
				destruct() {
					for (const e$1 of this._objects) e$1.texture.destroy(), e$1.fbo.destroy();
				}
				_createObject(e$1) {
					const i$1 = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o$1 = new t.T(this._context, {
						width: this._tileSize,
						height: this._tileSize,
						data: null
					}, this._context.gl.RGBA);
					return o$1.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i$1.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i$1.colorAttachment.set(o$1.texture), {
						id: e$1,
						fbo: i$1,
						texture: o$1,
						stamp: -1,
						inUse: !1
					};
				}
				getObjectForId(e$1) {
					return this._objects[e$1];
				}
				useObject(e$1) {
					e$1.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((t$1) => e$1.id !== t$1)), this._recentlyUsed.push(e$1.id);
				}
				stampObject(e$1) {
					e$1.stamp = ++this._stamp;
				}
				getOrCreateFreeObject() {
					for (const e$2 of this._recentlyUsed) if (!this._objects[e$2].inUse) return this._objects[e$2];
					if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
					const e$1 = this._createObject(this._objects.length);
					return this._objects.push(e$1), e$1;
				}
				freeObject(e$1) {
					e$1.inUse = !1;
				}
				freeAllObjects() {
					for (const e$1 of this._objects) this.freeObject(e$1);
				}
				isFull() {
					return !(this._objects.length < this._size) && !1 === this._objects.some(((e$1) => !e$1.inUse));
				}
			}
			const ja$1 = {
				background: !0,
				fill: !0,
				line: !0,
				raster: !0,
				hillshade: !0,
				"color-relief": !0
			};
			class Na$1 {
				constructor(e$1, t$1) {
					this.painter = e$1, this.terrain = t$1, this.pool = new Oa$1(e$1.context, 30, t$1.sourceCache.tileSize * t$1.qualityFactor);
				}
				destruct() {
					this.pool.destruct();
				}
				getTexture(e$1) {
					return this.pool.getObjectForId(e$1.rtt[this._stacks.length - 1].id).texture;
				}
				prepareForRender(e$1, t$1) {
					this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e$1._order.filter(((i$1) => !e$1._layers[i$1].isHidden(t$1))), this._coordsAscending = {};
					for (const t$2 in e$1.sourceCaches) {
						this._coordsAscending[t$2] = {};
						const i$1 = e$1.sourceCaches[t$2].getVisibleCoordinates(), o$1 = e$1.sourceCaches[t$2].getSource(), r$1 = o$1 instanceof X$1 ? o$1.terrainTileRanges : null;
						for (const e$2 of i$1) {
							const i$2 = this.terrain.sourceCache.getTerrainCoords(e$2, r$1);
							for (const e$3 in i$2) this._coordsAscending[t$2][e$3] || (this._coordsAscending[t$2][e$3] = []), this._coordsAscending[t$2][e$3].push(i$2[e$3]);
						}
					}
					this._coordsAscendingStr = {};
					for (const t$2 of e$1._order) {
						const i$1 = e$1._layers[t$2], o$1 = i$1.source;
						if (ja$1[i$1.type] && !this._coordsAscendingStr[o$1]) {
							this._coordsAscendingStr[o$1] = {};
							for (const e$2 in this._coordsAscending[o$1]) this._coordsAscendingStr[o$1][e$2] = this._coordsAscending[o$1][e$2].map(((e$3) => e$3.key)).sort().join();
						}
					}
					for (const e$2 of this._renderableTiles) for (const t$2 in this._coordsAscendingStr) {
						const i$1 = this._coordsAscendingStr[t$2][e$2.tileID.key];
						i$1 && i$1 !== e$2.rttCoords[t$2] && (e$2.rtt = []);
					}
				}
				renderLayer(e$1, i$1) {
					if (e$1.isHidden(this.painter.transform.zoom)) return !1;
					const o$1 = Object.assign(Object.assign({}, i$1), { isRenderingToTexture: !0 }), r$1 = e$1.type, a$1 = this.painter, s$1 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e$1.id;
					if (ja$1[r$1] && (this._prevType && ja$1[this._prevType] || this._stacks.push([]), this._prevType = r$1, this._stacks[this._stacks.length - 1].push(e$1.id), !s$1)) return !0;
					if (ja$1[this._prevType] || ja$1[r$1] && s$1) {
						this._prevType = r$1;
						const e$2 = this._stacks.length - 1, i$2 = this._stacks[e$2] || [];
						for (const r$2 of this._renderableTiles) {
							if (this.pool.isFull() && (Cr(this.painter, this.terrain, this._rttTiles, o$1), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(r$2), r$2.rtt[e$2]) {
								const t$1 = this.pool.getObjectForId(r$2.rtt[e$2].id);
								if (t$1.stamp === r$2.rtt[e$2].stamp) {
									this.pool.useObject(t$1);
									continue;
								}
							}
							const s$2 = this.pool.getOrCreateFreeObject();
							this.pool.useObject(s$2), this.pool.stampObject(s$2), r$2.rtt[e$2] = {
								id: s$2.id,
								stamp: s$2.stamp
							}, a$1.context.bindFramebuffer.set(s$2.fbo.framebuffer), a$1.context.clear({
								color: t.bf.transparent,
								stencil: 0
							}), a$1.currentStencilSource = void 0;
							for (let e$3 = 0; e$3 < i$2.length; e$3++) {
								const t$1 = a$1.style._layers[i$2[e$3]], n$1 = t$1.source ? this._coordsAscending[t$1.source][r$2.tileID.key] : [r$2.tileID];
								a$1.context.viewport.set([
									0,
									0,
									s$2.fbo.width,
									s$2.fbo.height
								]), a$1._renderTileClippingMasks(t$1, n$1, !0), a$1.renderLayer(a$1, a$1.style.sourceCaches[t$1.source], t$1, n$1, o$1), t$1.source && (r$2.rttCoords[t$1.source] = this._coordsAscendingStr[t$1.source][r$2.tileID.key]);
							}
						}
						return Cr(this.painter, this.terrain, this._rttTiles, o$1), this._rttTiles = [], this.pool.freeAllObjects(), ja$1[r$1];
					}
					return !1;
				}
			}
			const Ua$1 = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"AttributionControl.MapFeedback": "Map feedback",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "MapLibre logo",
				"Map.Title": "Map",
				"Marker.Title": "Map marker",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"Popup.Close": "Close popup",
				"ScaleControl.Feet": "ft",
				"ScaleControl.Meters": "m",
				"ScaleControl.Kilometers": "km",
				"ScaleControl.Miles": "mi",
				"ScaleControl.NauticalMiles": "nm",
				"GlobeControl.Enable": "Enable globe",
				"GlobeControl.Disable": "Disable globe",
				"TerrainControl.Enable": "Enable terrain",
				"TerrainControl.Disable": "Disable terrain",
				"CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
				"CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
				"CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
			}, Za$1 = i, Ga$1 = {
				hash: !1,
				interactive: !0,
				bearingSnap: 7,
				attributionControl: za$1,
				maplibreLogo: !1,
				refreshExpiredTiles: !0,
				canvasContextAttributes: {
					antialias: !1,
					preserveDrawingBuffer: !1,
					powerPreference: "high-performance",
					failIfMajorPerformanceCaveat: !1,
					desynchronized: !1,
					contextType: void 0
				},
				scrollZoom: !0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 60,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				trackResize: !0,
				center: [0, 0],
				elevation: 0,
				zoom: 0,
				bearing: 0,
				pitch: 0,
				roll: 0,
				renderWorldCopies: !0,
				maxTileCacheSize: null,
				maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS,
				transformRequest: null,
				transformCameraUpdate: null,
				fadeDuration: 300,
				crossSourceCollisions: !0,
				clickTolerance: 3,
				localIdeographFontFamily: "sans-serif",
				pitchWithRotate: !0,
				rollEnabled: !1,
				validateStyle: !0,
				maxCanvasSize: [4096, 4096],
				cancelPendingTileRequestsWhileZooming: !0,
				centerClampedToGround: !0
			}, Va$1 = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1,
				visualizeRoll: !0
			};
			class $a$1 {
				constructor(e$1, i$1, o$1 = !1) {
					this.mousedown = (e$2) => {
						this.startMove(e$2, n.mousePos(this.element, e$2)), n.addEventListener(window, "mousemove", this.mousemove), n.addEventListener(window, "mouseup", this.mouseup);
					}, this.mousemove = (e$2) => {
						this.move(e$2, n.mousePos(this.element, e$2));
					}, this.mouseup = (e$2) => {
						this._rotatePitchHandler.dragEnd(e$2), this.offTemp();
					}, this.touchstart = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e$2.targetTouches)[0], this.startMove(e$2, this._startPos), n.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.addEventListener(window, "touchend", this.touchend));
					}, this.touchmove = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, e$2.targetTouches)[0], this.move(e$2, this._lastPos));
					}, this.touchend = (e$2) => {
						0 === e$2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this.reset = () => {
						this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this._clickTolerance = 10, this.element = i$1;
					this._rotatePitchHandler = new Kr$1({
						clickTolerance: 3,
						move: (e$2, r$1) => {
							const a$1 = i$1.getBoundingClientRect(), s$1 = new t.P((a$1.bottom - a$1.top) / 2, (a$1.right - a$1.left) / 2);
							return {
								bearingDelta: t.cn(new t.P(e$2.x, r$1.y), r$1, s$1),
								pitchDelta: o$1 ? -.5 * (r$1.y - e$2.y) : void 0
							};
						},
						moveStateManager: new ia$1(),
						enable: !0,
						assignEvents: () => {}
					}), this.map = e$1, n.addEventListener(i$1, "mousedown", this.mousedown), n.addEventListener(i$1, "touchstart", this.touchstart, { passive: !1 }), n.addEventListener(i$1, "touchcancel", this.reset);
				}
				startMove(e$1, t$1) {
					this._rotatePitchHandler.dragStart(e$1, t$1), n.disableDrag();
				}
				move(e$1, t$1) {
					const i$1 = this.map, { bearingDelta: o$1, pitchDelta: r$1 } = this._rotatePitchHandler.dragMove(e$1, t$1) || {};
					o$1 && i$1.setBearing(i$1.getBearing() + o$1), r$1 && i$1.setPitch(i$1.getPitch() + r$1);
				}
				off() {
					const e$1 = this.element;
					n.removeEventListener(e$1, "mousedown", this.mousedown), n.removeEventListener(e$1, "touchstart", this.touchstart, { passive: !1 }), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend), n.removeEventListener(e$1, "touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					n.enableDrag(), n.removeEventListener(window, "mousemove", this.mousemove), n.removeEventListener(window, "mouseup", this.mouseup), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend);
				}
			}
			let qa$1;
			function Wa$1(e$1, i$1, o$1, r$1 = !1) {
				if (r$1 || !o$1.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e$1 ? void 0 : e$1.wrap();
				const a$1 = new t.S(e$1.lng, e$1.lat);
				if (e$1 = new t.S(e$1.lng, e$1.lat), i$1) {
					const r$2 = new t.S(e$1.lng - 360, e$1.lat), a$2 = new t.S(e$1.lng + 360, e$1.lat), s$1 = o$1.locationToScreenPoint(e$1).distSqr(i$1);
					o$1.locationToScreenPoint(r$2).distSqr(i$1) < s$1 ? e$1 = r$2 : o$1.locationToScreenPoint(a$2).distSqr(i$1) < s$1 && (e$1 = a$2);
				}
				for (; Math.abs(e$1.lng - o$1.center.lng) > 180;) {
					const t$1 = o$1.locationToScreenPoint(e$1);
					if (t$1.x >= 0 && t$1.y >= 0 && t$1.x <= o$1.width && t$1.y <= o$1.height) break;
					e$1.lng > o$1.center.lng ? e$1.lng -= 360 : e$1.lng += 360;
				}
				return e$1.lng !== a$1.lng && o$1.isPointOnMapSurface(o$1.locationToScreenPoint(e$1)) ? e$1 : a$1;
			}
			const Ha$1 = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			};
			function Xa$1(e$1, t$1, i$1) {
				const o$1 = e$1.classList;
				for (const e$2 in Ha$1) o$1.remove(`maplibregl-${i$1}-anchor-${e$2}`);
				o$1.add(`maplibregl-${i$1}-anchor-${t$1}`);
			}
			class Ka$1 extends t.E {
				constructor(e$1) {
					if (super(), this._onKeyPress = (e$2) => {
						const t$1 = e$2.code, i$1 = e$2.charCode || e$2.keyCode;
						"Space" !== t$1 && "Enter" !== t$1 && 32 !== i$1 && 13 !== i$1 || this.togglePopup();
					}, this._onMapClick = (e$2) => {
						const t$1 = e$2.originalEvent.target, i$1 = this._element;
						this._popup && (t$1 === i$1 || i$1.contains(t$1)) && this.togglePopup();
					}, this._update = (e$2) => {
						if (!this._map) return;
						const t$1 = this._map.loaded() && !this._map.isMoving();
						("terrain" === (null == e$2 ? void 0 : e$2.type) || "render" === (null == e$2 ? void 0 : e$2.type) && !t$1) && this._map.once("render", this._update), this._lngLat = Wa$1(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
						let i$1 = "";
						"viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i$1 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i$1 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
						let o$1 = "";
						"viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o$1 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o$1 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e$2 && "moveend" !== e$2.type || (this._pos = this._pos.round()), n.setTransform(this._element, `${Ha$1[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o$1} ${i$1}`), s.frameAsync(new AbortController()).then((() => {
							this._updateOpacity(e$2 && "moveend" === e$2.type);
						})).catch((() => {}));
					}, this._onMove = (e$2) => {
						if (!this._isDragging) {
							const t$1 = this._clickTolerance || this._map._clickTolerance;
							this._isDragging = e$2.point.dist(this._pointerdownPos) >= t$1;
						}
						this._isDragging && (this._pos = e$2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
					}, this._onUp = () => {
						this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
					}, this._addDragHandler = (e$2) => {
						this._element.contains(e$2.originalEvent.target) && (e$2.preventDefault(), this._positionDelta = e$2.point.sub(this._pos).add(this._offset), this._pointerdownPos = e$2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
					}, this._anchor = e$1 && e$1.anchor || "center", this._color = e$1 && e$1.color || "#3FB1CE", this._scale = e$1 && e$1.scale || 1, this._draggable = e$1 && e$1.draggable || !1, this._clickTolerance = e$1 && e$1.clickTolerance || 0, this._subpixelPositioning = e$1 && e$1.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e$1 && e$1.rotation || 0, this._rotationAlignment = e$1 && e$1.rotationAlignment || "auto", this._pitchAlignment = e$1 && e$1.pitchAlignment && "auto" !== e$1.pitchAlignment ? e$1.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e$1 ? void 0 : e$1.opacity, null == e$1 ? void 0 : e$1.opacityWhenCovered), e$1 && e$1.element) this._element = e$1.element, this._offset = t.P.convert(e$1 && e$1.offset || [0, 0]);
					else {
						this._defaultMarker = !0, this._element = n.create("div");
						const i$1 = n.createNS("http://www.w3.org/2000/svg", "svg"), o$1 = 41, r$1 = 27;
						i$1.setAttributeNS(null, "display", "block"), i$1.setAttributeNS(null, "height", `${o$1}px`), i$1.setAttributeNS(null, "width", `${r$1}px`), i$1.setAttributeNS(null, "viewBox", `0 0 ${r$1} ${o$1}`);
						const a$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						a$1.setAttributeNS(null, "stroke", "none"), a$1.setAttributeNS(null, "stroke-width", "1"), a$1.setAttributeNS(null, "fill", "none"), a$1.setAttributeNS(null, "fill-rule", "evenodd");
						const s$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						s$1.setAttributeNS(null, "fill-rule", "nonzero");
						const l$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						l$1.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l$1.setAttributeNS(null, "fill", "#000000");
						for (const e$2 of [
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "9.5",
								ry: "4.77275007"
							},
							{
								rx: "8.5",
								ry: "4.29549936"
							},
							{
								rx: "7.5",
								ry: "3.81822308"
							},
							{
								rx: "6.5",
								ry: "3.34094679"
							},
							{
								rx: "5.5",
								ry: "2.86367051"
							},
							{
								rx: "4.5",
								ry: "2.38636864"
							}
						]) {
							const t$1 = n.createNS("http://www.w3.org/2000/svg", "ellipse");
							t$1.setAttributeNS(null, "opacity", "0.04"), t$1.setAttributeNS(null, "cx", "10.5"), t$1.setAttributeNS(null, "cy", "5.80029008"), t$1.setAttributeNS(null, "rx", e$2.rx), t$1.setAttributeNS(null, "ry", e$2.ry), l$1.appendChild(t$1);
						}
						const h$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						h$1.setAttributeNS(null, "fill", this._color);
						const u$1 = n.createNS("http://www.w3.org/2000/svg", "path");
						u$1.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h$1.appendChild(u$1);
						const d$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						d$1.setAttributeNS(null, "opacity", "0.25"), d$1.setAttributeNS(null, "fill", "#000000");
						const _$2 = n.createNS("http://www.w3.org/2000/svg", "path");
						_$2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d$1.appendChild(_$2);
						const p$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						p$1.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p$1.setAttributeNS(null, "fill", "#FFFFFF");
						const m$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						m$1.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
						const f$1 = n.createNS("http://www.w3.org/2000/svg", "circle");
						f$1.setAttributeNS(null, "fill", "#000000"), f$1.setAttributeNS(null, "opacity", "0.25"), f$1.setAttributeNS(null, "cx", "5.5"), f$1.setAttributeNS(null, "cy", "5.5"), f$1.setAttributeNS(null, "r", "5.4999962");
						const g$2 = n.createNS("http://www.w3.org/2000/svg", "circle");
						g$2.setAttributeNS(null, "fill", "#FFFFFF"), g$2.setAttributeNS(null, "cx", "5.5"), g$2.setAttributeNS(null, "cy", "5.5"), g$2.setAttributeNS(null, "r", "5.4999962"), m$1.appendChild(f$1), m$1.appendChild(g$2), s$1.appendChild(l$1), s$1.appendChild(h$1), s$1.appendChild(d$1), s$1.appendChild(p$1), s$1.appendChild(m$1), i$1.appendChild(s$1), i$1.setAttributeNS(null, "height", o$1 * this._scale + "px"), i$1.setAttributeNS(null, "width", r$1 * this._scale + "px"), this._element.appendChild(i$1), this._offset = t.P.convert(e$1 && e$1.offset || [0, -14]);
					}
					if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e$2) => {
						e$2.preventDefault();
					})), this._element.addEventListener("mousedown", ((e$2) => {
						e$2.preventDefault();
					})), Xa$1(this._element, this._anchor, "marker"), e$1 && e$1.className) for (const t$1 of e$1.className.split(" ")) this._element.classList.add(t$1);
					this._popup = null;
				}
				addTo(e$1) {
					return this.remove(), this._map = e$1, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e$1._getUIString("Marker.Title")), e$1.getCanvasContainer().appendChild(this._element), e$1.on("move", this._update), e$1.on("moveend", this._update), e$1.on("terrain", this._update), e$1.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
				}
				remove() {
					return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.S.convert(e$1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
				}
				getElement() {
					return this._element;
				}
				setPopup(e$1) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e$1) {
						if (!("offset" in e$1.options)) {
							const t$1 = 38.1, i$1 = 13.5, o$1 = Math.abs(i$1) / Math.SQRT2;
							e$1.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t$1],
								"bottom-left": [o$1, -1 * (t$1 - i$1 + o$1)],
								"bottom-right": [-o$1, -1 * (t$1 - i$1 + o$1)],
								left: [i$1, -1 * (t$1 - i$1)],
								right: [-i$1, -1 * (t$1 - i$1)]
							} : this._offset;
						}
						this._popup = e$1, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
					}
					return this;
				}
				setSubpixelPositioning(e$1) {
					return this._subpixelPositioning = e$1, this;
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					const e$1 = this._popup;
					return this._element.style.opacity === this._opacityWhenCovered ? this : e$1 ? (e$1.isOpen() ? e$1.remove() : (e$1.setLngLat(this._lngLat), e$1.addTo(this._map)), this) : this;
				}
				_updateOpacity(e$1 = !1) {
					var i$1, o$1;
					const r$1 = null === (i$1 = this._map) || void 0 === i$1 ? void 0 : i$1.terrain, a$1 = this._map.transform.isLocationOccluded(this._lngLat);
					if (!r$1 || a$1) {
						const e$2 = a$1 ? this._opacityWhenCovered : this._opacity;
						this._element.style.opacity !== e$2 && (this._element.style.opacity = e$2);
						return;
					}
					if (e$1) this._opacityTimeout = null;
					else {
						if (this._opacityTimeout) return;
						this._opacityTimeout = setTimeout((() => {
							this._opacityTimeout = null;
						}), 100);
					}
					const s$1 = this._map, n$1 = s$1.terrain.depthAtPoint(this._pos), l$1 = s$1.terrain.getElevationForLngLatZoom(this._lngLat, s$1.transform.tileZoom);
					if (s$1.transform.lngLatToCameraDepth(this._lngLat, l$1) - n$1 < .006) return void (this._element.style.opacity = this._opacity);
					const c$1 = -this._offset.y / s$1.transform.pixelsPerMeter, h$1 = Math.sin(s$1.getPitch() * Math.PI / 180) * c$1, u$1 = s$1.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d$1 = s$1.transform.lngLatToCameraDepth(this._lngLat, l$1 + h$1) - u$1 > .006;
					!(null === (o$1 = this._popup) || void 0 === o$1) && o$1.isOpen() && d$1 && this._popup.remove(), this._element.style.opacity = d$1 ? this._opacityWhenCovered : this._opacity;
				}
				getOffset() {
					return this._offset;
				}
				setOffset(e$1) {
					return this._offset = t.P.convert(e$1), this._update(), this;
				}
				addClassName(e$1) {
					this._element.classList.add(e$1);
				}
				removeClassName(e$1) {
					this._element.classList.remove(e$1);
				}
				toggleClassName(e$1) {
					return this._element.classList.toggle(e$1);
				}
				setDraggable(e$1) {
					return this._draggable = !!e$1, this._map && (e$1 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e$1) {
					return this._rotation = e$1 || 0, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e$1) {
					return this._rotationAlignment = e$1 || "auto", this._update(), this;
				}
				getRotationAlignment() {
					return this._rotationAlignment;
				}
				setPitchAlignment(e$1) {
					return this._pitchAlignment = e$1 && "auto" !== e$1 ? e$1 : this._rotationAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return this._pitchAlignment;
				}
				setOpacity(e$1, t$1) {
					return (void 0 === this._opacity || void 0 === e$1 && void 0 === t$1) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e$1 && (this._opacity = e$1), void 0 !== t$1 && (this._opacityWhenCovered = t$1), this._map && this._updateOpacity(!0), this;
				}
			}
			const Ya$1 = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0
			};
			let Qa$1 = 0, Ja$1 = !1;
			const es$1 = {
				maxWidth: 100,
				unit: "metric"
			};
			function ts$1(e$1, t$1, i$1) {
				const o$1 = i$1 && i$1.maxWidth || 100, r$1 = e$1._container.clientHeight / 2, a$1 = e$1._container.clientWidth / 2, s$1 = e$1.unproject([a$1 - o$1 / 2, r$1]), n$1 = e$1.unproject([a$1 + o$1 / 2, r$1]), l$1 = Math.round(e$1.project(n$1).x - e$1.project(s$1).x), c$1 = Math.min(o$1, l$1, e$1._container.clientWidth), h$1 = s$1.distanceTo(n$1);
				if (i$1 && "imperial" === i$1.unit) {
					const i$2 = 3.2808 * h$1;
					i$2 > 5280 ? is$1(t$1, c$1, i$2 / 5280, e$1._getUIString("ScaleControl.Miles")) : is$1(t$1, c$1, i$2, e$1._getUIString("ScaleControl.Feet"));
				} else i$1 && "nautical" === i$1.unit ? is$1(t$1, c$1, h$1 / 1852, e$1._getUIString("ScaleControl.NauticalMiles")) : h$1 >= 1e3 ? is$1(t$1, c$1, h$1 / 1e3, e$1._getUIString("ScaleControl.Kilometers")) : is$1(t$1, c$1, h$1, e$1._getUIString("ScaleControl.Meters"));
			}
			function is$1(e$1, t$1, i$1, o$1) {
				const r$1 = function(e$2) {
					const t$2 = Math.pow(10, `${Math.floor(e$2)}`.length - 1);
					let i$2 = e$2 / t$2;
					return i$2 = i$2 >= 10 ? 10 : i$2 >= 5 ? 5 : i$2 >= 3 ? 3 : i$2 >= 2 ? 2 : i$2 >= 1 ? 1 : function(e$3) {
						const t$3 = Math.pow(10, Math.ceil(-Math.log(e$3) / Math.LN10));
						return Math.round(e$3 * t$3) / t$3;
					}(i$2), t$2 * i$2;
				}(i$1);
				e$1.style.width = t$1 * (r$1 / i$1) + "px", e$1.innerHTML = `${r$1}&nbsp;${o$1}`;
			}
			const os$1 = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				subpixelPositioning: !1,
				locationOccludedOpacity: void 0
			}, rs$1 = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function as$1(e$1) {
				if (e$1) {
					if ("number" == typeof e$1) {
						const i$1 = Math.round(Math.abs(e$1) / Math.SQRT2);
						return {
							center: new t.P(0, 0),
							top: new t.P(0, e$1),
							"top-left": new t.P(i$1, i$1),
							"top-right": new t.P(-i$1, i$1),
							bottom: new t.P(0, -e$1),
							"bottom-left": new t.P(i$1, -i$1),
							"bottom-right": new t.P(-i$1, -i$1),
							left: new t.P(e$1, 0),
							right: new t.P(-e$1, 0)
						};
					}
					if (e$1 instanceof t.P || Array.isArray(e$1)) {
						const i$1 = t.P.convert(e$1);
						return {
							center: i$1,
							top: i$1,
							"top-left": i$1,
							"top-right": i$1,
							bottom: i$1,
							"bottom-left": i$1,
							"bottom-right": i$1,
							left: i$1,
							right: i$1
						};
					}
					return {
						center: t.P.convert(e$1.center || [0, 0]),
						top: t.P.convert(e$1.top || [0, 0]),
						"top-left": t.P.convert(e$1["top-left"] || [0, 0]),
						"top-right": t.P.convert(e$1["top-right"] || [0, 0]),
						bottom: t.P.convert(e$1.bottom || [0, 0]),
						"bottom-left": t.P.convert(e$1["bottom-left"] || [0, 0]),
						"bottom-right": t.P.convert(e$1["bottom-right"] || [0, 0]),
						left: t.P.convert(e$1.left || [0, 0]),
						right: t.P.convert(e$1.right || [0, 0])
					};
				}
				return as$1(new t.P(0, 0));
			}
			const ss$1 = i;
			e.AJAXError = t.cz, e.Event = t.l, e.Evented = t.E, e.LngLat = t.S, e.MercatorCoordinate = t.a1, e.Point = t.P, e.addProtocol = t.cA, e.config = t.a, e.removeProtocol = t.cB, e.AttributionControl = Da$1, e.BoxZoomHandler = $r$1, e.CanvasSource = Y$1, e.CooperativeGesturesHandler = Ca$1, e.DoubleClickZoomHandler = ba$1, e.DragPanHandler = wa$1, e.DragRotateHandler = Ta$1, e.EdgeInsets = Mt$1, e.FullscreenControl = class extends t.E {
				constructor(e$1 = {}) {
					super(), this._onFullscreenChange = () => {
						var e$2;
						let t$1 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
						for (; null === (e$2 = null == t$1 ? void 0 : t$1.shadowRoot) || void 0 === e$2 ? void 0 : e$2.fullscreenElement;) t$1 = t$1.shadowRoot.fullscreenElement;
						t$1 === this._container !== this._fullscreen && this._handleFullscreenChange();
					}, this._onClickFullscreen = () => {
						this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
					}, this._fullscreen = !1, e$1 && e$1.container && (e$1.container instanceof HTMLElement ? this._container = e$1.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
				}
				onAdd(e$1) {
					return this._map = e$1, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
				}
				onRemove() {
					n.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_setupUI() {
					const e$1 = this._fullscreenButton = n.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
					n.create("span", "maplibregl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_updateTitle() {
					const e$1 = this._getTitle();
					this._fullscreenButton.setAttribute("aria-label", e$1), this._fullscreenButton.title = e$1;
				}
				_getTitle() {
					return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
				}
				_isFullscreen() {
					return this._fullscreen;
				}
				_handleFullscreenChange() {
					this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
				}
				_exitFullscreen() {
					window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
				}
				_requestFullscreen() {
					this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
				}
				_togglePseudoFullScreen() {
					this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
				}
			}, e.GeoJSONSource = H$1, e.GeolocateControl = class extends t.E {
				constructor(e$1) {
					super(), this._onSuccess = (e$2) => {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(e$2)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e$2)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = e$2, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR":
									this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
									break;
								default: throw new Error(`Unexpected watchState ${this._watchState}`);
							}
							this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e$2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e$2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e$2)), this._finish();
						}
					}, this._updateCamera = (e$2) => {
						const i$1 = new t.S(e$2.coords.longitude, e$2.coords.latitude), o$1 = e$2.coords.accuracy, r$1 = this._map.getBearing(), a$1 = t.e({ bearing: r$1 }, this.options.fitBoundsOptions), s$1 = G$1.fromLngLat(i$1, o$1);
						this._map.fitBounds(s$1, a$1, { geolocateSource: !0 });
					}, this._updateMarker = (e$2) => {
						if (e$2) {
							const i$1 = new t.S(e$2.coords.longitude, e$2.coords.latitude);
							this._accuracyCircleMarker.setLngLat(i$1).addTo(this._map), this._userLocationDotMarker.setLngLat(i$1).addTo(this._map), this._accuracy = e$2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}, this._onZoom = () => {
						this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
					}, this._onError = (e$2) => {
						if (this._map) {
							if (1 === e$2.code) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3), void 0 !== this._geolocationWatchID && this._clearWatch();
							} else {
								if (3 === e$2.code && Ja$1) return;
								this.options.trackUserLocation && this._setErrorState();
							}
							"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e$2)), this._finish();
						}
					}, this._finish = () => {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}, this._setupUI = () => {
						this._map && (this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this._geolocateButton = n.create("button", "maplibregl-ctrl-geolocate", this._container), n.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
					}, this._finishSetupUI = (e$2) => {
						if (this._map) {
							if (!1 === e$2) {
								t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							} else {
								const e$3 = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.disabled = !1, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ka$1({ element: this._dotElement }), this._circleElement = n.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ka$1({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((e$3) => {
								const i$1 = (null == e$3 ? void 0 : e$3[0]) instanceof ResizeObserverEntry;
								e$3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i$1 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
							}));
						}
					}, this.options = t.e({}, Ya$1, e$1);
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
						return t._(this, arguments, void 0, (function* (e$2 = !1) {
							if (void 0 !== qa$1 && !e$2) return qa$1;
							if (void 0 === window.navigator.permissions) return qa$1 = !!window.navigator.geolocation, qa$1;
							try {
								qa$1 = "denied" !== (yield window.navigator.permissions.query({ name: "geolocation" })).state;
							} catch (e$3) {
								qa$1 = !!window.navigator.geolocation;
							}
							return qa$1;
						}));
					}().then(((e$2) => this._finishSetupUI(e$2))), this._container;
				}
				onRemove() {
					void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Qa$1 = 0, Ja$1 = !1;
				}
				_isOutOfMapMaxBounds(e$1) {
					const t$1 = this._map.getMaxBounds(), i$1 = e$1.coords;
					return t$1 && (i$1.longitude < t$1.getWest() || i$1.longitude > t$1.getEast() || i$1.latitude < t$1.getSouth() || i$1.latitude > t$1.getNorth());
				}
				_setErrorState() {
					switch (this._watchState) {
						case "WAITING_ACTIVE":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
							break;
						case "ACTIVE_LOCK":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "BACKGROUND":
							this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "ACTIVE_ERROR": break;
						default: throw new Error(`Unexpected watchState ${this._watchState}`);
					}
				}
				_updateCircleRadius() {
					const e$1 = this._map.getBounds(), t$1 = e$1.getSouthEast(), i$1 = e$1.getNorthEast(), o$1 = t$1.distanceTo(i$1), r$1 = Math.ceil(this._accuracy / (o$1 / this._map._container.clientHeight) * 2);
					this._circleElement.style.width = `${r$1}px`, this._circleElement.style.height = `${r$1}px`;
				}
				trigger() {
					if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1;
					if (this.options.trackUserLocation) {
						switch (this._watchState) {
							case "OFF":
								this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
								break;
							case "WAITING_ACTIVE":
							case "ACTIVE_LOCK":
							case "ACTIVE_ERROR":
							case "BACKGROUND_ERROR":
								Qa$1--, Ja$1 = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
								break;
							case "BACKGROUND":
								this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
								break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "ACTIVE_LOCK":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "OFF": break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
						else if (void 0 === this._geolocationWatchID) {
							let e$1;
							this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Qa$1++, Qa$1 > 1 ? (e$1 = {
								maximumAge: 6e5,
								timeout: 0
							}, Ja$1 = !0) : (e$1 = this.options.positionOptions, Ja$1 = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e$1);
						}
					} else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
					return !0;
				}
				_clearWatch() {
					window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
				}
			}, e.GlobeControl = class {
				constructor() {
					this._toggleProjection = () => {
						var e$1;
						const t$1 = null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type;
						this._map.setProjection("mercator" !== t$1 && t$1 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
					}, this._updateGlobeIcon = () => {
						var e$1;
						this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
					};
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n.create("button", "maplibregl-ctrl-globe", this._container), n.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
				}
			}, e.Hash = Er, e.ImageSource = X$1, e.KeyboardHandler = pa$1, e.LngLatBounds = G$1, e.LogoControl = Aa$1, e.Map = class extends Ra$1 {
				constructor(e$1) {
					var i$1, o$1;
					t.cw.mark(t.cx.create);
					const r$1 = Object.assign(Object.assign(Object.assign({}, Ga$1), e$1), { canvasContextAttributes: Object.assign(Object.assign({}, Ga$1.canvasContextAttributes), e$1.canvasContextAttributes) });
					if (null != r$1.minZoom && null != r$1.maxZoom && r$1.minZoom > r$1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
					if (null != r$1.minPitch && null != r$1.maxPitch && r$1.minPitch > r$1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
					if (null != r$1.minPitch && r$1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (null != r$1.maxPitch && r$1.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
					const a$1 = new Lt$1(), s$1 = new Ot();
					if (void 0 !== r$1.minZoom && a$1.setMinZoom(r$1.minZoom), void 0 !== r$1.maxZoom && a$1.setMaxZoom(r$1.maxZoom), void 0 !== r$1.minPitch && a$1.setMinPitch(r$1.minPitch), void 0 !== r$1.maxPitch && a$1.setMaxPitch(r$1.maxPitch), void 0 !== r$1.renderWorldCopies && a$1.setRenderWorldCopies(r$1.renderWorldCopies), super(a$1, s$1, { bearingSnap: r$1.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new La$1(), this._controls = [], this._mapId = t.a7(), this._contextLost = (e$2) => {
						e$2.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t.l("webglcontextlost", { originalEvent: e$2 }));
					}, this._contextRestored = (e$2) => {
						this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e$2 }));
					}, this._onMapScroll = (e$2) => {
						if (e$2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}, this._onWindowOnline = () => {
						this._update();
					}, this._interactive = r$1.interactive, this._maxTileCacheSize = r$1.maxTileCacheSize, this._maxTileCacheZoomLevels = r$1.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, r$1.canvasContextAttributes), this._trackResize = !0 === r$1.trackResize, this._bearingSnap = r$1.bearingSnap, this._centerClampedToGround = r$1.centerClampedToGround, this._refreshExpiredTiles = !0 === r$1.refreshExpiredTiles, this._fadeDuration = r$1.fadeDuration, this._crossSourceCollisions = !0 === r$1.crossSourceCollisions, this._collectResourceTiming = !0 === r$1.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Ua$1), r$1.locale), this._clickTolerance = r$1.clickTolerance, this._overridePixelRatio = r$1.pixelRatio, this._maxCanvasSize = r$1.maxCanvasSize, this.transformCameraUpdate = r$1.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = !0 === r$1.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p.addThrottleControl((() => this.isMoving())), this._requestManager = new m(r$1.transformRequest), "string" == typeof r$1.container) {
						if (this._container = document.getElementById(r$1.container), !this._container) throw new Error(`Container '${r$1.container}' not found.`);
					} else {
						if (!(r$1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
						this._container = r$1.container;
					}
					if (r$1.maxBounds && this.setMaxBounds(r$1.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
						this.painter.terrainFacilitator.dirty = !0, this._update(!0);
					})), this.once("idle", (() => {
						this._idleTriggered = !0;
					})), "undefined" != typeof window) {
						addEventListener("online", this._onWindowOnline, !1);
						let e$2 = !1;
						const t$1 = Sr$1(((e$3) => {
							this._trackResize && !this._removed && (this.resize(e$3), this.redraw());
						}), 50);
						this._resizeObserver = new ResizeObserver(((i$2) => {
							e$2 ? t$1(i$2) : e$2 = !0;
						})), this._resizeObserver.observe(this._container);
					}
					this.handlers = new Ea$1(this, r$1), this._hash = r$1.hash && new Er("string" == typeof r$1.hash && r$1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
						center: r$1.center,
						elevation: r$1.elevation,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						roll: r$1.roll
					}), r$1.bounds && (this.resize(), this.fitBounds(r$1.bounds, t.e({}, r$1.fitBoundsOptions, { duration: 0 }))));
					const n$1 = "string" == typeof r$1.style || !("globe" === (null === (o$1 = null === (i$1 = r$1.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === o$1 ? void 0 : o$1.type));
					this.resize(null, n$1), this._localIdeographFontFamily = r$1.localIdeographFontFamily, this._validateStyle = r$1.validateStyle, r$1.style && this.setStyle(r$1.style, { localIdeographFontFamily: r$1.localIdeographFontFamily }), r$1.attributionControl && this.addControl(new Da$1("boolean" == typeof r$1.attributionControl ? void 0 : r$1.attributionControl)), r$1.maplibreLogo && this.addControl(new Aa$1(), r$1.logoPosition), this.on("style.load", (() => {
						if (n$1 || this._resizeTransform(), this.transform.unmodified) {
							const e$2 = t.Q(this.style.stylesheet, [
								"center",
								"zoom",
								"bearing",
								"pitch",
								"roll"
							]);
							this.jumpTo(e$2);
						}
					})), this.on("data", ((e$2) => {
						this._update("style" === e$2.dataType), this.fire(new t.l(`${e$2.dataType}data`, e$2));
					})), this.on("dataloading", ((e$2) => {
						this.fire(new t.l(`${e$2.dataType}dataloading`, e$2));
					})), this.on("dataabort", ((e$2) => {
						this.fire(new t.l("sourcedataabort", e$2));
					}));
				}
				_getMapId() {
					return this._mapId;
				}
				setGlobalStateProperty(e$1, t$1) {
					return this.style.setGlobalStateProperty(e$1, t$1), this._update(!0);
				}
				getGlobalState() {
					return this.style.getGlobalState();
				}
				addControl(e$1, i$1) {
					if (void 0 === i$1 && (i$1 = e$1.getDefaultPosition ? e$1.getDefaultPosition() : "top-right"), !e$1 || !e$1.onAdd) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
					const o$1 = e$1.onAdd(this);
					this._controls.push(e$1);
					const r$1 = this._controlPositions[i$1];
					return -1 !== i$1.indexOf("bottom") ? r$1.insertBefore(o$1, r$1.firstChild) : r$1.appendChild(o$1), this;
				}
				removeControl(e$1) {
					if (!e$1 || !e$1.onRemove) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
					const i$1 = this._controls.indexOf(e$1);
					return i$1 > -1 && this._controls.splice(i$1, 1), e$1.onRemove(this), this;
				}
				hasControl(e$1) {
					return this._controls.indexOf(e$1) > -1;
				}
				calculateCameraOptionsFromTo(e$1, t$1, i$1, o$1) {
					return null == o$1 && this.terrain && (o$1 = this.terrain.getElevationForLngLatZoom(i$1, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e$1, t$1, i$1, o$1);
				}
				resize(e$1, i$1 = !0) {
					const [o$1, r$1] = this._containerDimensions(), a$1 = this._getClampedPixelRatio(o$1, r$1);
					if (this._resizeCanvas(o$1, r$1, a$1), this.painter.resize(o$1, r$1, a$1), this.painter.overLimit()) {
						const e$2 = this.painter.context.gl;
						this._maxCanvasSize = [e$2.drawingBufferWidth, e$2.drawingBufferHeight];
						const t$1 = this._getClampedPixelRatio(o$1, r$1);
						this._resizeCanvas(o$1, r$1, t$1), this.painter.resize(o$1, r$1, t$1);
					}
					this._resizeTransform(i$1);
					const s$1 = !this._moving;
					return s$1 && (this.stop(), this.fire(new t.l("movestart", e$1)).fire(new t.l("move", e$1))), this.fire(new t.l("resize", e$1)), s$1 && this.fire(new t.l("moveend", e$1)), this;
				}
				_resizeTransform(e$1 = !0) {
					var t$1;
					const [i$1, o$1] = this._containerDimensions();
					this.transform.resize(i$1, o$1, e$1), null === (t$1 = this._requestedCameraState) || void 0 === t$1 || t$1.resize(i$1, o$1, e$1);
				}
				_getClampedPixelRatio(e$1, t$1) {
					const { 0: i$1, 1: o$1 } = this._maxCanvasSize, r$1 = this.getPixelRatio(), a$1 = e$1 * r$1, s$1 = t$1 * r$1;
					return Math.min(a$1 > i$1 ? i$1 / a$1 : 1, s$1 > o$1 ? o$1 / s$1 : 1) * r$1;
				}
				getPixelRatio() {
					var e$1;
					return null !== (e$1 = this._overridePixelRatio) && void 0 !== e$1 ? e$1 : devicePixelRatio;
				}
				setPixelRatio(e$1) {
					this._overridePixelRatio = e$1, this.resize();
				}
				getBounds() {
					return this.transform.getBounds();
				}
				getMaxBounds() {
					return this.transform.getMaxBounds();
				}
				setMaxBounds(e$1) {
					return this.transform.setMaxBounds(G$1.convert(e$1)), this._update();
				}
				setMinZoom(e$1) {
					if ((e$1 = null == e$1 ? -2 : e$1) >= -2 && e$1 <= this.transform.maxZoom) return this.transform.setMinZoom(e$1), this._update(), this.getZoom() < e$1 && this.setZoom(e$1), this;
					throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
				}
				getMinZoom() {
					return this.transform.minZoom;
				}
				setMaxZoom(e$1) {
					if ((e$1 = null == e$1 ? 22 : e$1) >= this.transform.minZoom) return this.transform.setMaxZoom(e$1), this._update(), this.getZoom() > e$1 && this.setZoom(e$1), this;
					throw new Error("maxZoom must be greater than the current minZoom");
				}
				getMaxZoom() {
					return this.transform.maxZoom;
				}
				setMinPitch(e$1) {
					if ((e$1 = null == e$1 ? 0 : e$1) < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (e$1 >= 0 && e$1 <= this.transform.maxPitch) return this.transform.setMinPitch(e$1), this._update(), this.getPitch() < e$1 && this.setPitch(e$1), this;
					throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
				}
				getMinPitch() {
					return this.transform.minPitch;
				}
				setMaxPitch(e$1) {
					if ((e$1 = null == e$1 ? 60 : e$1) > 180) throw new Error("maxPitch must be less than or equal to 180");
					if (e$1 >= this.transform.minPitch) return this.transform.setMaxPitch(e$1), this._update(), this.getPitch() > e$1 && this.setPitch(e$1), this;
					throw new Error("maxPitch must be greater than the current minPitch");
				}
				getMaxPitch() {
					return this.transform.maxPitch;
				}
				getRenderWorldCopies() {
					return this.transform.renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					return this.transform.setRenderWorldCopies(e$1), this._update();
				}
				project(e$1) {
					return this.transform.locationToScreenPoint(t.S.convert(e$1), this.style && this.terrain);
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this.terrain);
				}
				isMoving() {
					var e$1;
					return this._moving || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isMoving());
				}
				isZooming() {
					var e$1;
					return this._zooming || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isZooming());
				}
				isRotating() {
					var e$1;
					return this._rotating || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isRotating());
				}
				_createDelegatedListener(e$1, t$1, i$1) {
					if ("mouseenter" === e$1 || "mouseover" === e$1) {
						let o$1 = !1;
						const r$1 = (r$2) => {
							const a$1 = t$1.filter(((e$2) => this.getLayer(e$2))), s$1 = 0 !== a$1.length ? this.queryRenderedFeatures(r$2.point, { layers: a$1 }) : [];
							s$1.length ? o$1 || (o$1 = !0, i$1.call(this, new jr$1(e$1, this, r$2.originalEvent, { features: s$1 }))) : o$1 = !1;
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: () => {
									o$1 = !1;
								}
							}
						};
					}
					if ("mouseleave" === e$1 || "mouseout" === e$1) {
						let o$1 = !1;
						const r$1 = (r$2) => {
							const a$2 = t$1.filter(((e$2) => this.getLayer(e$2)));
							(0 !== a$2.length ? this.queryRenderedFeatures(r$2.point, { layers: a$2 }) : []).length ? o$1 = !0 : o$1 && (o$1 = !1, i$1.call(this, new jr$1(e$1, this, r$2.originalEvent)));
						}, a$1 = (t$2) => {
							o$1 && (o$1 = !1, i$1.call(this, new jr$1(e$1, this, t$2.originalEvent)));
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: a$1
							}
						};
					}
					{
						const o$1 = (e$2) => {
							const o$2 = t$1.filter(((e$3) => this.getLayer(e$3))), r$1 = 0 !== o$2.length ? this.queryRenderedFeatures(e$2.point, { layers: o$2 }) : [];
							r$1.length && (e$2.features = r$1, i$1.call(this, e$2), delete e$2.features);
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: { [e$1]: o$1 }
						};
					}
				}
				_saveDelegatedListener(e$1, t$1) {
					this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e$1] = this._delegatedListeners[e$1] || [], this._delegatedListeners[e$1].push(t$1);
				}
				_removeDelegatedListener(e$1, t$1, i$1) {
					if (!this._delegatedListeners || !this._delegatedListeners[e$1]) return;
					const o$1 = this._delegatedListeners[e$1];
					for (let e$2 = 0; e$2 < o$1.length; e$2++) {
						const r$1 = o$1[e$2];
						if (r$1.listener === i$1 && r$1.layers.length === t$1.length && r$1.layers.every(((e$3) => t$1.includes(e$3)))) {
							for (const e$3 in r$1.delegates) this.off(e$3, r$1.delegates[e$3]);
							o$1.splice(e$2, 1);
							return;
						}
					}
				}
				on(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.on(e$1, t$1);
					const o$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, o$1, i$1);
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.on(e$2, r$1.delegates[e$2]);
					return { unsubscribe: () => {
						this._removeDelegatedListener(e$1, o$1, i$1);
					} };
				}
				once(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.once(e$1, t$1);
					const o$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, o$1, i$1);
					for (const t$2 in r$1.delegates) {
						const a$1 = r$1.delegates[t$2];
						r$1.delegates[t$2] = (...t$3) => {
							this._removeDelegatedListener(e$1, o$1, i$1), a$1(...t$3);
						};
					}
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.once(e$2, r$1.delegates[e$2]);
					return this;
				}
				off(e$1, t$1, i$1) {
					return void 0 === i$1 ? super.off(e$1, t$1) : (this._removeDelegatedListener(e$1, "string" == typeof t$1 ? [t$1] : t$1, i$1), this);
				}
				queryRenderedFeatures(e$1, i$1) {
					if (!this.style) return [];
					let o$1;
					const r$1 = e$1 instanceof t.P || Array.isArray(e$1), a$1 = r$1 ? e$1 : [[0, 0], [this.transform.width, this.transform.height]];
					if (i$1 = i$1 || (r$1 ? {} : e$1) || {}, a$1 instanceof t.P || "number" == typeof a$1[0]) o$1 = [t.P.convert(a$1)];
					else {
						const e$2 = t.P.convert(a$1[0]), i$2 = t.P.convert(a$1[1]);
						o$1 = [
							e$2,
							new t.P(i$2.x, e$2.y),
							i$2,
							new t.P(e$2.x, i$2.y),
							e$2
						];
					}
					return this.style.queryRenderedFeatures(o$1, i$1, this.transform);
				}
				querySourceFeatures(e$1, t$1) {
					return this.style.querySourceFeatures(e$1, t$1);
				}
				setStyle(e$1, i$1) {
					return !1 !== (i$1 = t.e({}, {
						localIdeographFontFamily: this._localIdeographFontFamily,
						validate: this._validateStyle
					}, i$1)).diff && i$1.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e$1 ? (this._diffStyle(e$1, i$1), this) : (this._localIdeographFontFamily = i$1.localIdeographFontFamily, this._updateStyle(e$1, i$1));
				}
				setTransformRequest(e$1) {
					return this._requestManager.setTransformRequest(e$1), this;
				}
				_getUIString(e$1) {
					const t$1 = this._locale[e$1];
					if (null == t$1) throw new Error(`Missing UI string '${e$1}'`);
					return t$1;
				}
				_updateStyle(e$1, t$1) {
					var i$1, o$1;
					if (t$1.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e$1, t$1)));
					const r$1 = this.style && t$1.transformStyle ? this.style.serialize() : void 0;
					return this.style && (this.style.setEventedParent(null), this.style._remove(!e$1)), e$1 ? (this.style = new wi(this, t$1 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e$1 ? this.style.loadURL(e$1, t$1, r$1) : this.style.loadJSON(e$1, t$1, r$1), this) : (null === (o$1 = null === (i$1 = this.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === o$1 || o$1.destroy(), delete this.style, this);
				}
				_lazyInitEmptyStyle() {
					this.style || (this.style = new wi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
				}
				_diffStyle(e$1, i$1) {
					if ("string" == typeof e$1) {
						const o$1 = this._requestManager.transformRequest(e$1, "Style");
						t.j(o$1, new AbortController()).then(((e$2) => {
							this._updateDiff(e$2.data, i$1);
						})).catch(((e$2) => {
							e$2 && this.fire(new t.k(e$2));
						}));
					} else "object" == typeof e$1 && this._updateDiff(e$1, i$1);
				}
				_updateDiff(e$1, i$1) {
					try {
						this.style.setState(e$1, i$1) && this._update(!0);
					} catch (o$1) {
						t.w(`Unable to perform style diff: ${o$1.message || o$1.error || o$1}.  Rebuilding the style from scratch.`), this._updateStyle(e$1, i$1);
					}
				}
				getStyle() {
					if (this.style) return this.style.serialize();
				}
				isStyleLoaded() {
					return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
				}
				addSource(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addSource(e$1, t$1), this._update(!0);
				}
				isSourceLoaded(e$1) {
					const i$1 = this.style && this.style.sourceCaches[e$1];
					if (void 0 !== i$1) return i$1.loaded();
					this.fire(new t.k(/* @__PURE__ */ new Error(`There is no source with ID '${e$1}'`)));
				}
				setTerrain(e$1) {
					if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e$1) {
						const i$1 = this.style.sourceCaches[e$1.source];
						if (!i$1) throw new Error(`cannot load terrain, because there exists no source with ID: ${e$1.source}`);
						null === this.terrain && i$1.reload();
						for (const i$2 in this.style._layers) {
							const o$1 = this.style._layers[i$2];
							"hillshade" === o$1.type && o$1.source === e$1.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === o$1.type && o$1.source === e$1.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
						}
						this.terrain = new Ba$1(this.painter, i$1, e$1), this.painter.renderToTexture = new Na$1(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t$1) => {
							var i$2;
							"style" === t$1.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t$1.dataType && t$1.tile && (t$1.sourceId !== e$1.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i$2 = t$1.source) || void 0 === i$2 ? void 0 : i$2.type) ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t$1.tile.tileID));
						}, this.style.on("data", this._terrainDataCallback);
					} else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
					return this.fire(new t.l("terrain", { terrain: e$1 })), this;
				}
				getTerrain() {
					var e$1, t$1;
					return null !== (t$1 = null === (e$1 = this.terrain) || void 0 === e$1 ? void 0 : e$1.options) && void 0 !== t$1 ? t$1 : null;
				}
				areTilesLoaded() {
					const e$1 = this.style && this.style.sourceCaches;
					for (const t$1 in e$1) {
						const i$1 = e$1[t$1]._tiles;
						for (const e$2 in i$1) {
							const t$2 = i$1[e$2];
							if ("loaded" !== t$2.state && "errored" !== t$2.state) return !1;
						}
					}
					return !0;
				}
				removeSource(e$1) {
					return this.style.removeSource(e$1), this._update(!0);
				}
				getSource(e$1) {
					return this.style.getSource(e$1);
				}
				setSourceTileLodParams(e$1, t$1, i$1) {
					if (i$1) {
						const o$1 = this.getSource(i$1);
						if (!o$1) throw new Error(`There is no source with ID "${i$1}", cannot set LOD parameters`);
						o$1.calculateTileZoom = me$1(Math.max(1, e$1), Math.max(1, t$1));
					} else for (const i$2 in this.style.sourceCaches) this.style.sourceCaches[i$2].getSource().calculateTileZoom = me$1(Math.max(1, e$1), Math.max(1, t$1));
					return this._update(!0), this;
				}
				refreshTiles(e$1, i$1) {
					const o$1 = this.style.sourceCaches[e$1];
					if (!o$1) throw new Error(`There is no source cache with ID "${e$1}", cannot refresh tile`);
					void 0 === i$1 ? o$1.reload(!0) : o$1.refreshTiles(i$1.map(((e$2) => new t.a4(e$2.z, e$2.x, e$2.y))));
				}
				addImage(e$1, i$1, o$1 = {}) {
					const { pixelRatio: r$1 = 1, sdf: a$1 = !1, stretchX: n$1, stretchY: l$1, content: c$1, textFitWidth: h$1, textFitHeight: u$1 } = o$1;
					if (this._lazyInitEmptyStyle(), !(i$1 instanceof HTMLImageElement || t.b(i$1))) {
						if (void 0 === i$1.width || void 0 === i$1.height) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						{
							const { width: o$2, height: s$1, data: d$1 } = i$1, _$2 = i$1;
							return this.style.addImage(e$1, {
								data: new t.R({
									width: o$2,
									height: s$1
								}, new Uint8Array(d$1)),
								pixelRatio: r$1,
								stretchX: n$1,
								stretchY: l$1,
								content: c$1,
								textFitWidth: h$1,
								textFitHeight: u$1,
								sdf: a$1,
								version: 0,
								userImage: _$2
							}), _$2.onAdd && _$2.onAdd(this, e$1), this;
						}
					}
					{
						const { width: o$2, height: d$1, data: _$2 } = s.getImageData(i$1);
						this.style.addImage(e$1, {
							data: new t.R({
								width: o$2,
								height: d$1
							}, _$2),
							pixelRatio: r$1,
							stretchX: n$1,
							stretchY: l$1,
							content: c$1,
							textFitWidth: h$1,
							textFitHeight: u$1,
							sdf: a$1,
							version: 0
						});
					}
				}
				updateImage(e$1, i$1) {
					const o$1 = this.style.getImage(e$1);
					if (!o$1) return this.fire(new t.k(/* @__PURE__ */ new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
					const { width: a$1, height: n$1, data: l$1 } = i$1 instanceof HTMLImageElement || t.b(i$1) ? s.getImageData(i$1) : i$1;
					if (void 0 === a$1 || void 0 === n$1) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
					if (a$1 !== o$1.data.width || n$1 !== o$1.data.height) return this.fire(new t.k(/* @__PURE__ */ new Error("The width and height of the updated image must be that same as the previous version of the image")));
					const c$1 = !(i$1 instanceof HTMLImageElement || t.b(i$1));
					return o$1.data.replace(l$1, c$1), this.style.updateImage(e$1, o$1), this;
				}
				getImage(e$1) {
					return this.style.getImage(e$1);
				}
				hasImage(e$1) {
					return e$1 ? !!this.style.getImage(e$1) : (this.fire(new t.k(/* @__PURE__ */ new Error("Missing required image id"))), !1);
				}
				removeImage(e$1) {
					this.style.removeImage(e$1);
				}
				loadImage(e$1) {
					return p.getImage(this._requestManager.transformRequest(e$1, "Image"), new AbortController());
				}
				listImages() {
					return this.style.listImages();
				}
				addLayer(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addLayer(e$1, t$1), this._update(!0);
				}
				moveLayer(e$1, t$1) {
					return this.style.moveLayer(e$1, t$1), this._update(!0);
				}
				removeLayer(e$1) {
					return this.style.removeLayer(e$1), this._update(!0);
				}
				getLayer(e$1) {
					return this.style.getLayer(e$1);
				}
				getLayersOrder() {
					return this.style.getLayersOrder();
				}
				setLayerZoomRange(e$1, t$1, i$1) {
					return this.style.setLayerZoomRange(e$1, t$1, i$1), this._update(!0);
				}
				setFilter(e$1, t$1, i$1 = {}) {
					return this.style.setFilter(e$1, t$1, i$1), this._update(!0);
				}
				getFilter(e$1) {
					return this.style.getFilter(e$1);
				}
				setPaintProperty(e$1, t$1, i$1, o$1 = {}) {
					return this.style.setPaintProperty(e$1, t$1, i$1, o$1), this._update(!0);
				}
				getPaintProperty(e$1, t$1) {
					return this.style.getPaintProperty(e$1, t$1);
				}
				setLayoutProperty(e$1, t$1, i$1, o$1 = {}) {
					return this.style.setLayoutProperty(e$1, t$1, i$1, o$1), this._update(!0);
				}
				getLayoutProperty(e$1, t$1) {
					return this.style.getLayoutProperty(e$1, t$1);
				}
				setGlyphs(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setGlyphs(e$1, t$1), this._update(!0);
				}
				getGlyphs() {
					return this.style.getGlyphsUrl();
				}
				addSprite(e$1, t$1, i$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.addSprite(e$1, t$1, i$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				removeSprite(e$1) {
					return this._lazyInitEmptyStyle(), this.style.removeSprite(e$1), this._update(!0);
				}
				getSprite() {
					return this.style.getSprite();
				}
				setSprite(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSprite(e$1, t$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				setLight(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setLight(e$1, t$1), this._update(!0);
				}
				getLight() {
					return this.style.getLight();
				}
				setSky(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSky(e$1, t$1), this._update(!0);
				}
				getSky() {
					return this.style.getSky();
				}
				setFeatureState(e$1, t$1) {
					return this.style.setFeatureState(e$1, t$1), this._update();
				}
				removeFeatureState(e$1, t$1) {
					return this.style.removeFeatureState(e$1, t$1), this._update();
				}
				getFeatureState(e$1) {
					return this.style.getFeatureState(e$1);
				}
				getContainer() {
					return this._container;
				}
				getCanvasContainer() {
					return this._canvasContainer;
				}
				getCanvas() {
					return this._canvas;
				}
				_containerDimensions() {
					let e$1 = 0, t$1 = 0;
					return this._container && (e$1 = this._container.clientWidth || 400, t$1 = this._container.clientHeight || 300), [e$1, t$1];
				}
				_setupContainer() {
					const e$1 = this._container;
					e$1.classList.add("maplibregl-map");
					const t$1 = this._canvasContainer = n.create("div", "maplibregl-canvas-container", e$1);
					this._interactive && t$1.classList.add("maplibregl-interactive"), this._canvas = n.create("canvas", "maplibregl-canvas", t$1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
					const i$1 = this._containerDimensions(), o$1 = this._getClampedPixelRatio(i$1[0], i$1[1]);
					this._resizeCanvas(i$1[0], i$1[1], o$1);
					const r$1 = this._controlContainer = n.create("div", "maplibregl-control-container", e$1), a$1 = this._controlPositions = {};
					[
						"top-left",
						"top-right",
						"bottom-left",
						"bottom-right"
					].forEach(((e$2) => {
						a$1[e$2] = n.create("div", `maplibregl-ctrl-${e$2} `, r$1);
					})), this._container.addEventListener("scroll", this._onMapScroll, !1);
				}
				_resizeCanvas(e$1, t$1, i$1) {
					this._canvas.width = Math.floor(i$1 * e$1), this._canvas.height = Math.floor(i$1 * t$1), this._canvas.style.width = `${e$1}px`, this._canvas.style.height = `${t$1}px`;
				}
				_setupPainter() {
					const e$1 = Object.assign(Object.assign({}, this._canvasContextAttributes), {
						alpha: !0,
						depth: !0,
						stencil: !0,
						premultipliedAlpha: !0
					});
					let t$1 = null;
					this._canvas.addEventListener("webglcontextcreationerror", ((i$2) => {
						t$1 = { requestedAttributes: e$1 }, i$2 && (t$1.statusMessage = i$2.statusMessage, t$1.type = i$2.type);
					}), { once: !0 });
					let i$1 = null;
					if (i$1 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e$1) : this._canvas.getContext("webgl2", e$1) || this._canvas.getContext("webgl", e$1), !i$1) {
						const e$2 = "Failed to initialize WebGL";
						throw t$1 ? (t$1.message = e$2, new Error(JSON.stringify(t$1))) : new Error(e$2);
					}
					this.painter = new Mr$1(i$1, this.transform), l.testSupport(i$1);
				}
				migrateProjection(e$1, i$1) {
					super.migrateProjection(e$1, i$1), this.painter.transform = e$1, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
				}
				loaded() {
					return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
				}
				_update(e$1) {
					return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e$1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
				}
				_requestRenderFrame(e$1) {
					return this._update(), this._renderTaskQueue.add(e$1);
				}
				_cancelRenderFrame(e$1) {
					this._renderTaskQueue.remove(e$1);
				}
				_render(e$1) {
					var i$1, o$1, r$1, a$1, n$1;
					const l$1 = this._idleTriggered ? this._fadeDuration : 0, c$1 = (null === (i$1 = this.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0;
					if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e$1), this._removed) return;
					let h$1 = !1;
					if (this.style && this._styleDirty) {
						this._styleDirty = !1;
						const e$2 = this.transform.zoom, i$2 = s.now();
						this.style.zoomHistory.update(e$2, i$2);
						const o$2 = new t.F(e$2, {
							now: i$2,
							fadeDuration: l$1,
							zoomHistory: this.style.zoomHistory,
							transition: this.style.getTransition(),
							globalState: this.style.getGlobalState()
						}), r$2 = o$2.crossFadingFactor();
						1 === r$2 && r$2 === this._crossFadingFactor || (h$1 = !0, this._crossFadingFactor = r$2), this.style.update(o$2);
					}
					const u$1 = (null === (o$1 = this.style.projection) || void 0 === o$1 ? void 0 : o$1.transitionState) > 0 !== c$1;
					null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (a$1 = this.style.projection) || void 0 === a$1 ? void 0 : a$1.transitionState, null === (n$1 = this.style.projection) || void 0 === n$1 ? void 0 : n$1.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u$1) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l$1, this._crossSourceCollisions, u$1), this.painter.render(this.style, {
						showTileBoundaries: this.showTileBoundaries,
						showOverdrawInspector: this._showOverdrawInspector,
						rotating: this.isRotating(),
						zooming: this.isZooming(),
						moving: this.isMoving(),
						fadeDuration: l$1,
						showPadding: this.showPadding
					}), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cw.mark(t.cx.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h$1) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
					const d$1 = this._sourcesDirty || this._styleDirty || this._placementDirty;
					return d$1 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d$1 || (this._fullyLoaded = !0, t.cw.mark(t.cx.fullLoad)), this;
				}
				redraw() {
					return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
				}
				remove() {
					var e$1;
					this._hash && this._hash.remove();
					for (const e$2 of this._controls) e$2.onRemove(this);
					this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, !1), p.removeThrottleControl(this._imageQueueHandle), null === (e$1 = this._resizeObserver) || void 0 === e$1 || e$1.disconnect();
					const i$1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
					null != i$1 && i$1.loseContext && i$1.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), n.remove(this._canvasContainer), n.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cw.clearMetrics(), this._removed = !0, this.fire(new t.l("remove"));
				}
				triggerRepaint() {
					this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s.frame(this._frameRequest, ((e$1) => {
						t.cw.frame(e$1), this._frameRequest = null;
						try {
							this._render(e$1);
						} catch (e$2) {
							if (!t.cy(e$2) && !function(e$3) {
								return e$3.message === qo$1;
							}(e$2)) throw e$2;
						}
					}), (() => {})));
				}
				get showTileBoundaries() {
					return !!this._showTileBoundaries;
				}
				set showTileBoundaries(e$1) {
					this._showTileBoundaries !== e$1 && (this._showTileBoundaries = e$1, this._update());
				}
				get showPadding() {
					return !!this._showPadding;
				}
				set showPadding(e$1) {
					this._showPadding !== e$1 && (this._showPadding = e$1, this._update());
				}
				get showCollisionBoxes() {
					return !!this._showCollisionBoxes;
				}
				set showCollisionBoxes(e$1) {
					this._showCollisionBoxes !== e$1 && (this._showCollisionBoxes = e$1, e$1 ? this.style._generateCollisionBoxes() : this._update());
				}
				get showOverdrawInspector() {
					return !!this._showOverdrawInspector;
				}
				set showOverdrawInspector(e$1) {
					this._showOverdrawInspector !== e$1 && (this._showOverdrawInspector = e$1, this._update());
				}
				get repaint() {
					return !!this._repaint;
				}
				set repaint(e$1) {
					this._repaint !== e$1 && (this._repaint = e$1, this.triggerRepaint());
				}
				get vertices() {
					return !!this._vertices;
				}
				set vertices(e$1) {
					this._vertices = e$1, this._update();
				}
				get version() {
					return Za$1;
				}
				getCameraTargetElevation() {
					return this.transform.elevation;
				}
				getProjection() {
					return this.style.getProjection();
				}
				setProjection(e$1) {
					return this._lazyInitEmptyStyle(), this.style.setProjection(e$1), this._update(!0);
				}
			}, e.MapMouseEvent = jr$1, e.MapTouchEvent = Nr$1, e.MapWheelEvent = Ur$1, e.Marker = Ka$1, e.NavigationControl = class {
				constructor(e$1) {
					this._updateZoomButtons = () => {
						const e$2 = this._map.getZoom(), t$1 = e$2 === this._map.getMaxZoom(), i$1 = e$2 === this._map.getMinZoom();
						this._zoomInButton.disabled = t$1, this._zoomOutButton.disabled = i$1, this._zoomInButton.setAttribute("aria-disabled", t$1.toString()), this._zoomOutButton.setAttribute("aria-disabled", i$1.toString());
					}, this._rotateCompassArrow = () => {
						this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
					}, this._setButtonTitle = (e$2, t$1) => {
						const i$1 = this._map._getUIString(`NavigationControl.${t$1}`);
						e$2.title = i$1, e$2.setAttribute("aria-label", i$1);
					}, this.options = t.e({}, Va$1, e$1), this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e$2) => this._map.zoomIn({}, { originalEvent: e$2 }))), n.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e$2) => this._map.zoomOut({}, { originalEvent: e$2 }))), n.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e$2) => {
						this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e$2 }) : this._map.resetNorth({}, { originalEvent: e$2 });
					})), this._compassIcon = n.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
				}
				onAdd(e$1) {
					return this._map = e$1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new $a$1(this._map, this._compass, this.options.visualizePitch)), this._container;
				}
				onRemove() {
					n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
				}
				_createButton(e$1, t$1) {
					const i$1 = n.create("button", e$1, this._container);
					return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
				}
			}, e.Popup = class extends t.E {
				constructor(e$1) {
					super(), this._updateOpacity = () => {
						void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
					}, this.remove = () => (this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e$2) => {
						this._update(e$2.point);
					}, this._onMouseMove = (e$2) => {
						this._update(e$2.point);
					}, this._onDrag = (e$2) => {
						this._update(e$2.point);
					}, this._update = (e$2) => {
						if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
						if (!this._container) {
							if (this._container = n.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e$3 of this.options.className.split(" ")) this._container.classList.add(e$3);
							this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
						}
						if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Wa$1(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e$2) return;
						const t$1 = this._flatPos = this._pos = this._trackPointer && e$2 ? e$2 : this._map.project(this._lngLat);
						this._map.terrain && (this._flatPos = this._trackPointer && e$2 ? e$2 : this._map.transform.locationToScreenPoint(this._lngLat));
						let i$1 = this.options.anchor;
						const o$1 = as$1(this.options.offset);
						if (!i$1) {
							const e$3 = this._container.offsetWidth, r$2 = this._container.offsetHeight;
							let a$1;
							a$1 = t$1.y + o$1.bottom.y < r$2 ? ["top"] : t$1.y > this._map.transform.height - r$2 ? ["bottom"] : [], t$1.x < e$3 / 2 ? a$1.push("left") : t$1.x > this._map.transform.width - e$3 / 2 && a$1.push("right"), i$1 = 0 === a$1.length ? "bottom" : a$1.join("-");
						}
						let r$1 = t$1.add(o$1[i$1]);
						this.options.subpixelPositioning || (r$1 = r$1.round()), n.setTransform(this._container, `${Ha$1[i$1]} translate(${r$1.x}px,${r$1.y}px)`), Xa$1(this._container, i$1, "popup"), this._updateOpacity();
					}, this._onClose = () => {
						this.remove();
					}, this.options = t.e(Object.create(os$1), e$1);
				}
				addTo(e$1) {
					return this._map && this.remove(), this._map = e$1, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
				}
				isOpen() {
					return !!this._map;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.S.convert(e$1), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
				}
				trackPointer() {
					return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
				}
				getElement() {
					return this._container;
				}
				setText(e$1) {
					return this.setDOMContent(document.createTextNode(e$1));
				}
				setHTML(e$1) {
					const t$1 = document.createDocumentFragment(), i$1 = document.createElement("body");
					let o$1;
					for (i$1.innerHTML = e$1; o$1 = i$1.firstChild, o$1;) t$1.appendChild(o$1);
					return this.setDOMContent(t$1);
				}
				getMaxWidth() {
					var e$1;
					return null === (e$1 = this._container) || void 0 === e$1 ? void 0 : e$1.style.maxWidth;
				}
				setMaxWidth(e$1) {
					return this.options.maxWidth = e$1, this._update(), this;
				}
				setDOMContent(e$1) {
					if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
					else this._content = n.create("div", "maplibregl-popup-content", this._container);
					return this._content.appendChild(e$1), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
				}
				addClassName(e$1) {
					return this._container && this._container.classList.add(e$1), this;
				}
				removeClassName(e$1) {
					return this._container && this._container.classList.remove(e$1), this;
				}
				setOffset(e$1) {
					return this.options.offset = e$1, this._update(), this;
				}
				toggleClassName(e$1) {
					if (this._container) return this._container.classList.toggle(e$1);
				}
				setSubpixelPositioning(e$1) {
					this.options.subpixelPositioning = e$1;
				}
				_createCloseButton() {
					this.options.closeButton && (this._closeButton = n.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
				}
				_focusFirstElement() {
					if (!this.options.focusAfterOpen || !this._container) return;
					const e$1 = this._container.querySelector(rs$1);
					e$1 && e$1.focus();
				}
			}, e.RasterDEMTileSource = W$1, e.RasterTileSource = q$1, e.ScaleControl = class {
				constructor(e$1) {
					this._onMove = () => {
						ts$1(this._map, this._container, this.options);
					}, this.setUnit = (e$2) => {
						this.options.unit = e$2, ts$1(this._map, this._container, this.options);
					}, this.options = Object.assign(Object.assign({}, es$1), e$1);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e$1.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
				}
			}, e.ScrollZoomHandler = va$1, e.Style = wi, e.TerrainControl = class {
				constructor(e$1) {
					this._toggleTerrain = () => {
						this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
					}, this._updateTerrainIcon = () => {
						this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
					}, this.options = e$1;
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n.create("button", "maplibregl-ctrl-terrain", this._container), n.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
				}
			}, e.TwoFingersTouchPitchHandler = da$1, e.TwoFingersTouchRotateHandler = ha$1, e.TwoFingersTouchZoomHandler = la$1, e.TwoFingersTouchZoomRotateHandler = Pa$1, e.VectorTileSource = $$1, e.VideoSource = K$1, e.addSourceType = (e$1, i$1) => t._(void 0, void 0, void 0, (function* () {
				if (J$1(e$1)) throw new Error(`A source type called "${e$1}" already exists.`);
				((e$2, t$1) => {
					Q$1[e$2] = t$1;
				})(e$1, i$1);
			})), e.clearPrewarmedResources = function() {
				const e$1 = A;
				e$1 && (e$1.isPreloaded() && 1 === e$1.numActive() ? (e$1.release(R$2), A = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, e.createTileMesh = Xt$1, e.getMaxParallelImageRequests = function() {
				return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
			}, e.getRTLTextPluginStatus = function() {
				return oe$1().getRTLTextPluginStatus();
			}, e.getVersion = function() {
				return ss$1;
			}, e.getWorkerCount = function() {
				return z$1.workerCount;
			}, e.getWorkerUrl = function() {
				return t.a.WORKER_URL;
			}, e.importScriptInWorkers = function(e$1) {
				return B$1().broadcast("IS", e$1);
			}, e.prewarm = function() {
				k$1().acquire(R$2);
			}, e.setMaxParallelImageRequests = function(e$1) {
				t.a.MAX_PARALLEL_IMAGE_REQUESTS = e$1;
			}, e.setRTLTextPlugin = function(e$1, t$1) {
				return oe$1().setRTLTextPlugin(e$1, t$1);
			}, e.setWorkerCount = function(e$1) {
				z$1.workerCount = e$1;
			}, e.setWorkerUrl = function(e$1) {
				t.a.WORKER_URL = e$1;
			};
		}));
		return maplibregl;
	}));
}) });

//#endregion
//#region node_modules/.pnpm/js-base64@3.7.8/node_modules/js-base64/base64.mjs
var import_maplibre_gl = /* @__PURE__ */ __toESM(require_maplibre_gl(), 1);
/**
*  base64.ts
*
*  Licensed under the BSD 3-Clause License.
*    http://opensource.org/licenses/BSD-3-Clause
*
*  References:
*    http://en.wikipedia.org/wiki/Base64
*
* @author Dan Kogai (https://github.com/dankogai)
*/
var version = "3.7.8";
/**
* @deprecated use lowercase `version`.
*/
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64chs = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
var b64tab = ((a) => {
	let tab = {};
	a.forEach((c, i) => tab[c] = i);
	return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it$1) => new Uint8Array(Array.prototype.slice.call(it$1, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
/**
* polyfill version of `btoa`
*/
var btoaPolyfill = (bin) => {
	let u32, c0, c1, c2, asc = "";
	const pad = bin.length % 3;
	for (let i = 0; i < bin.length;) {
		if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError("invalid character found");
		u32 = c0 << 16 | c1 << 8 | c2;
		asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
	}
	return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
* does what `window.btoa` of web browsers do.
* @param {String} bin binary string
* @returns {string} Base64-encoded string
*/
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
	const maxargs = 4096;
	let strs = [];
	for (let i = 0, l = u8a.length; i < l; i += maxargs) strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
	return _btoa(strs.join(""));
};
/**
* converts a Uint8Array to a Base64 string.
* @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
* @returns {string} Base64 string
*/
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
	if (c.length < 2) {
		var cc$1 = c.charCodeAt(0);
		return cc$1 < 128 ? c : cc$1 < 2048 ? _fromCC(192 | cc$1 >>> 6) + _fromCC(128 | cc$1 & 63) : _fromCC(224 | cc$1 >>> 12 & 15) + _fromCC(128 | cc$1 >>> 6 & 63) + _fromCC(128 | cc$1 & 63);
	} else {
		var cc$1 = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
		return _fromCC(240 | cc$1 >>> 18 & 7) + _fromCC(128 | cc$1 >>> 12 & 63) + _fromCC(128 | cc$1 >>> 6 & 63) + _fromCC(128 | cc$1 & 63);
	}
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
* @deprecated should have been internal use only.
* @param {string} src UTF-8 string
* @returns {string} UTF-16 string
*/
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
/**
* converts a UTF-8-encoded string to a Base64 string.
* @param {boolean} [urlsafe] if `true` make the result URL-safe
* @returns {string} Base64 string
*/
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
/**
* converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
* @returns {string} Base64 string
*/
var encodeURI = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
	switch (cccc.length) {
		case 4:
			var offset = ((7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3)) - 65536;
			return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
		case 3: return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
		default: return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
	}
};
/**
* @deprecated should have been internal use only.
* @param {string} src UTF-16 string
* @returns {string} UTF-8 string
*/
var btou = (b$1) => b$1.replace(re_btou, cb_btou);
/**
* polyfill version of `atob`
*/
var atobPolyfill = (asc) => {
	asc = asc.replace(/\s+/g, "");
	if (!b64re.test(asc)) throw new TypeError("malformed base64.");
	asc += "==".slice(2 - (asc.length & 3));
	let u24, r1, r2;
	let binArray = [];
	for (let i = 0; i < asc.length;) {
		u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
		if (r1 === 64) binArray.push(_fromCC(u24 >> 16 & 255));
		else if (r2 === 64) binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
		else binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
	}
	return binArray.join("");
};
/**
* does what `window.atob` of web browsers do.
* @param {String} asc Base64-encoded string
* @returns {string} binary string
*/
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
/**
* converts a Base64 string to a Uint8Array.
*/
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
/**
* converts a Base64 string to a UTF-8 string.
* @param {String} src Base64 string.  Both normal and URL-safe are supported
* @returns {string} UTF-8 string
*/
var decode = (src) => _decode(_unURI(src));
/**
* check if a value is a valid Base64 string
* @param {String} src a value to check
*/
var isValid = (src) => {
	if (typeof src !== "string") return false;
	const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
	return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
	return {
		value: v,
		enumerable: false,
		writable: true,
		configurable: true
	};
};
/**
* extend String.prototype with relevant methods
*/
var extendString = function() {
	const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
	_add("fromBase64", function() {
		return decode(this);
	});
	_add("toBase64", function(urlsafe) {
		return encode(this, urlsafe);
	});
	_add("toBase64URI", function() {
		return encode(this, true);
	});
	_add("toBase64URL", function() {
		return encode(this, true);
	});
	_add("toUint8Array", function() {
		return toUint8Array(this);
	});
};
/**
* extend Uint8Array.prototype with relevant methods
*/
var extendUint8Array = function() {
	const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
	_add("toBase64", function(urlsafe) {
		return fromUint8Array(this, urlsafe);
	});
	_add("toBase64URI", function() {
		return fromUint8Array(this, true);
	});
	_add("toBase64URL", function() {
		return fromUint8Array(this, true);
	});
};
/**
* extend Builtin prototypes with relevant methods
*/
var extendBuiltins = () => {
	extendString();
	extendUint8Array();
};
var gBase64 = {
	version,
	VERSION,
	atob: _atob,
	atobPolyfill,
	btoa: _btoa,
	btoaPolyfill,
	fromBase64: decode,
	toBase64: encode,
	encode,
	encodeURI,
	encodeURL: encodeURI,
	utob,
	btou,
	decode,
	isValid,
	fromUint8Array,
	toUint8Array,
	extendString,
	extendUint8Array,
	extendBuiltins
};

//#endregion
//#region node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/events@3.3.0/node_modules/events/events.js": ((exports, module) => {
	var R$1 = typeof Reflect === "object" ? Reflect : null;
	var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply$1(target, receiver, args) {
		return Function.prototype.apply.call(target, receiver, args);
	};
	var ReflectOwnKeys;
	if (R$1 && typeof R$1.ownKeys === "function") ReflectOwnKeys = R$1.ownKeys;
	else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
	};
	else ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target);
	};
	function ProcessEmitWarning(warning) {
		if (console && console.warn) console.warn(warning);
	}
	var NumberIsNaN = Number.isNaN || function NumberIsNaN$1(value) {
		return value !== value;
	};
	function EventEmitter() {
		EventEmitter.init.call(this);
	}
	module.exports = EventEmitter;
	module.exports.once = once;
	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.prototype._events = void 0;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = void 0;
	var defaultMaxListeners = 10;
	function checkListener(listener) {
		if (typeof listener !== "function") throw new TypeError("The \"listener\" argument must be of type Function. Received type " + typeof listener);
	}
	Object.defineProperty(EventEmitter, "defaultMaxListeners", {
		enumerable: true,
		get: function() {
			return defaultMaxListeners;
		},
		set: function(arg) {
			if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError("The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received " + arg + ".");
			defaultMaxListeners = arg;
		}
	});
	EventEmitter.init = function() {
		if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
			this._events = Object.create(null);
			this._eventsCount = 0;
		}
		this._maxListeners = this._maxListeners || void 0;
	};
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
		if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError("The value of \"n\" is out of range. It must be a non-negative number. Received " + n + ".");
		this._maxListeners = n;
		return this;
	};
	function _getMaxListeners(that) {
		if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
		return that._maxListeners;
	}
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		return _getMaxListeners(this);
	};
	EventEmitter.prototype.emit = function emit(type) {
		var args = [];
		for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
		var doError = type === "error";
		var events = this._events;
		if (events !== void 0) doError = doError && events.error === void 0;
		else if (!doError) return false;
		if (doError) {
			var er$1;
			if (args.length > 0) er$1 = args[0];
			if (er$1 instanceof Error) throw er$1;
			var err = /* @__PURE__ */ new Error("Unhandled error." + (er$1 ? " (" + er$1.message + ")" : ""));
			err.context = er$1;
			throw err;
		}
		var handler = events[type];
		if (handler === void 0) return false;
		if (typeof handler === "function") ReflectApply(handler, this, args);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
		}
		return true;
	};
	function _addListener(target, type, listener, prepend) {
		var m;
		var events;
		var existing;
		checkListener(listener);
		events = target._events;
		if (events === void 0) {
			events = target._events = Object.create(null);
			target._eventsCount = 0;
		} else {
			if (events.newListener !== void 0) {
				target.emit("newListener", type, listener.listener ? listener.listener : listener);
				events = target._events;
			}
			existing = events[type];
		}
		if (existing === void 0) {
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === "function") existing = events[type] = prepend ? [listener, existing] : [existing, listener];
			else if (prepend) existing.unshift(listener);
			else existing.push(listener);
			m = _getMaxListeners(target);
			if (m > 0 && existing.length > m && !existing.warned) {
				existing.warned = true;
				var w = /* @__PURE__ */ new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
				w.name = "MaxListenersExceededWarning";
				w.emitter = target;
				w.type = type;
				w.count = existing.length;
				ProcessEmitWarning(w);
			}
		}
		return target;
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	EventEmitter.prototype.prependListener = function prependListener(type, listener) {
		return _addListener(this, type, listener, true);
	};
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			if (arguments.length === 0) return this.listener.call(this.target);
			return this.listener.apply(this.target, arguments);
		}
	}
	function _onceWrap(target, type, listener) {
		var state = {
			fired: false,
			wrapFn: void 0,
			target,
			type,
			listener
		};
		var wrapped = onceWrapper.bind(state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	EventEmitter.prototype.once = function once$1(type, listener) {
		checkListener(listener);
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
		checkListener(listener);
		this.prependListener(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.removeListener = function removeListener(type, listener) {
		var list, events, position, i, originalListener;
		checkListener(listener);
		events = this._events;
		if (events === void 0) return this;
		list = events[type];
		if (list === void 0) return this;
		if (list === listener || list.listener === listener) if (--this._eventsCount === 0) this._events = Object.create(null);
		else {
			delete events[type];
			if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
		}
		else if (typeof list !== "function") {
			position = -1;
			for (i = list.length - 1; i >= 0; i--) if (list[i] === listener || list[i].listener === listener) {
				originalListener = list[i].listener;
				position = i;
				break;
			}
			if (position < 0) return this;
			if (position === 0) list.shift();
			else spliceOne(list, position);
			if (list.length === 1) events[type] = list[0];
			if (events.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
		}
		return this;
	};
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
		var listeners, events = this._events, i;
		if (events === void 0) return this;
		if (events.removeListener === void 0) {
			if (arguments.length === 0) {
				this._events = Object.create(null);
				this._eventsCount = 0;
			} else if (events[type] !== void 0) if (--this._eventsCount === 0) this._events = Object.create(null);
			else delete events[type];
			return this;
		}
		if (arguments.length === 0) {
			var keys = Object.keys(events);
			var key;
			for (i = 0; i < keys.length; ++i) {
				key = keys[i];
				if (key === "removeListener") continue;
				this.removeAllListeners(key);
			}
			this.removeAllListeners("removeListener");
			this._events = Object.create(null);
			this._eventsCount = 0;
			return this;
		}
		listeners = events[type];
		if (typeof listeners === "function") this.removeListener(type, listeners);
		else if (listeners !== void 0) for (i = listeners.length - 1; i >= 0; i--) this.removeListener(type, listeners[i]);
		return this;
	};
	function _listeners(target, type, unwrap) {
		var events = target._events;
		if (events === void 0) return [];
		var evlistener = events[type];
		if (evlistener === void 0) return [];
		if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
		return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}
	EventEmitter.prototype.listeners = function listeners(type) {
		return _listeners(this, type, true);
	};
	EventEmitter.prototype.rawListeners = function rawListeners(type) {
		return _listeners(this, type, false);
	};
	EventEmitter.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
		else return listenerCount.call(emitter, type);
	};
	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
		if (events !== void 0) {
			var evlistener = events[type];
			if (typeof evlistener === "function") return 1;
			else if (evlistener !== void 0) return evlistener.length;
		}
		return 0;
	}
	EventEmitter.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};
	function arrayClone(arr, n) {
		var copy = new Array(n);
		for (var i = 0; i < n; ++i) copy[i] = arr[i];
		return copy;
	}
	function spliceOne(list, index) {
		for (; index + 1 < list.length; index++) list[index] = list[index + 1];
		list.pop();
	}
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
		return ret;
	}
	function once(emitter, name) {
		return new Promise(function(resolve, reject) {
			function errorListener(err) {
				emitter.removeListener(name, resolver);
				reject(err);
			}
			function resolver() {
				if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
				resolve([].slice.call(arguments));
			}
			eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
			if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
		});
	}
	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
	}
	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		if (typeof emitter.on === "function") if (flags.once) emitter.once(name, listener);
		else emitter.on(name, listener);
		else if (typeof emitter.addEventListener === "function") emitter.addEventListener(name, function wrapListener(arg) {
			if (flags.once) emitter.removeEventListener(name, wrapListener);
			listener(arg);
		});
		else throw new TypeError("The \"emitter\" argument must be of type EventEmitter. Received type " + typeof emitter);
	}
}) });

//#endregion
//#region node_modules/.pnpm/quick-lru@7.3.0/node_modules/quick-lru/index.js
var import_events = /* @__PURE__ */ __toESM(require_events(), 1);
var QuickLRU = class extends Map {
	#size = 0;
	#cache = /* @__PURE__ */ new Map();
	#oldCache = /* @__PURE__ */ new Map();
	#maxSize;
	#maxAge;
	#onEviction;
	constructor(options = {}) {
		super();
		if (!(options.maxSize && options.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		if (typeof options.maxAge === "number" && options.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
		this.#maxSize = options.maxSize;
		this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
		this.#onEviction = options.onEviction;
	}
	get __oldCache() {
		return this.#oldCache;
	}
	#emitEvictions(cache) {
		if (typeof this.#onEviction !== "function") return;
		for (const [key, item] of cache) this.#onEviction(key, item.value);
	}
	#deleteIfExpired(key, item) {
		if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
			if (typeof this.#onEviction === "function") this.#onEviction(key, item.value);
			return this.delete(key);
		}
		return false;
	}
	#getOrDeleteIfExpired(key, item) {
		if (this.#deleteIfExpired(key, item) === false) return item.value;
	}
	#getItemValue(key, item) {
		return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
	}
	#peek(key, cache) {
		const item = cache.get(key);
		return this.#getItemValue(key, item);
	}
	#set(key, value) {
		this.#cache.set(key, value);
		this.#size++;
		if (this.#size >= this.#maxSize) {
			this.#size = 0;
			this.#emitEvictions(this.#oldCache);
			this.#oldCache = this.#cache;
			this.#cache = /* @__PURE__ */ new Map();
		}
	}
	#moveToRecent(key, item) {
		this.#oldCache.delete(key);
		this.#set(key, item);
	}
	*#entriesAscending() {
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield item;
			}
		}
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield item;
		}
	}
	get(key) {
		if (this.#cache.has(key)) {
			const item = this.#cache.get(key);
			return this.#getItemValue(key, item);
		}
		if (this.#oldCache.has(key)) {
			const item = this.#oldCache.get(key);
			if (this.#deleteIfExpired(key, item) === false) {
				this.#moveToRecent(key, item);
				return item.value;
			}
		}
	}
	set(key, value, { maxAge = this.#maxAge } = {}) {
		const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
		if (this.#cache.has(key)) this.#cache.set(key, {
			value,
			expiry
		});
		else this.#set(key, {
			value,
			expiry
		});
		return this;
	}
	has(key) {
		if (this.#cache.has(key)) return !this.#deleteIfExpired(key, this.#cache.get(key));
		if (this.#oldCache.has(key)) return !this.#deleteIfExpired(key, this.#oldCache.get(key));
		return false;
	}
	peek(key) {
		if (this.#cache.has(key)) return this.#peek(key, this.#cache);
		if (this.#oldCache.has(key)) return this.#peek(key, this.#oldCache);
	}
	expiresIn(key) {
		const item = this.#cache.get(key) ?? this.#oldCache.get(key);
		if (item) return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
	}
	delete(key) {
		const deleted = this.#cache.delete(key);
		if (deleted) this.#size--;
		return this.#oldCache.delete(key) || deleted;
	}
	clear() {
		this.#cache.clear();
		this.#oldCache.clear();
		this.#size = 0;
	}
	resize(newSize) {
		if (!(newSize && newSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		const items = [...this.#entriesAscending()];
		const removeCount = items.length - newSize;
		if (removeCount < 0) {
			this.#cache = new Map(items);
			this.#oldCache = /* @__PURE__ */ new Map();
			this.#size = items.length;
		} else {
			if (removeCount > 0) this.#emitEvictions(items.slice(0, removeCount));
			this.#oldCache = new Map(items.slice(removeCount));
			this.#cache = /* @__PURE__ */ new Map();
			this.#size = 0;
		}
		this.#maxSize = newSize;
	}
	evict(count = 1) {
		const requested = Number(count);
		if (!requested || requested <= 0) return;
		const items = [...this.#entriesAscending()];
		const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
		if (evictCount <= 0) return;
		this.#emitEvictions(items.slice(0, evictCount));
		this.#oldCache = new Map(items.slice(evictCount));
		this.#cache = /* @__PURE__ */ new Map();
		this.#size = 0;
	}
	*keys() {
		for (const [key] of this) yield key;
	}
	*values() {
		for (const [, value] of this) yield value;
	}
	*[Symbol.iterator]() {
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesDescending() {
		let items = [...this.#cache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		items = [...this.#oldCache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesAscending() {
		for (const [key, value] of this.#entriesAscending()) yield [key, value.value];
	}
	get size() {
		if (!this.#size) return this.#oldCache.size;
		let oldCacheSize = 0;
		for (const key of this.#oldCache.keys()) if (!this.#cache.has(key)) oldCacheSize++;
		return Math.min(this.#size + oldCacheSize, this.#maxSize);
	}
	get maxSize() {
		return this.#maxSize;
	}
	get maxAge() {
		return this.#maxAge;
	}
	entries() {
		return this.entriesAscending();
	}
	forEach(callbackFunction, thisArgument = this) {
		for (const [key, value] of this.entriesAscending()) callbackFunction.call(thisArgument, value, key, this);
	}
	get [Symbol.toStringTag]() {
		return "QuickLRU";
	}
	toString() {
		return `QuickLRU(${this.size}/${this.maxSize})`;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		return this.toString();
	}
};

//#endregion
//#region node_modules/.pnpm/@maptiler+client@2.6.0/node_modules/@maptiler/client/dist/maptiler-client.mjs
function tryGettingFetch() {
	if (typeof self !== "undefined") return fetch.bind(self);
	if (typeof global !== "undefined" && global.fetch) return global.fetch;
	return null;
}
var ClientConfig = class {
	constructor() {
		/**
		* MapTiler Cloud API key
		*/
		this._apiKey = "";
		/**
		* The fetch function. To be set if in Node < 18, otherwise
		* will be automatically resolved.
		*/
		this._fetch = tryGettingFetch();
		/**
		* Number of tiles to keep in cache
		*/
		this.tileCacheSize = 200;
	}
	/**
	* Set the MapTiler Cloud API key
	*/
	set apiKey(k$1) {
		this._apiKey = k$1;
	}
	/**
	* Get the MapTiler Cloud API key
	*/
	get apiKey() {
		return this._apiKey;
	}
	/**
	* Set a the custom fetch function to replace the default one
	*/
	set fetch(f) {
		this._fetch = f;
	}
	/**
	* Get the fetch fucntion
	*/
	get fetch() {
		return this._fetch;
	}
};
var config = new ClientConfig();
var NonISOLanguage = {
	AUTO: {
		code: null,
		flag: "auto",
		name: "Auto",
		latin: false,
		isMode: true,
		geocoding: true
	},
	LATIN: {
		code: "latin",
		flag: "name:latin",
		name: "Latin",
		latin: true,
		isMode: false,
		geocoding: false
	},
	NON_LATIN: {
		code: "nonlatin",
		flag: "name:nonlatin",
		name: "Non Latin",
		latin: false,
		isMode: false,
		geocoding: false
	},
	LOCAL: {
		code: null,
		flag: "name",
		name: "Local",
		latin: true,
		isMode: false,
		geocoding: false
	}
};
var ISOLanguage = {
	ALBANIAN: {
		code: "sq",
		flag: "name:sq",
		name: "Albanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	AMHARIC: {
		code: "am",
		flag: "name:am",
		name: "Amharic",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ARABIC: {
		code: "ar",
		flag: "name:ar",
		name: "Arabic",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ARMENIAN: {
		code: "hy",
		flag: "name:hy",
		name: "Armenian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	AZERBAIJANI: {
		code: "az",
		flag: "name:az",
		name: "Azerbaijani",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BASQUE: {
		code: "eu",
		flag: "name:eu",
		name: "Basque",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BELARUSIAN: {
		code: "be",
		flag: "name:be",
		name: "Belarusian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	BENGALI: {
		code: "bn",
		flag: "name:bn",
		name: "Bengali",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BOSNIAN: {
		code: "bs",
		flag: "name:bs",
		name: "Bosnian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BRETON: {
		code: "br",
		flag: "name:br",
		name: "Breton",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BULGARIAN: {
		code: "bg",
		flag: "bg",
		name: "Bulgarian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	CATALAN: {
		code: "ca",
		flag: "name:ca",
		name: "Catalan",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CHINESE: {
		code: "zh",
		flag: "name:zh",
		name: "Chinese",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TRADITIONAL_CHINESE: {
		code: "zh-Hant",
		flag: "name:zh-Hant",
		name: "Chinese (traditional)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	SIMPLIFIED_CHINESE: {
		code: "zh-Hans",
		flag: "name:zh-Hans",
		name: "Chinese (simplified)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	CORSICAN: {
		code: "co",
		flag: "name:co",
		name: "Corsican",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CROATIAN: {
		code: "hr",
		flag: "name:hr",
		name: "Croatian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CZECH: {
		code: "cs",
		flag: "name:cs",
		name: "Czech",
		latin: true,
		isMode: false,
		geocoding: true
	},
	DANISH: {
		code: "da",
		flag: "name:da",
		name: "Danish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	DUTCH: {
		code: "nl",
		flag: "name:nl",
		name: "Dutch",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GERMAN: {
		code: "de",
		flag: "name:de",
		name: "German",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GREEK: {
		code: "el",
		flag: "name:el",
		name: "Greek",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ENGLISH: {
		code: "en",
		flag: "name:en",
		name: "English",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ESPERANTO: {
		code: "eo",
		flag: "name:eo",
		name: "Esperanto",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ESTONIAN: {
		code: "et",
		flag: "name:et",
		name: "Estonian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FINNISH: {
		code: "fi",
		flag: "name:fi",
		name: "Finnish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FRENCH: {
		code: "fr",
		flag: "name:fr",
		name: "French",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FRISIAN: {
		code: "fy",
		flag: "name:fy",
		name: "Frisian (West)",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GEORGIAN: {
		code: "ka",
		flag: "name:ka",
		name: "Georgian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HEBREW: {
		code: "he",
		flag: "name:he",
		name: "Hebrew",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HINDI: {
		code: "hi",
		flag: "name:hi",
		name: "Hindi",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HUNGARIAN: {
		code: "hu",
		flag: "name:hu",
		name: "Hungarian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ICELANDIC: {
		code: "is",
		flag: "name:is",
		name: "Icelandic",
		latin: true,
		isMode: false,
		geocoding: true
	},
	INDONESIAN: {
		code: "id",
		flag: "name:id",
		name: "Indonesian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	IRISH: {
		code: "ga",
		flag: "name:ga",
		name: "Irish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ITALIAN: {
		code: "it",
		flag: "name:it",
		name: "Italian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	JAPANESE: {
		code: "ja",
		flag: "name:ja",
		name: "Japanese",
		latin: false,
		isMode: false,
		geocoding: true
	},
	JAPANESE_HIRAGANA: {
		code: "ja-Hira",
		flag: "name:ja-Hira",
		name: "Japanese Hiragana form",
		latin: false,
		isMode: false,
		geocoding: false
	},
	JAPANESE_2018: {
		code: "ja-Latn",
		flag: "name:ja-Latn",
		name: "Japanese (Latin 2018)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	JAPANESE_KANA: {
		code: "ja_kana",
		flag: "name:ja_kana",
		name: "Japanese (Kana)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	JAPANESE_LATIN: {
		code: "ja_rm",
		flag: "name:ja_rm",
		name: "Japanese (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	KANNADA: {
		code: "kn",
		flag: "name:kn",
		name: "Kannada",
		latin: true,
		isMode: false,
		geocoding: true
	},
	KAZAKH: {
		code: "kk",
		flag: "name:kk",
		name: "Kazakh",
		latin: false,
		isMode: false,
		geocoding: true
	},
	KOREAN: {
		code: "ko",
		flag: "name:ko",
		name: "Korean",
		latin: false,
		isMode: false,
		geocoding: true
	},
	KOREAN_LATIN: {
		code: "ko-Latn",
		flag: "name:ko-Latn",
		name: "Korean (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	KURDISH: {
		code: "ku",
		flag: "name:ku",
		name: "Kurdish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CLASSICAL_LATIN: {
		code: "la",
		flag: "name:la",
		name: "Latin",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LATVIAN: {
		code: "lv",
		flag: "name:lv",
		name: "Latvian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LITHUANIAN: {
		code: "lt",
		flag: "name:lt",
		name: "Lithuanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LUXEMBOURGISH: {
		code: "lb",
		flag: "name:lb",
		name: "Luxembourgish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	MACEDONIAN: {
		code: "mk",
		flag: "name:mk",
		name: "Macedonian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	MALAYALAM: {
		code: "ml",
		flag: "name:ml",
		name: "Malayalam",
		latin: false,
		isMode: false,
		geocoding: true
	},
	MALTESE: {
		code: "mt",
		flag: "name:mt",
		name: "Maltese",
		latin: true,
		isMode: false,
		geocoding: true
	},
	NORWEGIAN: {
		code: "no",
		flag: "name:no",
		name: "Norwegian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	OCCITAN: {
		code: "oc",
		flag: "name:oc",
		name: "Occitan",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PERSIAN: {
		code: "fa",
		flag: "name:fa",
		name: "Persian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	POLISH: {
		code: "pl",
		flag: "name:pl",
		name: "Polish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PORTUGUESE: {
		code: "pt",
		flag: "name:pt",
		name: "Portuguese",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PUNJABI: {
		code: "pa",
		flag: "name:pa",
		name: "Punjabi",
		latin: false,
		isMode: false,
		geocoding: true
	},
	WESTERN_PUNJABI: {
		code: "pnb",
		flag: "name:pnb",
		name: "Western Punjabi",
		latin: false,
		isMode: false,
		geocoding: false
	},
	ROMANIAN: {
		code: "ro",
		flag: "name:ro",
		name: "Romanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ROMANSH: {
		code: "rm",
		flag: "name:rm",
		name: "Romansh",
		latin: true,
		isMode: false,
		geocoding: true
	},
	RUSSIAN: {
		code: "ru",
		flag: "name:ru",
		name: "Russian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	SERBIAN_CYRILLIC: {
		code: "sr",
		flag: "name:sr",
		name: "Serbian (Cyrillic script)",
		latin: false,
		isMode: false,
		geocoding: true
	},
	SERBIAN_LATIN: {
		code: "sr-Latn",
		flag: "name:sr-Latn",
		name: "Serbian (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	SCOTTISH_GAELIC: {
		code: "gd",
		flag: "name:gd",
		name: "Scottish Gaelic",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SLOVAK: {
		code: "sk",
		flag: "name:sk",
		name: "Slovak",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SLOVENE: {
		code: "sl",
		flag: "name:sl",
		name: "Slovene",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SPANISH: {
		code: "es",
		flag: "name:es",
		name: "Spanish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SWEDISH: {
		code: "sv",
		flag: "name:sv",
		name: "Swedish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	TAMIL: {
		code: "ta",
		flag: "name:ta",
		name: "Tamil",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TELUGU: {
		code: "te",
		flag: "name:te",
		name: "Telugu",
		latin: false,
		isMode: false,
		geocoding: true
	},
	THAI: {
		code: "th",
		flag: "name:th",
		name: "Thai",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TURKISH: {
		code: "tr",
		flag: "name:tr",
		name: "Turkish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	UKRAINIAN: {
		code: "uk",
		flag: "name:uk",
		name: "Ukrainian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	VIETNAMESE: {
		code: "vi",
		flag: "name:vi",
		name: "Vietnamese (Latin script)",
		latin: true,
		isMode: false,
		geocoding: true
	},
	WELSH: {
		code: "cy",
		flag: "name:cy",
		name: "Welsh",
		latin: true,
		isMode: false,
		geocoding: true
	}
};
var Language = {
	...NonISOLanguage,
	...ISOLanguage
};
function getLanguageInfoFromKey(languageKey, languageDictionary = Language) {
	if (languageKey in languageDictionary) return languageKey[languageKey];
	return null;
}
function getLanguageInfoFromCode(languageCode, languageDictionary = Language) {
	for (const lang of Object.values(languageDictionary)) if (lang.code === languageCode) return lang;
	return null;
}
function getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {
	for (const lang of Object.values(languageDictionary)) if (lang.flag === languageFlag) return lang;
	return null;
}
function getAutoLanguage() {
	if (typeof navigator === "undefined") {
		const code = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
		return getLanguageInfoFromCode(code) ?? Language.ENGLISH;
	}
	return Array.from(new Set(navigator.languages.map((l) => l.split("-")[0]))).map((code) => getLanguageInfoFromCode(code)).filter((li$1) => li$1)[0] ?? Language.ENGLISH;
}
function isLanguageInfo(obj) {
	return obj !== null && typeof obj === "object" && "code" in obj && "flag" in obj && "name" in obj && "latin" in obj && "isMode" in obj && "geocoding" in obj && (typeof obj.code === "string" || obj.code === null) && typeof obj.flag === "string" && typeof obj.name === "string" && typeof obj.latin === "boolean" && typeof obj.isMode === "boolean" && typeof obj.geocoding === "boolean";
}
function toLanguageInfo(lang, languageDictionary = Language) {
	if (isLanguageInfo(lang)) return getLanguageInfoFromFlag(lang.flag, languageDictionary);
	if (typeof lang !== "string") return null;
	return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;
}
function areSameLanguages(langA, langB, languageDictionary = Language) {
	const langAObj = toLanguageInfo(langA, languageDictionary);
	const langBObj = toLanguageInfo(langB, languageDictionary);
	return langAObj && langBObj && langAObj.flag === langBObj.flag;
}
async function callFetch(resource, options = {}) {
	if (config.fetch === null) throw new Error("The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch");
	if (new URL(resource).searchParams.get("key").trim() === "") throw new Error("The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com");
	return config.fetch(resource, options);
}
var defaults = {
	maptilerApiURL: "https://api.maptiler.com/",
	mapStyle: "streets-v2"
};
Object.freeze(defaults);
var ServiceError = class extends Error {
	constructor(res, customMessage = "") {
		super(`Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`);
		this.res = res;
	}
};
var customMessages$4 = {
	400: "Query too long / Invalid parameters",
	403: "Key is missing, invalid or restricted"
};
function addLanguageGeocodingOptions(searchParams, options) {
	const { language } = options;
	if (language === void 0) return;
	const languageCodes = (Array.isArray(language) ? language : [language]).map((elem) => toValidGeocodingLanguageCode(elem)).filter((elem) => elem);
	const languages = Array.from(new Set(languageCodes)).join(",");
	searchParams.set("language", languages);
}
function toValidGeocodingLanguageCode(lang) {
	const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === "string" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;
	return langInfo?.geocoding ? langInfo.code : null;
}
function addCommonForwardAndReverseGeocodingOptions(searchParams, options) {
	const { apiKey, limit, types, excludeTypes } = options;
	searchParams.set("key", apiKey ?? config.apiKey);
	if (limit !== void 0) searchParams.set("limit", String(limit));
	if (types !== void 0) searchParams.set("types", types.join(","));
	if (excludeTypes !== void 0) searchParams.set("excludeTypes", String(excludeTypes));
	addLanguageGeocodingOptions(searchParams, options);
}
function addForwardGeocodingOptions(searchParams, options) {
	addCommonForwardAndReverseGeocodingOptions(searchParams, options);
	const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;
	if (bbox !== void 0) searchParams.set("bbox", bbox.join(","));
	if (proximity !== void 0) searchParams.set("proximity", proximity === "ip" ? proximity : proximity.join(","));
	if (country !== void 0) searchParams.set("country", country.join(","));
	if (fuzzyMatch !== void 0) searchParams.set("fuzzyMatch", fuzzyMatch ? "true" : "false");
	if (autocomplete !== void 0) searchParams.set("autocomplete", autocomplete ? "true" : "false");
}
async function forward(query, options = {}) {
	if (typeof query !== "string" || query.trim().length === 0) throw new Error("The query must be a non-empty string");
	const endpoint = new URL(`geocoding/${encodeURIComponent(query)}.json`, defaults.maptilerApiURL);
	addForwardGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function reverse(position, options = {}) {
	if (!Array.isArray(position) || position.length < 2) throw new Error("The position must be an array of form [lng, lat].");
	const endpoint = new URL(`geocoding/${position[0]},${position[1]}.json`, defaults.maptilerApiURL);
	addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function byId(id, options = {}) {
	const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	addLanguageGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function batch$1(queries, options = {}) {
	if (!queries.length) return [];
	const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(";");
	const endpoint = new URL(`geocoding/${joinedQuery}.json`, defaults.maptilerApiURL);
	addForwardGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	const obj = await res.json();
	return queries.length === 1 ? [obj] : obj;
}
var geocoding = {
	forward,
	reverse,
	byId,
	batch: batch$1
};
var customMessages$3 = { 403: "Key is missing, invalid or restricted" };
async function info(options = {}) {
	const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("elevation" in options) endpoint.searchParams.set("elevation", options.elevation ? "true" : "false");
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$3 ? customMessages$3[res.status] : "");
	return await res.json();
}
var geolocation = { info };
var customMessages$2 = { 403: "Key is missing, invalid or restricted" };
async function search(query, options = {}) {
	if (typeof query !== "string" || query.trim().length === 0) throw new Error("The query must be a non-empty string");
	const endpoint = new URL(`coordinates/search/${query}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("limit" in options) endpoint.searchParams.set("limit", options.limit.toString());
	if ("transformations" in options) endpoint.searchParams.set("transformations", options.transformations.toString());
	if ("exports" in options) endpoint.searchParams.set("exports", options.exports.toString());
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
	return await res.json();
}
async function transform(positions, options = {}) {
	const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(";");
	const endpoint = new URL(`coordinates/transform/${coordinatesStr}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("sourceCrs" in options) endpoint.searchParams.set("s_srs", options.sourceCrs.toString());
	if ("targetCrs" in options) endpoint.searchParams.set("t_srs", options.targetCrs.toString());
	if ("operations" in options) endpoint.searchParams.set("ops", (Array.isArray(options.operations) ? options.operations : [options.operations]).join("|"));
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
	return await res.json();
}
var coordinates = {
	search,
	transform
};
var customMessages$1 = { 403: "Key is missing, invalid or restricted" };
async function get(dataId, options = {}) {
	if (typeof dataId !== "string" || dataId.trim().length === 0) throw new Error("The data ID must be a non-empty string");
	const endpoint = new URL(`data/${encodeURIComponent(dataId)}/features.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : "");
	return await res.json();
}
var data = { get };
function expandMapStyle(style) {
	const maptilerDomainRegex = /^maptiler:\/\/(.*)/;
	let match;
	const trimmed = style.trim();
	let expandedStyle;
	if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) expandedStyle = trimmed;
	else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;
	else expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;
	return expandedStyle;
}
var MapStyleVariant = class {
	constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false, deprecationMessage) {
		this.name = name;
		this.variantType = variantType;
		this.id = id;
		this.referenceStyle = referenceStyle;
		this.description = description;
		this.imageURL = imageURL;
		this.deprecated = deprecated;
		this.deprecationMessage = deprecationMessage;
	}
	/**
	* Get the human-friendly name
	* @returns
	*/
	getName() {
		return this.name;
	}
	getFullName() {
		return `${this.referenceStyle.getName()} ${this.name}`;
	}
	/**
	* Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
	* @returns
	*/
	getType() {
		return this.variantType;
	}
	/**
	* Get the MapTiler Cloud id
	* @returns
	*/
	getId() {
		return this.id;
	}
	/**
	* Get the human-friendly description
	*/
	getDescription() {
		return this.description;
	}
	/**
	* Get the reference style this variant belongs to
	* @returns
	*/
	getReferenceStyle() {
		return this.referenceStyle;
	}
	/**
	* Check if a variant of a given type exists for _this_ variants
	* (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
	* @param variantType
	* @returns
	*/
	hasVariant(variantType) {
		return this.referenceStyle.hasVariant(variantType);
	}
	/**
	* Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
	* (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
	* @param variantType
	* @returns
	*/
	getVariant(variantType) {
		const variant = this.referenceStyle.getVariant(variantType);
		this.warnIfDeprecated(variant);
		return variant;
	}
	/**
	* Get all the variants for _this_ variants, except _this_ current one
	* @returns
	*/
	getVariants() {
		return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {
			this.warnIfDeprecated(v);
			return v;
		});
	}
	/**
	* Get the image URL that represent _this_ variant
	* @returns
	*/
	getImageURL() {
		return this.imageURL;
	}
	/**
	* Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
	* @returns
	*/
	getExpandedStyleURL() {
		return expandMapStyle(this.getId());
	}
	warnIfDeprecated(variant = this) {
		if (!variant.deprecated) return variant;
		if (variant.deprecationMessage) console.warn(variant.deprecationMessage);
		else {
			const name = variant.getFullName();
			console.warn(`Style "${name}" is deprecated and will be removed in a future version.`);
		}
		return variant;
	}
};
var ReferenceMapStyle = class {
	constructor(name, id) {
		this.name = name;
		this.id = id;
		/**
		* Variants that belong to this reference style, key being the reference type
		*/
		this.variants = {};
		/**
		* Variants that belong to this reference style, ordered by relevance
		*/
		this.orderedVariants = [];
	}
	/**
	* Get the human-friendly name of this reference style
	* @returns
	*/
	getName() {
		return this.name;
	}
	/**
	* Get the id of _this_ reference style
	* @returns
	*/
	getId() {
		return this.id;
	}
	/**
	* Add a variant to _this_ reference style
	* @param v
	*/
	addVariant(v) {
		this.variants[v.getType()] = v;
		this.orderedVariants.push(v);
	}
	/**
	* Check if a given variant type exists for this reference style
	* @param variantType
	* @returns
	*/
	hasVariant(variantType) {
		return variantType in this.variants;
	}
	/**
	* Get a given variant. If the given type of variant does not exist for this reference style,
	* then the most relevant default variant is returned instead
	* @param variantType
	* @returns
	*/
	getVariant(variantType) {
		return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];
	}
	/**
	* Get the list of variants for this reference style
	* @returns
	*/
	getVariants() {
		return Object.values(this.variants);
	}
	/**
	* Get the defualt variant for this reference style
	* @returns
	*/
	getDefaultVariant() {
		return this.orderedVariants[0].warnIfDeprecated();
	}
};
var mapStylePresetList = [
	{
		referenceStyleID: "STREETS_V2",
		name: "Streets",
		description: "",
		variants: [
			{
				id: "streets-v2",
				name: "Default v2",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2" is deprecated, use "streets-v4" instead`
			},
			{
				id: "streets-v2-dark",
				name: "Dark v2",
				variantType: "DARK",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-dark" is deprecated, use "streets-v4-dark" instead`
			},
			{
				id: "streets-v2-light",
				name: "Light v2",
				variantType: "LIGHT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-light" is deprecated, use "streets-v4-light" instead`
			},
			{
				id: "streets-v2-night",
				name: "Night v2",
				variantType: "NIGHT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-night" is deprecated, use "streets-v4-night" instead`
			},
			{
				id: "streets-v2-pastel",
				name: "Pastel v2",
				variantType: "PASTEL",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-pastel" is deprecated, use "streets-v4-pastel" instead`
			}
		]
	},
	{
		referenceStyleID: "STREETS_V4",
		name: "Streets",
		description: "",
		variants: [
			{
				id: "streets-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "streets-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "streets-v4-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BASE_V4",
		name: "Base",
		description: "",
		variants: [
			{
				id: "base-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-ai",
				name: "Base AI",
				variantType: "NIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OUTDOOR",
		name: "Outdoor",
		description: "",
		variants: [{
			id: "outdoor-v2",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}, {
			id: "outdoor-v2-dark",
			name: "Dark",
			variantType: "DARK",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "WINTER",
		name: "Winter",
		description: "",
		variants: [{
			id: "winter-v2",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}, {
			id: "winter-v2-dark",
			name: "Dark",
			variantType: "DARK",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "SATELLITE",
		name: "Satellite",
		description: "",
		variants: [{
			id: "satellite",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "HYBRID",
		name: "Hybrid",
		description: "",
		variants: [{
			id: "hybrid",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "BASIC_V2",
		name: "Basic",
		description: "",
		variants: [
			{
				id: "basic-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"basic-v2" is deprecated, use "basic-v4" instead`
			},
			{
				id: "basic-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "basic-v2-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BRIGHT",
		name: "Bright",
		description: "",
		variants: [
			{
				id: "bright-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OPENSTREETMAP",
		name: "OpenStreetMap",
		description: "",
		variants: [{
			id: "openstreetmap",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "TOPO",
		name: "Topo",
		description: "",
		variants: [
			{
				id: "topo-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-shiny",
				name: "Shiny",
				deprecated: true,
				variantType: "SHINY",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-topographique",
				name: "Topographique",
				variantType: "TOPOGRAPHIQUE",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "VOYAGER",
		name: "Voyager",
		description: "",
		variants: [
			{
				id: "voyager-v2",
				name: "Default",
				deprecated: true,
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-darkmatter",
				name: "Darkmatter",
				deprecated: true,
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-positron",
				name: "Positron",
				deprecated: true,
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-vintage",
				name: "Vintage",
				deprecated: true,
				variantType: "VINTAGE",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "TONER",
		name: "Toner",
		description: "",
		variants: [
			{
				id: "toner-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-background",
				name: "Background",
				variantType: "BACKGROUND",
				deprecated: true,
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-lite",
				name: "Lite",
				variantType: "LITE",
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-lines",
				name: "Lines",
				variantType: "LINES",
				deprecated: true,
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "DATAVIZ",
		name: "Dataviz",
		description: "",
		variants: [
			{
				id: "dataviz",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "dataviz-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "dataviz-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BACKDROP",
		name: "Backdrop",
		description: "",
		variants: [
			{
				id: "backdrop",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "backdrop-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "backdrop-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OCEAN",
		name: "Ocean",
		description: "",
		variants: [{
			id: "ocean",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "AQUARELLE",
		name: "Aquarelle",
		description: "Watercolor map for creative use",
		variants: [
			{
				id: "aquarelle",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "aquarelle-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "aquarelle-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "LANDSCAPE_V2",
		name: "Landscape",
		description: "Terrain map for data overlays and visualisations",
		variants: [
			{
				id: "landscape",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape" is deprecated, use "landscape-v4" instead`
			},
			{
				id: "landscape-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape-dark" is deprecated, use "landscape-v4-dark" instead`
			},
			{
				id: "landscape-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape-vivid" is deprecated, use "landscape-v4-vivid" instead`
			}
		]
	},
	{
		referenceStyleID: "LANDSCAPE_V4",
		name: "Landscape",
		description: "Terrain map for data overlays and visualisations",
		variants: [
			{
				id: "landscape-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "landscape-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "landscape-v4-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: ""
			}
		]
	}
];
var defaultReferenceStyleMap = {
	STREETS: "STREETS_V2",
	BASIC: "BASIC_V2",
	LANDSCAPE: "LANDSCAPE_V2"
};
function applyVersionToDefaultReferenceStyle(defaultKey, referenceKey) {
	if (mapStylePresetList.find((style) => style.referenceStyleID === defaultKey)) console.warn(`Default reference style ${defaultKey} already exists, it will be overwritten...`);
	const versionedMapStyle = mapStylePresetList.find((style) => style.referenceStyleID === referenceKey);
	if (!versionedMapStyle) throw new Error(`Versioned map style not found for reference style: ${referenceKey}`);
	const defaultStyle = {
		...versionedMapStyle,
		referenceStyleID: defaultKey
	};
	mapStylePresetList.push(defaultStyle);
}
Object.entries(defaultReferenceStyleMap).forEach(([defaultKey, referenceKey]) => {
	applyVersionToDefaultReferenceStyle(defaultKey, referenceKey);
});
function makeReferenceStyleProxy(referenceStyle) {
	return new Proxy(referenceStyle, { get(target, prop, receiver) {
		if (target.hasVariant(prop)) return target.getVariant(prop);
		if (prop.toString().toUpperCase() === prop) return referenceStyle.getDefaultVariant();
		return Reflect.get(target, prop, receiver);
	} });
}
function buildMapStyles() {
	const mapStyle = {};
	for (let i = 0; i < mapStylePresetList.length; i += 1) {
		const refStyleInfo = mapStylePresetList[i];
		const refStyle = makeReferenceStyleProxy(new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID));
		for (let j$1 = 0; j$1 < refStyleInfo.variants.length; j$1 += 1) {
			const variantInfo = refStyleInfo.variants[j$1];
			const variant = new MapStyleVariant(variantInfo.name, variantInfo.variantType, variantInfo.id, refStyle, variantInfo.description, variantInfo.imageURL, variantInfo.deprecated);
			refStyle.addVariant(variant);
		}
		mapStyle[refStyleInfo.referenceStyleID] = refStyle;
	}
	return mapStyle;
}
function styleToStyle(style) {
	if (!style) return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();
	if (typeof style === "string" || style instanceof String) return style.trim().toLowerCase();
	if (style instanceof MapStyleVariant) return style.getId();
	if (style instanceof ReferenceMapStyle) return style.getDefaultVariant().getId();
}
var MapStyle = buildMapStyles();
function extractLineStrings(geoJson) {
	const lineStrings = [];
	function extractFromGeometry(geometry) {
		if (geometry.type === "LineString" || geometry.type === "MultiLineString") lineStrings.push(geometry);
	}
	function extractFromFeature(feature) {
		if (feature.geometry) extractFromGeometry(feature.geometry);
	}
	function extractFromFeatureCollection(collection) {
		for (const feature of collection.features) if (feature.type === "Feature") extractFromFeature(feature);
		else if (feature.type === "FeatureCollection") extractFromFeatureCollection(feature);
	}
	if (geoJson.type === "Feature") extractFromFeature(geoJson);
	else if (geoJson.type === "FeatureCollection") extractFromFeatureCollection(geoJson);
	else extractFromGeometry(geoJson);
	return lineStrings;
}
function getSqSegDist(p, p1, p2) {
	let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
	if (dx !== 0 || dy !== 0) {
		const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
		if (t > 1) {
			x = p2[0];
			y = p2[1];
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}
	dx = p[0] - x;
	dy = p[1] - y;
	return dx * dx + dy * dy;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
	let maxSqDist = sqTolerance, index;
	for (let i = first + 1; i < last; i++) {
		const sqDist = getSqSegDist(points[i], points[first], points[last]);
		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}
	if (maxSqDist > sqTolerance) {
		if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
		simplified.push(points[index]);
		if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
	}
}
function simplifyDouglasPeucker(points, sqTolerance) {
	const last = points.length - 1;
	const simplified = [points[0]];
	simplifyDPStep(points, 0, last, sqTolerance, simplified);
	simplified.push(points[last]);
	return simplified;
}
function simplify(points, tolerance) {
	if (points.length <= 2) return points;
	return simplifyDouglasPeucker(points, tolerance !== void 0 ? tolerance * tolerance : 1);
}
var misc = {
	extractLineStrings,
	simplify
};
function staticMapMarkerToString(marker, includeColor = true) {
	let str = `${marker[0]},${marker[1]}`;
	if (marker.length === 3 && includeColor) str += `,${marker[2]}`;
	return str;
}
function simplifyAndStringify(path, maxNbChar = 3e3) {
	let str = path.map((point) => point.join(",")).join("|");
	let tolerance = 5e-6;
	const toleranceStep = 1e-5;
	while (str.length > maxNbChar) {
		str = misc.simplify(path, tolerance).map((point) => `${point[0]},${point[1]}`).join("|");
		tolerance += toleranceStep;
	}
	return str;
}
function centered(center, zoom, options = {}) {
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
function bounded(boundingBox, options = {}) {
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("padding" in options) endpoint.searchParams.set("padding", options.padding.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
function automatic(options = {}) {
	if (!("markers" in options) && !("path" in options)) throw new Error("Automatic static maps require markers and/or path to be created.");
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/auto/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("padding" in options) endpoint.searchParams.set("padding", options.padding.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
var staticMaps = {
	centered,
	bounded,
	automatic
};
var EARTH_RADIUS = 6371008.8;
var EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
function longitudeToMercatorX(lng) {
	return (180 + lng) / 360;
}
function latitudeToMercatorY(lat) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function wgs84ToMercator(position) {
	const wrappedPos = wrapWgs84(position);
	return [longitudeToMercatorX(wrappedPos[0]), latitudeToMercatorY(wrappedPos[1])];
}
function mercatorXToLongitude(x) {
	return x * 360 - 180;
}
function mercatorYToLatitude(y) {
	const y2 = 180 - y * 360;
	return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
}
function mercatorToWgs84(position) {
	return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];
}
function haversineDistanceWgs84(from, to$1) {
	const rad = Math.PI / 180;
	const lat1 = from[1] * rad;
	const lat2 = to$1[1] * rad;
	const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to$1[0] - from[0]) * rad);
	return EARTH_RADIUS * Math.acos(Math.min(a, 1));
}
function haversineCumulatedDistanceWgs84(positions) {
	const cumulatedDistance = Array(positions.length);
	cumulatedDistance[0] = 0;
	const l = cumulatedDistance.length;
	for (let i = 1; i < l; i++) cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];
	return cumulatedDistance;
}
function wrapWgs84(position) {
	const lng = position[0];
	const lat = position[1];
	const d = 360;
	const w = ((lng + 180) % d + d) % d - 180;
	return [w === -180 ? 180 : w, lat];
}
function circumferenceAtLatitude(latitude) {
	return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
}
function mercatorToTileIndex(position, zoom, strict = true) {
	const numberOfTilePerAxis = 2 ** zoom;
	const fIndex = [position[0] * numberOfTilePerAxis, position[1] * numberOfTilePerAxis];
	return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;
}
function wgs84ToTileIndex(position, zoom, strict = true) {
	return mercatorToTileIndex(wgs84ToMercator(position), zoom, strict);
}
function toRadians(degrees) {
	return degrees * Math.PI / 180;
}
function toDegrees(radians) {
	return radians * 180 / Math.PI;
}
function haversineIntermediateWgs84(pos1, pos2, ratio) {
	const d = haversineDistanceWgs84(pos1, pos2);
	const 1 = toRadians(pos1[0]);
	const 1 = toRadians(pos1[1]);
	const 2 = toRadians(pos2[0]);
	const 2 = toRadians(pos2[1]);
	const  = d / EARTH_RADIUS;
	const a = Math.sin((1 - ratio) * ) / Math.sin();
	const b$1 = Math.sin(ratio * ) / Math.sin();
	const x = a * Math.cos(1) * Math.cos(1) + b$1 * Math.cos(2) * Math.cos(2);
	const y = a * Math.cos(1) * Math.sin(1) + b$1 * Math.cos(2) * Math.sin(2);
	const z$1 = a * Math.sin(1) + b$1 * Math.sin(2);
	const 3 = Math.atan2(z$1, Math.sqrt(x * x + y * y));
	return [toDegrees(Math.atan2(y, x)), toDegrees(3)];
}
var math = {
	EARTH_RADIUS,
	EARTH_CIRCUMFERENCE,
	longitudeToMercatorX,
	latitudeToMercatorY,
	wgs84ToMercator,
	mercatorXToLongitude,
	mercatorYToLatitude,
	mercatorToWgs84,
	haversineDistanceWgs84,
	wrapWgs84,
	circumferenceAtLatitude,
	mercatorToTileIndex,
	wgs84ToTileIndex,
	toRadians,
	toDegrees,
	haversineIntermediateWgs84,
	haversineCumulatedDistanceWgs84
};
var tileCache = null;
function getTileCache() {
	if (!tileCache) tileCache = new QuickLRU({ maxSize: config.tileCacheSize });
	return tileCache;
}
async function bufferToPixelDataBrowser(buff) {
	const blob = new Blob([buff]);
	const imageBitmap = await createImageBitmap(blob);
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");
	canvas.width = imageBitmap.width;
	canvas.height = imageBitmap.height;
	ctx.drawImage(imageBitmap, 0, 0);
	const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	return {
		pixels: imageData.data,
		width: canvas.width,
		height: canvas.height,
		components: imageData.data.length / (canvas.width * canvas.height)
	};
}
function getBufferToPixelDataParser() {
	if (config.bufferToPixelData) return config.bufferToPixelData;
	if (typeof window !== "undefined") return bufferToPixelDataBrowser;
	throw new Error("An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`");
}
function canParsePixelData() {
	return !!config.bufferToPixelData || typeof window !== "undefined";
}
var TERRAIN_TILESET = "terrain-rgb-v2";
var API_BATCH_SIZE = 50;
var API_WARN_SIZE = 1e3;
var terrainTileJson = null;
var customMessages = { 403: "Key is missing, invalid or restricted" };
async function computeOnServer(positions, apiKey) {
	if (positions.length > API_WARN_SIZE) console.warn("Computing elevation for complex geometries is discouraged - simplify the geometry before proceeding");
	const parts = Math.ceil(positions.length / API_BATCH_SIZE);
	const respPromises = Array.from({ length: parts }, () => null).map((_$1, part) => {
		const startPos = part * API_BATCH_SIZE;
		const batchEncoded = positions.slice(startPos, startPos + API_BATCH_SIZE).map((pos) => pos.join(",")).join(";");
		const endpoint = new URL(`elevation/${batchEncoded}.json`, defaults.maptilerApiURL);
		endpoint.searchParams.set("key", apiKey);
		return callFetch(endpoint.toString());
	});
	const resps = await Promise.allSettled(respPromises);
	return (await Promise.all(resps.map(async (resp) => {
		if (resp.status === "rejected") throw new Error(`Some segments could not be fetched, error: ${resp.reason}`);
		if (!resp.value.ok) throw new Error(`Some segments could not be fetched, response: ${resp.value.status} ${await resp.value.text()}, url: ${resp.value.url}`);
		return resp.value.json();
	}))).flat();
}
async function computeOnClient(positions, apiKey, zoom) {
	if (!terrainTileJson) {
		const endpoint = new URL(`tiles/${TERRAIN_TILESET}/tiles.json`, defaults.maptilerApiURL);
		endpoint.searchParams.set("key", apiKey);
		const res = await callFetch(endpoint.toString());
		if (res.ok) terrainTileJson = await res.json();
		else throw new ServiceError(res, customMessages[res.status] ?? "");
	}
	const tileParser = getBufferToPixelDataParser();
	const tileURLSchema = terrainTileJson.tiles[0];
	const cache = getTileCache();
	const maxZoom = terrainTileJson.maxzoom;
	let usedZoom = ~~(zoom ?? maxZoom);
	if (usedZoom > maxZoom || usedZoom < 0) usedZoom = maxZoom;
	const tileIndicesFloats = positions.map((position) => math.wgs84ToTileIndex(position, usedZoom, false));
	const tileIDs = tileIndicesFloats.map((index) => [~~index[0], ~~index[1]]).map((index) => `terrain_${usedZoom.toString()}_${index[0].toString()}_${index[1].toString()}`);
	const uniqueTilesToFetch = Array.from(new Set(tileIDs.filter((tileID) => !cache.has(tileID)))).map((tileID) => tileID.split("_").slice(1));
	const promisesFetchTiles = uniqueTilesToFetch.map((zxy) => tileURLSchema.replace("{x}", zxy[1].toString()).replace("{y}", zxy[2].toString()).replace("{z}", zxy[0].toString())).map((url) => callFetch(url));
	const fulfilledRes = (await Promise.allSettled(promisesFetchTiles)).map((el$1) => el$1.status === "fulfilled" ? el$1.value : null).filter((res) => res);
	const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);
	if (fulfilledRes.length !== promisesFetchTiles.length) throw new Error("Some tiles could not be fetched.");
	if (fulfilledRButNotOkRes.length) throw new ServiceError(fulfilledRButNotOkRes[0], customMessages[fulfilledRButNotOkRes[0].status] ?? "");
	const tileArrayBuffers = await Promise.all(fulfilledRes.map((res) => res.arrayBuffer()));
	if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) throw new Error("Some tiles are not available.");
	(await Promise.all(tileArrayBuffers.map((buff) => tileParser(buff)))).forEach((tilePixelData, i) => {
		const zxy = uniqueTilesToFetch[i];
		const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;
		cache.set(tileID, tilePixelData);
	});
	return positions.map((position, i) => {
		const tileID = tileIDs[i];
		const tileIndexFloat = tileIndicesFloats[i];
		const tilePixelData = cache.get(tileID);
		const pixelX = Math.min(Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)), tilePixelData.width - 1);
		const pixelDataIndex = (Math.min(Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)), tilePixelData.height - 1) * tilePixelData.width + pixelX) * tilePixelData.components;
		const R$2 = tilePixelData.pixels[pixelDataIndex];
		const G$1 = tilePixelData.pixels[pixelDataIndex + 1];
		const B$1 = tilePixelData.pixels[pixelDataIndex + 2];
		const elevation2 = -1e4 + (R$2 * 256 * 256 + G$1 * 256 + B$1) * .1;
		return [
			position[0],
			position[1],
			~~(elevation2 * 1e3) / 1e3
		];
	});
}
async function at$1(position, options = {}) {
	return (await batch([position], options))[0];
}
async function batch(positions, options = {}) {
	if (positions.length === 0) return [];
	const apiKey = options.apiKey ?? config.apiKey;
	const elevatedPositions = options.computeOn === "client" ? await computeOnClient(positions, apiKey, options.zoom) : await computeOnServer(positions, apiKey);
	if (options.smoothingKernelSize) {
		const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;
		const elevations = elevatedPositions.map((pos) => pos[2]);
		const kernelSpan = ~~(kernelSize / 2);
		for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {
			let sum = 0;
			for (let j$1 = 0; j$1 < kernelSize; j$1 += 1) {
				const elev = elevations[i - kernelSpan + j$1];
				sum += elev;
			}
			sum /= kernelSize;
			elevatedPositions[i][2] = sum;
		}
	}
	return elevatedPositions;
}
async function fromLineString(ls$1, options = {}) {
	if (ls$1.type !== "LineString") throw new Error("The provided object is not a GeoJSON LineString");
	options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
	const clone = structuredClone(ls$1);
	clone.coordinates = await batch(clone.coordinates, options);
	return clone;
}
async function fromMultiLineString(ls$1, options = {}) {
	if (ls$1.type !== "MultiLineString") throw new Error("The provided object is not a GeoJSON MultiLineString");
	options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
	const clone = structuredClone(ls$1);
	const multiLengths = clone.coordinates.map((poss) => poss.length);
	const flattenPositionsElevated = await batch(clone.coordinates.flat(), options);
	const result = [];
	let index = 0;
	for (const length of multiLengths) {
		result.push(flattenPositionsElevated.slice(index, index + length));
		index += length;
	}
	clone.coordinates = result;
	return clone;
}
var elevation = {
	at: at$1,
	batch,
	fromLineString,
	fromMultiLineString
};

//#endregion
//#region node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
	return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

//#endregion
//#region node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
	if (!getRandomValues) {
		if (typeof crypto === "undefined" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
		getRandomValues = crypto.getRandomValues.bind(crypto);
	}
	return getRandomValues(rnds8);
}

//#endregion
//#region node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

//#endregion
//#region node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
	if (native_default.randomUUID && !buf && !options) return native_default.randomUUID();
	options = options || {};
	const rnds = options.random ?? options.rng?.() ?? rng();
	if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
	rnds[6] = rnds[6] & 15 | 64;
	rnds[8] = rnds[8] & 63 | 128;
	if (buf) {
		offset = offset || 0;
		if (offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
		for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
		return buf;
	}
	return unsafeStringify(rnds);
}
var v4_default = v4;

//#endregion
//#region node_modules/.pnpm/@maptiler+sdk@3.9.0/node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
var Si = Object.defineProperty;
var Hn = (r) => {
	throw TypeError(r);
};
var xi = (r, e, t) => e in r ? Si(r, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r[e] = t;
var g = (r, e, t) => xi(r, typeof e != "symbol" ? e + "" : e, t), Lr = (r, e, t) => e.has(r) || Hn("Cannot " + t);
var k = (r, e, t) => (Lr(r, e, "read from private field"), t ? t.call(r) : e.get(r)), Z = (r, e, t) => e.has(r) ? Hn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), K = (r, e, t, n) => (Lr(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), X = (r, e, t) => (Lr(r, e, "access private method"), t);
var Mi = class extends import_maplibre_gl.default.Marker {
	addTo(e) {
		return super.addTo(e);
	}
};
var np = class extends import_maplibre_gl.default.Popup {
	addTo(e) {
		return super.addTo(e);
	}
};
var ap = class extends import_maplibre_gl.default.Style {
	constructor(e, t = {}) {
		super(e, t);
	}
};
var op = class extends import_maplibre_gl.default.CanvasSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var ip = class extends import_maplibre_gl.default.GeoJSONSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var sp = class extends import_maplibre_gl.default.ImageSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var lp = class extends import_maplibre_gl.default.RasterTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var up = class extends import_maplibre_gl.default.RasterDEMTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var cp = class extends import_maplibre_gl.default.VectorTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var pp = class extends import_maplibre_gl.default.VideoSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var Wa = class extends import_maplibre_gl.default.NavigationControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Pi = class extends import_maplibre_gl.default.GeolocateControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var fp = class extends import_maplibre_gl.default.AttributionControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Ri = class extends import_maplibre_gl.default.LogoControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var zi = class extends import_maplibre_gl.default.ScaleControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Oi = class extends import_maplibre_gl.default.FullscreenControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var dp = class extends import_maplibre_gl.default.TerrainControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var hp = class extends import_maplibre_gl.default.BoxZoomHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var mp = class extends import_maplibre_gl.default.ScrollZoomHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var yp = class extends import_maplibre_gl.default.CooperativeGesturesHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var gp = class extends import_maplibre_gl.default.KeyboardHandler {
	constructor(e) {
		super(e);
	}
};
var vp = class extends import_maplibre_gl.default.TwoFingersTouchPitchHandler {
	constructor(e) {
		super(e);
	}
};
var bp = class extends import_maplibre_gl.default.MapWheelEvent {
	constructor(e, t, n) {
		super(e, t, n);
	}
};
var wp = class extends import_maplibre_gl.default.MapTouchEvent {
	constructor(e, t, n) {
		super(e, t, n);
	}
};
var Sp = class extends import_maplibre_gl.default.MapMouseEvent {
	constructor(e, t, n, a = {}) {
		super(e, t, n, a);
	}
};
var z = {
	VISITOR: {
		code: null,
		flag: "visitor",
		name: "Visitor",
		latin: !0,
		isMode: !0,
		geocoding: !1
	},
	VISITOR_ENGLISH: {
		code: null,
		flag: "visitor_en",
		name: "Visitor English",
		latin: !0,
		isMode: !0,
		geocoding: !1
	},
	STYLE: {
		code: null,
		flag: "style",
		name: "Style",
		latin: !1,
		isMode: !0,
		geocoding: !1
	},
	STYLE_LOCK: {
		code: null,
		flag: "style_lock",
		name: "Style Lock",
		latin: !1,
		isMode: !0,
		geocoding: !1
	},
	...Language
};
function Yn() {
	if (typeof navigator > "u") {
		const e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
		return getLanguageInfoFromCode(e) || z.ENGLISH;
	}
	return Array.from(new Set(navigator.languages.map((e) => e.split("-")[0]))).map((e) => getLanguageInfoFromCode(e)).filter((e) => e)[0] ?? z.LOCAL;
}
var J = {
	maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
	maptilerURL: "https://www.maptiler.com/",
	maptilerApiHost: "api.maptiler.com",
	telemetryURL: "https://api.maptiler.com/metrics",
	rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
	primaryLanguage: z.STYLE,
	secondaryLanguage: z.LOCAL,
	terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
	terrainSourceId: "maptiler-terrain"
};
Object.freeze(J);
var dn = v4_default();
var $i = class extends import_events.default {
	constructor() {
		super(...arguments);
		/**
		* The primary language. By default, the language of the web browser is used.
		*/
		g(this, "primaryLanguage", J.primaryLanguage);
		/**
		* The secondary language, to overwrite the default language defined in the map style.
		* This settings is highly dependant on the style compatibility and may not work in most cases.
		*/
		g(this, "secondaryLanguage");
		/**
		* Setting on whether of not the SDK runs with a session logic.
		* A "session" is started at the initialization of the SDK and finished when the browser
		* page is being refreshed.
		* When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries
		* on the MapTiler Cloud API. This allows MapTiler to enable "session based billing".
		*/
		g(this, "session", !0);
		/**
		* Enables client-side caching of requests for tiles and fonts.
		* The cached requests persist multiple browser sessions and will be reused when possible.
		* Works only for requests to the MapTiler Cloud API when sessions are enabled.
		*/
		g(this, "caching", !0);
		/**
		* Telemetry is enabled by default but can be opted-out by setting this value to `false`.
		* The telemetry is very valuable to the team at MapTiler because it shares information
		* about where to add the extra effort. It also helps spotting some incompatibility issues
		* that may arise between the SDK and a specific version of a module.
		*
		* It consists in sending metrics about usage of the following features:
		* - SDK version [string]
		* - API key [string]
		* - MapTiler sesion ID (if opted-in) [string]
		* - if tile caching is enabled [boolean]
		* - if language specified at initialization [boolean]
		* - if terrain is activated at initialization [boolean]
		* - if globe projection is activated at initialization [boolean]
		*
		* In addition, each official module will be added to a list, alongside its version number.
		*/
		g(this, "telemetry", !0);
		/**
		* Unit to be used
		*/
		g(this, "_unit", "metric");
		/**
		* MapTiler Cloud API key
		*/
		g(this, "_apiKey", "");
	}
	/**
	* Set the unit system
	*/
	set unit(t) {
		this._unit = t, this.emit("unit", t);
	}
	/**
	* Get the unit system
	*/
	get unit() {
		return this._unit;
	}
	/**
	* Set the MapTiler Cloud API key
	*/
	set apiKey(t) {
		this._apiKey = t, config.apiKey = t, this.emit("apiKey", t);
	}
	/**
	* Get the MapTiler Cloud API key
	*/
	get apiKey() {
		return this._apiKey;
	}
	/**
	* Set a the custom fetch function to replace the default one
	*/
	set fetch(t) {
		config.fetch = t;
	}
	/**
	* Get the fetch fucntion
	*/
	get fetch() {
		return config.fetch;
	}
};
var j = new $i();
var Wn = class extends Ri {
	constructor(t = {}) {
		super(t);
		g(this, "logoURL", "");
		g(this, "linkURL", "");
		this.logoURL = t.logoURL ?? J.maptilerLogoURL, this.linkURL = t.linkURL ?? J.maptilerURL;
	}
	onAdd(t) {
		this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
		const n = window.document.createElement("a");
		return n.style.backgroundRepeat = "no-repeat", n.style.cursor = "pointer", n.style.display = "block", n.style.height = "23px", n.style.margin = "0 0 -4px -4px", n.style.overflow = "hidden", n.style.width = "88px", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = "100px 30px", n.style.width = "100px", n.style.height = "30px", n.target = "_blank", n.rel = "noopener", n.href = this.linkURL, n.setAttribute("aria-label", "MapTiler logo"), n.setAttribute("rel", "noopener"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
	}
};
var Vr = "localcache_source", Gr = "localcache", Fi = "maptiler_sdk", Ni = 1e3, ji = 100, Hr = typeof caches < "u", { addProtocol: Jn } = import_maplibre_gl.default;
function Di(r, e) {
	if (Hr && j.caching && j.session && r.host === J.maptilerApiHost) {
		if (e === "Source" && r.href.includes("tiles.json")) return r.href.replace("https://", `${Vr}://`);
		if (e === "Tile" || e === "Glyphs") return r.href.replace("https://", `${Gr}://`);
	}
	return r.href;
}
var Ar;
async function Ja() {
	return Ar || (Ar = await caches.open(Fi)), Ar;
}
var Qn = 0;
async function Ui() {
	const r = await Ja(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Ni, 0));
	for (const n of t) r.delete(n);
}
function Bi() {
	Jn(Vr, async (r, e) => {
		if (!r.url) throw new Error("");
		r.url = r.url.replace(`${Vr}://`, "https://");
		const t = r;
		t.signal = e.signal;
		const n = await fetch(r.url, t), a = await n.json();
		return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get("Last-Modified")}`), {
			data: a,
			cacheControl: n.headers.get("Cache-Control"),
			expires: n.headers.get("Expires")
		};
	}), Jn(Gr, async (r, e) => {
		if (!r.url) throw new Error("");
		r.url = r.url.replace(`${Gr}://`, "https://");
		const t = new URL(r.url), n = new URL(t);
		n.searchParams.delete("mtsid"), n.searchParams.delete("key");
		const a = n.toString(), o = new URL(t);
		o.searchParams.delete("last-modified");
		const i = o.toString(), s = async (d) => ({
			data: await d.arrayBuffer(),
			cacheControl: d.headers.get("Cache-Control"),
			expires: d.headers.get("Expires")
		}), l = await Ja(), u = await l.match(a);
		if (u) return s(u);
		const c = r;
		c.signal = e.signal;
		const p = await fetch(i, c);
		return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {}), ++Qn > ji && (Ui(), Qn = 0)), s(p);
	});
}
function qi(r, e) {
	for (const t of r) typeof e[t] == "function" && (e[t] = e[t].bind(e));
}
function ea(r, e) {
	let t = null;
	try {
		t = new URL(r);
	} catch {
		return { url: r };
	}
	return t.host === J.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", j.apiKey), j.session && t.searchParams.append("mtsid", dn)), { url: Di(t, e) };
}
function ta(r) {
	return (e, t) => {
		if (r != null) {
			const n = r(e, t), a = ea((n == null ? void 0 : n.url) ?? "", t);
			return {
				...n,
				...a
			};
		}
		return ea(e, t);
	};
}
function Qa() {
	return Math.random().toString(36).substring(2);
}
function ir(r) {
	return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi.test(r);
}
function Vi(r) {
	try {
		return JSON.parse(r);
	} catch {}
	return null;
}
function Gi() {
	return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function Hi(r) {
	const e = Gi();
	if (!e) return;
	let t = null;
	if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t) throw new Error("The Map container must be provided.");
	const n = document.createElement("div");
	throw n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n), new Error(e);
}
function xp(r) {
	const e = "The WebGL context was lost.", t = r.getContainer(), n = document.createElement("div");
	n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n);
}
function ra(r, e) {
	return !(!Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" || e && !r[1].startsWith("name:") || !e && r[1] !== "name");
}
function Zi(r, e, t) {
	const n = structuredClone(r), a = (o) => {
		if (typeof o != "string") for (let i = 0; i < o.length; i += 1) ra(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);
	};
	return ra(n, t) ? e : (a(n), n);
}
function Ki(r, e) {
	const t = e ? /\{name:\S+\}/ : /\{name\}/;
	return {
		contains: t.test(r),
		exactMatch: (/* @__PURE__ */ new RegExp(`^${t.source}$`)).test(r)
	};
}
function Xi(r, e, t) {
	const n = t ? /\{name:\S+\}/ : /\{name\}/, a = r.split(n);
	return ["concat", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];
}
function Yi(r) {
	var n;
	const e = /\{name(?::(?<language>\S+))?\}/g, t = [];
	for (;;) {
		const a = e.exec(r);
		if (!a) break;
		const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;
		t.push(o);
	}
	return t;
}
function Wi(r) {
	return !Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" ? null : r[1].trim() === "name" ? {
		isLanguage: !0,
		localization: null
	} : r[1].trim().startsWith("name:") ? {
		isLanguage: !0,
		localization: r[1].trim().split(":").pop()
	} : null;
}
function Ji(r) {
	const e = [], t = structuredClone(r), n = (a) => {
		if (typeof a != "string") for (let o = 0; o < a.length; o += 1) {
			const i = Wi(a[o]);
			i ? e.push(i.localization) : n(a[o]);
		}
	};
	return n([t]), e;
}
function Qi(r, e) {
	const t = [];
	for (const o of r) {
		if (o.type !== "symbol") continue;
		const { id: s, layout: l } = o;
		if (!l || !("text-field" in l)) continue;
		const u = e.getLayoutProperty(s, "text-field");
		if (u) if (typeof u == "string") {
			const c = Yi(u);
			t.push(c);
		} else {
			const c = Ji(u);
			t.push(c);
		}
	}
	const n = t.flat(), a = {
		unlocalized: 0,
		localized: {}
	};
	for (const o of n) o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);
	return a;
}
var es = 8, ts = {
	version: {
		required: !0,
		type: "enum",
		values: [8]
	},
	name: { type: "string" },
	metadata: { type: "*" },
	center: {
		type: "array",
		value: "number"
	},
	centerAltitude: { type: "number" },
	zoom: { type: "number" },
	bearing: {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees"
	},
	pitch: {
		type: "number",
		default: 0,
		units: "degrees"
	},
	roll: {
		type: "number",
		default: 0,
		units: "degrees"
	},
	state: {
		type: "state",
		default: {}
	},
	light: { type: "light" },
	sky: { type: "sky" },
	projection: { type: "projection" },
	terrain: { type: "terrain" },
	sources: {
		required: !0,
		type: "sources"
	},
	sprite: { type: "sprite" },
	glyphs: { type: "string" },
	transition: { type: "transition" },
	layers: {
		required: !0,
		type: "array",
		value: "layer"
	}
}, rs = { "*": { type: "source" } }, ns = [
	"source_vector",
	"source_raster",
	"source_raster_dem",
	"source_geojson",
	"source_video",
	"source_image"
], as = {
	type: {
		required: !0,
		type: "enum",
		values: { vector: {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {},
			tms: {}
		},
		default: "xyz"
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	attribution: { type: "string" },
	promoteId: { type: "promoteId" },
	volatile: {
		type: "boolean",
		default: !1
	},
	"*": { type: "*" }
}, os = {
	type: {
		required: !0,
		type: "enum",
		values: { raster: {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	tileSize: {
		type: "number",
		default: 512,
		units: "pixels"
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {},
			tms: {}
		},
		default: "xyz"
	},
	attribution: { type: "string" },
	volatile: {
		type: "boolean",
		default: !1
	},
	"*": { type: "*" }
}, is = {
	type: {
		required: !0,
		type: "enum",
		values: { "raster-dem": {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	tileSize: {
		type: "number",
		default: 512,
		units: "pixels"
	},
	attribution: { type: "string" },
	encoding: {
		type: "enum",
		values: {
			terrarium: {},
			mapbox: {},
			custom: {}
		},
		default: "mapbox"
	},
	redFactor: {
		type: "number",
		default: 1
	},
	blueFactor: {
		type: "number",
		default: 1
	},
	greenFactor: {
		type: "number",
		default: 1
	},
	baseShift: {
		type: "number",
		default: 0
	},
	volatile: {
		type: "boolean",
		default: !1
	},
	"*": { type: "*" }
}, ss = {
	type: {
		required: !0,
		type: "enum",
		values: { geojson: {} }
	},
	data: {
		required: !0,
		type: "*"
	},
	maxzoom: {
		type: "number",
		default: 18
	},
	attribution: { type: "string" },
	buffer: {
		type: "number",
		default: 128,
		maximum: 512,
		minimum: 0
	},
	filter: { type: "*" },
	tolerance: {
		type: "number",
		default: .375
	},
	cluster: {
		type: "boolean",
		default: !1
	},
	clusterRadius: {
		type: "number",
		default: 50,
		minimum: 0
	},
	clusterMaxZoom: { type: "number" },
	clusterMinPoints: { type: "number" },
	clusterProperties: { type: "*" },
	lineMetrics: {
		type: "boolean",
		default: !1
	},
	generateId: {
		type: "boolean",
		default: !1
	},
	promoteId: { type: "promoteId" }
}, ls = {
	type: {
		required: !0,
		type: "enum",
		values: { video: {} }
	},
	urls: {
		required: !0,
		type: "array",
		value: "string"
	},
	coordinates: {
		required: !0,
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number"
		}
	}
}, us = {
	type: {
		required: !0,
		type: "enum",
		values: { image: {} }
	},
	url: {
		required: !0,
		type: "string"
	},
	coordinates: {
		required: !0,
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number"
		}
	}
}, cs = {
	id: {
		type: "string",
		required: !0
	},
	type: {
		type: "enum",
		values: {
			fill: {},
			line: {},
			symbol: {},
			circle: {},
			heatmap: {},
			"fill-extrusion": {},
			raster: {},
			hillshade: {},
			"color-relief": {},
			background: {}
		},
		required: !0
	},
	metadata: { type: "*" },
	source: { type: "string" },
	"source-layer": { type: "string" },
	minzoom: {
		type: "number",
		minimum: 0,
		maximum: 24
	},
	maxzoom: {
		type: "number",
		minimum: 0,
		maximum: 24
	},
	filter: { type: "filter" },
	layout: { type: "layout" },
	paint: { type: "paint" }
}, ps = [
	"layout_fill",
	"layout_line",
	"layout_circle",
	"layout_heatmap",
	"layout_fill-extrusion",
	"layout_symbol",
	"layout_raster",
	"layout_hillshade",
	"layout_color-relief",
	"layout_background"
], fs = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ds = {
	"fill-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, hs = {
	"circle-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, ms = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ys = {
	"line-cap": {
		type: "enum",
		values: {
			butt: {},
			round: {},
			square: {}
		},
		default: "butt",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-join": {
		type: "enum",
		values: {
			bevel: {},
			round: {},
			miter: {}
		},
		default: "miter",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"line-miter-limit": {
		type: "number",
		default: 2,
		requires: [{ "line-join": "miter" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-round-limit": {
		type: "number",
		default: 1.05,
		requires: [{ "line-join": "round" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, gs = {
	"symbol-placement": {
		type: "enum",
		values: {
			point: {},
			line: {},
			"line-center": {}
		},
		default: "point",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-spacing": {
		type: "number",
		default: 250,
		minimum: 1,
		units: "pixels",
		requires: [{ "symbol-placement": "line" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-avoid-edges": {
		type: "boolean",
		default: !1,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"symbol-z-order": {
		type: "enum",
		values: {
			auto: {},
			"viewport-y": {},
			source: {}
		},
		default: "auto",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-allow-overlap": {
		type: "boolean",
		default: !1,
		requires: ["icon-image", { "!": "icon-overlap" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-overlap": {
		type: "enum",
		values: {
			never: {},
			always: {},
			cooperative: {}
		},
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-ignore-placement": {
		type: "boolean",
		default: !1,
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-optional": {
		type: "boolean",
		default: !1,
		requires: ["icon-image", "text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-rotation-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-size": {
		type: "number",
		default: 1,
		minimum: 0,
		units: "factor of the original icon size",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-text-fit": {
		type: "enum",
		values: {
			none: {},
			width: {},
			height: {},
			both: {}
		},
		default: "none",
		requires: ["icon-image", "text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-text-fit-padding": {
		type: "array",
		value: "number",
		length: 4,
		default: [
			0,
			0,
			0,
			0
		],
		units: "pixels",
		requires: [
			"icon-image",
			"text-field",
			{ "icon-text-fit": [
				"both",
				"width",
				"height"
			] }
		],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-image": {
		type: "resolvedImage",
		tokens: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-rotate": {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-padding": {
		type: "padding",
		default: [2],
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-keep-upright": {
		type: "boolean",
		default: !1,
		requires: [
			"icon-image",
			{ "icon-rotation-alignment": "map" },
			{ "symbol-placement": ["line", "line-center"] }
		],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-offset": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-anchor": {
		type: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		default: "center",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-rotation-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			"viewport-glyph": {},
			auto: {}
		},
		default: "auto",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-field": {
		type: "formatted",
		default: "",
		tokens: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-font": {
		type: "array",
		value: "string",
		default: ["Open Sans Regular", "Arial Unicode MS Regular"],
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-size": {
		type: "number",
		default: 16,
		minimum: 0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-max-width": {
		type: "number",
		default: 10,
		minimum: 0,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-line-height": {
		type: "number",
		default: 1.2,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-letter-spacing": {
		type: "number",
		default: 0,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-justify": {
		type: "enum",
		values: {
			auto: {},
			left: {},
			center: {},
			right: {}
		},
		default: "center",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-radial-offset": {
		type: "number",
		units: "ems",
		default: 0,
		requires: ["text-field"],
		"property-type": "data-driven",
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		}
	},
	"text-variable-anchor": {
		type: "array",
		value: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-variable-anchor-offset": {
		type: "variableAnchorOffsetCollection",
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-anchor": {
		type: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		default: "center",
		requires: ["text-field", { "!": "text-variable-anchor" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-max-angle": {
		type: "number",
		default: 45,
		units: "degrees",
		requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-writing-mode": {
		type: "array",
		value: "enum",
		values: {
			horizontal: {},
			vertical: {}
		},
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-rotate": {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-padding": {
		type: "number",
		default: 2,
		minimum: 0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-keep-upright": {
		type: "boolean",
		default: !0,
		requires: [
			"text-field",
			{ "text-rotation-alignment": "map" },
			{ "symbol-placement": ["line", "line-center"] }
		],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-transform": {
		type: "enum",
		values: {
			none: {},
			uppercase: {},
			lowercase: {}
		},
		default: "none",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-offset": {
		type: "array",
		value: "number",
		units: "ems",
		length: 2,
		default: [0, 0],
		requires: ["text-field", { "!": "text-radial-offset" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-allow-overlap": {
		type: "boolean",
		default: !1,
		requires: ["text-field", { "!": "text-overlap" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-overlap": {
		type: "enum",
		values: {
			never: {},
			always: {},
			cooperative: {}
		},
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-ignore-placement": {
		type: "boolean",
		default: !1,
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-optional": {
		type: "boolean",
		default: !1,
		requires: ["text-field", "icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, vs = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, bs = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ws = {
	type: "array",
	value: "*"
}, Ss = {
	type: "enum",
	values: {
		"==": {},
		"!=": {},
		">": {},
		">=": {},
		"<": {},
		"<=": {},
		in: {},
		"!in": {},
		all: {},
		any: {},
		none: {},
		has: {},
		"!has": {}
	}
}, xs = {
	type: "enum",
	values: {
		Point: {},
		LineString: {},
		Polygon: {}
	}
}, ks = {
	type: "array",
	minimum: 0,
	maximum: 24,
	value: ["number", "color"],
	length: 2
}, Ls = {
	type: "array",
	value: "*",
	minimum: 1
}, Es = {
	anchor: {
		type: "enum",
		default: "viewport",
		values: {
			map: {},
			viewport: {}
		},
		"property-type": "data-constant",
		transition: !1,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		}
	},
	position: {
		type: "array",
		default: [
			1.15,
			210,
			30
		],
		length: 3,
		value: "number",
		"property-type": "data-constant",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		}
	},
	color: {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	intensity: {
		type: "number",
		"property-type": "data-constant",
		default: .5,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	}
}, Cs = {
	"sky-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#88C6FC",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"horizon-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"fog-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"fog-ground-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .5,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"horizon-fog-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"sky-horizon-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"atmosphere-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	}
}, As = {
	source: {
		type: "string",
		required: !0
	},
	exaggeration: {
		type: "number",
		minimum: 0,
		default: 1
	}
}, Ts = { type: {
	type: "projectionDefinition",
	default: "mercator",
	"property-type": "data-constant",
	transition: !1,
	expression: {
		interpolated: !0,
		parameters: ["zoom"]
	}
} }, _s = [
	"paint_fill",
	"paint_line",
	"paint_circle",
	"paint_heatmap",
	"paint_fill-extrusion",
	"paint_symbol",
	"paint_raster",
	"paint_hillshade",
	"paint_color-relief",
	"paint_background"
], Is = {
	"fill-antialias": {
		type: "boolean",
		default: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "fill-pattern" }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-outline-color": {
		type: "color",
		transition: !0,
		requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["fill-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "cross-faded-data-driven"
	}
}, Ms = {
	"line-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "line-pattern" }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["line-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-width": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-gap-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-offset": {
		type: "number",
		default: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-dasharray": {
		type: "array",
		value: "number",
		minimum: 0,
		transition: !0,
		units: "line widths",
		requires: [{ "!": "line-pattern" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "cross-faded"
	},
	"line-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "cross-faded-data-driven"
	},
	"line-gradient": {
		type: "color",
		transition: !1,
		requires: [
			{ "!": "line-dasharray" },
			{ "!": "line-pattern" },
			{
				source: "geojson",
				has: { lineMetrics: !0 }
			}
		],
		expression: {
			interpolated: !0,
			parameters: ["line-progress"]
		},
		"property-type": "color-ramp"
	}
}, Ps = {
	"circle-radius": {
		type: "number",
		default: 5,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-blur": {
		type: "number",
		default: 0,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["circle-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-scale": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "viewport",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-stroke-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	}
}, Rs = {
	"heatmap-radius": {
		type: "number",
		default: 30,
		minimum: 1,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-weight": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-intensity": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"heatmap-color": {
		type: "color",
		default: [
			"interpolate",
			["linear"],
			["heatmap-density"],
			0,
			"rgba(0, 0, 255, 0)",
			.1,
			"royalblue",
			.3,
			"cyan",
			.5,
			"lime",
			.7,
			"yellow",
			1,
			"red"
		],
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["heatmap-density"]
		},
		"property-type": "color-ramp"
	},
	"heatmap-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, zs = {
	"icon-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-color": {
		type: "color",
		default: "rgba(0, 0, 0, 0)",
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["icon-image", "icon-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		overridable: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-color": {
		type: "color",
		default: "rgba(0, 0, 0, 0)",
		transition: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["text-field", "text-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Os = {
	"raster-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-hue-rotate": {
		type: "number",
		default: 0,
		period: 360,
		transition: !0,
		units: "degrees",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-min": {
		type: "number",
		default: 0,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-max": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-saturation": {
		type: "number",
		default: 0,
		minimum: -1,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-contrast": {
		type: "number",
		default: 0,
		minimum: -1,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-resampling": {
		type: "enum",
		values: {
			linear: {},
			nearest: {}
		},
		default: "linear",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-fade-duration": {
		type: "number",
		default: 300,
		minimum: 0,
		transition: !1,
		units: "milliseconds",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, $s = {
	"hillshade-illumination-direction": {
		type: "numberArray",
		default: 335,
		minimum: 0,
		maximum: 359,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-illumination-altitude": {
		type: "numberArray",
		default: 45,
		minimum: 0,
		maximum: 90,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-illumination-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "viewport",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-exaggeration": {
		type: "number",
		default: .5,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-shadow-color": {
		type: "colorArray",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-highlight-color": {
		type: "colorArray",
		default: "#FFFFFF",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-accent-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-method": {
		type: "enum",
		values: {
			standard: {},
			basic: {},
			combined: {},
			igor: {},
			multidirectional: {}
		},
		default: "standard",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Fs = {
	"background-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "background-pattern" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"background-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "cross-faded"
	},
	"background-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Ns = {
	duration: {
		type: "number",
		default: 300,
		minimum: 0,
		units: "milliseconds"
	},
	delay: {
		type: "number",
		default: 0,
		minimum: 0,
		units: "milliseconds"
	}
}, js = { "*": { type: "string" } }, Ds = {
	$version: es,
	$root: ts,
	sources: rs,
	source: ns,
	source_vector: as,
	source_raster: os,
	source_raster_dem: is,
	source_geojson: ss,
	source_video: ls,
	source_image: us,
	layer: cs,
	layout: ps,
	layout_background: fs,
	layout_fill: ds,
	layout_circle: hs,
	layout_heatmap: ms,
	"layout_fill-extrusion": { visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	} },
	layout_line: ys,
	layout_symbol: gs,
	layout_raster: vs,
	layout_hillshade: bs,
	"layout_color-relief": { visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	} },
	filter: ws,
	filter_operator: Ss,
	geometry_type: xs,
	function: {
		expression: { type: "expression" },
		stops: {
			type: "array",
			value: "function_stop"
		},
		base: {
			type: "number",
			default: 1,
			minimum: 0
		},
		property: {
			type: "string",
			default: "$zoom"
		},
		type: {
			type: "enum",
			values: {
				identity: {},
				exponential: {},
				interval: {},
				categorical: {}
			},
			default: "exponential"
		},
		colorSpace: {
			type: "enum",
			values: {
				rgb: {},
				lab: {},
				hcl: {}
			},
			default: "rgb"
		},
		default: {
			type: "*",
			required: !1
		}
	},
	function_stop: ks,
	expression: Ls,
	light: Es,
	sky: Cs,
	terrain: As,
	projection: Ts,
	paint: _s,
	paint_fill: Is,
	"paint_fill-extrusion": {
		"fill-extrusion-opacity": {
			type: "number",
			default: 1,
			minimum: 0,
			maximum: 1,
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-color": {
			type: "color",
			default: "#000000",
			transition: !0,
			requires: [{ "!": "fill-extrusion-pattern" }],
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-translate": {
			type: "array",
			value: "number",
			length: 2,
			default: [0, 0],
			transition: !0,
			units: "pixels",
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-translate-anchor": {
			type: "enum",
			values: {
				map: {},
				viewport: {}
			},
			default: "map",
			requires: ["fill-extrusion-translate"],
			expression: {
				interpolated: !1,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-pattern": {
			type: "resolvedImage",
			transition: !0,
			expression: {
				interpolated: !1,
				parameters: ["zoom", "feature"]
			},
			"property-type": "cross-faded-data-driven"
		},
		"fill-extrusion-height": {
			type: "number",
			default: 0,
			minimum: 0,
			units: "meters",
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-base": {
			type: "number",
			default: 0,
			minimum: 0,
			units: "meters",
			transition: !0,
			requires: ["fill-extrusion-height"],
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-vertical-gradient": {
			type: "boolean",
			default: !0,
			transition: !1,
			expression: {
				interpolated: !1,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		}
	},
	paint_line: Ms,
	paint_circle: Ps,
	paint_heatmap: Rs,
	paint_symbol: zs,
	paint_raster: Os,
	paint_hillshade: $s,
	"paint_color-relief": {
		"color-relief-opacity": {
			type: "number",
			default: 1,
			minimum: 0,
			maximum: 1,
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"color-relief-color": {
			type: "color",
			transition: !1,
			expression: {
				interpolated: !0,
				parameters: ["elevation"]
			},
			"property-type": "color-ramp"
		}
	},
	paint_background: Fs,
	transition: Ns,
	"property-type": {
		"data-driven": { type: "property-type" },
		"cross-faded": { type: "property-type" },
		"cross-faded-data-driven": { type: "property-type" },
		"color-ramp": { type: "property-type" },
		"data-constant": { type: "property-type" },
		constant: { type: "property-type" }
	},
	promoteId: js
};
var b = class {
	constructor(e, t, n, a) {
		this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);
	}
};
function Yt(r, ...e) {
	for (const t of e) for (const n in t) r[n] = t[n];
	return r;
}
var we = class extends Error {
	constructor(e, t) {
		super(t), this.message = t, this.key = e;
	}
};
var hn = class hn {
	constructor(e, t = []) {
		this.parent = e, this.bindings = {};
		for (const [n, a] of t) this.bindings[n] = a;
	}
	concat(e) {
		return new hn(this, e);
	}
	get(e) {
		if (this.bindings[e]) return this.bindings[e];
		if (this.parent) return this.parent.get(e);
		throw new Error(`${e} not found in scope.`);
	}
	has(e) {
		return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;
	}
};
var sr = { kind: "null" }, S = { kind: "number" }, P = { kind: "string" }, M = { kind: "boolean" }, Se = { kind: "color" }, lr = { kind: "projectionDefinition" }, Ve = { kind: "object" }, I = { kind: "value" }, Us = { kind: "error" }, ur = { kind: "collator" }, cr = { kind: "formatted" }, pr = { kind: "padding" }, vt = { kind: "colorArray" }, fr = { kind: "numberArray" }, _t = { kind: "resolvedImage" }, dr = { kind: "variableAnchorOffsetCollection" };
function ne(r, e) {
	return {
		kind: "array",
		itemType: r,
		N: e
	};
}
function D(r) {
	if (r.kind === "array") {
		const e = D(r.itemType);
		return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
	} else return r.kind;
}
var Bs = [
	sr,
	S,
	P,
	M,
	Se,
	lr,
	cr,
	Ve,
	ne(I),
	pr,
	fr,
	vt,
	_t,
	dr
];
function bt(r, e) {
	if (e.kind === "error") return null;
	if (r.kind === "array") {
		if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !bt(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N)) return null;
	} else {
		if (r.kind === e.kind) return null;
		if (r.kind === "value") {
			for (const t of Bs) if (!bt(t, e)) return null;
		}
	}
	return `Expected ${D(r)} but found ${D(e)} instead.`;
}
function mn(r, e) {
	return e.some((t) => t.kind === r.kind);
}
function Ge(r, e) {
	return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
}
function Ie(r, e) {
	return r.kind === "array" && e.kind === "array" ? r.itemType.kind === e.itemType.kind && typeof r.N == "number" : r.kind === e.kind;
}
var eo = .96422, to = 1, ro = .82521, no = 4 / 29, rt = 6 / 29, ao = 3 * rt * rt, qs = rt * rt * rt, Vs = Math.PI / 180, Gs = 180 / Math.PI;
function oo(r) {
	return r = r % 360, r < 0 && (r += 360), r;
}
function io([r, e, t, n]) {
	r = Tr(r), e = Tr(e), t = Tr(t);
	let a, o;
	const i = _r((.2225045 * r + .7168786 * e + .0606169 * t) / to);
	r === e && e === t ? a = o = i : (a = _r((.4360747 * r + .3850649 * e + .1430804 * t) / eo), o = _r((.0139322 * r + .0971045 * e + .7141733 * t) / ro));
	const s = 116 * i - 16;
	return [
		s < 0 ? 0 : s,
		500 * (a - i),
		200 * (i - o),
		n
	];
}
function Tr(r) {
	return r <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
}
function _r(r) {
	return r > qs ? Math.pow(r, 1 / 3) : r / ao + no;
}
function so([r, e, t, n]) {
	let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;
	return a = to * Mr(a), o = eo * Mr(o), i = ro * Mr(i), [
		Ir(3.1338561 * o - 1.6168667 * a - .4906146 * i),
		Ir(-.9787684 * o + 1.9161415 * a + .033454 * i),
		Ir(.0719453 * o - .2289914 * a + 1.4052427 * i),
		n
	];
}
function Ir(r) {
	return r = r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055, r < 0 ? 0 : r > 1 ? 1 : r;
}
function Mr(r) {
	return r > rt ? r * r * r : ao * (r - no);
}
function Hs(r) {
	const [e, t, n, a] = io(r), o = Math.sqrt(t * t + n * n);
	return [
		Math.round(o * 1e4) ? oo(Math.atan2(n, t) * Gs) : NaN,
		o,
		e,
		a
	];
}
function Zs([r, e, t, n]) {
	return r = isNaN(r) ? 0 : r * Vs, so([
		t,
		Math.cos(r) * e,
		Math.sin(r) * e,
		n
	]);
}
function Ks([r, e, t, n]) {
	r = oo(r), e /= 100, t /= 100;
	function a(o) {
		const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);
		return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));
	}
	return [
		a(0),
		a(8),
		a(4),
		n
	];
}
var Xs = Object.hasOwn || function(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t);
};
function mt(r, e) {
	return Xs(r, e) ? r[e] : void 0;
}
function Ys(r) {
	if (r = r.toLowerCase().trim(), r === "transparent") return [
		0,
		0,
		0,
		0
	];
	const e = mt(Ws, r);
	if (e) {
		const [a, o, i] = e;
		return [
			a / 255,
			o / 255,
			i / 255,
			1
		];
	}
	if (r.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {
		const o = r.length < 6 ? 1 : 2;
		let i = 1;
		return [
			Ut(r.slice(i, i += o)),
			Ut(r.slice(i, i += o)),
			Ut(r.slice(i, i += o)),
			Ut(r.slice(i, i + o) || "ff")
		];
	}
	if (r.startsWith("rgb")) {
		const o = r.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
		if (o) {
			const [i, s, l, u, c, p, d, f, h, m, y, w] = o, v = [
				u || " ",
				d || " ",
				m
			].join("");
			if (v === "  " || v === "  /" || v === ",," || v === ",,,") {
				const x = [
					l,
					p,
					h
				].join(""), A = x === "%%%" ? 100 : x === "" ? 255 : 0;
				if (A) {
					const E = [
						et(+s / A, 0, 1),
						et(+c / A, 0, 1),
						et(+f / A, 0, 1),
						y ? na(+y, w) : 1
					];
					if (aa(E)) return E;
				}
			}
			return;
		}
	}
	const n = r.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
	if (n) {
		const [a, o, i, s, l, u, c, p, d] = n, f = [
			i || " ",
			l || " ",
			c
		].join("");
		if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
			const h = [
				+o,
				et(+s, 0, 100),
				et(+u, 0, 100),
				p ? na(+p, d) : 1
			];
			if (aa(h)) return Ks(h);
		}
	}
}
function Ut(r) {
	return parseInt(r.padEnd(2, r), 16) / 255;
}
function na(r, e) {
	return et(e ? r / 100 : r, 0, 1);
}
function et(r, e, t) {
	return Math.min(Math.max(e, r), t);
}
function aa(r) {
	return !r.some(Number.isNaN);
}
var Ws = {
	aliceblue: [
		240,
		248,
		255
	],
	antiquewhite: [
		250,
		235,
		215
	],
	aqua: [
		0,
		255,
		255
	],
	aquamarine: [
		127,
		255,
		212
	],
	azure: [
		240,
		255,
		255
	],
	beige: [
		245,
		245,
		220
	],
	bisque: [
		255,
		228,
		196
	],
	black: [
		0,
		0,
		0
	],
	blanchedalmond: [
		255,
		235,
		205
	],
	blue: [
		0,
		0,
		255
	],
	blueviolet: [
		138,
		43,
		226
	],
	brown: [
		165,
		42,
		42
	],
	burlywood: [
		222,
		184,
		135
	],
	cadetblue: [
		95,
		158,
		160
	],
	chartreuse: [
		127,
		255,
		0
	],
	chocolate: [
		210,
		105,
		30
	],
	coral: [
		255,
		127,
		80
	],
	cornflowerblue: [
		100,
		149,
		237
	],
	cornsilk: [
		255,
		248,
		220
	],
	crimson: [
		220,
		20,
		60
	],
	cyan: [
		0,
		255,
		255
	],
	darkblue: [
		0,
		0,
		139
	],
	darkcyan: [
		0,
		139,
		139
	],
	darkgoldenrod: [
		184,
		134,
		11
	],
	darkgray: [
		169,
		169,
		169
	],
	darkgreen: [
		0,
		100,
		0
	],
	darkgrey: [
		169,
		169,
		169
	],
	darkkhaki: [
		189,
		183,
		107
	],
	darkmagenta: [
		139,
		0,
		139
	],
	darkolivegreen: [
		85,
		107,
		47
	],
	darkorange: [
		255,
		140,
		0
	],
	darkorchid: [
		153,
		50,
		204
	],
	darkred: [
		139,
		0,
		0
	],
	darksalmon: [
		233,
		150,
		122
	],
	darkseagreen: [
		143,
		188,
		143
	],
	darkslateblue: [
		72,
		61,
		139
	],
	darkslategray: [
		47,
		79,
		79
	],
	darkslategrey: [
		47,
		79,
		79
	],
	darkturquoise: [
		0,
		206,
		209
	],
	darkviolet: [
		148,
		0,
		211
	],
	deeppink: [
		255,
		20,
		147
	],
	deepskyblue: [
		0,
		191,
		255
	],
	dimgray: [
		105,
		105,
		105
	],
	dimgrey: [
		105,
		105,
		105
	],
	dodgerblue: [
		30,
		144,
		255
	],
	firebrick: [
		178,
		34,
		34
	],
	floralwhite: [
		255,
		250,
		240
	],
	forestgreen: [
		34,
		139,
		34
	],
	fuchsia: [
		255,
		0,
		255
	],
	gainsboro: [
		220,
		220,
		220
	],
	ghostwhite: [
		248,
		248,
		255
	],
	gold: [
		255,
		215,
		0
	],
	goldenrod: [
		218,
		165,
		32
	],
	gray: [
		128,
		128,
		128
	],
	green: [
		0,
		128,
		0
	],
	greenyellow: [
		173,
		255,
		47
	],
	grey: [
		128,
		128,
		128
	],
	honeydew: [
		240,
		255,
		240
	],
	hotpink: [
		255,
		105,
		180
	],
	indianred: [
		205,
		92,
		92
	],
	indigo: [
		75,
		0,
		130
	],
	ivory: [
		255,
		255,
		240
	],
	khaki: [
		240,
		230,
		140
	],
	lavender: [
		230,
		230,
		250
	],
	lavenderblush: [
		255,
		240,
		245
	],
	lawngreen: [
		124,
		252,
		0
	],
	lemonchiffon: [
		255,
		250,
		205
	],
	lightblue: [
		173,
		216,
		230
	],
	lightcoral: [
		240,
		128,
		128
	],
	lightcyan: [
		224,
		255,
		255
	],
	lightgoldenrodyellow: [
		250,
		250,
		210
	],
	lightgray: [
		211,
		211,
		211
	],
	lightgreen: [
		144,
		238,
		144
	],
	lightgrey: [
		211,
		211,
		211
	],
	lightpink: [
		255,
		182,
		193
	],
	lightsalmon: [
		255,
		160,
		122
	],
	lightseagreen: [
		32,
		178,
		170
	],
	lightskyblue: [
		135,
		206,
		250
	],
	lightslategray: [
		119,
		136,
		153
	],
	lightslategrey: [
		119,
		136,
		153
	],
	lightsteelblue: [
		176,
		196,
		222
	],
	lightyellow: [
		255,
		255,
		224
	],
	lime: [
		0,
		255,
		0
	],
	limegreen: [
		50,
		205,
		50
	],
	linen: [
		250,
		240,
		230
	],
	magenta: [
		255,
		0,
		255
	],
	maroon: [
		128,
		0,
		0
	],
	mediumaquamarine: [
		102,
		205,
		170
	],
	mediumblue: [
		0,
		0,
		205
	],
	mediumorchid: [
		186,
		85,
		211
	],
	mediumpurple: [
		147,
		112,
		219
	],
	mediumseagreen: [
		60,
		179,
		113
	],
	mediumslateblue: [
		123,
		104,
		238
	],
	mediumspringgreen: [
		0,
		250,
		154
	],
	mediumturquoise: [
		72,
		209,
		204
	],
	mediumvioletred: [
		199,
		21,
		133
	],
	midnightblue: [
		25,
		25,
		112
	],
	mintcream: [
		245,
		255,
		250
	],
	mistyrose: [
		255,
		228,
		225
	],
	moccasin: [
		255,
		228,
		181
	],
	navajowhite: [
		255,
		222,
		173
	],
	navy: [
		0,
		0,
		128
	],
	oldlace: [
		253,
		245,
		230
	],
	olive: [
		128,
		128,
		0
	],
	olivedrab: [
		107,
		142,
		35
	],
	orange: [
		255,
		165,
		0
	],
	orangered: [
		255,
		69,
		0
	],
	orchid: [
		218,
		112,
		214
	],
	palegoldenrod: [
		238,
		232,
		170
	],
	palegreen: [
		152,
		251,
		152
	],
	paleturquoise: [
		175,
		238,
		238
	],
	palevioletred: [
		219,
		112,
		147
	],
	papayawhip: [
		255,
		239,
		213
	],
	peachpuff: [
		255,
		218,
		185
	],
	peru: [
		205,
		133,
		63
	],
	pink: [
		255,
		192,
		203
	],
	plum: [
		221,
		160,
		221
	],
	powderblue: [
		176,
		224,
		230
	],
	purple: [
		128,
		0,
		128
	],
	rebeccapurple: [
		102,
		51,
		153
	],
	red: [
		255,
		0,
		0
	],
	rosybrown: [
		188,
		143,
		143
	],
	royalblue: [
		65,
		105,
		225
	],
	saddlebrown: [
		139,
		69,
		19
	],
	salmon: [
		250,
		128,
		114
	],
	sandybrown: [
		244,
		164,
		96
	],
	seagreen: [
		46,
		139,
		87
	],
	seashell: [
		255,
		245,
		238
	],
	sienna: [
		160,
		82,
		45
	],
	silver: [
		192,
		192,
		192
	],
	skyblue: [
		135,
		206,
		235
	],
	slateblue: [
		106,
		90,
		205
	],
	slategray: [
		112,
		128,
		144
	],
	slategrey: [
		112,
		128,
		144
	],
	snow: [
		255,
		250,
		250
	],
	springgreen: [
		0,
		255,
		127
	],
	steelblue: [
		70,
		130,
		180
	],
	tan: [
		210,
		180,
		140
	],
	teal: [
		0,
		128,
		128
	],
	thistle: [
		216,
		191,
		216
	],
	tomato: [
		255,
		99,
		71
	],
	turquoise: [
		64,
		224,
		208
	],
	violet: [
		238,
		130,
		238
	],
	wheat: [
		245,
		222,
		179
	],
	white: [
		255,
		255,
		255
	],
	whitesmoke: [
		245,
		245,
		245
	],
	yellow: [
		255,
		255,
		0
	],
	yellowgreen: [
		154,
		205,
		50
	]
};
function Ne(r, e, t) {
	return r + t * (e - r);
}
function ot(r, e, t) {
	return r.map((n, a) => Ne(n, e[a], t));
}
var $ = class $ {
	/**
	* @param r Red component premultiplied by `alpha` 0..1
	* @param g Green component premultiplied by `alpha` 0..1
	* @param b Blue component premultiplied by `alpha` 0..1
	* @param [alpha=1] Alpha component 0..1
	* @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
	* been multiplied by alpha. If `true` nothing happens if `false` then they will
	* be multiplied automatically.
	*/
	constructor(e, t, n, a = 1, o = !0) {
		this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [
			e,
			t,
			n,
			a
		]));
	}
	/**
	* Parses CSS color strings and converts colors to sRGB color space if needed.
	* Officially supported color formats:
	* - keyword, e.g. 'aquamarine' or 'steelblue'
	* - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
	* - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
	* - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
	*
	* @param input CSS color string to parse.
	* @returns A `Color` instance, or `undefined` if the input is not a valid color string.
	*/
	static parse(e) {
		if (e instanceof $) return e;
		if (typeof e != "string") return;
		const t = Ys(e);
		if (t) return new $(...t, !1);
	}
	/**
	* Used in color interpolation and by 'to-rgba' expression.
	*
	* @returns Gien color, with reversed alpha blending, in sRGB color space.
	*/
	get rgb() {
		const { r: e, g: t, b: n, a } = this, o = a || Infinity;
		return this.overwriteGetter("rgb", [
			e / o,
			t / o,
			n / o,
			a
		]);
	}
	/**
	* Used in color interpolation.
	*
	* @returns Gien color, with reversed alpha blending, in HCL color space.
	*/
	get hcl() {
		return this.overwriteGetter("hcl", Hs(this.rgb));
	}
	/**
	* Used in color interpolation.
	*
	* @returns Gien color, with reversed alpha blending, in LAB color space.
	*/
	get lab() {
		return this.overwriteGetter("lab", io(this.rgb));
	}
	/**
	* Lazy getter pattern. When getter is called for the first time lazy value
	* is calculated and then overwrites getter function in given object instance.
	*
	* @example:
	* const redColor = Color.parse('red');
	* let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
	* // the value of red in HCL space and invoke this `overwriteGetter` function
	* // which in turn will set a field with a key 'hcl' in the `redColor` object.
	* // In other words it will override `get hcl()` from its `Color` prototype
	* // with its own property: hcl = [calculated red value in hcl].
	* let y = redColor.hcl; // next call will no longer invoke getter but simply
	* // return the previously calculated value
	* x === y; // true - `x` is exactly the same object as `y`
	*
	* @param getterKey Getter key
	* @param lazyValue Lazily calculated value to be memoized by current instance
	* @private
	*/
	overwriteGetter(e, t) {
		return Object.defineProperty(this, e, { value: t }), t;
	}
	/**
	* Used by 'to-string' expression.
	*
	* @returns Serialized color in format `rgba(r,g,b,a)`
	* where r,g,b are numbers within 0..255 and alpha is number within 1..0
	*
	* @example
	* var purple = new Color.parse('purple');
	* purple.toString; // = "rgba(128,0,128,1)"
	* var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
	* translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
	*/
	toString() {
		const [e, t, n, a] = this.rgb;
		return `rgba(${[
			e,
			t,
			n
		].map((o) => Math.round(o * 255)).join(",")},${a})`;
	}
	static interpolate(e, t, n, a = "rgb") {
		switch (a) {
			case "rgb": {
				const [o, i, s, l] = ot(e.rgb, t.rgb, n);
				return new $(o, i, s, l, !1);
			}
			case "hcl": {
				const [o, i, s, l] = e.hcl, [u, c, p, d] = t.hcl;
				let f, h;
				if (!isNaN(o) && !isNaN(u)) {
					let x = u - o;
					u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), f = o + n * x;
				} else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (h = c)) : (f = o, (p === 1 || p === 0) && (h = i));
				const [m, y, w, v] = Zs([
					f,
					h ?? Ne(i, c, n),
					Ne(s, p, n),
					Ne(l, d, n)
				]);
				return new $(m, y, w, v, !1);
			}
			case "lab": {
				const [o, i, s, l] = so(ot(e.lab, t.lab, n));
				return new $(o, i, s, l, !1);
			}
		}
	}
};
$.black = new $(0, 0, 0, 1);
$.white = new $(1, 1, 1, 1);
$.transparent = new $(0, 0, 0, 0);
$.red = new $(1, 0, 0, 1);
var yn = class {
	constructor(e, t, n) {
		e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
			sensitivity: this.sensitivity,
			usage: "search"
		});
	}
	compare(e, t) {
		return this.collator.compare(e, t);
	}
	resolvedLocale() {
		return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
	}
};
var Js = [
	"bottom",
	"center",
	"top"
];
var Zr = class {
	constructor(e, t, n, a, o, i) {
		this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;
	}
};
var Ae = class Ae {
	constructor(e) {
		this.sections = e;
	}
	static fromString(e) {
		return new Ae([new Zr(e, null, null, null, null, null)]);
	}
	isEmpty() {
		return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
	}
	static factory(e) {
		return e instanceof Ae ? e : Ae.fromString(e);
	}
	toString() {
		return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
	}
};
var ie = class ie {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* Numeric padding values
	* @param input A padding value
	* @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
	*/
	static parse(e) {
		if (e instanceof ie) return e;
		if (typeof e == "number") return new ie([
			e,
			e,
			e,
			e
		]);
		if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
			for (const t of e) if (typeof t != "number") return;
			switch (e.length) {
				case 1:
					e = [
						e[0],
						e[0],
						e[0],
						e[0]
					];
					break;
				case 2:
					e = [
						e[0],
						e[1],
						e[0],
						e[1]
					];
					break;
				case 3:
					e = [
						e[0],
						e[1],
						e[2],
						e[1]
					];
					break;
			}
			return new ie(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		return new ie(ot(e.values, t.values, n));
	}
};
var se = class se {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* Numeric NumberArray values
	* @param input A NumberArray value
	* @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
	*/
	static parse(e) {
		if (e instanceof se) return e;
		if (typeof e == "number") return new se([e]);
		if (Array.isArray(e)) {
			for (const t of e) if (typeof t != "number") return;
			return new se(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		return new se(ot(e.values, t.values, n));
	}
};
var Q = class Q {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* ColorArray values
	* @param input A ColorArray value
	* @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
	*/
	static parse(e) {
		if (e instanceof Q) return e;
		if (typeof e == "string") {
			const n = $.parse(e);
			return n ? new Q([n]) : void 0;
		}
		if (!Array.isArray(e)) return;
		const t = [];
		for (const n of e) {
			if (typeof n != "string") return;
			const a = $.parse(n);
			if (!a) return;
			t.push(a);
		}
		return new Q(t);
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n, a = "rgb") {
		const o = [];
		if (e.values.length != t.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
		for (let i = 0; i < e.values.length; i++) o.push($.interpolate(e.values[i], t.values[i], n, a));
		return new Q(o);
	}
};
var U = class extends Error {
	constructor(e) {
		super(e), this.name = "RuntimeError";
	}
	toJSON() {
		return this.message;
	}
};
var Qs = /* @__PURE__ */ new Set([
	"center",
	"left",
	"right",
	"top",
	"bottom",
	"top-left",
	"top-right",
	"bottom-left",
	"bottom-right"
]);
var ye = class ye {
	constructor(e) {
		this.values = e.slice();
	}
	static parse(e) {
		if (e instanceof ye) return e;
		if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
			for (let t = 0; t < e.length; t += 2) {
				const n = e[t], a = e[t + 1];
				if (typeof n != "string" || !Qs.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number") return;
			}
			return new ye(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		const a = e.values, o = t.values;
		if (a.length !== o.length) throw new U(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
		const i = [];
		for (let s = 0; s < a.length; s += 2) {
			if (a[s] !== o[s]) throw new U(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);
			i.push(a[s]);
			const [l, u] = a[s + 1], [c, p] = o[s + 1];
			i.push([Ne(l, c, n), Ne(u, p, n)]);
		}
		return new ye(i);
	}
};
var De = class De {
	constructor(e) {
		this.name = e.name, this.available = e.available;
	}
	toString() {
		return this.name;
	}
	static fromString(e) {
		return e ? new De({
			name: e,
			available: !1
		}) : null;
	}
};
var de = class de {
	constructor(e, t, n) {
		this.from = e, this.to = t, this.transition = n;
	}
	static interpolate(e, t, n) {
		return new de(e, t, n);
	}
	static parse(e) {
		if (e instanceof de) return e;
		if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number") return new de(e[0], e[1], e[2]);
		if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number") return new de(e.from, e.to, e.transition);
		if (typeof e == "string") return new de(e, e, 1);
	}
};
function lo(r, e, t, n) {
	return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
		r,
		e,
		t,
		n
	].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [
		r,
		e,
		t,
		n
	] : [
		r,
		e,
		t
	]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function wt(r) {
	if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof de || r instanceof $ || r instanceof yn || r instanceof Ae || r instanceof ie || r instanceof se || r instanceof Q || r instanceof ye || r instanceof De) return !0;
	if (Array.isArray(r)) {
		for (const e of r) if (!wt(e)) return !1;
		return !0;
	} else if (typeof r == "object") {
		for (const e in r) if (!wt(r[e])) return !1;
		return !0;
	} else return !1;
}
function q(r) {
	if (r === null) return sr;
	if (typeof r == "string") return P;
	if (typeof r == "boolean") return M;
	if (typeof r == "number") return S;
	if (r instanceof $) return Se;
	if (r instanceof de) return lr;
	if (r instanceof yn) return ur;
	if (r instanceof Ae) return cr;
	if (r instanceof ie) return pr;
	if (r instanceof se) return fr;
	if (r instanceof Q) return vt;
	if (r instanceof ye) return dr;
	if (r instanceof De) return _t;
	if (Array.isArray(r)) {
		const e = r.length;
		let t;
		for (const n of r) {
			const a = q(n);
			if (!t) t = a;
			else {
				if (t === a) continue;
				t = I;
				break;
			}
		}
		return ne(t || I, e);
	} else return Ve;
}
function yt(r) {
	const e = typeof r;
	return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof $ || r instanceof de || r instanceof Ae || r instanceof ie || r instanceof se || r instanceof Q || r instanceof ye || r instanceof De ? r.toString() : JSON.stringify(r);
}
var it = class it {
	constructor(e, t) {
		this.type = e, this.value = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (!wt(e[1])) return t.error("invalid value");
		const n = e[1];
		let a = q(n);
		const o = t.expectedType;
		return a.kind === "array" && a.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (a = o), new it(a, n);
	}
	evaluate() {
		return this.value;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var Bt = {
	string: P,
	number: S,
	boolean: M,
	object: Ve
};
var he = class he {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		let n = 1, a;
		const o = e[0];
		if (o === "array") {
			let s;
			if (e.length > 2) {
				const u = e[1];
				if (typeof u != "string" || !(u in Bt) || u === "object") return t.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
				s = Bt[u], n++;
			} else s = I;
			let l;
			if (e.length > 3) {
				if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error("The length argument to \"array\" must be a positive integer literal", 2);
				l = e[2], n++;
			}
			a = ne(s, l);
		} else {
			if (!Bt[o]) throw new Error(`Types doesn't contain name = ${o}`);
			a = Bt[o];
		}
		const i = [];
		for (; n < e.length; n++) {
			const s = t.parse(e[n], n, I);
			if (!s) return null;
			i.push(s);
		}
		return new he(a, i);
	}
	evaluate(e) {
		for (let t = 0; t < this.args.length; t++) {
			const n = this.args[t].evaluate(e);
			if (bt(this.type, q(n))) {
				if (t === this.args.length - 1) throw new U(`Expected value to be of type ${D(this.type)}, but found ${D(q(n))} instead.`);
			} else return n;
		}
		throw new Error();
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
var oa = {
	"to-boolean": M,
	"to-color": Se,
	"to-number": S,
	"to-string": P
};
var $e = class $e {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		const n = e[0];
		if (!oa[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
		if ((n === "to-boolean" || n === "to-string") && e.length !== 2) return t.error("Expected one argument.");
		const a = oa[n], o = [];
		for (let i = 1; i < e.length; i++) {
			const s = t.parse(e[i], i, I);
			if (!s) return null;
			o.push(s);
		}
		return new $e(a, o);
	}
	evaluate(e) {
		switch (this.type.kind) {
			case "boolean": return !!this.args[0].evaluate(e);
			case "color": {
				let t, n;
				for (const a of this.args) {
					if (t = a.evaluate(e), n = null, t instanceof $) return t;
					if (typeof t == "string") {
						const o = e.parseColor(t);
						if (o) return o;
					} else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = lo(t[0], t[1], t[2], t[3]), !n)) return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
				}
				throw new U(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "padding": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = ie.parse(t);
					if (a) return a;
				}
				throw new U(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "numberArray": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = se.parse(t);
					if (a) return a;
				}
				throw new U(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "colorArray": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = Q.parse(t);
					if (a) return a;
				}
				throw new U(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "variableAnchorOffsetCollection": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = ye.parse(t);
					if (a) return a;
				}
				throw new U(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "number": {
				let t = null;
				for (const n of this.args) {
					if (t = n.evaluate(e), t === null) return 0;
					const a = Number(t);
					if (!isNaN(a)) return a;
				}
				throw new U(`Could not convert ${JSON.stringify(t)} to number.`);
			}
			case "formatted": return Ae.fromString(yt(this.args[0].evaluate(e)));
			case "resolvedImage": return De.fromString(yt(this.args[0].evaluate(e)));
			case "projectionDefinition": return this.args[0].evaluate(e);
			default: return yt(this.args[0].evaluate(e));
		}
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
var el = [
	"Unknown",
	"Point",
	"LineString",
	"Polygon"
];
var uo = class {
	constructor() {
		this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
	}
	id() {
		return this.feature && "id" in this.feature ? this.feature.id : null;
	}
	geometryType() {
		return this.feature ? typeof this.feature.type == "number" ? el[this.feature.type] : this.feature.type : null;
	}
	geometry() {
		return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
	}
	canonicalID() {
		return this.canonical;
	}
	properties() {
		return this.feature && this.feature.properties || {};
	}
	parseColor(e) {
		let t = this._parseColorCache.get(e);
		return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;
	}
};
var hr = class hr {
	constructor(e, t, n = [], a, o = new hn(), i = []) {
		this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(""), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;
	}
	/**
	* @param expr the JSON expression to parse
	* @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
	* @param options
	* @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
	* @private
	*/
	parse(e, t, n, a, o = {}) {
		return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);
	}
	_parse(e, t) {
		(e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
		function n(a, o, i) {
			return i === "assert" ? new he(o, [a]) : i === "coerce" ? new $e(o, [a]) : a;
		}
		if (Array.isArray(e)) {
			if (e.length === 0) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
			const a = e[0];
			if (typeof a != "string") return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
			const o = this.registry[a];
			if (o) {
				let i = o.parse(e, this);
				if (!i) return null;
				if (this.expectedType) {
					const s = this.expectedType, l = i.type;
					if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l.kind === "value") i = n(i, s, t.typeAnnotation || "assert");
					else if (s.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || [
						"color",
						"formatted",
						"resolvedImage"
					].includes(s.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(s.kind) && [
						"value",
						"number",
						"array"
					].includes(l.kind) || s.kind === "colorArray" && [
						"value",
						"string",
						"array"
					].includes(l.kind) || s.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind)) i = n(i, s, t.typeAnnotation || "coerce");
					else if (this.checkSubtype(s, l)) return null;
				}
				if (!(i instanceof it) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
					const s = new uo();
					try {
						i = new it(i.type, i.evaluate(s));
					} catch (l) {
						return this.error(l.message), null;
					}
				}
				return i;
			}
			return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
		} else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error("Bare objects invalid. Use [\"literal\", {...}] instead.") : this.error(`Expected an array, but found ${typeof e} instead.`);
	}
	/**
	* Returns a copy of this context suitable for parsing the subexpression at
	* index `index`, optionally appending to 'let' binding map.
	*
	* Note that `errors` property, intended for collecting errors while
	* parsing, is copied by reference rather than cloned.
	* @private
	*/
	concat(e, t, n) {
		const a = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
		return new hr(this.registry, this._isConstant, a, t || null, o, this.errors);
	}
	/**
	* Push a parsing (or type checking) error into the `this.errors`
	* @param error The message
	* @param keys Optionally specify the source of the error at a child
	* of the current expression at `this.key`.
	* @private
	*/
	error(e, ...t) {
		const n = `${this.key}${t.map((a) => `[${a}]`).join("")}`;
		this.errors.push(new we(n, e));
	}
	/**
	* Returns null if `t` is a subtype of `expected`; otherwise returns an
	* error message and also pushes it to `this.errors`.
	* @param expected The expected type
	* @param t The actual type
	* @returns null if `t` is a subtype of `expected`; otherwise returns an error message
	*/
	checkSubtype(e, t) {
		const n = bt(e, t);
		return n && this.error(n), n;
	}
};
var mr = class mr {
	constructor(e, t) {
		this.type = t.type, this.bindings = [].concat(e), this.result = t;
	}
	evaluate(e) {
		return this.result.evaluate(e);
	}
	eachChild(e) {
		for (const t of this.bindings) e(t[1]);
		e(this.result);
	}
	static parse(e, t) {
		if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
		const n = [];
		for (let o = 1; o < e.length - 1; o += 2) {
			const i = e[o];
			if (typeof i != "string") return t.error(`Expected string, but found ${typeof i} instead.`, o);
			if (/[^a-zA-Z0-9_]/.test(i)) return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
			const s = t.parse(e[o + 1], o + 1);
			if (!s) return null;
			n.push([i, s]);
		}
		const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
		return a ? new mr(n, a) : null;
	}
	outputDefined() {
		return this.result.outputDefined();
	}
};
var yr = class yr {
	constructor(e, t) {
		this.type = t.type, this.name = e, this.boundExpression = t;
	}
	static parse(e, t) {
		if (e.length !== 2 || typeof e[1] != "string") return t.error("'var' expression requires exactly one string literal argument.");
		const n = e[1];
		return t.scope.has(n) ? new yr(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
	}
	evaluate(e) {
		return this.boundExpression.evaluate(e);
	}
	eachChild() {}
	outputDefined() {
		return !1;
	}
};
var gn = class gn {
	constructor(e, t, n) {
		this.type = e, this.index = t, this.input = n;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, ne(t.expectedType || I));
		if (!n || !a) return null;
		const o = a.type;
		return new gn(o.itemType, n, a);
	}
	evaluate(e) {
		const t = this.index.evaluate(e), n = this.input.evaluate(e);
		if (t < 0) throw new U(`Array index out of bounds: ${t} < 0.`);
		if (t >= n.length) throw new U(`Array index out of bounds: ${t} > ${n.length - 1}.`);
		if (t !== Math.floor(t)) throw new U(`Array index must be an integer, but found ${t} instead.`);
		return n[t];
	}
	eachChild(e) {
		e(this.index), e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var vn = class vn {
	constructor(e, t) {
		this.type = M, this.needle = e, this.haystack = t;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
		return !n || !a ? null : mn(n.type, [
			M,
			P,
			S,
			sr,
			I
		]) ? new vn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
	}
	evaluate(e) {
		const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
		if (!n) return !1;
		if (!Ge(t, [
			"boolean",
			"string",
			"number",
			"null"
		])) throw new U(`Expected first argument to be of type boolean, string, number or null, but found ${D(q(t))} instead.`);
		if (!Ge(n, ["string", "array"])) throw new U(`Expected second argument to be of type array or string, but found ${D(q(n))} instead.`);
		return n.indexOf(t) >= 0;
	}
	eachChild(e) {
		e(this.needle), e(this.haystack);
	}
	outputDefined() {
		return !0;
	}
};
var Wt = class Wt {
	constructor(e, t, n) {
		this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;
	}
	static parse(e, t) {
		if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
		if (!n || !a) return null;
		if (!mn(n.type, [
			M,
			P,
			S,
			sr,
			I
		])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
		if (e.length === 4) {
			const o = t.parse(e[3], 3, S);
			return o ? new Wt(n, a, o) : null;
		} else return new Wt(n, a);
	}
	evaluate(e) {
		const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
		if (!Ge(t, [
			"boolean",
			"string",
			"number",
			"null"
		])) throw new U(`Expected first argument to be of type boolean, string, number or null, but found ${D(q(t))} instead.`);
		let a;
		if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ge(n, ["string"])) {
			const o = n.indexOf(t, a);
			return o === -1 ? -1 : [...n.slice(0, o)].length;
		} else {
			if (Ge(n, ["array"])) return n.indexOf(t, a);
			throw new U(`Expected second argument to be of type array or string, but found ${D(q(n))} instead.`);
		}
	}
	eachChild(e) {
		e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
	}
	outputDefined() {
		return !1;
	}
};
var bn = class bn {
	constructor(e, t, n, a, o, i) {
		this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;
	}
	static parse(e, t) {
		if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if (e.length % 2 !== 1) return t.error("Expected an even number of arguments.");
		let n, a;
		t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
		const o = {}, i = [];
		for (let u = 2; u < e.length - 1; u += 2) {
			let c = e[u];
			const p = e[u + 1];
			Array.isArray(c) || (c = [c]);
			const d = t.concat(u);
			if (c.length === 0) return d.error("Expected at least one branch label.");
			for (const h of c) {
				if (typeof h != "number" && typeof h != "string") return d.error("Branch labels must be numbers or strings.");
				if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER) return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
				if (typeof h == "number" && Math.floor(h) !== h) return d.error("Numeric branch labels must be integer values.");
				if (!n) n = q(h);
				else if (d.checkSubtype(n, q(h))) return null;
				if (typeof o[String(h)] < "u") return d.error("Branch labels must be unique.");
				o[String(h)] = i.length;
			}
			const f = t.parse(p, u, a);
			if (!f) return null;
			a = a || f.type, i.push(f);
		}
		const s = t.parse(e[1], 1, I);
		if (!s) return null;
		const l = t.parse(e[e.length - 1], e.length - 1, a);
		return !l || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new bn(n, a, s, o, i, l);
	}
	evaluate(e) {
		const t = this.input.evaluate(e);
		return (q(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
	}
	eachChild(e) {
		e(this.input), this.outputs.forEach(e), e(this.otherwise);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
	}
};
var wn = class wn {
	constructor(e, t, n) {
		this.type = e, this.branches = t, this.otherwise = n;
	}
	static parse(e, t) {
		if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
		if (e.length % 2 !== 0) return t.error("Expected an odd number of arguments.");
		let n;
		t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
		const a = [];
		for (let i = 1; i < e.length - 1; i += 2) {
			const s = t.parse(e[i], i, M);
			if (!s) return null;
			const l = t.parse(e[i + 1], i + 1, n);
			if (!l) return null;
			a.push([s, l]), n = n || l.type;
		}
		const o = t.parse(e[e.length - 1], e.length - 1, n);
		if (!o) return null;
		if (!n) throw new Error("Can't infer output type");
		return new wn(n, a, o);
	}
	evaluate(e) {
		for (const [t, n] of this.branches) if (t.evaluate(e)) return n.evaluate(e);
		return this.otherwise.evaluate(e);
	}
	eachChild(e) {
		for (const [t, n] of this.branches) e(t), e(n);
		e(this.otherwise);
	}
	outputDefined() {
		return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
	}
};
var Jt = class Jt {
	constructor(e, t, n, a) {
		this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;
	}
	static parse(e, t) {
		if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, S);
		if (!n || !a) return null;
		if (!mn(n.type, [
			ne(I),
			P,
			I
		])) return t.error(`Expected first argument to be of type array or string, but found ${D(n.type)} instead`);
		if (e.length === 4) {
			const o = t.parse(e[3], 3, S);
			return o ? new Jt(n.type, n, a, o) : null;
		} else return new Jt(n.type, n, a);
	}
	evaluate(e) {
		const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
		let a;
		if (this.endIndex && (a = this.endIndex.evaluate(e)), Ge(t, ["string"])) return [...t].slice(n, a).join("");
		if (Ge(t, ["array"])) return t.slice(n, a);
		throw new U(`Expected first argument to be of type array or string, but found ${D(q(t))} instead.`);
	}
	eachChild(e) {
		e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
	}
	outputDefined() {
		return !1;
	}
};
function co(r, e) {
	const t = r.length - 1;
	let n = 0, a = t, o = 0, i, s;
	for (; n <= a;) if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {
		if (o === t || e < s) return o;
		n = o + 1;
	} else if (i > e) a = o - 1;
	else throw new U("Input is not a number.");
	return 0;
}
var gr = class gr {
	constructor(e, t, n) {
		this.type = e, this.input = t, this.labels = [], this.outputs = [];
		for (const [a, o] of n) this.labels.push(a), this.outputs.push(o);
	}
	static parse(e, t) {
		if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
		const n = t.parse(e[1], 1, S);
		if (!n) return null;
		const a = [];
		let o = null;
		t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
		for (let i = 1; i < e.length; i += 2) {
			const s = i === 1 ? -Infinity : e[i], l = e[i + 1], u = i, c = i + 1;
			if (typeof s != "number") return t.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", u);
			if (a.length && a[a.length - 1][0] >= s) return t.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", u);
			const p = t.parse(l, c, o);
			if (!p) return null;
			o = o || p.type, a.push([s, p]);
		}
		return new gr(o, n, a);
	}
	evaluate(e) {
		const t = this.labels, n = this.outputs;
		if (t.length === 1) return n[0].evaluate(e);
		const a = this.input.evaluate(e);
		if (a <= t[0]) return n[0].evaluate(e);
		const o = t.length;
		if (a >= t[o - 1]) return n[o - 1].evaluate(e);
		return n[co(t, a)].evaluate(e);
	}
	eachChild(e) {
		e(this.input);
		for (const t of this.outputs) e(t);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined());
	}
};
function tl(r) {
	return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Pr, ia;
function rl() {
	if (ia) return Pr;
	ia = 1, Pr = r;
	function r(e, t, n, a) {
		this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;
	}
	return r.prototype = {
		sampleCurveX: function(e) {
			return ((this.ax * e + this.bx) * e + this.cx) * e;
		},
		sampleCurveY: function(e) {
			return ((this.ay * e + this.by) * e + this.cy) * e;
		},
		sampleCurveDerivativeX: function(e) {
			return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
		},
		solveCurveX: function(e, t) {
			if (t === void 0 && (t = 1e-6), e < 0) return 0;
			if (e > 1) return 1;
			for (var n = e, a = 0; a < 8; a++) {
				var o = this.sampleCurveX(n) - e;
				if (Math.abs(o) < t) return n;
				var i = this.sampleCurveDerivativeX(n);
				if (Math.abs(i) < 1e-6) break;
				n = n - o / i;
			}
			var s = 0, l = 1;
			for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++) e > o ? s = n : l = n, n = (l - s) * .5 + s;
			return n;
		},
		solve: function(e, t) {
			return this.sampleCurveY(this.solveCurveX(e, t));
		}
	}, Pr;
}
var al = /* @__PURE__ */ tl(rl());
var xe = class xe {
	constructor(e, t, n, a, o) {
		this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
		for (const [i, s] of o) this.labels.push(i), this.outputs.push(s);
	}
	static interpolationFactor(e, t, n, a) {
		let o = 0;
		if (e.name === "exponential") o = Rr(t, e.base, n, a);
		else if (e.name === "linear") o = Rr(t, 1, n, a);
		else if (e.name === "cubic-bezier") {
			const i = e.controlPoints;
			o = new al(i[0], i[1], i[2], i[3]).solve(Rr(t, 1, n, a));
		}
		return o;
	}
	static parse(e, t) {
		let [n, a, o, ...i] = e;
		if (!Array.isArray(a) || a.length === 0) return t.error("Expected an interpolation type expression.", 1);
		if (a[0] === "linear") a = { name: "linear" };
		else if (a[0] === "exponential") {
			const u = a[1];
			if (typeof u != "number") return t.error("Exponential interpolation requires a numeric base.", 1, 1);
			a = {
				name: "exponential",
				base: u
			};
		} else if (a[0] === "cubic-bezier") {
			const u = a.slice(1);
			if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
			a = {
				name: "cubic-bezier",
				controlPoints: u
			};
		} else return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
		if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
		if (o = t.parse(o, 2, S), !o) return null;
		const s = [];
		let l = null;
		(n === "interpolate-hcl" || n === "interpolate-lab") && t.expectedType != vt ? l = Se : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
		for (let u = 0; u < i.length; u += 2) {
			const c = i[u], p = i[u + 1], d = u + 3, f = u + 4;
			if (typeof c != "number") return t.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", d);
			if (s.length && s[s.length - 1][0] >= c) return t.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", d);
			const h = t.parse(p, f, l);
			if (!h) return null;
			l = l || h.type, s.push([c, h]);
		}
		return !Ie(l, S) && !Ie(l, lr) && !Ie(l, Se) && !Ie(l, pr) && !Ie(l, fr) && !Ie(l, vt) && !Ie(l, dr) && !Ie(l, ne(S)) ? t.error(`Type ${D(l)} is not interpolatable.`) : new xe(l, n, a, o, s);
	}
	evaluate(e) {
		const t = this.labels, n = this.outputs;
		if (t.length === 1) return n[0].evaluate(e);
		const a = this.input.evaluate(e);
		if (a <= t[0]) return n[0].evaluate(e);
		const o = t.length;
		if (a >= t[o - 1]) return n[o - 1].evaluate(e);
		const i = co(t, a), s = t[i], l = t[i + 1], u = xe.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);
		switch (this.operator) {
			case "interpolate": switch (this.type.kind) {
				case "number": return Ne(c, p, u);
				case "color": return $.interpolate(c, p, u);
				case "padding": return ie.interpolate(c, p, u);
				case "colorArray": return Q.interpolate(c, p, u);
				case "numberArray": return se.interpolate(c, p, u);
				case "variableAnchorOffsetCollection": return ye.interpolate(c, p, u);
				case "array": return ot(c, p, u);
				case "projectionDefinition": return de.interpolate(c, p, u);
			}
			case "interpolate-hcl": switch (this.type.kind) {
				case "color": return $.interpolate(c, p, u, "hcl");
				case "colorArray": return Q.interpolate(c, p, u, "hcl");
			}
			case "interpolate-lab": switch (this.type.kind) {
				case "color": return $.interpolate(c, p, u, "lab");
				case "colorArray": return Q.interpolate(c, p, u, "lab");
			}
		}
	}
	eachChild(e) {
		e(this.input);
		for (const t of this.outputs) e(t);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined());
	}
};
function Rr(r, e, t, n) {
	const a = n - t, o = r - t;
	return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);
}
$.interpolate, ie.interpolate, se.interpolate, Q.interpolate, ye.interpolate;
var St = class St {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		let n = null;
		const a = t.expectedType;
		a && a.kind !== "value" && (n = a);
		const o = [];
		for (const s of e.slice(1)) {
			const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
			if (!l) return null;
			n = n || l.type, o.push(l);
		}
		if (!n) throw new Error("No output type");
		return a && o.some((s) => bt(a, s.type)) ? new St(I, o) : new St(n, o);
	}
	evaluate(e) {
		let t = null, n = 0, a;
		for (const o of this.args) if (n++, t = o.evaluate(e), t && t instanceof De && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null) break;
		return t;
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
function sa(r, e) {
	return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function ol(r, e, t) {
	return e === t;
}
function il(r, e, t) {
	return e !== t;
}
function sl(r, e, t) {
	return e < t;
}
function ll(r, e, t) {
	return e > t;
}
function ul(r, e, t) {
	return e <= t;
}
function cl(r, e, t) {
	return e >= t;
}
function po(r, e, t, n) {
	return n.compare(e, t) === 0;
}
function pl(r, e, t, n) {
	return !po(r, e, t, n);
}
function fl(r, e, t, n) {
	return n.compare(e, t) < 0;
}
function dl(r, e, t, n) {
	return n.compare(e, t) > 0;
}
function hl(r, e, t, n) {
	return n.compare(e, t) <= 0;
}
function ml(r, e, t, n) {
	return n.compare(e, t) >= 0;
}
function lt(r, e, t) {
	const n = r !== "==" && r !== "!=";
	return class fo {
		constructor(o, i, s) {
			this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || i.type.kind === "value";
		}
		static parse(o, i) {
			if (o.length !== 3 && o.length !== 4) return i.error("Expected two or three arguments.");
			const s = o[0];
			let l = i.parse(o[1], 1, I);
			if (!l) return null;
			if (!sa(s, l.type)) return i.concat(1).error(`"${s}" comparisons are not supported for type '${D(l.type)}'.`);
			let u = i.parse(o[2], 2, I);
			if (!u) return null;
			if (!sa(s, u.type)) return i.concat(2).error(`"${s}" comparisons are not supported for type '${D(u.type)}'.`);
			if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value") return i.error(`Cannot compare types '${D(l.type)}' and '${D(u.type)}'.`);
			n && (l.type.kind === "value" && u.type.kind !== "value" ? l = new he(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new he(l.type, [u])));
			let c = null;
			if (o.length === 4) {
				if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value") return i.error("Cannot use collator to compare non-string types.");
				if (c = i.parse(o[3], 3, ur), !c) return null;
			}
			return new fo(l, u, c);
		}
		evaluate(o) {
			const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
			if (n && this.hasUntypedArgument) {
				const l = q(i), u = q(s);
				if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number")) throw new U(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);
			}
			if (this.collator && !n && this.hasUntypedArgument) {
				const l = q(i), u = q(s);
				if (l.kind !== "string" || u.kind !== "string") return e(o, i, s);
			}
			return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);
		}
		eachChild(o) {
			o(this.lhs), o(this.rhs), this.collator && o(this.collator);
		}
		outputDefined() {
			return !0;
		}
	};
}
var yl = lt("==", ol, po), gl = lt("!=", il, pl), vl = lt("<", sl, fl), bl = lt(">", ll, dl), wl = lt("<=", ul, hl), Sl = lt(">=", cl, ml);
var vr = class vr {
	constructor(e, t, n) {
		this.type = ur, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error("Expected one argument.");
		const n = e[1];
		if (typeof n != "object" || Array.isArray(n)) return t.error("Collator options argument must be an object.");
		const a = t.parse(n["case-sensitive"] === void 0 ? !1 : n["case-sensitive"], 1, M);
		if (!a) return null;
		const o = t.parse(n["diacritic-sensitive"] === void 0 ? !1 : n["diacritic-sensitive"], 1, M);
		if (!o) return null;
		let i = null;
		return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new vr(a, o, i);
	}
	evaluate(e) {
		return new yn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
	}
	eachChild(e) {
		e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
	}
	outputDefined() {
		return !1;
	}
};
var Sn = class Sn {
	constructor(e, t, n, a, o) {
		this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error("Expected two arguments.");
		const n = t.parse(e[1], 1, S);
		if (!n) return null;
		const a = e[2];
		if (typeof a != "object" || Array.isArray(a)) return t.error("NumberFormat options argument must be an object.");
		let o = null;
		if (a.locale && (o = t.parse(a.locale, 1, P), !o)) return null;
		let i = null;
		if (a.currency && (i = t.parse(a.currency, 1, P), !i)) return null;
		let s = null;
		if (a["min-fraction-digits"] && (s = t.parse(a["min-fraction-digits"], 1, S), !s)) return null;
		let l = null;
		return a["max-fraction-digits"] && (l = t.parse(a["max-fraction-digits"], 1, S), !l) ? null : new Sn(n, o, i, s, l);
	}
	evaluate(e) {
		return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
			style: this.currency ? "currency" : "decimal",
			currency: this.currency ? this.currency.evaluate(e) : void 0,
			minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
			maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
		}).format(this.number.evaluate(e));
	}
	eachChild(e) {
		e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
	}
	outputDefined() {
		return !1;
	}
};
var xn = class xn {
	constructor(e) {
		this.type = cr, this.sections = e;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		const n = e[1];
		if (!Array.isArray(n) && typeof n == "object") return t.error("First argument must be an image or text section.");
		const a = [];
		let o = !1;
		for (let i = 1; i <= e.length - 1; ++i) {
			const s = e[i];
			if (o && typeof s == "object" && !Array.isArray(s)) {
				o = !1;
				let l = null;
				if (s["font-scale"] && (l = t.parse(s["font-scale"], 1, S), !l)) return null;
				let u = null;
				if (s["text-font"] && (u = t.parse(s["text-font"], 1, ne(P)), !u)) return null;
				let c = null;
				if (s["text-color"] && (c = t.parse(s["text-color"], 1, Se), !c)) return null;
				let p = null;
				if (s["vertical-align"]) {
					if (typeof s["vertical-align"] == "string" && !Js.includes(s["vertical-align"])) return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`);
					if (p = t.parse(s["vertical-align"], 1, P), !p) return null;
				}
				const d = a[a.length - 1];
				d.scale = l, d.font = u, d.textColor = c, d.verticalAlign = p;
			} else {
				const l = t.parse(e[i], 1, I);
				if (!l) return null;
				const u = l.type.kind;
				if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage") return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
				o = !0, a.push({
					content: l,
					scale: null,
					font: null,
					textColor: null,
					verticalAlign: null
				});
			}
		}
		return new xn(a);
	}
	evaluate(e) {
		const t = (n) => {
			const a = n.content.evaluate(e);
			return q(a) === _t ? new Zr("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Zr(yt(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
		};
		return new Ae(this.sections.map(t));
	}
	eachChild(e) {
		for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
	}
	outputDefined() {
		return !1;
	}
};
var kn = class kn {
	constructor(e) {
		this.type = _t, this.input = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error("Expected two arguments.");
		const n = t.parse(e[1], 1, P);
		return n ? new kn(n) : t.error("No image name provided.");
	}
	evaluate(e) {
		const t = this.input.evaluate(e), n = De.fromString(t);
		return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
	}
	eachChild(e) {
		e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var Ln = class Ln {
	constructor(e) {
		this.type = S, this.input = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1);
		return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${D(n.type)} instead.`) : new Ln(n) : null;
	}
	evaluate(e) {
		const t = this.input.evaluate(e);
		if (typeof t == "string") return [...t].length;
		if (Array.isArray(t)) return t.length;
		throw new U(`Expected value to be of type string or array, but found ${D(q(t))} instead.`);
	}
	eachChild(e) {
		e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var ke = 8192;
function xl(r, e) {
	const t = kl(r[0]), n = El(r[1]), a = Math.pow(2, e.z);
	return [Math.round(t * a * ke), Math.round(n * a * ke)];
}
function En(r, e) {
	const t = Math.pow(2, e.z), n = (r[0] / ke + e.x) / t, a = (r[1] / ke + e.y) / t;
	return [Ll(n), Cl(a)];
}
function kl(r) {
	return (180 + r) / 360;
}
function Ll(r) {
	return r * 360 - 180;
}
function El(r) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Cl(r) {
	return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;
}
function It(r, e) {
	r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
}
function xt(r, e) {
	return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
}
function Al(r, e, t) {
	return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function Tl(r, e, t) {
	const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];
	return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;
}
function br(r, e, t, n) {
	const a = [e[0] - r[0], e[1] - r[1]];
	return Pl([n[0] - t[0], n[1] - t[1]], a) === 0 ? !1 : !!(la(r, e, t, n) && la(t, n, r, e));
}
function _l(r, e, t) {
	for (const n of t) for (let a = 0; a < n.length - 1; ++a) if (br(r, e, n[a], n[a + 1])) return !0;
	return !1;
}
function ut(r, e, t = !1) {
	let n = !1;
	for (const a of e) for (let o = 0; o < a.length - 1; o++) {
		if (Tl(r, a[o], a[o + 1])) return t;
		Al(r, a[o], a[o + 1]) && (n = !n);
	}
	return n;
}
function Il(r, e) {
	for (const t of e) if (ut(r, t)) return !0;
	return !1;
}
function ho(r, e) {
	for (const t of r) if (!ut(t, e)) return !1;
	for (let t = 0; t < r.length - 1; ++t) if (_l(r[t], r[t + 1], e)) return !1;
	return !0;
}
function Ml(r, e) {
	for (const t of e) if (ho(r, t)) return !0;
	return !1;
}
function Pl(r, e) {
	return r[0] * e[1] - r[1] * e[0];
}
function la(r, e, t, n) {
	const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;
	return c > 0 && p < 0 || c < 0 && p > 0;
}
function Cn(r, e, t) {
	const n = [];
	for (let a = 0; a < r.length; a++) {
		const o = [];
		for (let i = 0; i < r[a].length; i++) {
			const s = xl(r[a][i], t);
			It(e, s), o.push(s);
		}
		n.push(o);
	}
	return n;
}
function mo(r, e, t) {
	const n = [];
	for (let a = 0; a < r.length; a++) {
		const o = Cn(r[a], e, t);
		n.push(o);
	}
	return n;
}
function yo(r, e, t, n) {
	if (r[0] < t[0] || r[0] > t[2]) {
		const a = n * .5;
		let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;
		o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;
	}
	It(e, r);
}
function Rl(r) {
	r[0] = r[1] = Infinity, r[2] = r[3] = -Infinity;
}
function ua(r, e, t, n) {
	const a = Math.pow(2, n.z) * ke, o = [n.x * ke, n.y * ke], i = [];
	for (const s of r) for (const l of s) {
		const u = [l.x + o[0], l.y + o[1]];
		yo(u, e, t, a), i.push(u);
	}
	return i;
}
function ca(r, e, t, n) {
	const a = Math.pow(2, n.z) * ke, o = [n.x * ke, n.y * ke], i = [];
	for (const s of r) {
		const l = [];
		for (const u of s) {
			const c = [u.x + o[0], u.y + o[1]];
			It(e, c), l.push(c);
		}
		i.push(l);
	}
	if (e[2] - e[0] <= a / 2) {
		Rl(e);
		for (const s of i) for (const l of s) yo(l, e, t, a);
	}
	return i;
}
function zl(r, e) {
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], n = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], a = r.canonicalID();
	if (e.type === "Polygon") {
		const o = Cn(e.coordinates, n, a), i = ua(r.geometry(), t, n, a);
		if (!xt(t, n)) return !1;
		for (const s of i) if (!ut(s, o)) return !1;
	}
	if (e.type === "MultiPolygon") {
		const o = mo(e.coordinates, n, a), i = ua(r.geometry(), t, n, a);
		if (!xt(t, n)) return !1;
		for (const s of i) if (!Il(s, o)) return !1;
	}
	return !0;
}
function Ol(r, e) {
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], n = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], a = r.canonicalID();
	if (e.type === "Polygon") {
		const o = Cn(e.coordinates, n, a), i = ca(r.geometry(), t, n, a);
		if (!xt(t, n)) return !1;
		for (const s of i) if (!ho(s, o)) return !1;
	}
	if (e.type === "MultiPolygon") {
		const o = mo(e.coordinates, n, a), i = ca(r.geometry(), t, n, a);
		if (!xt(t, n)) return !1;
		for (const s of i) if (!Ml(s, o)) return !1;
	}
	return !0;
}
var He = class He {
	constructor(e, t) {
		this.type = M, this.geojson = e, this.geometries = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (wt(e[1])) {
			const n = e[1];
			if (n.type === "FeatureCollection") {
				const a = [];
				for (const o of n.features) {
					const { type: i, coordinates: s } = o.geometry;
					i === "Polygon" && a.push(s), i === "MultiPolygon" && a.push(...s);
				}
				if (a.length) return new He(n, {
					type: "MultiPolygon",
					coordinates: a
				});
			} else if (n.type === "Feature") {
				const a = n.geometry.type;
				if (a === "Polygon" || a === "MultiPolygon") return new He(n, n.geometry);
			} else if (n.type === "Polygon" || n.type === "MultiPolygon") return new He(n, n);
		}
		return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
	}
	evaluate(e) {
		if (e.geometry() != null && e.canonicalID() != null) {
			if (e.geometryType() === "Point") return zl(e, this.geometries);
			if (e.geometryType() === "LineString") return Ol(e, this.geometries);
		}
		return !1;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var go = class {
	constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
		if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
	}
	push(e) {
		this.data.push(e), this._up(this.length++);
	}
	pop() {
		if (this.length === 0) return;
		const e = this.data[0], t = this.data.pop();
		return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
	}
	peek() {
		return this.data[0];
	}
	_up(e) {
		const { data: t, compare: n } = this, a = t[e];
		for (; e > 0;) {
			const o = e - 1 >> 1, i = t[o];
			if (n(a, i) >= 0) break;
			t[e] = i, e = o;
		}
		t[e] = a;
	}
	_down(e) {
		const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];
		for (; e < a;) {
			let i = (e << 1) + 1;
			const s = i + 1;
			if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;
			t[e] = t[i], e = i;
		}
		t[e] = o;
	}
};
function $l(r, e) {
	if (r.length <= 1) return [r];
	const n = [];
	let a, o;
	for (const i of r) {
		const s = Fl(i);
		s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));
	}
	return a && n.push(a), n;
}
function Fl(r) {
	let e = 0;
	for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++) o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);
	return e;
}
var Nl = 6378.137, pa = 1 / 298.257223563, fa = pa * (2 - pa), da = Math.PI / 180;
var An = class {
	constructor(e) {
		const t = da * Nl * 1e3, n = Math.cos(e * da), a = 1 / (1 - fa * (1 - n * n)), o = Math.sqrt(a);
		this.kx = t * o * n, this.ky = t * o * a * (1 - fa);
	}
	/**
	* Given two points of the form [longitude, latitude], returns the distance.
	*
	* @param a - point [longitude, latitude]
	* @param b - point [longitude, latitude]
	* @returns distance
	* @example
	* const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
	* //=distance
	*/
	distance(e, t) {
		const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;
		return Math.sqrt(n * n + a * a);
	}
	/**
	* Returns an object of the form {point, index, t}, where point is closest point on the line
	* from the given point, index is the start index of the segment with the closest point,
	* and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
	*
	* @param line - an array of points that form the line
	* @param p - point [longitude, latitude]
	* @returns the nearest point, its index in the array and the proportion along the line
	* @example
	* const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
	* //=point
	*/
	pointOnLine(e, t) {
		let n = Infinity, a, o, i, s;
		for (let l = 0; l < e.length - 1; l++) {
			let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, d = (e[l + 1][1] - c) * this.ky, f = 0;
			(p !== 0 || d !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * d) / (p * p + d * d), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += d / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, d = (t[1] - c) * this.ky;
			const h = p * p + d * d;
			h < n && (n = h, a = u, o = c, i = l, s = f);
		}
		return {
			point: [a, o],
			index: i,
			t: Math.max(0, Math.min(1, s))
		};
	}
	wrap(e) {
		for (; e < -180;) e += 360;
		for (; e > 180;) e -= 360;
		return e;
	}
};
var Kr = 100, Xr = 50;
function vo(r, e) {
	return e[0] - r[0];
}
function Qt(r) {
	return r[1] - r[0] + 1;
}
function _e(r, e) {
	return r[1] >= r[0] && r[1] < e;
}
function Yr(r, e) {
	if (r[0] > r[1]) return [null, null];
	const t = Qt(r);
	if (e) {
		if (t === 2) return [r, null];
		const a = Math.floor(t / 2);
		return [[r[0], r[0] + a], [r[0] + a, r[1]]];
	}
	if (t === 1) return [r, null];
	const n = Math.floor(t / 2) - 1;
	return [[r[0], r[0] + n], [r[0] + n + 1, r[1]]];
}
function Wr(r, e) {
	if (!_e(e, r.length)) return [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	for (let n = e[0]; n <= e[1]; ++n) It(t, r[n]);
	return t;
}
function Jr(r) {
	const e = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	for (const t of r) for (const n of t) It(e, n);
	return e;
}
function ha(r) {
	return r[0] !== -Infinity && r[1] !== -Infinity && r[2] !== Infinity && r[3] !== Infinity;
}
function Tn(r, e, t) {
	if (!ha(r) || !ha(e)) return NaN;
	let n = 0, a = 0;
	return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);
}
function qe(r, e, t) {
	const n = t.pointOnLine(e, r);
	return t.distance(r, n.point);
}
function _n(r, e, t, n, a) {
	const o = Math.min(qe(r, [t, n], a), qe(e, [t, n], a)), i = Math.min(qe(t, [r, e], a), qe(n, [r, e], a));
	return Math.min(o, i);
}
function jl(r, e, t, n, a) {
	if (!(_e(e, r.length) && _e(n, t.length))) return Infinity;
	let i = Infinity;
	for (let s = e[0]; s < e[1]; ++s) {
		const l = r[s], u = r[s + 1];
		for (let c = n[0]; c < n[1]; ++c) {
			const p = t[c], d = t[c + 1];
			if (br(l, u, p, d)) return 0;
			i = Math.min(i, _n(l, u, p, d, a));
		}
	}
	return i;
}
function Dl(r, e, t, n, a) {
	if (!(_e(e, r.length) && _e(n, t.length))) return NaN;
	let i = Infinity;
	for (let s = e[0]; s <= e[1]; ++s) for (let l = n[0]; l <= n[1]; ++l) if (i = Math.min(i, a.distance(r[s], t[l])), i === 0) return i;
	return i;
}
function Ul(r, e, t) {
	if (ut(r, e, !0)) return 0;
	let n = Infinity;
	for (const a of e) {
		const o = a[0], i = a[a.length - 1];
		if (o !== i && (n = Math.min(n, qe(r, [i, o], t)), n === 0)) return n;
		const s = t.pointOnLine(a, r);
		if (n = Math.min(n, t.distance(r, s.point)), n === 0) return n;
	}
	return n;
}
function Bl(r, e, t, n) {
	if (!_e(e, r.length)) return NaN;
	for (let o = e[0]; o <= e[1]; ++o) if (ut(r[o], t, !0)) return 0;
	let a = Infinity;
	for (let o = e[0]; o < e[1]; ++o) {
		const i = r[o], s = r[o + 1];
		for (const l of t) for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {
			const d = l[p], f = l[u];
			if (br(i, s, d, f)) return 0;
			a = Math.min(a, _n(i, s, d, f, n));
		}
	}
	return a;
}
function ma(r, e) {
	for (const t of r) for (const n of t) if (ut(n, e, !0)) return !0;
	return !1;
}
function ql(r, e, t, n = Infinity) {
	const a = Jr(r), o = Jr(e);
	if (n !== Infinity && Tn(a, o, t) >= n) return n;
	if (xt(a, o)) {
		if (ma(r, e)) return 0;
	} else if (ma(e, r)) return 0;
	let i = Infinity;
	for (const s of r) for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {
		const p = s[c], d = s[l];
		for (const f of e) for (let h = 0, m = f.length, y = m - 1; h < m; y = h++) {
			const w = f[y], v = f[h];
			if (br(p, d, w, v)) return 0;
			i = Math.min(i, _n(p, d, w, v, t));
		}
	}
	return i;
}
function ya(r, e, t, n, a, o) {
	if (!o) return;
	const i = Tn(Wr(n, o), a, t);
	i < e && r.push([
		i,
		o,
		[0, 0]
	]);
}
function qt(r, e, t, n, a, o, i) {
	if (!o || !i) return;
	const s = Tn(Wr(n, o), Wr(a, i), t);
	s < e && r.push([
		s,
		o,
		i
	]);
}
function er(r, e, t, n, a = Infinity) {
	let o = Math.min(n.distance(r[0], t[0][0]), a);
	if (o === 0) return o;
	const i = new go([[
		0,
		[0, r.length - 1],
		[0, 0]
	]], vo), s = Jr(t);
	for (; i.length > 0;) {
		const l = i.pop();
		if (l[0] >= o) continue;
		const u = l[1], c = e ? Xr : Kr;
		if (Qt(u) <= c) {
			if (!_e(u, r.length)) return NaN;
			if (e) {
				const p = Bl(r, u, t, n);
				if (isNaN(p) || p === 0) return p;
				o = Math.min(o, p);
			} else for (let p = u[0]; p <= u[1]; ++p) {
				const d = Ul(r[p], t, n);
				if (o = Math.min(o, d), o === 0) return 0;
			}
		} else {
			const p = Yr(u, e);
			ya(i, o, n, r, s, p[0]), ya(i, o, n, r, s, p[1]);
		}
	}
	return o;
}
function tr(r, e, t, n, a, o = Infinity) {
	let i = Math.min(o, a.distance(r[0], t[0]));
	if (i === 0) return i;
	const s = new go([[
		0,
		[0, r.length - 1],
		[0, t.length - 1]
	]], vo);
	for (; s.length > 0;) {
		const l = s.pop();
		if (l[0] >= i) continue;
		const u = l[1], c = l[2], p = e ? Xr : Kr, d = n ? Xr : Kr;
		if (Qt(u) <= p && Qt(c) <= d) {
			if (!_e(u, r.length) && _e(c, t.length)) return NaN;
			let f;
			if (e && n) f = jl(r, u, t, c, a), i = Math.min(i, f);
			else if (e && !n) {
				const h = r.slice(u[0], u[1] + 1);
				for (let m = c[0]; m <= c[1]; ++m) if (f = qe(t[m], h, a), i = Math.min(i, f), i === 0) return i;
			} else if (!e && n) {
				const h = t.slice(c[0], c[1] + 1);
				for (let m = u[0]; m <= u[1]; ++m) if (f = qe(r[m], h, a), i = Math.min(i, f), i === 0) return i;
			} else f = Dl(r, u, t, c, a), i = Math.min(i, f);
		} else {
			const f = Yr(u, e), h = Yr(c, n);
			qt(s, i, a, r, t, f[0], h[0]), qt(s, i, a, r, t, f[0], h[1]), qt(s, i, a, r, t, f[1], h[0]), qt(s, i, a, r, t, f[1], h[1]);
		}
	}
	return i;
}
function Vl(r, e) {
	const t = r.geometry(), n = t.flat().map((i) => En([i.x, i.y], r.canonical));
	if (t.length === 0) return NaN;
	const a = new An(n[0][1]);
	let o = Infinity;
	for (const i of e) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, tr(n, !1, [i.coordinates], !1, a, o));
				break;
			case "LineString":
				o = Math.min(o, tr(n, !1, i.coordinates, !0, a, o));
				break;
			case "Polygon":
				o = Math.min(o, er(n, !1, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function Gl(r, e) {
	const t = r.geometry(), n = t.flat().map((i) => En([i.x, i.y], r.canonical));
	if (t.length === 0) return NaN;
	const a = new An(n[0][1]);
	let o = Infinity;
	for (const i of e) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, tr(n, !0, [i.coordinates], !1, a, o));
				break;
			case "LineString":
				o = Math.min(o, tr(n, !0, i.coordinates, !0, a, o));
				break;
			case "Polygon":
				o = Math.min(o, er(n, !0, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function Hl(r, e) {
	const t = r.geometry();
	if (t.length === 0 || t[0].length === 0) return NaN;
	const n = $l(t).map((i) => i.map((s) => s.map((l) => En([l.x, l.y], r.canonical)))), a = new An(n[0][0][0][1]);
	let o = Infinity;
	for (const i of e) for (const s of n) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, er([i.coordinates], !1, s, a, o));
				break;
			case "LineString":
				o = Math.min(o, er(i.coordinates, !0, s, a, o));
				break;
			case "Polygon":
				o = Math.min(o, ql(s, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function zr(r) {
	return r.type === "MultiPolygon" ? r.coordinates.map((e) => ({
		type: "Polygon",
		coordinates: e
	})) : r.type === "MultiLineString" ? r.coordinates.map((e) => ({
		type: "LineString",
		coordinates: e
	})) : r.type === "MultiPoint" ? r.coordinates.map((e) => ({
		type: "Point",
		coordinates: e
	})) : [r];
}
var Ze = class Ze {
	constructor(e, t) {
		this.type = S, this.geojson = e, this.geometries = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (wt(e[1])) {
			const n = e[1];
			if (n.type === "FeatureCollection") return new Ze(n, n.features.map((a) => zr(a.geometry)).flat());
			if (n.type === "Feature") return new Ze(n, zr(n.geometry));
			if ("type" in n && "coordinates" in n) return new Ze(n, zr(n));
		}
		return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
	}
	evaluate(e) {
		if (e.geometry() != null && e.canonicalID() != null) {
			if (e.geometryType() === "Point") return Vl(e, this.geometries);
			if (e.geometryType() === "LineString") return Gl(e, this.geometries);
			if (e.geometryType() === "Polygon") return Hl(e, this.geometries);
		}
		return NaN;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var Mt = class Mt {
	constructor(e) {
		this.type = I, this.key = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
		const n = e[1];
		return n == null ? t.error("Global state property must be defined.") : typeof n != "string" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new Mt(n);
	}
	evaluate(e) {
		var t;
		const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;
		return !n || Object.keys(n).length === 0 ? null : mt(n, this.key);
	}
	eachChild() {}
	outputDefined() {
		return !1;
	}
};
var In = {
	"==": yl,
	"!=": gl,
	">": bl,
	"<": vl,
	">=": Sl,
	"<=": wl,
	array: he,
	at: gn,
	boolean: he,
	case: wn,
	coalesce: St,
	collator: vr,
	format: xn,
	image: kn,
	in: vn,
	"index-of": Wt,
	interpolate: xe,
	"interpolate-hcl": xe,
	"interpolate-lab": xe,
	length: Ln,
	let: mr,
	literal: it,
	match: bn,
	number: he,
	"number-format": Sn,
	object: he,
	slice: Jt,
	step: gr,
	string: he,
	"to-boolean": $e,
	"to-color": $e,
	"to-number": $e,
	"to-string": $e,
	var: yr,
	within: He,
	distance: Ze,
	"global-state": Mt
};
var me = class me {
	constructor(e, t, n, a) {
		this.name = e, this.type = t, this._evaluate = n, this.args = a;
	}
	evaluate(e) {
		return this._evaluate(e, this.args);
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return !1;
	}
	static parse(e, t) {
		const n = e[0], a = me.definitions[n];
		if (!a) return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
		const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || u.length === e.length - 1);
		let l = null;
		for (const [u, c] of s) {
			l = new hr(t.registry, rr, t.path, null, t.scope);
			const p = [];
			let d = !1;
			for (let f = 1; f < e.length; f++) {
				const h = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, y = l.parse(h, 1 + p.length, m);
				if (!y) {
					d = !0;
					break;
				}
				p.push(y);
			}
			if (!d) {
				if (Array.isArray(u) && u.length !== p.length) {
					l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);
					continue;
				}
				for (let f = 0; f < p.length; f++) {
					const h = Array.isArray(u) ? u[f] : u.type, m = p[f];
					l.concat(f + 1).checkSubtype(h, m.type);
				}
				if (l.errors.length === 0) return new me(n, o, c, p);
			}
		}
		if (s.length === 1) t.errors.push(...l.errors);
		else {
			const c = (s.length ? s : i).map(([d]) => Kl(d)).join(" | "), p = [];
			for (let d = 1; d < e.length; d++) {
				const f = t.parse(e[d], 1 + p.length);
				if (!f) return null;
				p.push(D(f.type));
			}
			t.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
		}
		return null;
	}
	static register(e, t) {
		me.definitions = t;
		for (const n in t) e[n] = me;
	}
};
function ga(r, [e, t, n, a]) {
	e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
	const o = a ? a.evaluate(r) : 1, i = lo(e, t, n, o);
	if (i) throw new U(i);
	return new $(e / 255, t / 255, n / 255, o, !1);
}
function va(r, e) {
	return r in e;
}
function Or(r, e) {
	const t = e[r];
	return typeof t > "u" ? null : t;
}
function Zl(r, e, t, n) {
	for (; t <= n;) {
		const a = t + n >> 1;
		if (e[a] === r) return !0;
		e[a] > r ? n = a - 1 : t = a + 1;
	}
	return !1;
}
function Ue(r) {
	return { type: r };
}
me.register(In, {
	error: [
		Us,
		[P],
		(r, [e]) => {
			throw new U(e.evaluate(r));
		}
	],
	typeof: [
		P,
		[I],
		(r, [e]) => D(q(e.evaluate(r)))
	],
	"to-rgba": [
		ne(S, 4),
		[Se],
		(r, [e]) => {
			const [t, n, a, o] = e.evaluate(r).rgb;
			return [
				t * 255,
				n * 255,
				a * 255,
				o
			];
		}
	],
	rgb: [
		Se,
		[
			S,
			S,
			S
		],
		ga
	],
	rgba: [
		Se,
		[
			S,
			S,
			S,
			S
		],
		ga
	],
	has: {
		type: M,
		overloads: [[[P], (r, [e]) => va(e.evaluate(r), r.properties())], [[P, Ve], (r, [e, t]) => va(e.evaluate(r), t.evaluate(r))]]
	},
	get: {
		type: I,
		overloads: [[[P], (r, [e]) => Or(e.evaluate(r), r.properties())], [[P, Ve], (r, [e, t]) => Or(e.evaluate(r), t.evaluate(r))]]
	},
	"feature-state": [
		I,
		[P],
		(r, [e]) => Or(e.evaluate(r), r.featureState || {})
	],
	properties: [
		Ve,
		[],
		(r) => r.properties()
	],
	"geometry-type": [
		P,
		[],
		(r) => r.geometryType()
	],
	id: [
		I,
		[],
		(r) => r.id()
	],
	zoom: [
		S,
		[],
		(r) => r.globals.zoom
	],
	"heatmap-density": [
		S,
		[],
		(r) => r.globals.heatmapDensity || 0
	],
	elevation: [
		S,
		[],
		(r) => r.globals.elevation || 0
	],
	"line-progress": [
		S,
		[],
		(r) => r.globals.lineProgress || 0
	],
	accumulated: [
		I,
		[],
		(r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
	],
	"+": [
		S,
		Ue(S),
		(r, e) => {
			let t = 0;
			for (const n of e) t += n.evaluate(r);
			return t;
		}
	],
	"*": [
		S,
		Ue(S),
		(r, e) => {
			let t = 1;
			for (const n of e) t *= n.evaluate(r);
			return t;
		}
	],
	"-": {
		type: S,
		overloads: [[[S, S], (r, [e, t]) => e.evaluate(r) - t.evaluate(r)], [[S], (r, [e]) => -e.evaluate(r)]]
	},
	"/": [
		S,
		[S, S],
		(r, [e, t]) => e.evaluate(r) / t.evaluate(r)
	],
	"%": [
		S,
		[S, S],
		(r, [e, t]) => e.evaluate(r) % t.evaluate(r)
	],
	ln2: [
		S,
		[],
		() => Math.LN2
	],
	pi: [
		S,
		[],
		() => Math.PI
	],
	e: [
		S,
		[],
		() => Math.E
	],
	"^": [
		S,
		[S, S],
		(r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
	],
	sqrt: [
		S,
		[S],
		(r, [e]) => Math.sqrt(e.evaluate(r))
	],
	log10: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r)) / Math.LN10
	],
	ln: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r))
	],
	log2: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r)) / Math.LN2
	],
	sin: [
		S,
		[S],
		(r, [e]) => Math.sin(e.evaluate(r))
	],
	cos: [
		S,
		[S],
		(r, [e]) => Math.cos(e.evaluate(r))
	],
	tan: [
		S,
		[S],
		(r, [e]) => Math.tan(e.evaluate(r))
	],
	asin: [
		S,
		[S],
		(r, [e]) => Math.asin(e.evaluate(r))
	],
	acos: [
		S,
		[S],
		(r, [e]) => Math.acos(e.evaluate(r))
	],
	atan: [
		S,
		[S],
		(r, [e]) => Math.atan(e.evaluate(r))
	],
	min: [
		S,
		Ue(S),
		(r, e) => Math.min(...e.map((t) => t.evaluate(r)))
	],
	max: [
		S,
		Ue(S),
		(r, e) => Math.max(...e.map((t) => t.evaluate(r)))
	],
	abs: [
		S,
		[S],
		(r, [e]) => Math.abs(e.evaluate(r))
	],
	round: [
		S,
		[S],
		(r, [e]) => {
			const t = e.evaluate(r);
			return t < 0 ? -Math.round(-t) : Math.round(t);
		}
	],
	floor: [
		S,
		[S],
		(r, [e]) => Math.floor(e.evaluate(r))
	],
	ceil: [
		S,
		[S],
		(r, [e]) => Math.ceil(e.evaluate(r))
	],
	"filter-==": [
		M,
		[P, I],
		(r, [e, t]) => r.properties()[e.value] === t.value
	],
	"filter-id-==": [
		M,
		[I],
		(r, [e]) => r.id() === e.value
	],
	"filter-type-==": [
		M,
		[P],
		(r, [e]) => r.geometryType() === e.value
	],
	"filter-<": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n < a;
		}
	],
	"filter-id-<": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t < n;
		}
	],
	"filter->": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n > a;
		}
	],
	"filter-id->": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t > n;
		}
	],
	"filter-<=": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n <= a;
		}
	],
	"filter-id-<=": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t <= n;
		}
	],
	"filter->=": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n >= a;
		}
	],
	"filter-id->=": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t >= n;
		}
	],
	"filter-has": [
		M,
		[I],
		(r, [e]) => e.value in r.properties()
	],
	"filter-has-id": [
		M,
		[],
		(r) => r.id() !== null && r.id() !== void 0
	],
	"filter-type-in": [
		M,
		[ne(P)],
		(r, [e]) => e.value.indexOf(r.geometryType()) >= 0
	],
	"filter-id-in": [
		M,
		[ne(I)],
		(r, [e]) => e.value.indexOf(r.id()) >= 0
	],
	"filter-in-small": [
		M,
		[P, ne(I)],
		(r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
	],
	"filter-in-large": [
		M,
		[P, ne(I)],
		(r, [e, t]) => Zl(r.properties()[e.value], t.value, 0, t.value.length - 1)
	],
	all: {
		type: M,
		overloads: [[[M, M], (r, [e, t]) => e.evaluate(r) && t.evaluate(r)], [Ue(M), (r, e) => {
			for (const t of e) if (!t.evaluate(r)) return !1;
			return !0;
		}]]
	},
	any: {
		type: M,
		overloads: [[[M, M], (r, [e, t]) => e.evaluate(r) || t.evaluate(r)], [Ue(M), (r, e) => {
			for (const t of e) if (t.evaluate(r)) return !0;
			return !1;
		}]]
	},
	"!": [
		M,
		[M],
		(r, [e]) => !e.evaluate(r)
	],
	"is-supported-script": [
		M,
		[P],
		(r, [e]) => {
			const t = r.globals && r.globals.isSupportedScript;
			return t ? t(e.evaluate(r)) : !0;
		}
	],
	upcase: [
		P,
		[P],
		(r, [e]) => e.evaluate(r).toUpperCase()
	],
	downcase: [
		P,
		[P],
		(r, [e]) => e.evaluate(r).toLowerCase()
	],
	concat: [
		P,
		Ue(I),
		(r, e) => e.map((t) => yt(t.evaluate(r))).join("")
	],
	"resolved-locale": [
		P,
		[ur],
		(r, [e]) => e.evaluate(r).resolvedLocale()
	]
});
function Kl(r) {
	return Array.isArray(r) ? `(${r.map(D).join(", ")})` : `(${D(r.type)}...)`;
}
function rr(r) {
	if (r instanceof yr) return rr(r.boundExpression);
	if (r instanceof me && r.name === "error") return !1;
	if (r instanceof vr) return !1;
	if (r instanceof He) return !1;
	if (r instanceof Ze) return !1;
	if (r instanceof Mt) return !1;
	const e = r instanceof $e || r instanceof he;
	let t = !0;
	return r.eachChild((n) => {
		e ? t = t && rr(n) : t = t && n instanceof it;
	}), t ? wr(r) && Sr(r, [
		"zoom",
		"heatmap-density",
		"elevation",
		"line-progress",
		"accumulated",
		"is-supported-script"
	]) : !1;
}
function wr(r) {
	if (r instanceof me) {
		if (r.name === "get" && r.args.length === 1) return !1;
		if (r.name === "feature-state") return !1;
		if (r.name === "has" && r.args.length === 1) return !1;
		if (r.name === "properties" || r.name === "geometry-type" || r.name === "id") return !1;
		if (/^filter-/.test(r.name)) return !1;
	}
	if (r instanceof He || r instanceof Ze) return !1;
	let e = !0;
	return r.eachChild((t) => {
		e && !wr(t) && (e = !1);
	}), e;
}
function kt(r) {
	if (r instanceof me && r.name === "feature-state") return !1;
	let e = !0;
	return r.eachChild((t) => {
		e && !kt(t) && (e = !1);
	}), e;
}
function Sr(r, e) {
	if (r instanceof me && e.indexOf(r.name) >= 0) return !1;
	let t = !0;
	return r.eachChild((n) => {
		t && !Sr(n, e) && (t = !1);
	}), t;
}
function Qr(r) {
	return {
		result: "success",
		value: r
	};
}
function tt(r) {
	return {
		result: "error",
		value: r
	};
}
function nr(r) {
	return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
}
function bo(r) {
	return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
}
function wo(r) {
	return !!r.expression && r.expression.interpolated;
}
function R(r) {
	return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
}
function Mn(r) {
	return typeof r == "object" && r !== null && !Array.isArray(r) && q(r) === Ve;
}
var Xl = class {
	constructor(e, t) {
		this.expression = e, this._warningHistory = {}, this._evaluator = new uo(), this._defaultValue = t ? Jl(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);
	}
	evaluate(e, t, n, a, o, i) {
		this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;
		try {
			const s = this.expression.evaluate(this._evaluator);
			if (s == null || typeof s == "number" && s !== s) return this._defaultValue;
			if (this._enumValues && !(s in this._enumValues)) throw new U(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);
			return s;
		} catch (s) {
			return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < "u" && console.warn(s.message)), this._defaultValue;
		}
	}
};
function So(r) {
	return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in In;
}
function xo(r, e) {
	const t = new hr(In, rr, [], e ? Wl(e) : void 0), n = t.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
	return n ? Qr(new Xl(n, e)) : tt(t.errors);
}
var ba = class {
	constructor(e, t) {
		this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !kt(t.expression), this.globalStateRefs = Pn(t.expression);
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
	}
	evaluate(e, t, n, a, o, i) {
		return this._styleExpression.evaluate(e, t, n, a, o, i);
	}
};
var wa = class {
	constructor(e, t, n, a) {
		this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !kt(t.expression), this.globalStateRefs = Pn(t.expression), this.interpolationType = a;
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
	}
	evaluate(e, t, n, a, o, i) {
		return this._styleExpression.evaluate(e, t, n, a, o, i);
	}
	interpolationFactor(e, t, n) {
		return this.interpolationType ? xe.interpolationFactor(this.interpolationType, e, t, n) : 0;
	}
};
function Yl(r, e) {
	const t = xo(r, e);
	if (t.result === "error") return t;
	const n = t.value.expression, a = wr(n);
	if (!a && !nr(e)) return tt([new we("", "data expressions not supported")]);
	const o = Sr(n, ["zoom"]);
	if (!o && !bo(e)) return tt([new we("", "zoom expressions not supported")]);
	const i = Ht(n);
	if (!i && !o) return tt([new we("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
	if (i instanceof we) return tt([i]);
	if (i instanceof xe && !wo(e)) return tt([new we("", "\"interpolate\" expressions cannot be used with this property")]);
	if (!i) return Qr(a ? new ba("constant", t.value) : new ba("source", t.value));
	const s = i instanceof xe ? i.interpolation : void 0;
	return Qr(a ? new wa("camera", t.value, i.labels, s) : new wa("composite", t.value, i.labels, s));
}
function Ht(r) {
	let e = null;
	if (r instanceof mr) e = Ht(r.result);
	else if (r instanceof St) {
		for (const t of r.args) if (e = Ht(t), e) break;
	} else (r instanceof gr || r instanceof xe) && r.input instanceof me && r.input.name === "zoom" && (e = r);
	return e instanceof we || r.eachChild((t) => {
		const n = Ht(t);
		n instanceof we ? e = n : !e && n ? e = new we("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e && n && e !== n && (e = new we("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
	}), e;
}
function Pn(r, e = /* @__PURE__ */ new Set()) {
	return r instanceof Mt && e.add(r.key), r.eachChild((t) => {
		Pn(t, e);
	}), e;
}
function Wl(r) {
	const e = {
		color: Se,
		string: P,
		number: S,
		enum: P,
		boolean: M,
		formatted: cr,
		padding: pr,
		numberArray: fr,
		colorArray: vt,
		projectionDefinition: lr,
		resolvedImage: _t,
		variableAnchorOffsetCollection: dr
	};
	return r.type === "array" ? ne(e[r.value] || I, r.length) : e[r.type];
}
function Jl(r) {
	if (r.type === "color" && Mn(r.default)) return new $(0, 0, 0, 0);
	switch (r.type) {
		case "color": return $.parse(r.default) || null;
		case "padding": return ie.parse(r.default) || null;
		case "numberArray": return se.parse(r.default) || null;
		case "colorArray": return Q.parse(r.default) || null;
		case "variableAnchorOffsetCollection": return ye.parse(r.default) || null;
		case "projectionDefinition": return de.parse(r.default) || null;
		default: return r.default === void 0 ? null : r.default;
	}
}
function ko(r) {
	if (r === !0 || r === !1) return !0;
	if (!Array.isArray(r) || r.length === 0) return !1;
	switch (r[0]) {
		case "has": return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
		case "in": return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
		case "!in":
		case "!has":
		case "none": return !1;
		case "==":
		case "!=":
		case ">":
		case ">=":
		case "<":
		case "<=": return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
		case "any":
		case "all":
			for (const e of r.slice(1)) if (!ko(e) && typeof e != "boolean") return !1;
			return !0;
		default: return !0;
	}
}
function Lo(r) {
	const e = r.key, t = r.value;
	return t ? [new b(e, t, "constants have been deprecated as of v8")] : [];
}
function B(r) {
	return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
}
function Ye(r) {
	if (Array.isArray(r)) return r.map(Ye);
	if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
		const e = {};
		for (const t in r) e[t] = Ye(r[t]);
		return e;
	}
	return B(r);
}
function le(r) {
	const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;
	let l = [];
	const u = R(t);
	if (u !== "object") return [new b(e, t, `object expected, ${u} found`)];
	for (const c in t) {
		const p = c.split(".")[0], d = mt(n, p) || n["*"];
		let f;
		if (mt(a, p)) f = a[p];
		else if (mt(n, p)) f = s;
		else if (a["*"]) f = a["*"];
		else if (n["*"]) f = s;
		else {
			l.push(new b(e, t[c], `unknown property "${c}"`));
			continue;
		}
		l = l.concat(f({
			key: (e && `${e}.`) + c,
			value: t[c],
			valueSpec: d,
			style: o,
			styleSpec: i,
			object: t,
			objectKey: c,
			validateSpec: s
		}, t));
	}
	for (const c in n) a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new b(e, t, `missing required property "${c}"`));
	return l;
}
function Rn(r) {
	const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;
	if (R(e) !== "array") return [new b(i, e, `array expected, ${R(e)} found`)];
	if (t.length && e.length !== t.length) return [new b(i, e, `array length ${t.length} expected, length ${e.length} found`)];
	if (t["min-length"] && e.length < t["min-length"]) return [new b(i, e, `array length at least ${t["min-length"]} expected, length ${e.length} found`)];
	let l = {
		type: t.value,
		values: t.values
	};
	o.$version < 7 && (l.function = t.function), R(t.value) === "object" && (l = t.value);
	let u = [];
	for (let c = 0; c < e.length; c++) u = u.concat(s({
		array: e,
		arrayIndex: c,
		value: e[c],
		valueSpec: l,
		validateSpec: r.validateSpec,
		style: a,
		styleSpec: o,
		key: `${i}[${c}]`
	}));
	return u;
}
function xr(r) {
	const e = r.key, t = r.value, n = r.valueSpec;
	let a = R(t);
	return a === "number" && t !== t && (a = "NaN"), a !== "number" ? [new b(e, t, `number expected, ${a} found`)] : "minimum" in n && t < n.minimum ? [new b(e, t, `${t} is less than the minimum value ${n.minimum}`)] : "maximum" in n && t > n.maximum ? [new b(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];
}
function Eo(r) {
	const e = r.valueSpec, t = B(r.value.type);
	let n, a = {}, o, i;
	const s = t !== "categorical" && r.value.property === void 0, l = !s, u = R(r.value.stops) === "array" && R(r.value.stops[0]) === "array" && R(r.value.stops[0][0]) === "object", c = le({
		key: r.key,
		value: r.value,
		valueSpec: r.styleSpec.function,
		validateSpec: r.validateSpec,
		style: r.style,
		styleSpec: r.styleSpec,
		objectElementValidators: {
			stops: p,
			default: h
		}
	});
	return t === "identity" && s && c.push(new b(r.key, r.value, "missing required property \"property\"")), t !== "identity" && !r.value.stops && c.push(new b(r.key, r.value, "missing required property \"stops\"")), t === "exponential" && r.valueSpec.expression && !wo(r.valueSpec) && c.push(new b(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (l && !nr(r.valueSpec) ? c.push(new b(r.key, r.value, "property functions not supported")) : s && !bo(r.valueSpec) && c.push(new b(r.key, r.value, "zoom functions not supported"))), (t === "categorical" || u) && r.value.property === void 0 && c.push(new b(r.key, r.value, "\"property\" property is required")), c;
	function p(m) {
		if (t === "identity") return [new b(m.key, m.value, "identity function may not have a \"stops\" property")];
		let y = [];
		const w = m.value;
		return y = y.concat(Rn({
			key: m.key,
			value: w,
			valueSpec: m.valueSpec,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec,
			arrayElementValidator: d
		})), R(w) === "array" && w.length === 0 && y.push(new b(m.key, w, "array must have at least one stop")), y;
	}
	function d(m) {
		let y = [];
		const w = m.value, v = m.key;
		if (R(w) !== "array") return [new b(v, w, `array expected, ${R(w)} found`)];
		if (w.length !== 2) return [new b(v, w, `array length 2 expected, length ${w.length} found`)];
		if (u) {
			if (R(w[0]) !== "object") return [new b(v, w, `object expected, ${R(w[0])} found`)];
			if (w[0].zoom === void 0) return [new b(v, w, "object stop key must have zoom")];
			if (w[0].value === void 0) return [new b(v, w, "object stop key must have value")];
			if (i && i > B(w[0].zoom)) return [new b(v, w[0].zoom, "stop zoom values must appear in ascending order")];
			B(w[0].zoom) !== i && (i = B(w[0].zoom), o = void 0, a = {}), y = y.concat(le({
				key: `${v}[0]`,
				value: w[0],
				valueSpec: { zoom: {} },
				validateSpec: m.validateSpec,
				style: m.style,
				styleSpec: m.styleSpec,
				objectElementValidators: {
					zoom: xr,
					value: f
				}
			}));
		} else y = y.concat(f({
			key: `${v}[0]`,
			value: w[0],
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		}, w));
		return So(Ye(w[1])) ? y.concat([new b(`${v}[1]`, w[1], "expressions are not allowed in function stops.")]) : y.concat(m.validateSpec({
			key: `${v}[1]`,
			value: w[1],
			valueSpec: e,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		}));
	}
	function f(m, y) {
		const w = R(m.value), v = B(m.value), x = m.value !== null ? m.value : y;
		if (!n) n = w;
		else if (w !== n) return [new b(m.key, x, `${w} stop domain type must match previous stop domain type ${n}`)];
		if (w !== "number" && w !== "string" && w !== "boolean") return [new b(m.key, x, "stop domain value must be a number, string, or boolean")];
		if (w !== "number" && t !== "categorical") {
			let A = `number expected, ${w} found`;
			return nr(e) && t === void 0 && (A += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new b(m.key, x, A)];
		}
		return t === "categorical" && w === "number" && (!isFinite(v) || Math.floor(v) !== v) ? [new b(m.key, x, `integer expected, found ${v}`)] : t !== "categorical" && w === "number" && o !== void 0 && v < o ? [new b(m.key, x, "stop domain values must appear in ascending order")] : (o = v, t === "categorical" && v in a ? [new b(m.key, x, "stop domain values must be unique")] : (a[v] = !0, []));
	}
	function h(m) {
		return m.validateSpec({
			key: m.key,
			value: m.value,
			valueSpec: e,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		});
	}
}
function st(r) {
	const e = (r.expressionContext === "property" ? Yl : xo)(Ye(r.value), r.valueSpec);
	if (e.result === "error") return e.value.map((n) => new b(`${r.key}${n.key}`, r.value, n.message));
	const t = e.value.expression || e.value._styleExpression.expression;
	if (r.expressionContext === "property" && r.propertyKey === "text-font" && !t.outputDefined()) return [new b(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
	if (r.expressionContext === "property" && r.propertyType === "layout" && !kt(t)) return [new b(r.key, r.value, "\"feature-state\" data expressions are not supported with layout properties.")];
	if (r.expressionContext === "filter" && !kt(t)) return [new b(r.key, r.value, "\"feature-state\" data expressions are not supported with filters.")];
	if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
		if (!Sr(t, ["zoom", "feature-state"])) return [new b(r.key, r.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
		if (r.expressionContext === "cluster-initial" && !wr(t)) return [new b(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
	}
	return [];
}
function Ql(r) {
	const e = r.value, t = r.key, n = R(e);
	return n !== "boolean" ? [new b(t, e, `boolean expected, ${n} found`)] : [];
}
function en(r) {
	const e = r.key, t = r.value, n = R(t);
	return n !== "string" ? [new b(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new b(e, t, `color expected, "${t}" found`)];
}
function Lt(r) {
	const e = r.key, t = r.value, n = r.valueSpec, a = [];
	return Array.isArray(n.values) ? n.values.indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${n.values.join(", ")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(t)} found`)), a;
}
function zn(r) {
	return ko(Ye(r.value)) ? st(Yt({}, r, {
		expressionContext: "filter",
		valueSpec: { value: "boolean" }
	})) : Co(r);
}
function Co(r) {
	const e = r.value, t = r.key;
	if (R(e) !== "array") return [new b(t, e, `array expected, ${R(e)} found`)];
	const n = r.styleSpec;
	let a, o = [];
	if (e.length < 1) return [new b(t, e, "filter array must have at least 1 element")];
	switch (o = o.concat(Lt({
		key: `${t}[0]`,
		value: e[0],
		valueSpec: n.filter_operator,
		style: r.style,
		styleSpec: r.styleSpec
	})), B(e[0])) {
		case "<":
		case "<=":
		case ">":
		case ">=": e.length >= 2 && B(e[1]) === "$type" && o.push(new b(t, e, `"$type" cannot be use with operator "${e[0]}"`));
		case "==":
		case "!=": e.length !== 3 && o.push(new b(t, e, `filter array for operator "${e[0]}" must have 3 elements`));
		case "in":
		case "!in":
			e.length >= 2 && (a = R(e[1]), a !== "string" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`)));
			for (let i = 2; i < e.length; i++) a = R(e[i]), B(e[1]) === "$type" ? o = o.concat(Lt({
				key: `${t}[${i}]`,
				value: e[i],
				valueSpec: n.geometry_type,
				style: r.style,
				styleSpec: r.styleSpec
			})) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new b(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));
			break;
		case "any":
		case "all":
		case "none":
			for (let i = 1; i < e.length; i++) o = o.concat(Co({
				key: `${t}[${i}]`,
				value: e[i],
				style: r.style,
				styleSpec: r.styleSpec
			}));
			break;
		case "has":
		case "!has":
			a = R(e[1]), e.length !== 2 ? o.push(new b(t, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`));
			break;
	}
	return o;
}
function Ao(r, e) {
	const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];
	if (!l) return [];
	const u = s.match(/^(.*)-transition$/);
	if (e === "paint" && u && l[u[1]] && l[u[1]].transition) return n({
		key: t,
		value: i,
		valueSpec: o.transition,
		style: a,
		styleSpec: o
	});
	const c = r.valueSpec || l[s];
	if (!c) return [new b(t, i, `unknown property "${s}"`)];
	let p;
	if (R(i) === "string" && nr(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i))) return [new b(t, i, `"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)];
	const d = [];
	return r.layerType === "symbol" && (s === "text-field" && a && !a.glyphs && d.push(new b(t, i, "use of \"text-field\" requires a style \"glyphs\" property")), s === "text-font" && Mn(Ye(i)) && B(i.type) === "identity" && d.push(new b(t, i, "\"text-font\" does not support identity functions"))), d.concat(n({
		key: r.key,
		value: i,
		valueSpec: c,
		style: a,
		styleSpec: o,
		expressionContext: "property",
		propertyType: e,
		propertyKey: s
	}));
}
function To(r) {
	return Ao(r, "paint");
}
function _o(r) {
	return Ao(r, "layout");
}
function Io(r) {
	let e = [];
	const t = r.value, n = r.key, a = r.style, o = r.styleSpec;
	if (R(t) !== "object") return [new b(n, t, `object expected, ${R(t)} found`)];
	!t.type && !t.ref && e.push(new b(n, t, "either \"type\" or \"ref\" is required"));
	let i = B(t.type);
	const s = B(t.ref);
	if (t.id) {
		const l = B(t.id);
		for (let u = 0; u < r.arrayIndex; u++) {
			const c = a.layers[u];
			B(c.id) === l && e.push(new b(n, t.id, `duplicate layer id "${t.id}", previously used at line ${c.id.__line__}`));
		}
	}
	if ("ref" in t) {
		[
			"type",
			"source",
			"source-layer",
			"filter",
			"layout"
		].forEach((u) => {
			u in t && e.push(new b(n, t[u], `"${u}" is prohibited for ref layers`));
		});
		let l;
		a.layers.forEach((u) => {
			B(u.id) === s && (l = u);
		}), l ? l.ref ? e.push(new b(n, t.ref, "ref cannot reference another ref layer")) : i = B(l.type) : e.push(new b(n, t.ref, `ref layer "${s}" not found`));
	} else if (i !== "background") if (!t.source) e.push(new b(n, t, "missing required property \"source\""));
	else {
		const l = a.sources && a.sources[t.source], u = l && B(l.type);
		l ? u === "vector" && i === "raster" ? e.push(new b(n, t.source, `layer "${t.id}" requires a raster source`)) : u !== "raster-dem" && i === "hillshade" ? e.push(new b(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u !== "raster-dem" && i === "color-relief" ? e.push(new b(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u === "raster" && i !== "raster" ? e.push(new b(n, t.source, `layer "${t.id}" requires a vector source`)) : u === "vector" && !t["source-layer"] ? e.push(new b(n, t, `layer "${t.id}" must specify a "source-layer"`)) : u === "raster-dem" && i !== "hillshade" && i !== "color-relief" ? e.push(new b(n, t.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : i === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new b(n, t, `layer "${t.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new b(n, t.source, `source "${t.source}" not found`));
	}
	return e = e.concat(le({
		key: n,
		value: t,
		valueSpec: o.layer,
		style: r.style,
		styleSpec: r.styleSpec,
		validateSpec: r.validateSpec,
		objectElementValidators: {
			"*"() {
				return [];
			},
			type() {
				return r.validateSpec({
					key: `${n}.type`,
					value: t.type,
					valueSpec: o.layer.type,
					style: r.style,
					styleSpec: r.styleSpec,
					validateSpec: r.validateSpec,
					object: t,
					objectKey: "type"
				});
			},
			filter: zn,
			layout(l) {
				return le({
					layer: t,
					key: l.key,
					value: l.value,
					style: l.style,
					styleSpec: l.styleSpec,
					validateSpec: l.validateSpec,
					objectElementValidators: { "*"(u) {
						return _o(Yt({ layerType: i }, u));
					} }
				});
			},
			paint(l) {
				return le({
					layer: t,
					key: l.key,
					value: l.value,
					style: l.style,
					styleSpec: l.styleSpec,
					validateSpec: l.validateSpec,
					objectElementValidators: { "*"(u) {
						return To(Yt({ layerType: i }, u));
					} }
				});
			}
		}
	})), e;
}
function We(r) {
	const e = r.value, t = r.key, n = R(e);
	return n !== "string" ? [new b(t, e, `string expected, ${n} found`)] : [];
}
function eu(r) {
	var e;
	const t = (e = r.sourceName) !== null && e !== void 0 ? e : "", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;
	let s = [];
	const l = R(n);
	if (n === void 0) return s;
	if (l !== "object") return s.push(new b("source_raster_dem", n, `object expected, ${l} found`)), s;
	const c = B(n.encoding) === "custom", p = [
		"redFactor",
		"greenFactor",
		"blueFactor",
		"baseShift"
	], d = r.value.encoding ? `"${r.value.encoding}"` : "Default";
	for (const f in n) !c && p.includes(f) ? s.push(new b(f, n[f], `In "${t}": "${f}" is only valid when "encoding" is set to "custom". ${d} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({
		key: f,
		value: n[f],
		valueSpec: o[f],
		validateSpec: r.validateSpec,
		style: i,
		styleSpec: a
	})) : s.push(new b(f, n[f], `unknown property "${f}"`));
	return s;
}
var Sa = { promoteId: tu };
function Mo(r) {
	const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;
	if (!e.type) return [new b(t, e, "\"type\" is required")];
	const i = B(e.type);
	let s;
	switch (i) {
		case "vector":
		case "raster": return s = le({
			key: t,
			value: e,
			valueSpec: n[`source_${i.replace("-", "_")}`],
			style: r.style,
			styleSpec: n,
			objectElementValidators: Sa,
			validateSpec: o
		}), s;
		case "raster-dem": return s = eu({
			sourceName: t,
			value: e,
			style: r.style,
			styleSpec: n,
			validateSpec: o
		}), s;
		case "geojson":
			if (s = le({
				key: t,
				value: e,
				valueSpec: n.source_geojson,
				style: a,
				styleSpec: n,
				validateSpec: o,
				objectElementValidators: Sa
			}), e.cluster) for (const l in e.clusterProperties) {
				const [u, c] = e.clusterProperties[l], p = typeof u == "string" ? [
					u,
					["accumulated"],
					["get", l]
				] : u;
				s.push(...st({
					key: `${t}.${l}.map`,
					value: c,
					expressionContext: "cluster-map"
				})), s.push(...st({
					key: `${t}.${l}.reduce`,
					value: p,
					expressionContext: "cluster-reduce"
				}));
			}
			return s;
		case "video": return le({
			key: t,
			value: e,
			valueSpec: n.source_video,
			style: a,
			validateSpec: o,
			styleSpec: n
		});
		case "image": return le({
			key: t,
			value: e,
			valueSpec: n.source_image,
			style: a,
			validateSpec: o,
			styleSpec: n
		});
		case "canvas": return [new b(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
		default: return Lt({
			key: `${t}.type`,
			value: e.type,
			valueSpec: { values: [
				"vector",
				"raster",
				"raster-dem",
				"geojson",
				"video",
				"image"
			] }
		});
	}
}
function tu({ key: r, value: e }) {
	if (R(e) === "string") return We({
		key: r,
		value: e
	});
	{
		const t = [];
		for (const n in e) t.push(...We({
			key: `${r}.${n}`,
			value: e[n]
		}));
		return t;
	}
}
function Po(r) {
	const e = r.value, t = r.styleSpec, n = t.light, a = r.style;
	let o = [];
	const i = R(e);
	if (e === void 0) return o;
	if (i !== "object") return o = o.concat([new b("light", e, `object expected, ${i} found`)]), o;
	for (const s in e) {
		const l = s.match(/^(.*)-transition$/);
		l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({
			key: s,
			value: e[s],
			valueSpec: t.transition,
			validateSpec: r.validateSpec,
			style: a,
			styleSpec: t
		})) : n[s] ? o = o.concat(r.validateSpec({
			key: s,
			value: e[s],
			valueSpec: n[s],
			validateSpec: r.validateSpec,
			style: a,
			styleSpec: t
		})) : o = o.concat([new b(s, e[s], `unknown property "${s}"`)]);
	}
	return o;
}
function Ro(r) {
	const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);
	if (e === void 0) return [];
	if (o !== "object") return [new b("sky", e, `object expected, ${o} found`)];
	let i = [];
	for (const s in e) n[s] ? i = i.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		style: a,
		styleSpec: t
	})) : i = i.concat([new b(s, e[s], `unknown property "${s}"`)]);
	return i;
}
function zo(r) {
	const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;
	let o = [];
	const i = R(e);
	if (e === void 0) return o;
	if (i !== "object") return o = o.concat([new b("terrain", e, `object expected, ${i} found`)]), o;
	for (const s in e) n[s] ? o = o.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		validateSpec: r.validateSpec,
		style: a,
		styleSpec: t
	})) : o = o.concat([new b(s, e[s], `unknown property "${s}"`)]);
	return o;
}
function ru(r) {
	return We(r).length === 0 ? [] : st(r);
}
function nu(r) {
	return We(r).length === 0 ? [] : st(r);
}
function au(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		if (t.length < 1 || t.length > 4) return [new b(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];
		const a = { type: "number" };
		let o = [];
		for (let i = 0; i < t.length; i++) o = o.concat(r.validateSpec({
			key: `${e}[${i}]`,
			value: t[i],
			validateSpec: r.validateSpec,
			valueSpec: a
		}));
		return o;
	} else return xr({
		key: e,
		value: t,
		valueSpec: {}
	});
}
function ou(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		const a = { type: "number" };
		if (t.length < 1) return [new b(e, t, "array length at least 1 expected, length 0 found")];
		let o = [];
		for (let i = 0; i < t.length; i++) o = o.concat(r.validateSpec({
			key: `${e}[${i}]`,
			value: t[i],
			validateSpec: r.validateSpec,
			valueSpec: a
		}));
		return o;
	} else return xr({
		key: e,
		value: t,
		valueSpec: {}
	});
}
function iu(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		if (t.length < 1) return [new b(e, t, "array length at least 1 expected, length 0 found")];
		let a = [];
		for (let o = 0; o < t.length; o++) a = a.concat(en({
			key: `${e}[${o}]`,
			value: t[o]
		}));
		return a;
	} else return en({
		key: e,
		value: t
	});
}
function su(r) {
	const e = r.key, t = r.value, n = R(t), a = r.styleSpec;
	if (n !== "array" || t.length < 1 || t.length % 2 !== 0) return [new b(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
	let o = [];
	for (let i = 0; i < t.length; i += 2) o = o.concat(Lt({
		key: `${e}[${i}]`,
		value: t[i],
		valueSpec: a.layout_symbol["text-anchor"]
	})), o = o.concat(Rn({
		key: `${e}[${i + 1}]`,
		value: t[i + 1],
		valueSpec: {
			length: 2,
			value: "number"
		},
		validateSpec: r.validateSpec,
		style: r.style,
		styleSpec: a
	}));
	return o;
}
function Oo(r) {
	let e = [];
	const t = r.value, n = r.key;
	if (Array.isArray(t)) {
		const a = [], o = [];
		for (const i in t) {
			t[i].id && a.includes(t[i].id) && e.push(new b(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new b(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);
			e = e.concat(le({
				key: `${n}[${i}]`,
				value: t[i],
				valueSpec: {
					id: {
						type: "string",
						required: !0
					},
					url: {
						type: "string",
						required: !0
					}
				},
				validateSpec: r.validateSpec
			}));
		}
		return e;
	} else return We({
		key: n,
		value: t
	});
}
function lu(r) {
	const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);
	if (e === void 0) return [];
	if (o !== "object") return [new b("projection", e, `object expected, ${o} found`)];
	let i = [];
	for (const s in e) n[s] ? i = i.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		style: a,
		styleSpec: t
	})) : i = i.concat([new b(s, e[s], `unknown property "${s}"`)]);
	return i;
}
function uu(r) {
	const e = r.key;
	let t = r.value;
	t = t instanceof String ? t.valueOf() : t;
	const n = R(t);
	return n === "array" && !pu(t) && !cu(t) ? [new b(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : ["array", "string"].includes(n) ? [] : [new b(e, t, `projection expected, invalid type "${n}" found`)];
}
function cu(r) {
	return !![
		"interpolate",
		"step",
		"literal"
	].includes(r[0]);
}
function pu(r) {
	return Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number";
}
function fu(r) {
	return !!r && r.constructor === Object;
}
function $o(r) {
	return fu(r.value) ? [] : [new b(r.key, r.value, `object expected, ${R(r.value)} found`)];
}
var xa = {
	"*"() {
		return [];
	},
	array: Rn,
	boolean: Ql,
	number: xr,
	color: en,
	constants: Lo,
	enum: Lt,
	filter: zn,
	function: Eo,
	layer: Io,
	object: le,
	source: Mo,
	light: Po,
	sky: Ro,
	terrain: zo,
	projection: lu,
	projectionDefinition: uu,
	string: We,
	formatted: ru,
	resolvedImage: nu,
	padding: au,
	numberArray: ou,
	colorArray: iu,
	variableAnchorOffsetCollection: su,
	sprite: Oo,
	state: $o
};
function ar(r) {
	const e = r.value, t = r.valueSpec, n = r.styleSpec;
	return r.validateSpec = ar, t.expression && Mn(B(e)) ? Eo(r) : t.expression && So(Ye(e)) ? st(r) : t.type && xa[t.type] ? xa[t.type](r) : le(Yt({}, r, { valueSpec: t.type ? n[t.type] : t }));
}
function Fo(r) {
	const e = r.value, t = r.key, n = We(r);
	return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new b(t, e, "\"glyphs\" url must include a \"{fontstack}\" token")), e.indexOf("{range}") === -1 && n.push(new b(t, e, "\"glyphs\" url must include a \"{range}\" token"))), n;
}
function ae(r, e = Ds) {
	let t = [];
	return t = t.concat(ar({
		key: "",
		value: r,
		valueSpec: e.$root,
		styleSpec: e,
		style: r,
		validateSpec: ar,
		objectElementValidators: {
			glyphs: Fo,
			"*"() {
				return [];
			}
		}
	})), r.constants && (t = t.concat(Lo({
		key: "constants",
		value: r.constants
	}))), No(t);
}
ae.source = ve(ge(Mo));
ae.sprite = ve(ge(Oo));
ae.glyphs = ve(ge(Fo));
ae.light = ve(ge(Po));
ae.sky = ve(ge(Ro));
ae.terrain = ve(ge(zo));
ae.state = ve(ge($o));
ae.layer = ve(ge(Io));
ae.filter = ve(ge(zn));
ae.paintProperty = ve(ge(To));
ae.layoutProperty = ve(ge(_o));
function ge(r) {
	return function(e) {
		return r({
			...e,
			validateSpec: ar
		});
	};
}
function No(r) {
	return [].concat(r).sort((e, t) => e.line - t.line);
}
function ve(r) {
	return function(...e) {
		return No(r.apply(this, e));
	};
}
function ka(r) {
	if (!r) return {
		style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !0
	};
	if (typeof r == "string") {
		const t = hu(r);
		return t.isValidStyle ? {
			style: t.styleObject,
			requiresUrlMonitoring: !1,
			isFallback: !1
		} : t.isValidJSON ? {
			style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
			requiresUrlMonitoring: !1,
			isFallback: !0
		} : r.startsWith("http") ? {
			style: r,
			requiresUrlMonitoring: !0,
			isFallback: !1
		} : r.toLowerCase().includes(".json") ? {
			style: du(r),
			requiresUrlMonitoring: !0,
			isFallback: !1
		} : {
			style: expandMapStyle(r),
			requiresUrlMonitoring: !0,
			isFallback: !1
		};
	}
	return r instanceof MapStyleVariant ? {
		style: r.getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !1
	} : r instanceof ReferenceMapStyle ? {
		style: r.getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !1
	} : ae(r).length === 0 ? {
		style: r,
		requiresUrlMonitoring: !1,
		isFallback: !1,
		isJSON: !0
	} : {
		style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !0
	};
}
function du(r) {
	try {
		return new URL(r).href;
	} catch {}
	return new URL(r, location.origin).href;
}
function hu(r) {
	try {
		const e = JSON.parse(r), t = ae(e);
		return {
			isValidJSON: !0,
			isValidStyle: t.length === 0,
			styleObject: t.length === 0 ? e : null
		};
	} catch {
		return {
			isValidJSON: !1,
			isValidStyle: !1,
			styleObject: null
		};
	}
}
function Te(r, e, t) {
	const n = window.document.createElement(r);
	return e !== void 0 && (n.className = e), t && t.appendChild(n), n;
}
function Et(r) {
	r.parentNode && r.parentNode.removeChild(r);
}
var mu = class {
	constructor() {
		g(this, "_map");
		g(this, "_container");
		g(this, "_terrainButton");
		qi(["_toggleTerrain", "_updateTerrainIcon"], this);
	}
	onAdd(e) {
		return this._map = e, this._container = Te("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Te("button", "maplibregl-ctrl-terrain", this._container), Te("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
	}
	onRemove() {
		Et(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
	}
	_toggleTerrain() {
		jo(this._map), this._updateTerrainIcon();
	}
	_updateTerrainIcon() {
		this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
	}
};
function jo(r) {
	r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();
}
var yu = class extends Wa {
	constructor(t = {}) {
		super({
			showCompass: t.showCompass ?? !0,
			showZoom: t.showZoom ?? !0,
			visualizePitch: t.visualizePitch ?? !0
		});
		/**
		* Overloading: Limit how flat the compass icon can get
		*/
		g(this, "_rotateCompassArrow", () => {
			const t$1 = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** .5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t$1}deg)` : `rotate(${-t$1}deg)`;
			this._compassIcon.style.transform = a;
		});
		this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (n) => {
			this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });
		}));
	}
	/**
	* Overloading: the button now stores its click callback so that we can later on delete it and replace it
	*/
	_createButton(t, n) {
		const a = super._createButton(t, n);
		return a.clickFunction = n, a;
	}
};
var La = import_maplibre_gl.default.Marker, Ea = import_maplibre_gl.default.LngLat, gu = import_maplibre_gl.default.LngLatBounds;
var vu = class extends Pi {
	constructor() {
		super(...arguments);
		g(this, "lastUpdatedCenter", new Ea(0, 0));
		/**
		* Update the camera location to center on the current position
		*
		* @param {Position} position the Geolocation API Position
		* @private
		*/
		g(this, "_updateCamera", (t) => {
			var c;
			const n = new Ea(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {
				bearing: this._map.getBearing(),
				...this.options.fitBoundsOptions,
				linear: !0
			}, s = this._map.getZoom();
			s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(gu.fromLngLat(n, a), i, { geolocateSource: !0 });
			let l = !1;
			const u = () => {
				l = !0;
			};
			this._map.once("click", u), this._map.once("dblclick", u), this._map.once("dragstart", u), this._map.once("mousedown", u), this._map.once("touchstart", u), this._map.once("wheel", u), this._map.once("moveend", () => {
				this._map.off("click", u), this._map.off("dblclick", u), this._map.off("dragstart", u), this._map.off("mousedown", u), this._map.off("touchstart", u), this._map.off("wheel", u), !l && (this.lastUpdatedCenter = this._map.getCenter());
			});
		});
		g(this, "_finishSetupUI", (t) => {
			if (this._map) {
				if (t === !1) {
					const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
					this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
				} else {
					const n = this._map._getUIString("GeolocateControl.FindMyLocation");
					this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
				}
				this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Te("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new La({ element: this._dotElement }), this._circleElement = Te("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new La({
					element: this._circleElement,
					pitchAlignment: "map"
				}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("moveend", (n) => {
					const a = n.originalEvent && n.originalEvent.type === "resize", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
					!n.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && o > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
				});
			}
		});
		g(this, "_onZoom", () => {
			this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
		});
	}
	_updateCircleRadius() {
		if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK") return;
		const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);
		this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
	}
	_setErrorState() {
		switch (this._watchState) {
			case "WAITING_ACTIVE":
				this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
				break;
			case "ACTIVE_LOCK":
				this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
				break;
			case "BACKGROUND":
				this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
				break;
			case "ACTIVE_ERROR": break;
			case "BACKGROUND_ERROR": break;
			default: throw new Error(`Unexpected watchState ${this._watchState}`);
		}
	}
};
var Me, Y, Pe, Re, nt;
var bu = class {
	/**
	* @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM
	* @param onClick Function called when the element is clicked
	* @param onRender Function called every time the underlying map renders a new state
	*/
	constructor(e, t, n) {
		Z(this, Me);
		Z(this, Y);
		Z(this, Pe);
		Z(this, Re);
		Z(this, nt);
		if (typeof e == "string") {
			const a = document.querySelector(e);
			if (!a) throw new Error(`No element has been found with selector "${e}" when creating an external control.`);
			K(this, Y, a);
		} else K(this, Y, e);
		t && K(this, Pe, (a) => {
			t(k(this, Me), k(this, Y), a);
		}), n && K(this, Re, (a) => {
			n(k(this, Me), k(this, Y), a);
		}), K(this, nt, k(this, Y).parentElement);
	}
	onAdd(e) {
		return K(this, Me, e), k(this, Pe) && k(this, Y).addEventListener("click", k(this, Pe)), k(this, Re) && k(this, Me).on("render", k(this, Re)), Et(k(this, Y)), k(this, Y);
	}
	onRemove() {
		k(this, Pe) && k(this, Y).removeEventListener("click", k(this, Pe)), k(this, Re) && k(this, Me).off("render", k(this, Re)), k(this, nt) ? k(this, nt).appendChild(k(this, Y)) : Et(k(this, Y));
	}
};
Me = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), Re = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap();
var wu = class {
	constructor() {
		g(this, "map");
		g(this, "container");
		g(this, "projectionButton");
	}
	onAdd(e) {
		return this.map = e, this.container = Te("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = Te("button", "maplibregl-ctrl-projection", this.container), Te("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), e.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
	}
	onRemove() {
		Et(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
	}
	toggleProjection() {
		Do(this.map), this.updateProjectionIcon();
	}
	updateProjectionIcon() {
		this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
	}
};
function Do(r) {
	r.getProjection() === void 0 && r.setProjection({ type: "mercator" }), r.isGlobeProjection() ? r.enableMercatorProjection() : r.enableGlobeProjection();
}
var pt = {
	"zoom-in": (r) => r.zoomIn(),
	"zoom-out": (r) => r.zoomOut(),
	"toggle-projection": Do,
	"toggle-terrain": jo,
	"reset-view": (r) => {
		r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();
	},
	"reset-bearing": (r) => {
		r.rotateTo(0);
	},
	"reset-pitch": (r) => {
		r.setPitch(0);
	},
	"reset-roll": (r) => {
		r.setRoll(0);
	}
};
var At, at;
var tn = class extends bu {
	/**
	* Constructs an instance of External Control to have a predefined functionality
	* @param controlElement Element to be used as control, specified as reference to element itself
	* @param controlType One of the predefined types of functionality
	*/
	constructor(t, n) {
		if (n && !(n in pt)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
		super(t, n && pt[n]);
		Z(this, At);
		Z(this, at, /* @__PURE__ */ new Map());
	}
	onAdd(t) {
		return K(this, At, t), super.onAdd(t);
	}
	onRemove() {
		for (const [t, n] of k(this, at)) {
			const a = t.deref();
			a && a.removeEventListener("click", n);
		}
		k(this, at).clear(), super.onRemove();
	}
	/**
	* Configure a child element to be part of this control and to have a predefined functionality added
	* @param controlElement Element that is a descendant of the control element and that optionally should have some functionality
	* @param controlType One of the predefined types of functionality
	*/
	configureGroupItem(t, n) {
		if (!n) return;
		if (!(n in pt)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
		const a = (o) => {
			pt[n](k(this, At), t, o);
		};
		t.addEventListener("click", a), k(this, at).set(new WeakRef(t), a);
	}
};
At = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), g(tn, "controlCallbacks", pt);
var W, fe, ze, Oe, te, Tt, G, Uo, oe, Bo;
var $r = class {
	constructor(e, t) {
		Z(this, G);
		Z(this, W);
		g(this, "map");
		Z(this, fe);
		Z(this, ze);
		Z(this, Oe);
		Z(this, te, !1);
		Z(this, Tt);
		e.style !== void 0 && K(this, te, !0), K(this, W, {
			zoomAdjust: -4,
			position: "top-right",
			...t,
			forceNoAttributionControl: !0,
			attributionControl: !1,
			navigationControl: !1,
			geolocateControl: !1,
			maptilerLogo: !1,
			minimap: !1,
			hash: !1,
			pitchAdjust: !1,
			...e,
			containerStyle: {
				border: "1px solid #000",
				width: "400px",
				height: "300px",
				...e.containerStyle ?? {}
			}
		}), e.lockZoom !== void 0 && (k(this, W).minZoom = e.lockZoom, k(this, W).maxZoom = e.lockZoom);
	}
	setStyle(e, t) {
		k(this, te) || this.map.setStyle(e, t), X(this, G, oe).call(this);
	}
	addLayer(e, t) {
		return k(this, te) || this.map.addLayer(e, t), X(this, G, oe).call(this), this.map;
	}
	moveLayer(e, t) {
		return k(this, te) || this.map.moveLayer(e, t), X(this, G, oe).call(this), this.map;
	}
	removeLayer(e) {
		return k(this, te) || this.map.removeLayer(e), X(this, G, oe).call(this), this;
	}
	setLayerZoomRange(e, t, n) {
		return k(this, te) || this.map.setLayerZoomRange(e, t, n), X(this, G, oe).call(this), this;
	}
	setFilter(e, t, n) {
		return k(this, te) || this.map.setFilter(e, t, n), X(this, G, oe).call(this), this;
	}
	setPaintProperty(e, t, n, a) {
		return k(this, te) || this.map.setPaintProperty(e, t, n, a), X(this, G, oe).call(this), this;
	}
	setLayoutProperty(e, t, n, a) {
		return k(this, te) || this.map.setLayoutProperty(e, t, n, a), X(this, G, oe).call(this), this;
	}
	setGlyphs(e, t) {
		return k(this, te) || this.map.setGlyphs(e, t), X(this, G, oe).call(this), this;
	}
	onAdd(e) {
		K(this, fe, e), K(this, ze, Te("div", "maplibregl-ctrl maplibregl-ctrl-group"));
		for (const [t, n] of Object.entries(k(this, W).containerStyle)) k(this, ze).style.setProperty(t, n);
		return k(this, W).container = k(this, ze), k(this, W).zoom = e.getZoom() + k(this, W).zoomAdjust, this.map = new Go(k(this, W)), this.map.once("style.load", () => {
			this.map.resize();
		}), this.map.once("load", () => {
			X(this, G, Uo).call(this, k(this, W).parentRect), K(this, Tt, X(this, G, Bo).call(this));
		}), k(this, ze);
	}
	onRemove() {
		var e;
		(e = k(this, Tt)) == null || e.call(this), Et(k(this, ze));
	}
};
W = /* @__PURE__ */ new WeakMap(), fe = /* @__PURE__ */ new WeakMap(), ze = /* @__PURE__ */ new WeakMap(), Oe = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap(), Tt = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakSet(), Uo = function(e) {
	e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (K(this, Oe, {
		type: "Feature",
		properties: { name: "parentRect" },
		geometry: {
			type: "Polygon",
			coordinates: [[
				[],
				[],
				[],
				[],
				[]
			]]
		}
	}), this.map.addSource("parentRect", {
		type: "geojson",
		data: k(this, Oe)
	}), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
		id: "parentRectOutline",
		type: "line",
		source: "parentRect",
		layout: { ...e.lineLayout },
		paint: {
			"line-color": "#FFF",
			"line-width": 1,
			"line-opacity": .85,
			...e.linePaint
		}
	}), e.fillPaint !== void 0 && this.map.addLayer({
		id: "parentRectFill",
		type: "fill",
		source: "parentRect",
		layout: {},
		paint: {
			"fill-color": "#08F",
			"fill-opacity": .135,
			...e.fillPaint
		}
	}), X(this, G, oe).call(this));
}, oe = function() {
	if (k(this, Oe) === void 0) return;
	const { devicePixelRatio: e } = window, t = k(this, fe).getCanvas(), n = t.width / e, a = t.height / e, o = k(this, fe).unproject.bind(k(this, fe)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);
	k(this, Oe).geometry.coordinates = [[
		l.toArray(),
		u.toArray(),
		s.toArray(),
		i.toArray(),
		l.toArray()
	]];
	const c = this.map.getSource("parentRect");
	c !== void 0 && c.setData(k(this, Oe));
}, Bo = function() {
	const { pitchAdjust: e } = k(this, W), t = () => {
		i("parent");
	}, n = () => {
		i("minimap");
	}, a = () => {
		k(this, fe).on("move", t), this.map.on("move", n);
	}, o = () => {
		k(this, fe).off("move", t), this.map.off("move", n);
	}, i = (s) => {
		o();
		const l = s === "parent" ? k(this, fe) : this.map, u = s === "parent" ? this.map : k(this, fe), c = l.getCenter(), p = l.getZoom() + k(this, W).zoomAdjust * (s === "parent" ? 1 : -1), d = l.getBearing(), f = l.getPitch();
		u.jumpTo({
			center: c,
			zoom: p,
			bearing: d,
			pitch: e ? f : 0
		}), X(this, G, oe).call(this), a();
	};
	return a(), () => {
		o();
	};
};
var Su = class {
	/**
	*
	* @param map : a Map instance
	* @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
	*/
	constructor(e, t = 2e3) {
		g(this, "map");
		g(this, "registeredModules", /* @__PURE__ */ new Set());
		g(this, "viewerType");
		this.map = e, this.viewerType = "Map", setTimeout(async () => {
			if (!j.telemetry) return;
			const n = this.preparePayload();
			try {
				(await fetch(n, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
			} catch (a) {
				console.warn("The metrics could not be sent to MapTiler Cloud", a);
			}
		}, Math.max(1e3, t));
	}
	/**
	* Register a module to the telemetry system of the SDK.
	* The arguments `name` and `version` likely come from the package.json
	* of each module.
	*/
	registerModule(e, t) {
		this.registeredModules.add(`${e}:${t}`);
	}
	registerViewerType(e = "Map") {
		this.viewerType = e;
	}
	preparePayload() {
		const e = new URL(J.telemetryURL);
		return e.searchParams.append("sdk", Kc()), e.searchParams.append("key", j.apiKey), e.searchParams.append("mtsid", dn), e.searchParams.append("session", j.session ? "1" : "0"), e.searchParams.append("caching", j.caching ? "1" : "0"), e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), e.searchParams.append("viewerType", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")), e.href;
	}
};
var Ct = typeof Float32Array < "u" ? Float32Array : Array;
function gt() {
	var r = new Ct(16);
	return Ct != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
}
function xu(r, e, t, n, a, o, i, s, l, u, c, p, d, f, h, m, y) {
	return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = d, r[12] = f, r[13] = h, r[14] = m, r[15] = y, r;
}
function ku(r, e, t) {
	var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], d = e[9], f = e[10], h = e[11], m = e[12], y = e[13], w = e[14], v = e[15], x = t[0], A = t[1], E = t[2], C = t[3];
	return r[0] = x * n + A * s + E * p + C * m, r[1] = x * a + A * l + E * d + C * y, r[2] = x * o + A * u + E * f + C * w, r[3] = x * i + A * c + E * h + C * v, x = t[4], A = t[5], E = t[6], C = t[7], r[4] = x * n + A * s + E * p + C * m, r[5] = x * a + A * l + E * d + C * y, r[6] = x * o + A * u + E * f + C * w, r[7] = x * i + A * c + E * h + C * v, x = t[8], A = t[9], E = t[10], C = t[11], r[8] = x * n + A * s + E * p + C * m, r[9] = x * a + A * l + E * d + C * y, r[10] = x * o + A * u + E * f + C * w, r[11] = x * i + A * c + E * h + C * v, x = t[12], A = t[13], E = t[14], C = t[15], r[12] = x * n + A * s + E * p + C * m, r[13] = x * a + A * l + E * d + C * y, r[14] = x * o + A * u + E * f + C * w, r[15] = x * i + A * c + E * h + C * v, r;
}
function Lu(r, e, t) {
	var n = t[0], a = t[1], o = t[2];
	return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function Ca(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], d = e[11];
	return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + d * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = d * a - l * n, r;
}
function Eu(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], d = e[11];
	return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - d * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + d * a, r;
}
function Aa(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], d = e[7];
	return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + d * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = d * a - l * n, r;
}
function Cu(r, e, t, n, a) {
	var o = 1 / Math.tan(e / 2);
	if (r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== Infinity) {
		var i = 1 / (n - a);
		r[10] = (a + n) * i, r[14] = 2 * a * n * i;
	} else r[10] = -1, r[14] = -2 * n;
	return r;
}
var Au = Cu;
function Zt() {
	var r = new Ct(3);
	return Ct != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function Tu(r, e, t) {
	var n = new Ct(3);
	return n[0] = r, n[1] = e, n[2] = t, n;
}
function Fr(r, e) {
	var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;
	return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;
}
function Ta(r, e, t) {
	var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];
	return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;
}
(function() {
	var r = Zt();
	return function(e, t, n, a, o, i) {
		var s, l;
		for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t) r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];
		return e;
	};
})();
function _u(r) {
	return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Nr, _a;
function Iu() {
	return _a || (_a = 1, Nr = {
		aliceblue: [
			240,
			248,
			255
		],
		antiquewhite: [
			250,
			235,
			215
		],
		aqua: [
			0,
			255,
			255
		],
		aquamarine: [
			127,
			255,
			212
		],
		azure: [
			240,
			255,
			255
		],
		beige: [
			245,
			245,
			220
		],
		bisque: [
			255,
			228,
			196
		],
		black: [
			0,
			0,
			0
		],
		blanchedalmond: [
			255,
			235,
			205
		],
		blue: [
			0,
			0,
			255
		],
		blueviolet: [
			138,
			43,
			226
		],
		brown: [
			165,
			42,
			42
		],
		burlywood: [
			222,
			184,
			135
		],
		cadetblue: [
			95,
			158,
			160
		],
		chartreuse: [
			127,
			255,
			0
		],
		chocolate: [
			210,
			105,
			30
		],
		coral: [
			255,
			127,
			80
		],
		cornflowerblue: [
			100,
			149,
			237
		],
		cornsilk: [
			255,
			248,
			220
		],
		crimson: [
			220,
			20,
			60
		],
		cyan: [
			0,
			255,
			255
		],
		darkblue: [
			0,
			0,
			139
		],
		darkcyan: [
			0,
			139,
			139
		],
		darkgoldenrod: [
			184,
			134,
			11
		],
		darkgray: [
			169,
			169,
			169
		],
		darkgreen: [
			0,
			100,
			0
		],
		darkgrey: [
			169,
			169,
			169
		],
		darkkhaki: [
			189,
			183,
			107
		],
		darkmagenta: [
			139,
			0,
			139
		],
		darkolivegreen: [
			85,
			107,
			47
		],
		darkorange: [
			255,
			140,
			0
		],
		darkorchid: [
			153,
			50,
			204
		],
		darkred: [
			139,
			0,
			0
		],
		darksalmon: [
			233,
			150,
			122
		],
		darkseagreen: [
			143,
			188,
			143
		],
		darkslateblue: [
			72,
			61,
			139
		],
		darkslategray: [
			47,
			79,
			79
		],
		darkslategrey: [
			47,
			79,
			79
		],
		darkturquoise: [
			0,
			206,
			209
		],
		darkviolet: [
			148,
			0,
			211
		],
		deeppink: [
			255,
			20,
			147
		],
		deepskyblue: [
			0,
			191,
			255
		],
		dimgray: [
			105,
			105,
			105
		],
		dimgrey: [
			105,
			105,
			105
		],
		dodgerblue: [
			30,
			144,
			255
		],
		firebrick: [
			178,
			34,
			34
		],
		floralwhite: [
			255,
			250,
			240
		],
		forestgreen: [
			34,
			139,
			34
		],
		fuchsia: [
			255,
			0,
			255
		],
		gainsboro: [
			220,
			220,
			220
		],
		ghostwhite: [
			248,
			248,
			255
		],
		gold: [
			255,
			215,
			0
		],
		goldenrod: [
			218,
			165,
			32
		],
		gray: [
			128,
			128,
			128
		],
		green: [
			0,
			128,
			0
		],
		greenyellow: [
			173,
			255,
			47
		],
		grey: [
			128,
			128,
			128
		],
		honeydew: [
			240,
			255,
			240
		],
		hotpink: [
			255,
			105,
			180
		],
		indianred: [
			205,
			92,
			92
		],
		indigo: [
			75,
			0,
			130
		],
		ivory: [
			255,
			255,
			240
		],
		khaki: [
			240,
			230,
			140
		],
		lavender: [
			230,
			230,
			250
		],
		lavenderblush: [
			255,
			240,
			245
		],
		lawngreen: [
			124,
			252,
			0
		],
		lemonchiffon: [
			255,
			250,
			205
		],
		lightblue: [
			173,
			216,
			230
		],
		lightcoral: [
			240,
			128,
			128
		],
		lightcyan: [
			224,
			255,
			255
		],
		lightgoldenrodyellow: [
			250,
			250,
			210
		],
		lightgray: [
			211,
			211,
			211
		],
		lightgreen: [
			144,
			238,
			144
		],
		lightgrey: [
			211,
			211,
			211
		],
		lightpink: [
			255,
			182,
			193
		],
		lightsalmon: [
			255,
			160,
			122
		],
		lightseagreen: [
			32,
			178,
			170
		],
		lightskyblue: [
			135,
			206,
			250
		],
		lightslategray: [
			119,
			136,
			153
		],
		lightslategrey: [
			119,
			136,
			153
		],
		lightsteelblue: [
			176,
			196,
			222
		],
		lightyellow: [
			255,
			255,
			224
		],
		lime: [
			0,
			255,
			0
		],
		limegreen: [
			50,
			205,
			50
		],
		linen: [
			250,
			240,
			230
		],
		magenta: [
			255,
			0,
			255
		],
		maroon: [
			128,
			0,
			0
		],
		mediumaquamarine: [
			102,
			205,
			170
		],
		mediumblue: [
			0,
			0,
			205
		],
		mediumorchid: [
			186,
			85,
			211
		],
		mediumpurple: [
			147,
			112,
			219
		],
		mediumseagreen: [
			60,
			179,
			113
		],
		mediumslateblue: [
			123,
			104,
			238
		],
		mediumspringgreen: [
			0,
			250,
			154
		],
		mediumturquoise: [
			72,
			209,
			204
		],
		mediumvioletred: [
			199,
			21,
			133
		],
		midnightblue: [
			25,
			25,
			112
		],
		mintcream: [
			245,
			255,
			250
		],
		mistyrose: [
			255,
			228,
			225
		],
		moccasin: [
			255,
			228,
			181
		],
		navajowhite: [
			255,
			222,
			173
		],
		navy: [
			0,
			0,
			128
		],
		oldlace: [
			253,
			245,
			230
		],
		olive: [
			128,
			128,
			0
		],
		olivedrab: [
			107,
			142,
			35
		],
		orange: [
			255,
			165,
			0
		],
		orangered: [
			255,
			69,
			0
		],
		orchid: [
			218,
			112,
			214
		],
		palegoldenrod: [
			238,
			232,
			170
		],
		palegreen: [
			152,
			251,
			152
		],
		paleturquoise: [
			175,
			238,
			238
		],
		palevioletred: [
			219,
			112,
			147
		],
		papayawhip: [
			255,
			239,
			213
		],
		peachpuff: [
			255,
			218,
			185
		],
		peru: [
			205,
			133,
			63
		],
		pink: [
			255,
			192,
			203
		],
		plum: [
			221,
			160,
			221
		],
		powderblue: [
			176,
			224,
			230
		],
		purple: [
			128,
			0,
			128
		],
		rebeccapurple: [
			102,
			51,
			153
		],
		red: [
			255,
			0,
			0
		],
		rosybrown: [
			188,
			143,
			143
		],
		royalblue: [
			65,
			105,
			225
		],
		saddlebrown: [
			139,
			69,
			19
		],
		salmon: [
			250,
			128,
			114
		],
		sandybrown: [
			244,
			164,
			96
		],
		seagreen: [
			46,
			139,
			87
		],
		seashell: [
			255,
			245,
			238
		],
		sienna: [
			160,
			82,
			45
		],
		silver: [
			192,
			192,
			192
		],
		skyblue: [
			135,
			206,
			235
		],
		slateblue: [
			106,
			90,
			205
		],
		slategray: [
			112,
			128,
			144
		],
		slategrey: [
			112,
			128,
			144
		],
		snow: [
			255,
			250,
			250
		],
		springgreen: [
			0,
			255,
			127
		],
		steelblue: [
			70,
			130,
			180
		],
		tan: [
			210,
			180,
			140
		],
		teal: [
			0,
			128,
			128
		],
		thistle: [
			216,
			191,
			216
		],
		tomato: [
			255,
			99,
			71
		],
		turquoise: [
			64,
			224,
			208
		],
		violet: [
			238,
			130,
			238
		],
		wheat: [
			245,
			222,
			179
		],
		white: [
			255,
			255,
			255
		],
		whitesmoke: [
			245,
			245,
			245
		],
		yellow: [
			255,
			255,
			0
		],
		yellowgreen: [
			154,
			205,
			50
		]
	}), Nr;
}
var jr, Ia;
function qo() {
	if (Ia) return jr;
	Ia = 1;
	const r = Iu(), e = {};
	for (const a of Object.keys(r)) e[r[a]] = a;
	const t = {
		rgb: {
			channels: 3,
			labels: "rgb"
		},
		hsl: {
			channels: 3,
			labels: "hsl"
		},
		hsv: {
			channels: 3,
			labels: "hsv"
		},
		hwb: {
			channels: 3,
			labels: "hwb"
		},
		cmyk: {
			channels: 4,
			labels: "cmyk"
		},
		xyz: {
			channels: 3,
			labels: "xyz"
		},
		lab: {
			channels: 3,
			labels: "lab"
		},
		lch: {
			channels: 3,
			labels: "lch"
		},
		hex: {
			channels: 1,
			labels: ["hex"]
		},
		keyword: {
			channels: 1,
			labels: ["keyword"]
		},
		ansi16: {
			channels: 1,
			labels: ["ansi16"]
		},
		ansi256: {
			channels: 1,
			labels: ["ansi256"]
		},
		hcg: {
			channels: 3,
			labels: [
				"h",
				"c",
				"g"
			]
		},
		apple: {
			channels: 3,
			labels: [
				"r16",
				"g16",
				"b16"
			]
		},
		gray: {
			channels: 1,
			labels: ["gray"]
		}
	};
	jr = t;
	for (const a of Object.keys(t)) {
		if (!("channels" in t[a])) throw new Error("missing channels property: " + a);
		if (!("labels" in t[a])) throw new Error("missing channel labels property: " + a);
		if (t[a].labels.length !== t[a].channels) throw new Error("channel and label counts mismatch: " + a);
		const { channels: o, labels: i } = t[a];
		delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], "channels", { value: o }), Object.defineProperty(t[a], "labels", { value: i });
	}
	t.rgb.hsl = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;
		let p, d;
		u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);
		const f = (l + u) / 2;
		return u === l ? d = 0 : f <= .5 ? d = c / (u + l) : d = c / (2 - u - l), [
			p,
			d * 100,
			f * 100
		];
	}, t.rgb.hsv = function(a) {
		let o, i, s, l, u;
		const c = a[0] / 255, p = a[1] / 255, d = a[2] / 255, f = Math.max(c, p, d), h = f - Math.min(c, p, d), m = function(y) {
			return (f - y) / 6 / h + 1 / 2;
		};
		return h === 0 ? (l = 0, u = 0) : (u = h / f, o = m(c), i = m(p), s = m(d), c === f ? l = s - i : p === f ? l = 1 / 3 + o - s : d === f && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [
			l * 360,
			u * 100,
			f * 100
		];
	}, t.rgb.hwb = function(a) {
		const o = a[0], i = a[1];
		let s = a[2];
		const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));
		return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [
			l,
			u * 100,
			s * 100
		];
	}, t.rgb.cmyk = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;
		return [
			u * 100,
			c * 100,
			p * 100,
			l * 100
		];
	};
	function n(a, o) {
		return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;
	}
	return t.rgb.keyword = function(a) {
		const o = e[a];
		if (o) return o;
		let i = Infinity, s;
		for (const l of Object.keys(r)) {
			const u = r[l], c = n(a, u);
			c < i && (i = c, s = l);
		}
		return s;
	}, t.keyword.rgb = function(a) {
		return r[a];
	}, t.rgb.xyz = function(a) {
		let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;
		o = o > .04045 ? ((o + .055) / 1.055) ** 2.4 : o / 12.92, i = i > .04045 ? ((i + .055) / 1.055) ** 2.4 : i / 12.92, s = s > .04045 ? ((s + .055) / 1.055) ** 2.4 : s / 12.92;
		const l = o * .4124 + i * .3576 + s * .1805, u = o * .2126 + i * .7152 + s * .0722, c = o * .0193 + i * .1192 + s * .9505;
		return [
			l * 100,
			u * 100,
			c * 100
		];
	}, t.rgb.lab = function(a) {
		const o = t.rgb.xyz(a);
		let i = o[0], s = o[1], l = o[2];
		i /= 95.047, s /= 100, l /= 108.883, i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > .008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > .008856 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
		return [
			116 * s - 16,
			500 * (i - s),
			200 * (s - l)
		];
	}, t.hsl.rgb = function(a) {
		const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
		let l, u, c;
		if (i === 0) return c = s * 255, [
			c,
			c,
			c
		];
		s < .5 ? l = s * (1 + i) : l = s + i - s * i;
		const p = 2 * s - l, d = [
			0,
			0,
			0
		];
		for (let f = 0; f < 3; f++) u = o + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, d[f] = c * 255;
		return d;
	}, t.hsl.hsv = function(a) {
		const o = a[0];
		let i = a[1] / 100, s = a[2] / 100, l = i;
		const u = Math.max(s, .01);
		s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;
		const c = (s + i) / 2;
		return [
			o,
			(s === 0 ? 2 * l / (u + l) : 2 * i / (s + i)) * 100,
			c * 100
		];
	}, t.hsv.rgb = function(a) {
		const o = a[0] / 60, i = a[1] / 100;
		let s = a[2] / 100;
		const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), d = 255 * s * (1 - i * (1 - u));
		switch (s *= 255, l) {
			case 0: return [
				s,
				d,
				c
			];
			case 1: return [
				p,
				s,
				c
			];
			case 2: return [
				c,
				s,
				d
			];
			case 3: return [
				c,
				p,
				s
			];
			case 4: return [
				d,
				c,
				s
			];
			case 5: return [
				s,
				c,
				p
			];
		}
	}, t.hsv.hsl = function(a) {
		const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, .01);
		let u, c;
		c = (2 - i) * s;
		const p = (2 - i) * l;
		return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [
			o,
			u * 100,
			c * 100
		];
	}, t.hwb.rgb = function(a) {
		const o = a[0] / 360;
		let i = a[1] / 100, s = a[2] / 100;
		const l = i + s;
		let u;
		l > 1 && (i /= l, s /= l);
		const c = Math.floor(6 * o), p = 1 - s;
		u = 6 * o - c, c & 1 && (u = 1 - u);
		const d = i + u * (p - i);
		let f, h, m;
		switch (c) {
			default:
			case 6:
			case 0:
				f = p, h = d, m = i;
				break;
			case 1:
				f = d, h = p, m = i;
				break;
			case 2:
				f = i, h = p, m = d;
				break;
			case 3:
				f = i, h = d, m = p;
				break;
			case 4:
				f = d, h = i, m = p;
				break;
			case 5:
				f = p, h = i, m = d;
				break;
		}
		return [
			f * 255,
			h * 255,
			m * 255
		];
	}, t.cmyk.rgb = function(a) {
		const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);
		return [
			u * 255,
			c * 255,
			p * 255
		];
	}, t.xyz.rgb = function(a) {
		const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;
		let l, u, c;
		return l = o * 3.2406 + i * -1.5372 + s * -.4986, u = o * -.9689 + i * 1.8758 + s * .0415, c = o * .0557 + i * -.204 + s * 1.057, l = l > .0031308 ? 1.055 * l ** (1 / 2.4) - .055 : l * 12.92, u = u > .0031308 ? 1.055 * u ** (1 / 2.4) - .055 : u * 12.92, c = c > .0031308 ? 1.055 * c ** (1 / 2.4) - .055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [
			l * 255,
			u * 255,
			c * 255
		];
	}, t.xyz.lab = function(a) {
		let o = a[0], i = a[1], s = a[2];
		o /= 95.047, i /= 100, s /= 108.883, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > .008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
		return [
			116 * i - 16,
			500 * (o - i),
			200 * (i - s)
		];
	}, t.lab.xyz = function(a) {
		const o = a[0], i = a[1], s = a[2];
		let l, u, c;
		u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;
		const p = u ** 3, d = l ** 3, f = c ** 3;
		return u = p > .008856 ? p : (u - 16 / 116) / 7.787, l = d > .008856 ? d : (l - 16 / 116) / 7.787, c = f > .008856 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [
			l,
			u,
			c
		];
	}, t.lab.lch = function(a) {
		const o = a[0], i = a[1], s = a[2];
		let l;
		l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);
		return [
			o,
			Math.sqrt(i * i + s * s),
			l
		];
	}, t.lch.lab = function(a) {
		const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI;
		return [
			o,
			i * Math.cos(l),
			i * Math.sin(l)
		];
	}, t.rgb.ansi16 = function(a, o = null) {
		const [i, s, l] = a;
		let u = o === null ? t.rgb.hsv(a)[2] : o;
		if (u = Math.round(u / 50), u === 0) return 30;
		let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));
		return u === 2 && (c += 60), c;
	}, t.hsv.ansi16 = function(a) {
		return t.rgb.ansi16(t.hsv.rgb(a), a[2]);
	}, t.rgb.ansi256 = function(a) {
		const o = a[0], i = a[1], s = a[2];
		return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);
	}, t.ansi16.rgb = function(a) {
		let o = a % 10;
		if (o === 0 || o === 7) return a > 50 && (o += 3.5), o = o / 10.5 * 255, [
			o,
			o,
			o
		];
		const i = (~~(a > 50) + 1) * .5;
		return [
			(o & 1) * i * 255,
			(o >> 1 & 1) * i * 255,
			(o >> 2 & 1) * i * 255
		];
	}, t.ansi256.rgb = function(a) {
		if (a >= 232) {
			const u = (a - 232) * 10 + 8;
			return [
				u,
				u,
				u
			];
		}
		a -= 16;
		let o;
		return [
			Math.floor(a / 36) / 5 * 255,
			Math.floor((o = a % 36) / 6) / 5 * 255,
			o % 6 / 5 * 255
		];
	}, t.rgb.hex = function(a) {
		const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();
		return "000000".substring(i.length) + i;
	}, t.hex.rgb = function(a) {
		const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!o) return [
			0,
			0,
			0
		];
		let i = o[0];
		o[0].length === 3 && (i = i.split("").map((p) => p + p).join(""));
		const s = parseInt(i, 16);
		return [
			s >> 16 & 255,
			s >> 8 & 255,
			s & 255
		];
	}, t.rgb.hcg = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;
		let p, d;
		return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? d = 0 : l === o ? d = (i - s) / c % 6 : l === i ? d = 2 + (s - o) / c : d = 4 + (o - i) / c, d /= 6, d %= 1, [
			d * 360,
			c * 100,
			p * 100
		];
	}, t.hsl.hcg = function(a) {
		const o = a[1] / 100, i = a[2] / 100, s = i < .5 ? 2 * o * i : 2 * o * (1 - i);
		let l = 0;
		return s < 1 && (l = (i - .5 * s) / (1 - s)), [
			a[0],
			s * 100,
			l * 100
		];
	}, t.hsv.hcg = function(a) {
		const o = a[1] / 100, i = a[2] / 100, s = o * i;
		let l = 0;
		return s < 1 && (l = (i - s) / (1 - s)), [
			a[0],
			s * 100,
			l * 100
		];
	}, t.hcg.rgb = function(a) {
		const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
		if (i === 0) return [
			s * 255,
			s * 255,
			s * 255
		];
		const l = [
			0,
			0,
			0
		], u = o % 1 * 6, c = u % 1, p = 1 - c;
		let d = 0;
		switch (Math.floor(u)) {
			case 0:
				l[0] = 1, l[1] = c, l[2] = 0;
				break;
			case 1:
				l[0] = p, l[1] = 1, l[2] = 0;
				break;
			case 2:
				l[0] = 0, l[1] = 1, l[2] = c;
				break;
			case 3:
				l[0] = 0, l[1] = p, l[2] = 1;
				break;
			case 4:
				l[0] = c, l[1] = 0, l[2] = 1;
				break;
			default: l[0] = 1, l[1] = 0, l[2] = p;
		}
		return d = (1 - i) * s, [
			(i * l[0] + d) * 255,
			(i * l[1] + d) * 255,
			(i * l[2] + d) * 255
		];
	}, t.hcg.hsv = function(a) {
		const o = a[1] / 100, s = o + a[2] / 100 * (1 - o);
		let l = 0;
		return s > 0 && (l = o / s), [
			a[0],
			l * 100,
			s * 100
		];
	}, t.hcg.hsl = function(a) {
		const o = a[1] / 100, s = a[2] / 100 * (1 - o) + .5 * o;
		let l = 0;
		return s > 0 && s < .5 ? l = o / (2 * s) : s >= .5 && s < 1 && (l = o / (2 * (1 - s))), [
			a[0],
			l * 100,
			s * 100
		];
	}, t.hcg.hwb = function(a) {
		const o = a[1] / 100, s = o + a[2] / 100 * (1 - o);
		return [
			a[0],
			(s - o) * 100,
			(1 - s) * 100
		];
	}, t.hwb.hcg = function(a) {
		const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;
		let u = 0;
		return l < 1 && (u = (s - l) / (1 - l)), [
			a[0],
			l * 100,
			u * 100
		];
	}, t.apple.rgb = function(a) {
		return [
			a[0] / 65535 * 255,
			a[1] / 65535 * 255,
			a[2] / 65535 * 255
		];
	}, t.rgb.apple = function(a) {
		return [
			a[0] / 255 * 65535,
			a[1] / 255 * 65535,
			a[2] / 255 * 65535
		];
	}, t.gray.rgb = function(a) {
		return [
			a[0] / 100 * 255,
			a[0] / 100 * 255,
			a[0] / 100 * 255
		];
	}, t.gray.hsl = function(a) {
		return [
			0,
			0,
			a[0]
		];
	}, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {
		return [
			0,
			100,
			a[0]
		];
	}, t.gray.cmyk = function(a) {
		return [
			0,
			0,
			0,
			a[0]
		];
	}, t.gray.lab = function(a) {
		return [
			a[0],
			0,
			0
		];
	}, t.gray.hex = function(a) {
		const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();
		return "000000".substring(s.length) + s;
	}, t.rgb.gray = function(a) {
		return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];
	}, jr;
}
var Dr, Ma;
function Mu() {
	if (Ma) return Dr;
	Ma = 1;
	const r = qo();
	function e() {
		const o = {}, i = Object.keys(r);
		for (let s = i.length, l = 0; l < s; l++) o[i[l]] = {
			distance: -1,
			parent: null
		};
		return o;
	}
	function t(o) {
		const i = e(), s = [o];
		for (i[o].distance = 0; s.length;) {
			const l = s.pop(), u = Object.keys(r[l]);
			for (let c = u.length, p = 0; p < c; p++) {
				const d = u[p], f = i[d];
				f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, s.unshift(d));
			}
		}
		return i;
	}
	function n(o, i) {
		return function(s) {
			return i(o(s));
		};
	}
	function a(o, i) {
		const s = [i[o].parent, o];
		let l = r[i[o].parent][o], u = i[o].parent;
		for (; i[u].parent;) s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;
		return l.conversion = s, l;
	}
	return Dr = function(o) {
		const i = t(o), s = {}, l = Object.keys(i);
		for (let u = l.length, c = 0; c < u; c++) {
			const p = l[c];
			i[p].parent !== null && (s[p] = a(p, i));
		}
		return s;
	}, Dr;
}
var Ur, Pa;
function Pu() {
	if (Pa) return Ur;
	Pa = 1;
	const r = qo(), e = Mu(), t = {}, n = Object.keys(r);
	function a(i) {
		const s = function(...l) {
			const u = l[0];
			return u == null ? u : (u.length > 1 && (l = u), i(l));
		};
		return "conversion" in i && (s.conversion = i.conversion), s;
	}
	function o(i) {
		const s = function(...l) {
			const u = l[0];
			if (u == null) return u;
			u.length > 1 && (l = u);
			const c = i(l);
			if (typeof c == "object") for (let p = c.length, d = 0; d < p; d++) c[d] = Math.round(c[d]);
			return c;
		};
		return "conversion" in i && (s.conversion = i.conversion), s;
	}
	return n.forEach((i) => {
		t[i] = {}, Object.defineProperty(t[i], "channels", { value: r[i].channels }), Object.defineProperty(t[i], "labels", { value: r[i].labels });
		const s = e(i);
		Object.keys(s).forEach((u) => {
			const c = s[u];
			t[i][u] = o(c), t[i][u].raw = a(c);
		});
	}), Ur = t, Ur;
}
var zu = /* @__PURE__ */ _u(Pu());
function Ra({ gl: r, type: e, source: t }) {
	const n = r.createShader(e);
	if (n === null) throw new Error("Cannot create shader");
	if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS)) throw console.error("Shader compilation error:", r.getShaderInfoLog(n)), r.deleteShader(n), /* @__PURE__ */ new Error("Cannot compile shader");
	return n;
}
function Ou({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {
	const n = Ra({
		gl: r,
		type: r.VERTEX_SHADER,
		source: e
	}), a = Ra({
		gl: r,
		type: r.FRAGMENT_SHADER,
		source: t
	}), o = r.createProgram();
	if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS)) throw console.error("Error: ", r.getProgramInfoLog(o)), /* @__PURE__ */ new Error("Cannot link shader program");
	return o;
}
function $u(r, e, t) {
	const n = r.getUniformLocation(e, t);
	if (n === null) throw new Error(`Cannot get uniform location for ${t}`);
	return n;
}
function Vo({ gl: r, vertexShaderSource: e, fragmentShaderSource: t, attributesKeys: n, uniformsKeys: a, vertices: o, indices: i }) {
	const s = Ou({
		gl: r,
		vertexShaderSource: e,
		fragmentShaderSource: t
	}), l = n.reduce((f, h) => (f[h] = r.getAttribLocation(s, `a_${h}`), f), {}), u = a.reduce((f, h) => (f[h] = $u(r, s, `u_${h}`), f), {}), c = r.createBuffer();
	r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);
	let p, d;
	return i !== void 0 && (p = r.createBuffer(), d = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {
		shaderProgram: s,
		programInfo: {
			attributesLocations: l,
			uniformsLocations: u
		},
		positionBuffer: c,
		indexBuffer: p,
		indexBufferLength: d
	};
}
function Kt(r) {
	if (!r) return [
		1,
		1,
		1,
		0
	];
	if (r === "transparent") return [
		1,
		1,
		1,
		0
	];
	try {
		const e = Fu(r), t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e);
		if (t != null && t.length) {
			const a = !!t[4];
			return [...zu.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];
		}
		const n = e.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? [
			"0",
			"0",
			"0"
		];
		if (e.includes("rgb")) {
			const a = e.includes("rgba"), o = [...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)];
			return a || o.push(1), o;
		}
	} catch {}
	return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [
		0,
		0,
		0,
		1
	];
}
var ft;
function Fu(r) {
	return ft = ft ?? document.createElement("canvas").getContext("2d"), ft ? (ft.fillStyle = r, ft.fillStyle) : "#000000";
}
var On = 1, ue = On / 2, ce = On / 2, pe = On / 2, Nu = [
	-.5,
	-.5,
	pe,
	ue,
	-.5,
	pe,
	ue,
	ce,
	pe,
	-.5,
	ce,
	pe
], ju = [
	-.5,
	-.5,
	-.5,
	-.5,
	ce,
	-.5,
	ue,
	ce,
	-.5,
	ue,
	-.5,
	-.5
], Du = [
	-.5,
	ce,
	-.5,
	-.5,
	ce,
	pe,
	ue,
	ce,
	pe,
	ue,
	ce,
	-.5
], Uu = [
	-.5,
	-.5,
	-.5,
	ue,
	-.5,
	-.5,
	ue,
	-.5,
	pe,
	-.5,
	-.5,
	pe
], Bu = [
	ue,
	-.5,
	-.5,
	ue,
	ce,
	-.5,
	ue,
	ce,
	pe,
	ue,
	-.5,
	pe
], qu = [
	-.5,
	-.5,
	-.5,
	-.5,
	-.5,
	pe,
	-.5,
	ce,
	pe,
	-.5,
	ce,
	-.5
], Vu = [
	...Nu,
	...ju,
	...Du,
	...Uu,
	...Bu,
	...qu
], Gu = [
	0,
	1,
	2,
	0,
	2,
	3,
	4,
	5,
	6,
	4,
	6,
	7,
	8,
	9,
	10,
	8,
	10,
	11,
	12,
	13,
	14,
	12,
	14,
	15,
	16,
	17,
	18,
	16,
	18,
	19,
	20,
	21,
	22,
	20,
	22,
	23
], Hu = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`, za = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`;
var Zu = /* @__PURE__ */ ((r) => (r.UNIVERSE_DARK = "universe-dark", r))(Zu || {});
var Ke = {
	stars: {
		color: "hsl(233,100%,92%)",
		preset: "stars"
	},
	space: {
		color: "hsl(210, 100%, 4%)",
		preset: "space"
	},
	milkyway: {
		color: "hsl(233,100%,92%)",
		preset: "milkyway"
	},
	"milkyway-subtle": {
		color: "hsl(233,100%,92%)",
		preset: "milkyway-subtle"
	},
	"milkyway-bright": {
		color: "hsl(233,100%,92%)",
		preset: "milkyway-bright"
	},
	"milkyway-colored": {
		color: "black",
		preset: "milkyway-colored"
	}
};
var Be = /* @__PURE__ */ ((r) => (r.POSITIVE_X = "pX", r.NEGATIVE_X = "nX", r.POSITIVE_Y = "pY", r.NEGATIVE_Y = "nY", r.POSITIVE_Z = "pZ", r.NEGATIVE_Z = "nZ", r))(Be || {});
var Vt = /* @__PURE__ */ new Map(), Oa = /* @__PURE__ */ new Map();
var $a;
function Ku({ gl: r, faces: e, onReady: t, forceRefresh: n }) {
	if (Vt.get(r) && !n && $a === JSON.stringify(e)) {
		t(Vt.get(r), Oa.get(r));
		return;
	}
	$a = JSON.stringify(e);
	const a = Vt.get(r) ?? r.createTexture();
	if (!e) {
		console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
		return;
	}
	const o = Object.keys(e).length;
	if (o !== 6) {
		console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);
		return;
	}
	const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {
		const p = s;
		if (l === void 0) {
			c(/* @__PURE__ */ new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));
			return;
		}
		const d = new Image();
		d.crossOrigin = "anonymous";
		const f = () => {
			u({
				image: d,
				key: p
			});
		};
		d.src = l, d.complete && d.naturalWidth > 0 ? f() : d.onload = f, d.onerror = () => {
			c(/* @__PURE__ */ new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));
		};
	}));
	Promise.all(i).then((s) => {
		for (let u = 0; u < s.length; u++) {
			const p = r.RGBA, d = r.RGBA, f = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};
			if (!h || !m) {
				console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
				continue;
			}
			const y = Xu(r, m);
			r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(y, 0, p, d, f, h);
		}
		r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);
		const l = s.map((u) => u.image);
		t(a, l), Oa.set(r, l), Vt.set(r, a);
	}).catch((s) => {
		console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", s);
	});
}
function Xu(r, e) {
	if (e === Be.POSITIVE_X) return r.TEXTURE_CUBE_MAP_POSITIVE_X;
	if (e === Be.NEGATIVE_X) return r.TEXTURE_CUBE_MAP_NEGATIVE_X;
	if (e === Be.POSITIVE_Y) return r.TEXTURE_CUBE_MAP_POSITIVE_Y;
	if (e === Be.NEGATIVE_Y) return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	if (e === Be.POSITIVE_Z) return r.TEXTURE_CUBE_MAP_POSITIVE_Z;
	if (e === Be.NEGATIVE_Z) return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);
}
function Yu(r, e, t) {
	return [
		Fe(r[0], e[0], t),
		Fe(r[1], e[1], t),
		Fe(r[2], e[2], t),
		Fe(r[3], e[3], t)
	];
}
function Fe(r, e, t) {
	return r + (e - r) * t;
}
function or(r) {
	if (!r) return {};
	const e = Object.keys(r).sort().map((t) => [t, r[t]]);
	return Object.fromEntries(e);
}
var Je = "https://api.maptiler.com/resources/space", Wu = ["vertexPosition"], Ju = [
	"projectionMatrix",
	"modelViewMatrix",
	"cubeSampler",
	"bgColor",
	"fadeOpacity"
], Fa = "%USE_TEXTURE_MACRO_MARKER%", Qu = "#define USE_TEXTURE", Na = Ke.stars;
function ec(r, e) {
	if (!rn(r)) return { color: "transparent" };
	if (r === !0) return e;
	const t = { ...r };
	if (r.faces || r.path) return delete t.preset, t;
	const n = r.preset;
	if (!(n === void 0) && !(n in Ke)) throw new Error(`[CubemapLayer]: Invalid preset "${n}". Available presets: ${Object.keys(Ke).join(", ")}`);
	return {
		...t,
		color: t.color ?? Ke[n].color ?? "hsl(233,100%,92%)"
	};
}
var Br = class {
	/**
	* Creates a new instance of CubemapLayer
	*
	* @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.
	* Can specify faces, preset, path, and color properties to configure the cubemap.
	*
	* @remarks You shouldn't have to use this class directly.
	* Instead, use the `Map.setHalo` method to create and add a halo layer to the map.
	* The constructor initializes the cubemap with the provided configuration.
	* It processes the faces definition, sets up background colors, and determines
	* whether to use a cubemap texture based on the provided options.
	*/
	constructor(e) {
		g(this, "id", "Cubemap Layer");
		g(this, "type", "custom");
		g(this, "renderingMode", "3d");
		/**
		* The map instance to which this layer is added.
		* @type {MapSDK}
		* @private
		*/
		g(this, "map");
		/**
		* The cubemap faces definition, which can be either a preset, path, or explicit face URLs.
		* @type {CubemapFaces | null}
		* @remarks
		* This property is set during the initialization of the layer and can be updated later.
		* If no faces are defined, it will be `null`.
		*/
		g(this, "faces");
		/**
		* Indicates whether to use a cubemap texture for rendering.
		* @type {boolean}
		* @private
		* @default true
		*/
		g(this, "useCubemapTexture", !0);
		/**
		* The current opacity of the fade effect applied to the cubemap image texture, used for fading in and out.
		* @type {number}
		* @private
		* @default 0.0
		*/
		g(this, "currentFadeOpacity", 0);
		/**
		* Indicates whether the cubemap needs to be updated, typically when the faces or texture changes.
		* @type {boolean}
		* @private
		* @default false
		*/
		g(this, "cubeMapNeedsUpdate", !1);
		/**
		* The background color of the cubemap layer, represented as a Vec4 (RGBA).
		* @type {Vec4}
		* @private
		*/
		g(this, "bgColor");
		/**
		* The previous background color used for transition animations.
		* @type {Vec4}
		* @private
		*/
		g(this, "previousBgColor", [
			0,
			0,
			0,
			0
		]);
		/**
		* The target background color to which the layer will transition.
		* @type {Vec4}
		* @private
		*/
		g(this, "targetBgColor", [
			0,
			0,
			0,
			0
		]);
		/**
		* The delta value used for transitioning the background color. 0 = start of transition, 1 = end of transition.
		* This value is incremented over time to create a smooth transition effect.
		* @type {number}
		* @private
		*/
		g(this, "transitionDelta", 0);
		/**
		* The WebGL context used for rendering the cubemap layer.
		* @type {WebGLContext}
		* @private
		*/
		g(this, "gl");
		/**
		* The cubemap object that contains the shader program, buffers and uniform locations for rendering.
		* @type {Object3D}
		* @private
		*/
		g(this, "cubemap");
		/**
		* The WebGL texture used for the cubemap, which is created from the defined faces.
		* This texture is used to render the cubemap in the scene.
		* @type {WebGLTexture | undefined}
		* @private
		*/
		g(this, "texture");
		/**
		* The key representing the current faces definition, used to diff / track changes in the cubemap faces.
		* @type {string}
		*/
		g(this, "currentFacesDefinitionKey", "");
		/**
		* The configuration options for the cubemap layer.
		* @type {CubemapLayerConstructorOptions}
		* @private
		*/
		g(this, "options");
		g(this, "animationActive", !0);
		/**
		* Animates the cubemap image fading in.
		* This method gradually increases the opacity of the cubemap image to create a fade-in effect.
		*
		* @private
		*/
		g(this, "imageIsAnimating", !1);
		/**
		* The delta value used for the image fade-in animation.
		* This value is incremented over time to create a smooth fade-in effect.
		* @type {number}
		* @private
		*/
		g(this, "imageFadeInDelta", 0);
		const t = ec(e, Na);
		this.options = t, this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path), this.bgColor = [
			0,
			0,
			0,
			0
		], this.targetBgColor = Kt(t.color), this.faces = ja(t), this.useCubemapTexture = this.faces !== null;
	}
	/**
	* Updates the cubemap object with the current faces and shader configuration.
	* This method is called when the cubemap faces change or when the layer is initialized.
	* @returns {void}
	* @remarks
	* It creates a new Object3D instance with the specified vertex and fragment shaders,
	* attributes, and uniforms. The cubemap will be rendered using this configuration.
	*/
	updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: !0 }) {
		this.useCubemapTexture = this.faces !== null;
		const t = Ju.filter((n) => n === "cubeSampler" || n === "fadeOpacity" ? this.useCubemapTexture : !0);
		this.cubemap = Vo({
			gl: this.gl,
			vertexShaderSource: Hu,
			fragmentShaderSource: this.useCubemapTexture ? za.replace(Fa, Qu) : za.replace(Fa, ""),
			attributesKeys: Wu,
			uniformsKeys: t,
			vertices: Vu,
			indices: Gu
		}), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();
	}
	/**
	* Called when the layer is added to the map.
	* Initializes the cubemap and sets up the WebGL context.
	*
	* @param {MapSDK} map - The map instance to which this layer is added.
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	*/
	onAdd(e, t) {
		this.map = e, this.gl = t, this.updateCubemap();
	}
	/**
	* Called when the layer is removed from the map.
	* Cleans up the cubemap resources and WebGL buffers.
	*
	* @param {MapSDK} _map - The map instance from which this layer is removed.
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	*/
	onRemove(e, t) {
		this.cubemap && (this.texture && t.deleteTexture(this.texture), t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer), this.texture = void 0);
	}
	/**
	* Updates the cubemap texture with the provided faces.
	* This method is called when the cubemap faces change or when the layer is initialized.
	*
	* @param {WebGLContext} gl - The WebGL context used for rendering.
	* @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.
	*/
	updateTexture(e, t) {
		if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {
			if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture) return;
			Ku({
				gl: e,
				faces: t,
				onReady: (n) => {
					this.texture = n, this.animateIn();
				}
			});
		}
	}
	/**
	* Called before the layer is rendered.
	* Updates the cubemap texture with the current faces.
	*
	* @param {WebGLContext} gl - The WebGL context used for rendering.
	* @param {CustomRenderMethodInput} _options - Additional options for the render method.
	*/
	prerender(e, t) {
		this.faces && this.updateTexture(this.gl, this.faces);
	}
	/**
	* Lerps the background color transition of the cubemap layer.
	* This method smoothly transitions the background color from the previous color to the target color.
	*
	* @private
	*/
	animateColorChange() {
		const e = () => {
			this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = Yu(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += .075, this.map.triggerRepaint());
		};
		requestAnimationFrame(e);
	}
	/**
	* Animates the cubemap image fading in.
	* This method gradually increases the opacity of the cubemap image to create a fade-in effect.
	* @private
	*/
	async animateIn() {
		if (!this.imageIsAnimating) {
			if (!this.animationActive) {
				this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();
				return;
			}
			return new Promise((e) => {
				this.imageIsAnimating = !0;
				const t = () => {
					if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1), this.currentFadeOpacity = Fe(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {
						requestAnimationFrame(t);
						return;
					}
					this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
				};
				requestAnimationFrame(t);
			});
		}
	}
	/**
	* Animates the cubemap image fading out.
	* This method gradually decreases the opacity of the cubemap image to create a fade-out effect.
	* @returns {Promise<void>} A promise that resolves when the animation is complete.
	* @private
	*/
	async animateOut() {
		if (!(this.imageIsAnimating || !this.animationActive)) return new Promise((e) => {
			const t = () => {
				if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1), this.currentFadeOpacity = Fe(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {
					this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
					return;
				}
				requestAnimationFrame(t);
			};
			requestAnimationFrame(t);
		});
	}
	setAnimationActive(e) {
		this.animationActive = e;
	}
	/**
	* Renders the cubemap layer to the WebGL context.
	* This method is called internally during the rendering phase of the map.
	*
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	* @param {CustomRenderMethodInput} _options - Additional options for the render method.
	* @throws Error if the map, cubemap, or texture is undefined.
	*/
	render(e, t) {
		if (!this.map.isGlobeProjection()) return;
		if (this.map === void 0) throw new Error("[CubemapLayer]: Map is undefined");
		if (this.cubemap === void 0) throw new Error("[CubemapLayer]: Cubemap is undefined");
		this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
		const n = .1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = gt();
		Au(u, l, i, n, a), Aa(u, u, s.rollInRadians), Ca(u, u, -s.pitchInRadians), Aa(u, u, s.bearingInRadians);
		const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;
		Ca(u, u, c), Eu(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, u);
		const d = gt();
		if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, d), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0) throw new Error("Index buffer is undefined");
		if (this.cubemap.indexBufferLength === void 0) throw new Error("Index buffer length is undefined");
		e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);
	}
	setBgColor(e) {
		this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;
	}
	/**
	* Returns the current configuration options for the cubemap layer.
	* @returns {CubemapLayerConstructorOptions} The current configuration options.
	*/
	getConfig() {
		return this.options;
	}
	/**
	* Checks if the cubemap needs to be updated based on the provided specification.
	*
	* @param {CubemapDefinition} spec - The cubemap specification to compare with the current cubemap.
	* @returns {boolean} True if the cubemap needs to be updated, false otherwise.
	*/
	shouldUpdate(e) {
		const t = this.getConfig();
		if (e === void 0 && t) return !1;
		const n = or(e), a = or(t);
		return JSON.stringify(n) !== JSON.stringify(a);
	}
	async setCubemapFaces(e) {
		if (await this.animateOut(), !e.faces && !e.preset && !e.path) {
			this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = "empty", await this.animateIn();
			return;
		}
		this.faces = ja(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);
	}
	/**
	* Sets the cubemap for the layer based on the provided definition.
	* This method updates the cubemap faces, background color, and triggers a repaint of the map.
	*
	* @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.
	* @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.
	* @remarks
	* This method checks if the provided cubemap definition has a color, and if so, it updates the background color.
	* It also checks if the faces definition has changed compared to the current one,
	* and if so, it updates the cubemap faces.
	* Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.
	*/
	async setCubemap(e) {
		const t = typeof e == "boolean" ? Na : e;
		this.options = t;
		const n = JSON.stringify(t.faces ?? t.preset ?? t.path), a = this.currentFacesDefinitionKey !== n;
		a && (await this.setCubemapFaces(t), this.cubeMapNeedsUpdate = !0);
		const o = Kt(t.color);
		if (t.color && this.targetBgColor.toString() !== o.toString()) this.setBgColor(o);
		else if (!t.color && t.preset && t.preset in Ke) {
			const i = Ke[t.preset];
			this.setBgColor(Kt(i.color));
		}
		this.updateCubemap({ facesNeedUpdate: a });
	}
	/**
	* Shows the cubemap layer by setting its visibility to "visible".
	* This method is used to make the cubemap layer visible on the map.
	*/
	show() {
		this.map.setLayoutProperty(this.id, "visibility", "visible");
	}
	/**
	* Hides the cubemap layer by setting its visibility to "none".
	* This method is used to remove the cubemap layer from the map without deleting it.
	*/
	hide() {
		this.map.setLayoutProperty(this.id, "visibility", "none");
	}
};
function rn(r) {
	return r ? typeof r == "boolean" ? !0 : !(!r.path && !r.preset && !r.faces && !r.color || r.preset && !(r.preset in Ke) || r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ)) : !1;
}
function ja(r) {
	if (r.faces) return r.faces;
	if (r.preset) return {
		pX: `${Je}/${r.preset}/px.webp`,
		nX: `${Je}/${r.preset}/nx.webp`,
		pY: `${Je}/${r.preset}/py.webp`,
		nY: `${Je}/${r.preset}/ny.webp`,
		pZ: `${Je}/${r.preset}/pz.webp`,
		nZ: `${Je}/${r.preset}/nz.webp`
	};
	if (r.path) {
		const e = r.path.baseUrl, t = r.path.format ?? "png";
		return {
			pX: `${e}/px.${t}`,
			nX: `${e}/nx.${t}`,
			pY: `${e}/py.${t}`,
			nY: `${e}/ny.${t}`,
			pZ: `${e}/pz.${t}`,
			nZ: `${e}/nz.${t}`
		};
	}
	return null;
}
var tc = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`, rc = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

const float EPSILON = 0.000001;

vec2 center = vec2(0.0, 0.0);
void main() {
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastStopValue = u_stops[i - 1];
    float thisStopValue = u_stops[i];

    // this is to avoid blending errors when the stops are the same
    // eg when you would want a sharp edge between two stops.
    // \`numbersAreEqual\` will be 1.0 if the numbers are equal, 0.0 if they are not.
    // We then subtract EPSILON from the last stop making the stop value _almost_ equal
    // to the next stop but not enough to cause blending issues.
    // It's more efficient to do this than an if / else statement.
    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));
    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;

    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`, dt = 2, nc = ["position"], ac = [
	"matrix",
	"rotationMatrix",
	"stopsNumber",
	"stops",
	"colors",
	"maxDistance",
	"scale"
], oc = [
	-2,
	-2,
	0,
	dt,
	-2,
	0,
	-2,
	dt,
	0,
	dt,
	dt,
	0
], Qe = {
	scale: .9,
	stops: [
		[0, "rgba(176, 208, 240, 1)"],
		[.1, "rgba(98, 168, 229, 0.3)"],
		[.2, "rgba(98, 168, 229, 0.0)"]
	]
}, Da = .06;
var qr = class {
	/**
	* Creates a new RadialGradientLayer instance.
	*
	* @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.
	* If a boolean is provided, default configuration options will be used.
	* If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.
	*/
	constructor(e) {
		g(this, "id", "Halo Layer");
		g(this, "type", "custom");
		g(this, "renderingMode", "3d");
		/**
		* The gradient definition used by this layer.
		* It contains the stops and scale for the radial gradient.
		* @private
		* @type {GradientDefinition}
		*/
		g(this, "gradient");
		/**
		* The scale of the radial gradient, which determines its size.
		* This value is animated from 0 to the target scale during the layer's appearance.
		* @private
		* @type {number}
		*/
		g(this, "scale", 0);
		/**
		* The animation delta value used to control the progress of the gradient's appearance animation.
		* It is incremented during each frame of the animation until it reaches 1.
		* @private
		* @type {number}
		*/
		g(this, "animationDelta", 0);
		/**
		* The MapSDK instance to which this layer is added.
		* This is set when the layer is added to the map.
		* @private
		* @type {MapSDK}
		*/
		g(this, "map");
		/**
		* The 3D object representing the radial gradient plane.
		* This object is created when the layer is added to the map and contains the shader program and buffers.
		* It is used for rendering the radial gradient effect.
		* @private
		* @type {Object3D<(typeof ATTRIBUTES_KEYS)[number], (typeof UNIFORMS_KEYS)[number]>}
		*/
		g(this, "plane");
		/**
		* Whether the halo should be animated in and out.
		* @private
		* @type {boolean}
		*/
		g(this, "animationActive", !0);
		if (typeof e == "boolean") {
			this.gradient = Qe;
			return;
		}
		const t = Ua(e);
		if (t.length > 0) throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
		this.gradient = {
			...Qe,
			...e
		};
	}
	/**
	* Adds the radial gradient layer to the specified map.
	* This method is called by the map when the layer is added to it.
	*
	* @param {MapSDK} map - The MapSDK instance to which this layer is being added
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer
	* @returns void
	*/
	onAdd(e, t) {
		this.map = e, this.plane = Vo({
			gl: t,
			vertexShaderSource: tc,
			fragmentShaderSource: rc,
			attributesKeys: nc,
			uniformsKeys: ac,
			vertices: oc
		}), this.animateIn();
	}
	/**
	* Returns the current gradient configuration of the radial gradient layer.
	*
	* @returns {GradientDefinition} The current gradient configuration.
	*/
	getConfig() {
		return this.gradient;
	}
	/**
	* Checks if the gradient needs to be updated based on the provided specification.
	*
	* @param {GradientDefinition} spec - The gradient specification to compare with the current gradient.
	* @returns {boolean} True if the gradient needs to be updated, false otherwise.
	*/
	shouldUpdate(e) {
		const t = this.getConfig();
		if (e === void 0 && t) return !1;
		const n = or(e), a = or(t);
		return JSON.stringify(n) !== JSON.stringify(a);
	}
	/**
	* Animates the radial gradient into view by gradually scaling from 0 to the target scale.
	*
	* This method uses requestAnimationFrame to create a smooth scaling animation effect.
	* During each frame, it:
	*   1. Interpolates the scale value between 0 and the target scale
	*   2. Increments the animation progress (animationDelta)
	*   3. Triggers a map repaint
	*
	* @private
	* @returns {Promise<void>} A promise that resolves when the animation completes
	*/
	async animateIn() {
		if (!this.animationActive) {
			this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();
			return;
		}
		return new Promise((e) => {
			this.animationDelta = 0;
			const t = () => {
				if (this.animationDelta < 1) {
					this.scale = Fe(0, this.gradient.scale, this.animationDelta), this.animationDelta += Da, this.map.triggerRepaint(), requestAnimationFrame(t);
					return;
				}
				e();
			};
			requestAnimationFrame(t);
		});
	}
	/**
	* Animates the radial gradient layer out by gradually reducing its scale to zero.
	*
	* This method creates a smooth transition effect by linearly interpolating the scale
	* from its current value to zero over multiple animation frames. During each frame,
	* the animation progresses by incrementing the internal animation delta value.
	*
	* The map is repainted after each animation step to reflect the updated scale.
	*
	* @private
	* @returns A Promise that resolves when the animation is complete.
	*/
	async animateOut() {
		if (this.animationActive) return this.animationDelta = 0, new Promise((e) => {
			const t = () => {
				if (this.animationDelta < 1) {
					this.scale = Fe(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Da, this.map.triggerRepaint(), requestAnimationFrame(t);
					return;
				}
				e();
			};
			t();
		});
	}
	onRemove(e, t) {
		this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));
	}
	prerender(e, t) {}
	render(e, t) {
		if (this.map === void 0) throw new Error("[RadialGradientLayer]: Map is undefined");
		if (!this.map.isGlobeProjection()) return;
		if (this.plane === void 0) throw new Error("[RadialGradientLayer]: Plane is undefined");
		e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);
		const n = this.plane.programInfo.attributesLocations.position;
		e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, !1, 0, 0);
		const a = gt(), o = this.scale;
		Lu(a, a, [
			o,
			o,
			o
		]);
		const i = gt();
		ku(i, t.defaultProjectionData.mainMatrix, a);
		const s = this.plane.programInfo.uniformsLocations.matrix;
		e.uniformMatrix4fv(s, !1, i);
		const l = gt(), u = this.map.transform.cameraPosition, c = Fr(Zt(), u), p = Tu(0, 1, 0), d = Zt();
		Ta(d, p, c), Fr(d, d);
		const f = Zt();
		Ta(f, c, d), Fr(f, f), xu(l, d[0], d[1], d[2], 0, f[0], f[1], f[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);
		const h = this.plane.programInfo.uniformsLocations.rotationMatrix;
		e.uniformMatrix4fv(h, !1, l);
		const m = this.gradient.stops.length, y = [], w = [];
		for (let v = 0; v <= m; v++) if (v < m) {
			y[v] = this.gradient.stops[v][0];
			const x = Kt(this.gradient.stops[v][1]);
			w.push(...x);
		}
		e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(y)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(w)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, dt), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
	}
	/**
	* Sets a new gradient for the radial gradient layer and animates the transition.
	*
	* This method first animates the current gradient out, then updates the gradient
	* property with the new gradient definition, and finally animates the new gradient in.
	*
	* @param {GradientDefinition} gradient - The new gradient definition to set for this layer.
	* @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.
	*/
	async setGradient(e) {
		if (e === !1) {
			await this.animateOut();
			return;
		}
		await this.animateOut();
		const t = Ua(e);
		if (t.length > 0) throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
		e === !0 ? (this.gradient.scale = Qe.scale, this.gradient.stops = Qe.stops) : (this.gradient.scale = e.scale ?? Qe.scale, this.gradient.stops = e.stops ?? Qe.stops), await this.animateIn();
	}
	setAnimationActive(e) {
		this.animationActive = e;
	}
	show() {
		this.map.setLayoutProperty(this.id, "visibility", "visible");
	}
	hide() {
		this.map.setLayoutProperty(this.id, "visibility", "none");
	}
};
var ic = ["scale", "stops"];
function Ua(r) {
	var t;
	const e = [];
	if (typeof r == "boolean") return [];
	try {
		const n = Object.keys(r).filter((a) => !ic.includes(a));
		n.length > 0 && e.push(`Properties ${n.map((a) => `\`${a}\``).join(", ")} are not supported.`);
	} catch {
		e.push("Halo specification is not an object.");
	}
	return typeof r.scale != "number" && e.push("Halo `scale` property is not a number."), (!r.stops || r.stops.length === 0) && e.push("Halo `stops` property is not an array."), (t = r.stops) != null && t.some((n) => typeof n[0] != "number" || typeof n[1] != "string") && e.push("Halo `stops` property is not an array of [number, string]"), e;
}
var sc = {
	POINT: "POINT",
	COUNTRY: "COUNTRY"
};
var Go = class Ho extends import_maplibre_gl.default.Map {
	constructor(t) {
		Hi(t.container), t.apiKey && (j.apiKey = t.apiKey);
		const { style: n, requiresUrlMonitoring: a, isFallback: o } = ka(t.style);
		o && console.warn("Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."), j.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
		const i = location.hash;
		let s = { compact: !1 };
		t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (s = {
			...s,
			...t.attributionControl
		});
		const l = {
			...t,
			style: n,
			maplibreLogo: !1,
			transformRequest: ta(t.transformRequest),
			attributionControl: t.forceNoAttributionControl === !0 ? !1 : s
		};
		delete l.style;
		super(l);
		g(this, "telemetry");
		g(this, "space");
		g(this, "halo");
		g(this, "options");
		g(this, "isTerrainEnabled", !1);
		g(this, "terrainExaggeration", 1);
		g(this, "primaryLanguage");
		g(this, "terrainGrowing", !1);
		g(this, "terrainFlattening", !1);
		g(this, "minimap");
		g(this, "forceLanguageUpdate");
		g(this, "languageAlwaysBeenStyle");
		g(this, "isReady", !1);
		g(this, "terrainAnimationDuration", 1e3);
		g(this, "monitoredStyleUrls");
		g(this, "styleInProcess", !1);
		g(this, "curentProjection");
		g(this, "originalLabelStyle", new window.Map());
		g(this, "isStyleLocalized", !1);
		g(this, "languageIsUpdated", !1);
		this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);
		const u = () => {
			let h = "The distant style could not be loaded.";
			this.getStyle() ? h += " Leaving the style as is." : (this.setStyle(MapStyle.STREETS), h += `Loading default MapTiler Cloud style "${MapStyle.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(h);
		};
		if (this.on("style.load", () => {
			this.styleInProcess = !1;
		}), this.on("error", (h) => {
			if (console.error(h.error), h.error instanceof import_maplibre_gl.default.AJAXError) {
				const y = h.error.url, w = new URL(y);
				w.search = "";
				const v = w.href;
				this.monitoredStyleUrls && this.monitoredStyleUrls.has(v) && (this.monitoredStyleUrls.delete(v), u());
				return;
			}
			if (this.styleInProcess) {
				u();
				return;
			}
		}), j.caching && !Hr && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), j.caching && Hr && Bi(), typeof t.language > "u") this.primaryLanguage = j.primaryLanguage;
		else this.primaryLanguage = toLanguageInfo(t.language, z) ?? j.primaryLanguage;
		this.forceLanguageUpdate = !(this.primaryLanguage === z.STYLE || this.primaryLanguage === z.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === z.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on("style.load", (h) => {
			this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
		}), this.once("styledata", async () => {
			if (!t.geolocate || t.center || t.hash && i) return;
			try {
				if (t.geolocate === sc.COUNTRY) {
					await this.fitToIpBounds();
					return;
				}
			} catch (y) {
				console.warn(y.message);
			}
			let h;
			try {
				await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();
			} catch (y) {
				console.warn(y.message);
			}
			(await navigator.permissions.query({ name: "geolocation" })).state === "granted" && navigator.geolocation.getCurrentPosition((y) => {
				h === this.getCameraHash() && (this.terrain ? this.easeTo({
					center: [y.coords.longitude, y.coords.latitude],
					zoom: t.zoom || 12,
					duration: 2e3
				}) : this.once("terrain", () => {
					this.easeTo({
						center: [y.coords.longitude, y.coords.latitude],
						zoom: t.zoom || 12,
						duration: 2e3
					});
				}));
			}, null, {
				maximumAge: 24 * 3600 * 1e3,
				timeout: 5e3,
				enableHighAccuracy: !1
			});
		}), this.on("styledata", () => {
			this.setPrimaryLanguage(this.primaryLanguage);
		}), this.on("styledata", () => {
			this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
		}), this.once("load", async () => {
			let h = { logo: null };
			try {
				const m = Object.keys(this.style.sourceCaches).map((v) => this.getSource(v)).filter((v) => v && "url" in v && typeof v.url == "string" && v.url.includes("tiles.json")), y = new URL(m[0].url);
				y.searchParams.has("key") || y.searchParams.append("key", j.apiKey), h = await (await fetch(y.href)).json();
			} catch {}
			if (t.customControls) {
				const m = "[data-maptiler-control-group]", y = "[data-maptiler-control]", w = (C) => {
					let N = C.dataset.maptilerControl;
					return (N === "true" || N === "") && (N = void 0), N;
				}, v = (C) => C.dataset.maptilerPosition;
				let x = [...this._container.ownerDocument.querySelectorAll(m)], A = [...this._container.ownerDocument.querySelectorAll(y)].filter((C) => C.closest(m) === null);
				if (typeof t.customControls == "string") {
					const C = t.customControls;
					x = x.filter((N) => N.matches(C) || N.closest(C) !== null), A = A.filter((N) => N.matches(C) || N.closest(C) !== null);
				}
				for (const C of x) {
					const N = new tn(C);
					this.addControl(N, v(C));
					for (const ee of C.querySelectorAll(y)) N.configureGroupItem(ee, w(ee));
				}
				for (const C of A) this.addControl(new tn(C, w(C)), v(C));
				const E = () => {
					const { lng: C, lat: N } = this.getCenter();
					this._container.style.setProperty("--maptiler-center-lng", String(C)), this._container.style.setProperty("--maptiler-center-lat", String(N)), this._container.style.setProperty("--maptiler-zoom", String(this.getZoom())), this._container.style.setProperty("--maptiler-bearing", String(this.getBearing())), this._container.style.setProperty("--maptiler-pitch", String(this.getPitch())), this._container.style.setProperty("--maptiler-roll", String(this.getRoll())), this._container.style.setProperty("--maptiler-is-globe-projection", String(this.isGlobeProjection())), this._container.style.setProperty("--maptiler-has-terrain", String(this.hasTerrain()));
				};
				E(), this.on("render", E);
			}
			if (t.forceNoAttributionControl !== !0) if ("logo" in h && h.logo) {
				const m = h.logo;
				this.addControl(new Wn({ logoURL: m }), t.logoPosition);
			} else t.maptilerLogo && this.addControl(new Wn(), t.logoPosition);
			if (t.scaleControl) {
				const m = t.scaleControl === !0 || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, y = new zi({ unit: j.unit });
				this.addControl(y, m), j.on("unit", (w) => {
					y.setUnit(w);
				});
			}
			if (t.navigationControl !== !1) {
				const m = t.navigationControl === !0 || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
				this.addControl(new yu(), m);
			}
			if (t.geolocateControl !== !1) {
				const m = t.geolocateControl === !0 || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
				this.addControl(new vu({
					positionOptions: {
						enableHighAccuracy: !0,
						maximumAge: 0,
						timeout: 6e3
					},
					fitBoundsOptions: { maxZoom: 15 },
					trackUserLocation: !0,
					showAccuracyCircle: !0,
					showUserLocation: !0
				}), m);
			}
			if (t.terrainControl) {
				const m = t.terrainControl === !0 || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
				this.addControl(new mu(), m);
			}
			if (t.projectionControl) {
				const m = t.projectionControl === !0 || t.projectionControl === void 0 ? "top-right" : t.projectionControl;
				this.addControl(new wu(), m);
			}
			if (t.fullscreenControl) {
				const m = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
				this.addControl(new Oi({}), m);
			}
			this.isReady = !0, this.fire("ready", { target: this });
		});
		let c = !1, p = !1, d;
		this.once("ready", () => {
			c = !0, p && this.fire("loadWithTerrain", d);
		}), this.once("style.load", () => {
			const { minimap: h } = t;
			if (typeof h == "object") {
				const { zoom: m, center: y, style: w, language: v, apiKey: x, maptilerLogo: A, canvasContextAttributes: E, refreshExpiredTiles: C, maxBounds: N, scrollZoom: ee, minZoom: Le, maxZoom: Ee, boxZoom: V, locale: be, fadeDuration: zt, crossSourceCollisions: Ot, clickTolerance: $t, bounds: Ft, fitBoundsOptions: Nt, pixelRatio: jt, validateStyle: Dt } = t;
				this.minimap = new $r(h, {
					zoom: m,
					center: y,
					style: w,
					language: v,
					apiKey: x,
					container: "null",
					maptilerLogo: A,
					canvasContextAttributes: E,
					refreshExpiredTiles: C,
					maxBounds: N,
					scrollZoom: ee,
					minZoom: Le,
					maxZoom: Ee,
					boxZoom: V,
					locale: be,
					fadeDuration: zt,
					crossSourceCollisions: Ot,
					clickTolerance: $t,
					bounds: Ft,
					fitBoundsOptions: Nt,
					pixelRatio: jt,
					validateStyle: Dt
				}), this.addControl(this.minimap, h.position ?? "bottom-left");
			} else h === !0 ? (this.minimap = new $r({}, t), this.addControl(this.minimap, "bottom-left")) : h !== void 0 && h !== !1 && (this.minimap = new $r({}, t), this.addControl(this.minimap, h));
		});
		const f = (h) => {
			h.terrain && (p = !0, d = {
				type: "loadWithTerrain",
				target: this,
				terrain: h.terrain
			}, this.off("terrain", f), c && this.fire("loadWithTerrain", d));
		};
		this.on("terrain", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
			this.getCanvas().addEventListener("webglcontextlost", (h) => {
				if (this._removed === !0) {
					console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
					return;
				}
				console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", h);
			}), t.halo && this.initHalo({
				options: t,
				before: this.getLayersOrder()[0]
			}), t.space && this.initSpace({
				options: t,
				before: this.getLayersOrder()[0]
			});
		}), this.telemetry = new Su(this);
	}
	getSpace() {
		return this.space;
	}
	/**
	* Sets the space for the map.
	* @param {CubemapDefinition} space the `CubemapDefinition` options to set.
	* @remarks This method, at present, ** overwrites ** the current config.
	* If an option is not set it will internally revert to the default option
	* unless explicitly set when calling.
	*/
	setSpace(t, n = !0) {
		if (n && (this.options.space = t), t === !1) {
			this.space = void 0;
			return;
		}
		if (this.space) {
			this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);
			return;
		}
		this.space = new Br(t), this.once("load", () => {
			const a = this.getLayersOrder()[0];
			this.space && this.addLayer(this.space, a);
		});
	}
	/**
	* Enables the animations for the space layer.
	*/
	enableSpaceAnimations() {
		this.setSpaceAnimationActive(!0);
	}
	/**
	* Disables the animations for the space layer.
	*/
	disableSpaceAnimations() {
		this.setSpaceAnimationActive(!1);
	}
	/**
	* Enables the animations for the halo layer.
	*/
	enableHaloAnimations() {
		this.setHaloAnimationActive(!0);
	}
	/**
	* Disables the animations for the halo layer.
	*/
	disableHaloAnimations() {
		this.setHaloAnimationActive(!1);
	}
	/**
	* Sets whether the halo layer should be animated in and out.
	* @param active - Whether the animation should be active.
	*/
	setHaloAnimationActive(t) {
		this.halo ? this.halo.setAnimationActive(t) : this.once("load", () => {
			var n;
			(n = this.halo) == null || n.setAnimationActive(t);
		});
	}
	/**
	* Sets whether the space layer should be animated in and out.
	* @param active - Whether the animation should be active.
	*/
	setSpaceAnimationActive(t) {
		this.space ? this.space.setAnimationActive(t) : this.once("load", () => {
			var n;
			(n = this.space) == null || n.setAnimationActive(t);
		});
	}
	setSpaceFromSpec({ spec: t }) {
		var o;
		if (this.options.space === !1) return;
		if (typeof t == "boolean") {
			this.setSpace(t, !0);
			return;
		}
		if (this.options.space !== !0 && rn(this.options.space)) {
			this.setSpace(this.options.space, !0);
			return;
		}
		const n = rn(t);
		if (JSON.stringify((o = this.space) == null ? void 0 : o.getConfig()) === JSON.stringify(t)) {
			if (this.space && !this.getLayer(this.space.id)) {
				const i = this.getLayersOrder()[0];
				this.addLayer(this.space, i);
			}
			return;
		}
		if (n) {
			this.setSpace(t, !1);
			return;
		}
		if (this.options.space === !0) {
			this.setSpace(!0);
			return;
		}
		this.space && this.isGlobeProjection() && this.space.setCubemap(t);
	}
	setHaloFromSpec({ spec: t }) {
		var a, o;
		if (this.options.halo === !1) {
			console.log("options.halo is false");
			return;
		}
		if (typeof t == "boolean") {
			console.log("spec is boolean", t), this.setHalo(t);
			return;
		}
		if (JSON.stringify((a = this.halo) == null ? void 0 : a.getConfig()) === JSON.stringify(t)) {
			if (console.log("HALO IS THE SAME", t), this.halo && !this.getLayer(this.halo.id)) {
				const i = this.getLayersOrder().indexOf(((o = this.space) == null ? void 0 : o.id) ?? "") + 1, s = this.getLayersOrder()[i];
				this.addLayer(this.halo, s);
			}
			return;
		}
		if (!t && !this.options.halo) {
			console.log("spec is false, and options.halo is false"), this.setHalo({
				stops: [[0, "transparent"], [1, "transparent"]],
				scale: 1
			});
			return;
		}
		(() => {
			var i;
			if (console.log("updateHalo", t), this.halo) {
				if (console.log("halo exists", this.getLayer(this.halo.id)), !this.getLayer(this.halo.id)) {
					console.log("halo not in map, adding it");
					const s = this.getLayersOrder().indexOf(((i = this.space) == null ? void 0 : i.id) ?? "") + 1, l = this.getLayersOrder()[s];
					this.addLayer(this.halo, l);
				}
				t && (console.log("SET HALO FROM SPEC", t), this.halo.setGradient(t));
			}
		})();
	}
	initSpace({ options: t = this.options, before: n = this.getLayersOrder()[0], spec: a }) {
		if (this.space) {
			this.getLayer(this.space.id) || this.addLayer(this.space, n);
			return;
		}
		if (t.space === !1) return;
		const o = a;
		if (t.space) {
			this.space = new Br(t.space), this.addLayer(this.space, n);
			return;
		}
		o && (this.space = new Br(o), this.addLayer(this.space, n));
	}
	initHalo({ options: t = this.options, before: n = this.getLayersOrder()[0], spec: a }) {
		if (this.halo && this.getLayer(this.halo.id) || t.halo === !1) return;
		const o = a;
		if (t.halo) {
			this.halo = new qr(t.halo), this.addLayer(this.halo, n);
			return;
		}
		o && (this.halo = new qr(o), this.addLayer(this.halo, n));
	}
	getHalo() {
		return this.halo;
	}
	setHalo(t) {
		if (this.options.halo = t, !!this.isGlobeProjection()) {
			if (this.halo) {
				this.halo.setGradient(t);
				return;
			}
			this.halo = new qr(t), this.once("load", () => {
				var s;
				const n = this.getLayersOrder(), a = n[0], i = n[n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 2];
				this.halo && this.addLayer(this.halo, this.space ? i : a);
			});
		}
	}
	/**
	* Recreates the map instance with the same options.
	* Useful for WebGL context loss.
	*/
	recreate() {
		const t = {
			center: this.getCenter(),
			zoom: this.getZoom(),
			bearing: this.getBearing(),
			pitch: this.getPitch()
		};
		this.remove(), Object.assign(this, new Ho({ ...this.options })), this.once("load", () => {
			this.jumpTo(t);
		});
	}
	/**
	* Set the duration (millisec) of the terrain animation for growing or flattening.
	* Must be positive. (Built-in default: `1000` milliseconds)
	*/
	setTerrainAnimationDuration(t) {
		this.terrainAnimationDuration = Math.max(t, 0);
	}
	/**
	* Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
	* If _this_ Map instance is already loaded, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "load" event.
	* @returns
	*/
	async onLoadAsync() {
		return new Promise((t) => {
			if (this.loaded()) {
				t(this);
				return;
			}
			this.once("load", () => {
				t(this);
			});
		});
	}
	/**
	* Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
	* If _this_ Map instance is already ready, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "ready" event.
	* A map instance is "ready" when all the controls that can be managed by the contructor are
	* dealt with. This happens after the "load" event, due to the asynchronous nature
	* of some built-in controls.
	*/
	async onReadyAsync() {
		return new Promise((t) => {
			if (this.isReady) {
				t(this);
				return;
			}
			this.once("ready", () => {
				t(this);
			});
		});
	}
	/**
	* Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
	* and returns a Promise to the Map.
	* If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "loadWithTerrain" event.
	* @returns
	*/
	async onLoadWithTerrainAsync() {
		return new Promise((t) => {
			if (this.isReady && this.terrain) {
				t(this);
				return;
			}
			this.once("loadWithTerrain", () => {
				t(this);
			});
		});
	}
	monitorStyleUrl(t) {
		typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
		const n = new URL(t);
		n.search = "", this.monitoredStyleUrls.add(n.href);
	}
	/**
	* Update the style of the map.
	* Can be:
	* - a full style URL (possibly with API key)
	* - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
	* - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
	*/
	setStyle(t, n = {}) {
		var s, l, u, c, p;
		const o = {
			transformStyle: (d, f) => {
				var E, C, N, ee, Le, Ee, V, be, zt, Ot, $t, Ft, Nt, jt, Dt, jn, Dn, Un, Bn, qn, Vn, Gn;
				const h = !((C = (E = f == null ? void 0 : f.metadata) == null ? void 0 : E.maptiler) != null && C.space) && !!((ee = (N = d == null ? void 0 : d.metadata) == null ? void 0 : N.maptiler) != null && ee.space), m = !((Ee = (Le = f == null ? void 0 : f.metadata) == null ? void 0 : Le.maptiler) != null && Ee.halo) && !!((be = (V = d == null ? void 0 : d.metadata) == null ? void 0 : V.maptiler) != null && be.halo);
				h && (console.trace("space has been removed from style, removing it"), (zt = this.space) == null || zt.onRemove(this, this.getCanvas().getContext("webgl2")), this.space = void 0), m && (console.trace("halo has been removed from style, removing it"), (Ot = this.halo) == null || Ot.onRemove(this, this.getCanvas().getContext("webgl2")), this.halo = void 0);
				const y = this.space ? this.space.shouldUpdate((Ft = ($t = f == null ? void 0 : f.metadata) == null ? void 0 : $t.maptiler) == null ? void 0 : Ft.space) : !0, w = this.halo ? this.halo.shouldUpdate((jt = (Nt = f == null ? void 0 : f.metadata) == null ? void 0 : Nt.maptiler) == null ? void 0 : jt.halo) : !0, v = ((Dt = d == null ? void 0 : d.terrain) == null ? void 0 : Dt.source) !== ((jn = f == null ? void 0 : f.terrain) == null ? void 0 : jn.source) || ((Dn = d == null ? void 0 : d.terrain) == null ? void 0 : Dn.exaggeration) !== ((Un = f == null ? void 0 : f.terrain) == null ? void 0 : Un.exaggeration), x = y || v, A = w || v;
				if (x) try {
					const Ce = ((qn = (Bn = f == null ? void 0 : f.metadata) == null ? void 0 : Bn.maptiler) == null ? void 0 : qn.space) ?? !1;
					this.once("style.load", () => {
						var ct;
						this.getLayer(((ct = this.space) == null ? void 0 : ct.id) ?? "") ? this.setSpaceFromSpec({ spec: Ce }) : this.initSpace({ spec: Ce });
					});
				} catch (Ce) {
					console.error(Ce);
				}
				if (A) try {
					const Ce = ((Gn = (Vn = f == null ? void 0 : f.metadata) == null ? void 0 : Vn.maptiler) == null ? void 0 : Gn.halo) ?? !1;
					this.once("style.load", () => {
						var ct;
						this.getLayer(((ct = this.halo) == null ? void 0 : ct.id) ?? "") ? this.setHaloFromSpec({ spec: Ce }) : this.initHalo({ spec: Ce });
					});
				} catch (Ce) {
					console.error(Ce);
				}
				return { ...f };
			},
			diff: !0,
			...n
		};
		this.originalLabelStyle.clear(), (s = this.minimap) == null || s.setStyle(t, {}), this.forceLanguageUpdate = !0, this.once("idle", () => {
			this.forceLanguageUpdate = !1;
		});
		const i = ka(t);
		if (i.requiresUrlMonitoring && this.monitorStyleUrl(i.style), i.isFallback) {
			if (this.getStyle()) return console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."), this;
			console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.");
		}
		try {
			super.setStyle(i.style, o), this.styleInProcess = !0;
		} catch (d) {
			this.styleInProcess = !1, console.error("[Map.setStyle]: Error while setting style:", d);
		}
		try {
			if (i.isJSON) {
				const d = (u = (l = i.style.metadata) == null ? void 0 : l.maptiler) == null ? void 0 : u.halo, f = (p = (c = i.style.metadata) == null ? void 0 : c.maptiler) == null ? void 0 : p.space;
				d && this.setHalo(d), f && this.setSpace(f);
			}
		} catch (d) {
			console.error("[Map.setStyle]: Error while setting halo or space from style:", d);
		}
		return this;
	}
	/**
	* Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
	* to the map's style.
	*
	* A layer defines how data from a specified source will be styled. Read more about layer types
	* and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
	*
	* @param layer - The layer to add,
	* conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
	* less commonly, the {@link CustomLayerInterface} specification.
	* The MapLibre Style Specification's layer definition is appropriate for most layers.
	*
	* @param beforeId - The ID of an existing layer to insert the new layer before,
	* resulting in the new layer appearing visually beneath the existing layer.
	* If this argument is not specified, the layer will be appended to the end of the layers array
	* and appear visually above all other layers.
	*
	* @returns `this`
	*/
	addLayer(t, n) {
		var a;
		return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);
	}
	/**
	* Moves a layer to a different z-position.
	*
	* @param id - The ID of the layer to move.
	* @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
	* @returns `this`
	*
	* @example
	* Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
	* ```ts
	* map.moveLayer('polygon', 'country-label');
	* ```
	*/
	moveLayer(t, n) {
		var a;
		return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);
	}
	/**
	* Removes the layer with the given ID from the map's style.
	*
	* An {@link ErrorEvent} will be fired if the image parameter is invald.
	*
	* @param id - The ID of the layer to remove
	* @returns `this`
	*
	* @example
	* If a layer with ID 'state-data' exists, remove it.
	* ```ts
	* if (map.getLayer('state-data')) map.removeLayer('state-data');
	* ```
	*/
	removeLayer(t) {
		var n;
		return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);
	}
	/**
	* Sets the zoom extent for the specified style layer. The zoom extent includes the
	* [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
	* and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
	* at which the layer will be rendered.
	*
	* Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
	* minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
	* zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
	* layer will not be rendered at all zoom levels in the zoom range.
	*/
	setLayerZoomRange(t, n, a) {
		var o;
		return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);
	}
	/**
	* Sets the filter for the specified style layer.
	*
	* Filters control which features a style layer renders from its source.
	* Any feature for which the filter expression evaluates to `true` will be
	* rendered on the map. Those that are false will be hidden.
	*
	* Use `setFilter` to show a subset of your source data.
	*
	* To clear the filter, pass `null` or `undefined` as the second parameter.
	*/
	setFilter(t, n, a) {
		var o;
		return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);
	}
	/**
	* Sets the value of a paint property in the specified style layer.
	*
	* @param layerId - The ID of the layer to set the paint property in.
	* @param name - The name of the paint property to set.
	* @param value - The value of the paint property to set.
	* Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
	* @param options - Options object.
	* @returns `this`
	* @example
	* ```ts
	* map.setPaintProperty('my-layer', 'fill-color', '#faafee');
	* ```
	*/
	setPaintProperty(t, n, a, o) {
		var i;
		return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);
	}
	/**
	* Sets the value of a layout property in the specified style layer.
	* Layout properties define how the layer is styled.
	* Layout properties for layers of the same type are documented together.
	* Layers of different types have different layout properties.
	* See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
	* @param layerId - The ID of the layer to set the layout property in.
	* @param name - The name of the layout property to set.
	* @param value - The value of the layout property to set.
	* Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
	* @param options - Options object.
	* @returns `this`
	*/
	setLayoutProperty(t, n, a, o) {
		var i;
		return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);
	}
	/**
	* Sets the value of the style's glyphs property.
	*
	* @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
	* @param options - Options object.
	* @returns `this`
	* @example
	* ```ts
	* map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
	* ```
	*/
	setGlyphs(t, n) {
		var a;
		return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);
	}
	getStyleLanguage() {
		return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? getLanguageInfoFromFlag(this.style.stylesheet.metadata["maptiler:language"]) : null;
	}
	/**
	* Define the primary language of the map. Note that not all the languages shorthands provided are available.
	*/
	setLanguage(t) {
		var n;
		(n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {
			this.setPrimaryLanguage(t);
		});
	}
	/**
	* Define the primary language of the map. Note that not all the languages shorthands provided are available.
	*/
	setPrimaryLanguage(t) {
		const n = this.getStyleLanguage(), a = toLanguageInfo(t, z);
		if (!a) {
			console.warn(`The language "${a}" is not supported.`);
			return;
		}
		if (!(a.flag === z.STYLE.flag && n && (n.flag === z.AUTO.flag || n.flag === z.VISITOR.flag)) && (a.flag !== z.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate)) return;
		if (this.primaryLanguage.flag === z.STYLE_LOCK.flag) {
			console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
			return;
		}
		this.primaryLanguage = a;
		let o = a;
		if (a.flag === z.STYLE.flag) {
			if (!n) {
				console.warn("The style has no default languages or has an invalid one.");
				return;
			}
			o = n;
		}
		let i = z.LOCAL.flag, s = ["get", i];
		o.flag === z.VISITOR.flag ? (i = Yn().flag, s = [
			"case",
			[
				"all",
				["has", i],
				["has", z.LOCAL.flag]
			],
			[
				"case",
				[
					"==",
					["get", i],
					["get", z.LOCAL.flag]
				],
				["get", z.LOCAL.flag],
				[
					"format",
					["get", i],
					{ "font-scale": .8 },
					`
`,
					["get", z.LOCAL.flag],
					{ "font-scale": 1.1 }
				]
			],
			["get", z.LOCAL.flag]
		]) : o.flag === z.VISITOR_ENGLISH.flag ? (i = z.ENGLISH.flag, s = [
			"case",
			[
				"all",
				["has", i],
				["has", z.LOCAL.flag]
			],
			[
				"case",
				[
					"==",
					["get", i],
					["get", z.LOCAL.flag]
				],
				["get", z.LOCAL.flag],
				[
					"format",
					["get", i],
					{ "font-scale": .8 },
					`
`,
					["get", z.LOCAL.flag],
					{ "font-scale": 1.1 }
				]
			],
			["get", z.LOCAL.flag]
		]) : o.flag === z.AUTO.flag ? (i = Yn().flag, s = [
			"coalesce",
			["get", i],
			["get", z.LOCAL.flag]
		]) : o === z.LOCAL ? (i = z.LOCAL.flag, s = ["get", i]) : (i = o.flag, s = [
			"coalesce",
			["get", i],
			["get", z.LOCAL.flag]
		]);
		const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;
		if (u) {
			const c = Qi(l, this);
			this.isStyleLocalized = Object.keys(c.localized).length > 0;
		}
		for (const c of l) {
			if (c.type !== "symbol") continue;
			const p = c, d = this.getSource(p.source);
			if (!d || !("url" in d && typeof d.url == "string") || new URL(d.url).host !== J.maptilerApiHost) continue;
			const { id: h, layout: m } = p;
			if (!m || !("text-field" in m)) continue;
			let y;
			if (u ? (y = this.getLayoutProperty(h, "text-field"), this.originalLabelStyle.set(h, y)) : y = this.originalLabelStyle.get(h), typeof y == "string") {
				const { contains: w, exactMatch: v } = Ki(y, this.isStyleLocalized);
				if (!w) continue;
				if (v) this.setLayoutProperty(h, "text-field", s);
				else {
					const x = Xi(y, s, this.isStyleLocalized);
					this.setLayoutProperty(h, "text-field", x);
				}
			} else {
				const w = Zi(y, s, this.isStyleLocalized);
				this.setLayoutProperty(h, "text-field", w);
			}
		}
		this.languageIsUpdated = !0;
	}
	/**
	* Get the primary language
	* @returns
	*/
	getPrimaryLanguage() {
		return this.primaryLanguage;
	}
	/**
	* Get the exaggeration factor applied to the terrain
	* @returns
	*/
	getTerrainExaggeration() {
		return this.terrainExaggeration;
	}
	/**
	* Know if terrian is enabled or not
	* @returns
	*/
	hasTerrain() {
		return this.isTerrainEnabled;
	}
	growTerrain(t) {
		if (!this.terrain) return;
		const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {
			if (!this.terrain || this.terrainFlattening) return;
			const s = (performance.now() - n) / this.terrainAnimationDuration;
			if (s < .99) {
				const u = a + (1 - (1 - s) ** 4) * o;
				this.terrain.exaggeration = u, requestAnimationFrame(i);
			} else this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire("terrainAnimationStop", { terrain: this.terrain });
			this._elevationFreeze = !1, this.triggerRepaint();
		};
		!this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);
	}
	/**
	* Enables the 3D terrain visualization
	*/
	enableTerrain(t = this.terrainExaggeration) {
		if (t < 0) {
			console.warn("Terrain exaggeration cannot be negative.");
			return;
		}
		const n = (o) => {
			!this.terrain || o.type !== "data" || o.dataType !== "source" || !("source" in o) || o.sourceId !== "maptiler-terrain" || o.source.type !== "raster-dem" || o.isSourceLoaded && (this.off("data", n), this.growTerrain(t));
		}, a = () => {
			this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on("data", n), this.addSource(J.terrainSourceId, {
				type: "raster-dem",
				url: J.terrainSourceURL
			}), this.setTerrain({
				source: J.terrainSourceId,
				exaggeration: 0
			});
		};
		if (this.getTerrain()) {
			this.isTerrainEnabled = !0, this.growTerrain(t);
			return;
		}
		if (this.loaded() || this.isTerrainEnabled) a();
		else {
			const o = () => {
				this.getTerrain() && this.getSource(J.terrainSourceId) || a();
			};
			this.once("load", () => {
				o();
			}), this.once("moveend", () => {
				o();
			});
		}
	}
	/**
	* Disable the 3D terrain visualization
	*/
	disableTerrain() {
		if (!this.terrain) return;
		this.isTerrainEnabled = !1;
		const t = performance.now(), n = this.terrain.exaggeration, a = () => {
			if (!this.terrain || this.terrainGrowing) return;
			const o = (performance.now() - t) / this.terrainAnimationDuration;
			if (this._elevationFreeze = !1, o < .99) {
				const s = n * (1 - o) ** 4;
				this.terrain.exaggeration = s, requestAnimationFrame(a);
			} else this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(J.terrainSourceId) && this.removeSource(J.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
			this.triggerRepaint();
		};
		!this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);
	}
	/**
	* Sets the 3D terrain exageration factor.
	* If the terrain was not enabled prior to the call of this method,
	* the method `.enableTerrain()` will be called.
	* If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
	* If `animate` is `false`, no animated transition to the newly defined exaggeration.
	*/
	setTerrainExaggeration(t, n = !0) {
		!n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
	}
	/**
	* Perform an action when the style is ready. It could be at the moment of calling this method
	* or later.
	*/
	onStyleReady(t) {
		this.isStyleLoaded() ? t() : this.once("styledata", () => {
			t();
		});
	}
	async fitToIpBounds() {
		const t = await geolocation.info();
		this.fitBounds(t.country_bounds, {
			duration: 0,
			padding: 100
		});
	}
	async centerOnIpPoint(t) {
		const n = await geolocation.info();
		this.jumpTo({
			center: [n.longitude ?? 0, n.latitude ?? 0],
			zoom: t || 11
		});
	}
	getCameraHash() {
		const t = new Float32Array(5), n = this.getCenter();
		return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), gBase64.fromUint8Array(new Uint8Array(t.buffer));
	}
	/**
	* Get the SDK config object.
	* This is convenient to dispatch the SDK configuration to externally built layers
	* that do not directly have access to the SDK configuration but do have access to a Map instance.
	*/
	getSdkConfig() {
		return j;
	}
	/**
	* Get the MapTiler session ID. Convenient to dispatch to externaly built component
	* that do not directly have access to the SDK configuration but do have access to a Map instance.
	* @returns
	*/
	getMaptilerSessionId() {
		return dn;
	}
	/**
	*  Updates the requestManager's transform request with a new function.
	*
	* @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
	*    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
	*
	* @returns {Map} `this`
	*
	*  @example
	*  map.setTransformRequest((url: string, resourceType: string) => {});
	*/
	setTransformRequest(t) {
		return super.setTransformRequest(ta(t)), this;
	}
	/**
	* Gets the {@link ProjectionSpecification}.
	* @returns the projection specification.
	* @example
	* ```ts
	* let projection = map.getProjection();
	* ```
	*/
	getProjection() {
		return this.style.getProjection();
	}
	/**
	* Returns whether a globe projection is currently being used
	*/
	isGlobeProjection() {
		const t = this.getProjection();
		return t ? t.type === "globe" : !1;
	}
	/**
	* Activate the globe projection.
	*/
	enableGlobeProjection() {
		this.isGlobeProjection() !== !0 && (this.setProjection({ type: "globe" }), this.curentProjection = "globe");
	}
	/**
	* Activate the mercator projection.
	*/
	enableMercatorProjection() {
		this.isGlobeProjection() !== !1 && (this.setProjection({ type: "mercator" }), this.curentProjection = "mercator");
	}
	setProjection(t) {
		return this.fire("projection.change", {
			target: this,
			projection: t
		}), super.setProjection(t);
	}
	/**
	* Returns `true` is the language was ever updated, meaning changed
	* from what is delivered in the style.
	* Returns `false` if language in use is the language from the style
	* and has never been changed.
	*/
	isLanguageUpdated() {
		return this.languageIsUpdated;
	}
};
var re = class {
	constructor(e, t, n, a = {}) {
		g(this, "type");
		g(this, "target");
		g(this, "originalEvent");
		g(this, "imageX");
		g(this, "imageY");
		g(this, "isOutOfBounds");
		this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);
	}
};
var Zo = [
	"idle",
	"render",
	"load",
	"remove",
	"idle"
], Ko = ["error"], Xo = ["resize"], Yo = ["webglcontextlost", "webglcontextrestored"], Wo = [
	"moveend",
	"movestart",
	"move",
	"zoomend",
	"zoomstart",
	"zoom",
	"rotatestart",
	"rotateend",
	"rotate",
	"dragstart",
	"dragend",
	"drag",
	"boxzoomcancel",
	"boxzoomend",
	"boxzoomstart"
], Jo = [
	"click",
	"dblclick",
	"mousedown",
	"mouseup",
	"mousemove",
	"mouseout",
	"mouseover",
	"contextmenu",
	"touchstart",
	"touchend",
	"touchmove",
	"touchcancel"
], Qo = ["cooperativegestureprevented"], ei = [
	"data",
	"dataloading",
	"sourcedata",
	"sourcedataloading",
	"dataabort",
	"sourcedataabort"
], lc = [
	...Zo,
	...Ko,
	...Xo,
	...Yo,
	...Wo,
	...Jo,
	...ei,
	...Qo
], uc = ["lngLat", "_defaultPrevented"];
function cc({ map: r, viewer: e, lngLatToPx: t }) {
	lc.forEach((n) => {
		try {
			r.on(n, (a) => {
				const o = n;
				if (Jo.includes(o)) {
					const f = a, h = f.lngLat && t(f.lngLat), m = e.getImageMetadata(), w = {
						isOutOfBounds: m ? h[0] < 0 || h[0] > m.width || h[1] < 0 || h[1] > m.height : !0,
						imageX: h[0],
						imageY: h[1],
						...Object.fromEntries(Object.entries(a).filter(([v]) => !uc.includes(v)))
					};
					e.fire(new re(n, e, f.originalEvent, w));
					return;
				}
				const i = n;
				if (Wo.includes(i)) {
					const f = a;
					e.fire(new re(n, e, f.originalEvent, f));
					return;
				}
				const s = n;
				if (Ko.includes(s)) {
					const f = a;
					e.fire(new re(n, e, null, f));
					return;
				}
				const l = n;
				if (Xo.includes(l)) {
					const f = a;
					e.fire(new re(n, e, null, f));
					return;
				}
				const u = n;
				if (Yo.includes(u)) {
					const f = a;
					e.fire(new re(n, e, f.originalEvent, f));
					return;
				}
				const c = n;
				if (ei.includes(c)) {
					const f = a;
					e.fire(new re(n, e, null, f));
					return;
				}
				const p = n;
				if (Qo.includes(p)) {
					const f = a;
					e.fire(new re(n, e, null, f));
					return;
				}
				const d = n;
				if (Zo.includes(d)) {
					e.fire(new re(n, e));
					return;
				}
			});
		} catch (a) {
			console.error(`Error forwarding event to ImageViewer, event of type "${n}" is not supported`, a);
		}
	});
}
var pc = class extends Error {
	constructor(t, n, a) {
		const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;
		super(o);
		g(this, "status");
		g(this, "statusText");
		this.name = "FetchError", this.message = o, this.status = t.status, this.statusText = t.statusText;
	}
};
var fc = 85.051129;
function dc(r, e) {
	return new fn(e.x / r, e.y / r).toLngLat();
}
function hc(r) {
	return Math.pow(2, r);
}
function mc(r) {
	return Math.log(r) / Math.LN2;
}
function ti(r, e, t) {
	return Math.min(t, Math.max(e, r));
}
function nn(r) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function an(r) {
	return (180 + r) / 360;
}
function Ba(r, e, t) {
	const n = t - e, a = ((r - e) % n + n) % n + e;
	return a === e ? t : a;
}
function yc(r, e) {
	const t = ti(e.lat, -85.051129, fc);
	return new bi(an(e.lng) * r, nn(t) * r);
}
function gc(r) {
	r.transform.getConstrained = function(e, t) {
		t = ti(+t, this.minZoom, this.maxZoom);
		const n = {
			center: new vi(e.lng, e.lat),
			zoom: t
		};
		let a = this._helper._lngRange;
		a === null && (a = [-179.9999999999, 179.9999999999]);
		const o = this.tileSize * hc(n.zoom);
		let i = 0, s = o, l = 0, u = o, c = 0, p = 0;
		const { x: d, y: f } = this.size, h = .5;
		if (this._helper._latRange) {
			const V = this._helper._latRange;
			i = nn(V[1]) * o, s = nn(V[0]) * o, s - i < h * f && (c = h * f / (s - i));
		}
		a && (l = Ba(an(a[0]) * o, 0, o), u = Ba(an(a[1]) * o, 0, o), u < l && (u += o), u - l < h * d && (p = h * d / (u - l)));
		const { x: m, y } = yc(o, e);
		let w, v;
		const x = Math.min(p || 0, c || 0);
		if (x) return n.zoom += mc(x), n;
		let A = 0, E = 0;
		const C = 1, N = 1 - (s - i) / f, ee = 1 - (u - l) / d;
		A = Math.max(ee, C), E = Math.max(N, C);
		const Le = 1 - A, Ee = 1 - E;
		if (this._helper._latRange) {
			const V = Ee * f / 2;
			y - V < i && (v = i + V), y + V > s && (v = s - V);
		}
		if (a) {
			const V = m, be = Le * d / 2;
			V - be < l && (w = l + be), V + be > u && (w = u - be);
		}
		if (w !== void 0 || v !== void 0) n.center = dc(o, new bi(w ?? m, v ?? y)).wrap();
		return n;
	};
}
var vc = {
	center: "translate(-50%,-50%)",
	top: "translate(-50%,0)",
	"top-left": "translate(0,0)",
	"top-right": "translate(-100%,0)",
	bottom: "translate(-50%,-100%)",
	"bottom-left": "translate(0,-100%)",
	"bottom-right": "translate(-100%,-100%)",
	left: "translate(0,-50%)",
	right: "translate(-100%,-50%)"
};
function bc(r) {
	function e(t) {
		if (!this._map) return;
		const n = this._map.loaded() && !this._map.isMoving();
		((t == null ? void 0 : t.type) === "terrain" || (t == null ? void 0 : t.type) === "render" && !n) && this._map.once("render", this._update), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
		let a = "";
		this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
		let o = "";
		this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = `rotateX(${this._map.getPitch()}deg)`), !this._subpixelPositioning && (!t || t.type === "moveend") && (this._pos = this._pos.round());
		const i = `${vc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${a}`;
		this._element.style.transform = i;
	}
	r._update = e.bind(r);
}
var wc = class {
	constructor({ imageViewer: e }) {
		g(this, "viewer");
		g(this, "container");
		g(this, "handleClick", () => {
			this.viewer.fitImageToViewport({ ease: !0 });
		});
		if (!e) throw new Error("ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required");
		this.viewer = e;
	}
	onAdd(e) {
		const t = document.createElement("button");
		this.container = document.createElement("div"), this.container.classList.add("maplibregl-ctrl", "maplibregl-ctrl-group"), t.classList.add("maplibregl-ctrl-fit-image-to-bounds");
		const n = document.createElement("span");
		return n.classList.add("maplibregl-ctrl-icon"), t.title = "Zoom image to viewport bounds", t.appendChild(n), t.addEventListener("click", this.handleClick), this.container.appendChild(t), this.container;
	}
	onRemove() {
		this.container.remove();
	}
};
var ri = Symbol("MapTiler:ImageViewer:Internal:lngLatToPxInternal"), ni = Symbol("MapTiler:ImageViewer:Internal:pxToLngLatInternal"), { Evented: Sc } = import_maplibre_gl.default, xc = {
	style: {
		version: 8,
		sources: {},
		layers: []
	},
	minPitch: 0,
	maxPitch: 0,
	pitch: 0,
	bearing: 0,
	projection: "mercator",
	geolocateControl: !1,
	navigationControl: !1,
	projectionControl: !1,
	hash: !1,
	renderWorldCopies: !1,
	terrain: !1,
	space: !1,
	halo: !1
}, kc = {
	debug: !1,
	fitToBoundsControl: !0,
	navigationControl: !0
};
var Ka, Xa, Ya;
var Lc = class extends (Ya = Sc, Xa = ri, Ka = ni, Ya) {
	/**
	* The constructor for the ImageViewer.
	*
	* @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.
	* @example
	* ```ts
	* import "@maptiler/sdk/dist/maptiler-sdk.css"; // import css
	* import { ImageViewer } from "@maptiler/sdk"; // import the sdk
	*
	* const imageViewer = new ImageViewer({
	*   container: document.getElementById("map"),
	*   imageUUID: "01986025-ceb9-7487-9ea6-7a8637dcc1a1",
	*   debug: true, // show tile boundaries, padding, collision boxes etc
	*   fitToBoundsControl: true, // show a control to fit the image to the viewport
	*   navigationControl: true, // show a navigation control
	*   center: [0, 0], // center in pixels
	*   zoom: 1, // zoom level
	*   bearing: 0, // bearing
	* });
	* ```
	*/
	constructor(t) {
		super();
		/**
		* The UUID of the image.
		*
		* @internal
		*/
		g(this, "imageUUID");
		/**
		* Whether to enable debug mode.
		*
		* @internal
		*/
		g(this, "debug");
		/**
		* The metadata of the image.
		*
		*/
		g(this, "imageMetadata");
		/**
		* Why not extend the Map class?
		* Because ImageViewer technically operates in screen space and not in map space.
		* We wrap map and perform calculations in screen space.
		* We do not want to have to extend the Map class and give access to
		* methods and properties that operate in LngLat space.   *
		*/
		g(this, "sdk");
		/**
		* The options for the ImageViewer.
		*
		* @internal
		*/
		g(this, "options");
		/**
		* The size of the image.
		*
		* @internal
		*/
		g(this, "imageSize");
		/**
		* The padded size max.
		*
		* @internal
		*/
		g(this, "paddedSizeMax");
		/**
		* The control to fit the image to the viewport.
		*/
		g(this, "fitToBoundsControlInstance");
		g(this, "shouldFitImageToViewport", !0);
		g(this, Xa, this.lngLatToPx.bind(this));
		g(this, Ka, this.pxToLngLat.bind(this));
		if (!t.imageUUID) throw new Error("[ImageViewer]: `imageUUID` is required");
		if (typeof t.container != "string" && !(t.container instanceof HTMLElement)) throw new Error("[ImageViewer]: `container` is required and must be a string or HTMLElement");
		this.options = {
			...kc,
			...t
		};
		const n = {
			...this.options,
			...xc
		};
		delete n.center, this.sdk = new Go(n), this.sdk.telemetry.registerViewerType("ImageViewer");
		const { imageUUID: a, debug: o } = t;
		this.imageUUID = a, this.debug = o ?? !1, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();
	}
	/**
	* The version of the ImageViewer / SDK.
	*/
	get version() {
		return this.sdk.version;
	}
	/**
	* Waits for the ImageViewer to be ready.
	*
	* @returns {Promise<void>}
	*/
	async onReadyAsync() {
		try {
			await this.sdk.onReadyAsync(), await Promise.race([new Promise((t, n) => {
				this.once("imageviewerready", (a) => {
					t(a);
				}), this.once("imagevieweriniterror", (a) => {
					n(a.error);
				});
			}), new Promise((t, n) => {
				setTimeout(() => {
					n(/* @__PURE__ */ new Error("Timeout waiting for image viewer to be ready"));
				}, 5e3);
			})]);
		} catch (t) {
			throw t;
		}
	}
	/**
	* Initializes the ImageViewer
	*  - fetches the image metadata
	*  - adds the image source to the sdk instance
	*  - sets the center to the middle of the image (if center is not provided)
	*  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.
	*  - sets up global event forwarding / intercepting from the map instance
	*  - sets the center to the middle of the image (if center is not provided)
	*
	* @internal
	* @returns {Promise<void>}
	*/
	async init() {
		var t, n, a;
		try {
			await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(new Wa({
				visualizePitch: !1,
				visualizeRoll: !1
			})), this.fitToBoundsControlInstance = new wc({ imageViewer: this }), this.options.fitToBoundsControl && this.sdk.addControl(this.fitToBoundsControlInstance), cc({
				map: this.sdk,
				viewer: this,
				lngLatToPx: (u) => this.lngLatToPx(u)
			}), gc(this.sdk);
			const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];
			this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on("wheel", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("touchstart", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("drag", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("resize", () => {
				var d, f;
				const u = this.getCenter(), c = ((d = this.imageMetadata) == null ? void 0 : d.width) ?? 0, p = ((f = this.imageMetadata) == null ? void 0 : f.height) ?? 0;
				this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);
			}), this.fire("imageviewerready", new re("imageviewerready", this));
		} catch (o) {
			this.fire("imagevieweriniterror", { error: o });
		}
	}
	/**
	* Fits the image to the viewport.
	*
	* @param {Object} options - The options for the fit image to viewport.
	* @param {boolean} options.ease - Whether to ease to the viewport bounds.
	*/
	fitImageToViewport({ ease: t = !1 } = {}) {
		if (!this.imageMetadata) throw new Error("[ImageViewer]: Image metadata not found");
		const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });
		o && (t ? this.sdk.easeTo({
			...o,
			pitch: 0
		}, null) : this.sdk.jumpTo({
			...o,
			pitch: 0
		}, null)), this.shouldFitImageToViewport = !0;
	}
	/**
	* Fetches the image metadata from the API.
	*
	* @internal
	* @returns {Promise<void>}
	*/
	async fetchImageMetadata() {
		const t = Ec(this.imageUUID), n = await fetch(t);
		if (!n.ok) throw new pc(n, "image metadata", "ImageViewer");
		this.imageMetadata = await n.json(), Object.freeze(this.imageMetadata);
	}
	/**
	* Adds the image source to the sdk instance.
	*
	* @internal
	* @returns {void}
	*/
	addImageSource() {
		if (!this.imageMetadata) throw this.fire("error", new re("error", this, null, { error: /* @__PURE__ */ new Error("[ImageViewer]: Image metadata not found") })), /* @__PURE__ */ new Error("[ImageViewer]: Image metadata not found");
		const t = Cc(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
		this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));
		const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [
			a.lng,
			o.lat,
			o.lng,
			a.lat
		];
		this.sdk.addSource("image", {
			...this.imageMetadata,
			type: "raster",
			bounds: i,
			tiles: [t]
		}), this.sdk.addLayer({
			id: "image",
			type: "raster",
			source: "image"
		});
	}
	/**
	* Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().
	*
	* @internal
	* @returns {void}
	*/
	triggerRepaint() {
		this.sdk.triggerRepaint();
	}
	/**
	* The scroll zoom handler.
	*
	* @internal
	* @returns {ScrollZoomHandler}
	*/
	get scrollZoom() {
		return this.sdk.scrollZoom;
	}
	/**
	* The scroll zoom handler.
	*
	* @internal
	* @param {ScrollZoomHandler} value - The scroll zoom handler.
	*/
	set scrollZoom(t) {
		this.sdk.scrollZoom = t;
	}
	/**
	* The box zoom handler.
	*
	* @internal
	* @returns {BoxZoomHandler}
	*/
	get boxZoom() {
		return this.sdk.boxZoom;
	}
	/**
	* The box zoom handler.
	*
	* @internal
	* @param {BoxZoomHandler} value - The box zoom handler.
	*/
	set boxZoom(t) {
		this.sdk.boxZoom = t;
	}
	/**
	* The drag pan handler.
	*
	* @internal
	* @returns {DragPanHandler}
	*/
	get dragPan() {
		return this.sdk.dragPan;
	}
	/**
	* The drag pan handler.
	*
	* @internal
	* @param {DragPanHandler} value - The drag pan handler.
	*/
	set dragPan(t) {
		this.sdk.dragPan = t;
	}
	/**
	* The keyboard handler.
	*
	* @internal
	* @returns {KeyboardHandler}
	*/
	get keyboard() {
		return this.sdk.keyboard;
	}
	/**
	* The keyboard handler.
	*
	* @internal
	* @param {KeyboardHandler} value - The keyboard handler.
	*/
	set keyboard(t) {
		this.sdk.keyboard = t;
	}
	/**
	* The double click zoom handler.
	*
	* @internal
	* @returns {DoubleClickZoomHandler}
	*/
	get doubleClickZoom() {
		return this.sdk.doubleClickZoom;
	}
	/**
	* The double click zoom handler.
	*
	* @internal
	* @param {DoubleClickZoomHandler} value - The double click zoom handler.
	*/
	set doubleClickZoom(t) {
		this.sdk.doubleClickZoom = t;
	}
	/**
	* The touch zoom rotate handler.
	*
	* @internal
	* @returns {TwoFingersTouchZoomRotateHandler}
	*/
	get touchZoomRotate() {
		return this.sdk.touchZoomRotate;
	}
	/**
	* The touch zoom rotate handler.
	*
	* @internal
	* @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.
	*/
	set touchZoomRotate(t) {
		this.sdk.touchZoomRotate = t;
	}
	/**
	* The cooperative gestures handler.
	*
	* @internal
	* @returns {CooperativeGesturesHandler}
	*/
	get cooperativeGestures() {
		return this.sdk.cooperativeGestures;
	}
	/**
	* The cooperative gestures handler.
	*
	* @internal
	* @param {CooperativeGesturesHandler} value - The cooperative gestures handler.
	*/
	set cooperativeGestures(t) {
		this.sdk.cooperativeGestures = t;
	}
	/**
	* Converts a LngLat to a px coordinate, based on the image metadata.
	*
	* @internal
	* @param {LngLat} lngLat - The LngLat to convert.
	* @returns {[number, number]} The px coordinate.
	*/
	lngLatToPx(t) {
		if (!this.paddedSizeMax) {
			const a = "[ImageViewer]: Unable to convert LngLat to px, padded size max not set";
			throw this.fire("error", new re("error", this, null, { error: new Error(a) })), new Error(a);
		}
		const n = fn.fromLngLat(t);
		return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];
	}
	/**
	* Converts a px coordinate to a LngLat, based on the image metadata.
	*
	* @internal
	* @param {LngLat} lngLat - The LngLat to convert.
	* @returns {[number, number]} The px coordinate.
	*/
	pxToLngLat(t) {
		if (!this.paddedSizeMax) {
			const a = "[ImageViewer]: Unable to convert px to LngLat, padded size max not set";
			throw this.fire("error", new re("error", this, null, { error: new Error(a) })), new Error(a);
		}
		return new fn(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();
	}
	/**
	* Get the internal SDK instance.
	*
	* @returns {Map} The internal SDK instance.
	* @internal
	*/
	getSDKInternal() {
		return this.sdk;
	}
	/**
	* Get the canvas of the internal SDK instance.
	*
	* @returns {HTMLCanvasElement} The canvas of the internal SDK instance.
	*/
	getCanvas() {
		return this.sdk.getCanvas();
	}
	/**
	* Fly to a given center.
	*
	* @param {ImageViewerFlyToOptions} options - The options for the fly to.
	* @param {MapDataEvent} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	flyTo(t, n) {
		const a = this.pxToLngLat(t.center);
		return this.sdk.flyTo({
			...t,
			pitch: 0,
			center: a
		}, n), this;
	}
	/**
	* Jump to a given center.
	*
	* @param {ImageViewerJumpToOptions} options - The options for the jump to.
	* @param {MapDataEvent} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	jumpTo(t, n) {
		const a = this.pxToLngLat(t.center);
		return this.sdk.jumpTo({
			...t,
			pitch: 0,
			center: a
		}, n), this;
	}
	/**
	* Set the zoom level.
	*
	* @param {number} zoom - The zoom level.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setZoom(t) {
		return this.sdk.setZoom(t), this;
	}
	/**
	* Get the zoom level.
	*
	* @returns {number} The zoom level.
	*/
	getZoom() {
		return this.sdk.getZoom();
	}
	/**
	* Get the center of the ImageViewer in pixels.
	*
	* @internal
	* @returns {[number, number]} The center of the ImageViewer.
	*/
	getCenter() {
		const t = this.sdk.getCenter();
		return this.lngLatToPx(t);
	}
	/**
	* Set the center of the ImageViewer in pixels.
	*
	* @param {number} center - The center of the ImageViewer.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setCenter(t) {
		return this.sdk.setCenter(this.pxToLngLat(t)), this;
	}
	/**
	* Set the bearing of the ImageViewer in degrees.
	*
	* @param {number} bearing - The bearing of the ImageViewer.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setBearing(t) {
		return this.sdk.setBearing(t), this;
	}
	/**
	* Get the bearing of the ImageViewer in degrees.
	*
	* @returns {number} The bearing of the ImageViewer.
	*/
	getBearing() {
		return this.sdk.getBearing();
	}
	/**
	* Pan by a given delta in pixels.
	*
	* @param {PointLike} delta - The delta to pan by.
	* @param {ImageViewerEaseToOptions} options - The options for the pan.
	* @param {any} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	panBy(t, n, a) {
		return this.sdk.panBy(t, {
			...n,
			pitch: 0
		}, a), this;
	}
	/**
	* Pan to a given center in pixels.
	*
	* @param {number} center - The center to pan to.
	* @param {ImageViewerEaseToOptions} options - The options for the pan.
	* @param {any} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	panTo(t, n, a) {
		return this.sdk.panTo(this.pxToLngLat(t), {
			...n,
			pitch: 0
		}, a), this;
	}
	/**
	* Get the image metadata.
	*
	* @returns {ImageMetadata} The image metadata.
	*/
	getImageMetadata() {
		return this.imageMetadata;
	}
	/**
	* Get the visible bounds of the image in the viewport in imagePixels.
	* [topLeft, bottomRight]
	*
	* @returns {[[number, number], [number, number]]} The visible bounds of the image.
	*/
	getImageBounds() {
		const n = this.sdk.getBounds().toArray().map((i) => this.lngLatToPx(vi.convert(i)));
		return [[n[0][0], n[1][1]], [n[1][0], n[0][1]]];
	}
	/**
	* Set the bounds of the image.
	*
	* @param {[[number, number], [number, number]]} bounds - The bounds of the image.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	fitImageBounds([t, n]) {
		const a = this.pxToLngLat(t), o = this.pxToLngLat(n), i = Xc.convert([a, o]);
		return this.sdk.fitBounds(i), this;
	}
	/**
	* Destroys the ImageViewer, removes the map instance and all event listeners. Useful for cleanup.
	*
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	remove() {
		this.fire("beforeremove", new re("beforeremove", this)), this.sdk.remove(), this._listeners && Object.entries(this._listeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this._oneTimeListeners && Object.entries(this._oneTimeListeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		});
	}
	pointIsWithinImageBounds(t) {
		const n = this.getImageMetadata();
		if (!n) return !1;
		const a = [[0, 0], [n.width, n.height]];
		return t[0] >= a[0][0] && t[0] <= a[1][0] && t[1] >= a[0][1] && t[1] <= a[1][1];
	}
};
function Ec(r) {
	return `${ai()}/${r}/image.json?key=${j.apiKey}`;
}
function Cc(r) {
	return `${ai()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;
}
function ai() {
	return "https://api.maptiler.com/images";
}
var { Evented: Ac } = import_maplibre_gl.default;
var kp = class extends Ac {
	constructor({ ...t }) {
		super();
		g(this, "viewer");
		g(this, "marker");
		g(this, "position", [0, 0]);
		this.marker = new Mi(t);
	}
	/**
	* Adds the ImageViewerMarker to an instance of ImageViewer.
	*
	* @param {ImageViewer} viewer - The instance of ImageViewer to add the ImageViewerMarker to.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	addTo(t) {
		if (!(t instanceof Lc)) throw new Error("[ImageViewerMarker]: an ImageViewerMarker must be added to an instance of ImageViewer");
		this.viewer = t, Mc(this.marker, this, this.viewer[ri]);
		const n = this.viewer.getSDKInternal();
		return this.setPosition(this.position), bc(this.marker), this.marker.addTo(n), this;
	}
	/**
	* Adds a class name to the ImageViewerMarker.
	*
	* @param {string} className - The class name to add to the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	addClassName(t) {
		return this.marker.addClassName(t), this;
	}
	/**
	* Gets the element of the ImageViewerMarker.
	*
	* @returns {HTMLElement} The element of the ImageViewerMarker.
	*/
	getElement() {
		return this.marker.getElement();
	}
	/**
	* Gets the position of the ImageViewerMarker.
	*
	* @returns {PointLike} The position of the ImageViewerMarker.
	* @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
	*
	*/
	getPosition() {
		return this.position;
	}
	/**
	* Gets the offset of the ImageViewerMarker.
	*
	* @returns {PointLike} The offset of the ImageViewerMarker.
	* @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
	*/
	getOffset() {
		return this.marker.getOffset();
	}
	/**
	* Gets the pitch alignment of the ImageViewerMarker.
	*
	* @returns {Alignment} The pitch alignment of the ImageViewerMarker.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	getPitchAlignment() {
		return this.marker.getPitchAlignment();
	}
	/**
	* Gets the popup of the ImageViewerMarker.
	*
	* @returns {Popup} The popup of the ImageViewerMarker.
	* @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
	*/
	getPopup() {
		return this.marker.getPopup();
	}
	/**
	* Gets the rotation of the ImageViewerMarker.
	*
	* @returns {number} The rotation of the ImageViewerMarker.
	*/
	getRotation() {
		return this.marker.getRotation();
	}
	/**
	* Gets the rotation alignment of the ImageViewerMarker.
	*
	* @returns {Alignment} The rotation alignment of the ImageViewerMarker.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	getRotationAlignment() {
		return this.marker.getRotationAlignment();
	}
	/**
	* Checks if the ImageViewerMarker is draggable.
	*
	* @returns {boolean} True if the ImageViewerMarker is draggable, false otherwise.
	*/
	isDraggable() {
		return this.marker.isDraggable();
	}
	/**
	* Fires an event on the ImageViewerMarker.
	*
	* @param {MarkerEventTypes | Event} event - The event to fire.
	* @param {Record<string, any>} data - The data to fire the event with.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	fire(t, n) {
		return super.fire(t, n), this;
	}
	/**
	* Removes an event listener from the ImageViewerMarker.
	*
	* @param {MarkerEventTypes} event - The event to remove the listener from.
	* @param {ImageViewerMarkerEvent} listener - The listener to remove.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	off(t, n) {
		return super.off(t, n), this;
	}
	/**
	* Adds an event listener to the ImageViewerMarker.
	*
	* @param {MarkerEventTypes} event - The event to add the listener to.
	* @param {ImageViewerMarkerEvent} listener - The listener to add.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	on(t, n) {
		return super.on(t, n);
	}
	/**
	* Checks if the ImageViewerMarker is within the image bounds.
	*
	* @returns {boolean} True if the ImageViewerMarker is within the image bounds, false otherwise.
	*/
	isWithinImageBounds() {
		return this.viewer.pointIsWithinImageBounds(this.position);
	}
	/**
	* Removes the ImageViewerMarker from the ImageViewer and cleans up the event listeners.
	*
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	remove() {
		return this.marker.remove(), this.marker._listeners && Object.entries(this.marker._listeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this.marker._oneTimeListeners && Object.entries(this.marker._oneTimeListeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this;
	}
	/**
	* Removes a class name from the ImageViewerMarker dom element.
	*
	* @param {string} className - The class name to remove from the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	removeClassName(t) {
		return this.marker.removeClassName(t), this;
	}
	/**
	* Sets the draggable state of the ImageViewerMarker.
	*
	* @param {boolean} draggable - The draggable state of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setDraggable(t) {
		return this.marker.setDraggable(t), this;
	}
	/**
	* Sets the position of the ImageViewerMarker.
	*
	* @param {[number, number]} px - The position of the ImageViewerMarker in image pixels.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setPosition(t) {
		if (this.position[0] = t[0], this.position[1] = t[1], !this.viewer) return this;
		const n = this.viewer[ni](t);
		return this.marker.setLngLat(n), this;
	}
	/**
	* Sets the offset of the ImageViewerMarker.
	*
	* @param {PointLike} offset - The offset of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setOffset(t) {
		return this.marker.setOffset(t), this;
	}
	/**
	* Sets the opacity of the ImageViewerMarker.
	*
	* @param {string} opacity - The opacity of the ImageViewerMarker.
	* @param {string} opacityWhenCovered - The opacity of the ImageViewerMarker when covered.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setOpacity(t, n) {
		return this.marker.setOpacity(t, n), this;
	}
	/**
	* Sets the pitch alignment of the ImageViewerMarker.
	*
	* @param {Alignment} pitchAlignment - The pitch alignment of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	setPitchAlignment(t) {
		return this.marker.setPitchAlignment(t), this;
	}
	/**
	* Sets the popup of the ImageViewerMarker.
	*
	* @param {Popup} popup - The popup of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
	*/
	setPopup(t) {
		return this.marker.setPopup(t), this;
	}
	/**
	* Sets the rotation of the ImageViewerMarker.
	*
	* @param {number} rotation - The rotation of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setRotation(t) {
		return this.marker.setRotation(t), this;
	}
	/**
	* Sets the rotation alignment of the ImageViewerMarker.
	*
	* @param {Alignment} rotationAlignment - The rotation alignment of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	setRotationAlignment(t) {
		return this.marker.setRotationAlignment(t), this;
	}
	/**
	* Sets if subpixel positioning is enabled for the ImageViewerMarker.
	*
	* @param {boolean} subpixelPositioning - The subpixel positioning of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setSubpixelPositioning(t) {
		return this.marker.setSubpixelPositioning(t), this;
	}
	/**
	* Toggles a class name on the ImageViewerMarker dom element.
	*
	* @param {string} className - The class name to toggle on the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	toggleClassName(t) {
		return this.marker.toggleClassName(t), this;
	}
	/**
	* Toggles the popup of the ImageViewerMarker.
	*
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	togglePopup() {
		return this.marker.togglePopup(), this;
	}
};
var Tc = [
	"dragstart",
	"drag",
	"dragend"
], _c = [
	"lngLat",
	"_defaultPrevented",
	"target"
];
var Ic = class {
	constructor(e, t, n) {
		g(this, "type");
		g(this, "target");
		this.type = e, this.target = t, Object.assign(this, n);
	}
};
function Mc(r, e, t) {
	Tc.forEach((n) => {
		r.on(n, (a) => {
			var i, s;
			if ((i = a.target) == null ? void 0 : i.getLngLat()) {
				const l = t((s = a.target) == null ? void 0 : s.getLngLat());
				e.setPosition(l);
			}
			e.fire(n, new Ic(n, e, { ...Object.fromEntries(Object.entries(a).filter(([l]) => !_c.includes(l))) }));
		});
	});
}
function $n(r) {
	if (typeof DOMParser < "u") {
		const e = new DOMParser().parseFromString(r, "application/xml");
		if (e.querySelector("parsererror")) throw new Error("The provided string is not valid XML");
		return e;
	}
	throw new Error("No XML parser found");
}
function oi(r, e) {
	if (!r.hasChildNodes()) return !1;
	for (const t of Array.from(r.childNodes)) {
		const n = t.nodeName;
		if (typeof n == "string" && n.trim().toLowerCase() === e.toLowerCase()) return !0;
	}
	return !1;
}
function qa(r) {
	if (typeof XMLSerializer < "u") return new XMLSerializer().serializeToString(r);
	throw new Error("No XML serializer found");
}
function ii(r) {
	const e = typeof r == "string" ? $n(r) : r;
	if (!oi(e, "gpx")) throw new Error("The XML document is not valid GPX");
	const t = H(e, "trk"), n = H(e, "rte"), a = H(e, "wpt"), o = {
		type: "FeatureCollection",
		features: []
	};
	for (const i of Array.from(t)) {
		const s = Oc(i);
		s && o.features.push(s);
	}
	for (const i of Array.from(n)) {
		const s = $c(i);
		s && o.features.push(s);
	}
	for (const i of Array.from(a)) o.features.push(Fc(i));
	return o;
}
function si(r, e) {
	let t = r;
	if (typeof t == "string" && (t = $n(t)), !oi(t, "kml")) throw new Error("The XML document is not valid KML");
	const n = {
		type: "FeatureCollection",
		features: []
	}, a = {}, o = {}, i = {}, s = H(t, "Placemark"), l = H(t, "Style"), u = H(t, "StyleMap");
	for (const c of Array.from(l)) {
		const p = Ga(e !== void 0 ? e(c) : qa(c)).toString(16);
		a[`#${Xe(c, "id")}`] = p, o[p] = c;
	}
	for (const c of Array.from(u)) {
		a[`#${Xe(c, "id")}`] = Ga(e !== void 0 ? e(c) : qa(c)).toString(16);
		const p = H(c, "Pair"), d = {};
		for (const f of Array.from(p)) d[F(_(f, "key")) ?? ""] = F(_(f, "styleUrl"));
		i[`#${Xe(c, "id")}`] = d;
	}
	for (const c of Array.from(s)) n.features = n.features.concat(zc(c, a, o, i));
	return n;
}
function Va(r) {
	if (r === null) return ["#000000", 1];
	let e = "", t = 1, n = r;
	return n.startsWith("#") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? "#000000", t ?? 1];
}
function Pc(r) {
	return ci(r.split(" "));
}
function Rc(r) {
	let e = H(r, "coord");
	const t = [], n = [];
	e.length === 0 && (e = H(r, "gx:coord"));
	for (const o of Array.from(e)) t.push(Pc(F(o) ?? ""));
	const a = H(r, "when");
	for (const o of Array.from(a)) n.push(F(o));
	return {
		coords: t,
		times: n
	};
}
function Xt(r) {
	const e = [
		"Polygon",
		"LineString",
		"Point",
		"Track",
		"gx:Track"
	];
	let t, n, a, o, i;
	const s = [], l = [];
	if (_(r, "MultiGeometry") !== null) return Xt(_(r, "MultiGeometry"));
	if (_(r, "MultiTrack") !== null) return Xt(_(r, "MultiTrack"));
	if (_(r, "gx:MultiTrack") !== null) return Xt(_(r, "gx:MultiTrack"));
	for (a = 0; a < e.length; a++) if (n = H(r, e[a]), n) {
		for (o = 0; o < n.length; o++) if (t = n[o], e[a] === "Point") s.push({
			type: "Point",
			coordinates: pi(F(_(t, "coordinates")) ?? "")
		});
		else if (e[a] === "LineString") s.push({
			type: "LineString",
			coordinates: Za(F(_(t, "coordinates")) ?? "")
		});
		else if (e[a] === "Polygon") {
			const u = H(t, "LinearRing"), c = [];
			for (i = 0; i < u.length; i++) c.push(Za(F(_(u[i], "coordinates")) ?? ""));
			s.push({
				type: "Polygon",
				coordinates: c
			});
		} else if (e[a] === "Track" || e[a] === "gx:Track") {
			const u = Rc(t);
			s.push({
				type: "LineString",
				coordinates: u.coords
			}), u.times.length && l.push(u.times);
		}
	}
	return {
		geoms: s,
		coordTimes: l
	};
}
function zc(r, e, t, n) {
	const a = Xt(r), o = {}, i = F(_(r, "name")), s = F(_(r, "address")), l = F(_(r, "description")), u = _(r, "TimeSpan"), c = _(r, "TimeStamp"), p = _(r, "ExtendedData"), d = _(r, "visibility");
	let f, h = F(_(r, "styleUrl")), m = _(r, "LineStyle"), y = _(r, "PolyStyle");
	if (!a.geoms.length) return [];
	if (i && (o.name = i), s && (o.address = s), h) {
		h.startsWith("#") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? ""]);
		const v = t[o.styleHash ?? ""];
		if (v) {
			m || (m = _(v, "LineStyle")), y || (y = _(v, "PolyStyle"));
			const x = _(v, "IconStyle");
			if (x) {
				const A = _(x, "Icon");
				if (A) {
					const E = F(_(A, "href"));
					E && (o.icon = E);
				}
			}
		}
	}
	if (l && (o.description = l), u) {
		const v = F(_(u, "begin")), x = F(_(u, "end"));
		v && x && (o.timespan = {
			begin: v,
			end: x
		});
	}
	if (c !== null && (o.timestamp = F(_(c, "when")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {
		const v = Va(F(_(m, "color"))), x = v[0], A = v[1], E = Number.parseFloat(F(_(m, "width")) ?? "");
		x && (o.stroke = x), Number.isNaN(A) || (o["stroke-opacity"] = A), Number.isNaN(E) || (o["stroke-width"] = E);
	}
	if (y) {
		const v = Va(F(_(y, "color"))), x = v[0], A = v[1], E = F(_(y, "fill")), C = F(_(y, "outline"));
		x && (o.fill = x), Number.isNaN(A) || (o["fill-opacity"] = A), E && (o["fill-opacity"] = E === "1" ? o["fill-opacity"] || 1 : 0), C && (o["stroke-opacity"] = C === "1" ? o["stroke-opacity"] || 1 : 0);
	}
	if (p) {
		const v = H(p, "Data"), x = H(p, "SimpleData");
		for (f = 0; f < v.length; f++) o[v[f].getAttribute("name") ?? ""] = F(_(v[f], "value")) ?? "";
		for (f = 0; f < x.length; f++) o[x[f].getAttribute("name") ?? ""] = F(x[f]) ?? "";
	}
	d !== null && (o.visibility = F(d) ?? ""), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);
	const w = {
		type: "Feature",
		geometry: a.geoms.length === 1 ? a.geoms[0] : {
			type: "GeometryCollection",
			geometries: a.geoms
		},
		properties: o
	};
	return Xe(r, "id") && (w.id = Xe(r, "id") ?? void 0), [w];
}
function li(r, e) {
	const t = H(r, e), n = [], a = [];
	let o = [];
	const i = t.length;
	if (!(i < 2)) {
		for (let s = 0; s < i; s++) {
			const l = fi(t[s]);
			n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));
		}
		return {
			line: n,
			times: a,
			heartRates: o
		};
	}
}
function Oc(r) {
	const e = H(r, "trkseg"), t = [], n = [], a = [];
	let o;
	for (let s = 0; s < e.length; s++) if (o = li(e[s], "trkpt"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {
		if (!a.length) for (let l = 0; l < s; l++) a.push(new Array(t[l].length).fill(null));
		o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));
	}
	if (t.length === 0) return;
	const i = {
		...Fn(r),
		...ui(_(r, "extensions"))
	};
	return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {
		type: "Feature",
		properties: i,
		geometry: {
			type: "LineString",
			coordinates: t[0]
		}
	} : {
		type: "Feature",
		properties: i,
		geometry: {
			type: "MultiLineString",
			coordinates: t
		}
	};
}
function $c(r) {
	const e = li(r, "rtept");
	return e === void 0 ? void 0 : {
		type: "Feature",
		properties: {
			...Fn(r),
			...ui(_(r, "extensions"))
		},
		geometry: {
			type: "LineString",
			coordinates: e.line
		}
	};
}
function Fc(r) {
	return {
		type: "Feature",
		properties: {
			...Fn(r),
			...on(r, ["sym"])
		},
		geometry: {
			type: "Point",
			coordinates: fi(r).coordinates
		}
	};
}
function ui(r) {
	const e = {};
	if (r) {
		const t = _(r, "line");
		if (t) {
			const n = F(_(t, "color")), a = Number.parseFloat(F(_(t, "opacity")) ?? "0"), o = Number.parseFloat(F(_(t, "width")) ?? "0");
			n && (e.stroke = n), Number.isNaN(a) || (e["stroke-opacity"] = a), Number.isNaN(o) || (e["stroke-width"] = o * 96 / 25.4);
		}
	}
	return e;
}
function Fn(r) {
	const e = on(r, [
		"name",
		"cmt",
		"desc",
		"type",
		"time",
		"keywords"
	]), t = H(r, "link");
	if (t.length !== 0) {
		e.links = [];
		for (const n of Array.from(t)) {
			const a = {
				href: Xe(n, "href"),
				...on(n, ["text", "type"])
			};
			e.links.push(a);
		}
	}
	return e;
}
function Ga(r) {
	let e = 0;
	if (!r || !r.length) return e;
	for (let t = 0; t < r.length; t++) e = (e << 5) - e + r.charCodeAt(t) | 0;
	return e;
}
function H(r, e) {
	return r.getElementsByTagName(e);
}
function Xe(r, e) {
	return r.getAttribute(e);
}
function Ha(r, e) {
	return Number.parseFloat(Xe(r, e) ?? "0");
}
function _(r, e) {
	const t = H(r, e);
	return t.length ? t[0] : null;
}
function Nc(r) {
	return r.normalize && r.normalize(), r;
}
function ci(r) {
	return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);
}
function F(r) {
	return r && Nc(r), r && r.textContent;
}
function on(r, e) {
	const t = {};
	let n, a;
	for (a = 0; a < e.length; a++) n = _(r, e[a]), n && (t[e[a]] = F(n) ?? "");
	return t;
}
function pi(r) {
	return ci(r.replace(/\s*/g, "").split(","));
}
function Za(r) {
	const e = r.replace(/^\s*|\s*$/g, "").split(/\s+/), t = [];
	for (const n of e) t.push(pi(n));
	return t;
}
function fi(r) {
	const e = [Ha(r, "lon"), Ha(r, "lat")], t = _(r, "ele"), n = _(r, "gpxtpx:hr") || _(r, "hr"), a = _(r, "time");
	let o;
	return t && (o = Number.parseFloat(F(t) ?? "0"), Number.isNaN(o) || e.push(o)), {
		coordinates: e,
		time: a ? F(a) : null,
		heartRate: n !== null ? Number.parseFloat(F(n) ?? "0") : null
	};
}
function jc(r) {
	let e = r;
	try {
		typeof e == "string" && (e = $n(e));
	} catch {
		return null;
	}
	try {
		return ii(e);
	} catch {}
	try {
		return si(e);
	} catch {}
	return null;
}
async function Dc(r, e = {}) {
	const t = e.download ?? !1, n = await Uc(r);
	if (t) {
		const a = e.filename ?? "maptiler_screenshot.png", o = document.createElement("a");
		o.style.display = "none", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {
			document.body.removeChild(o), URL.revokeObjectURL(o.href);
		}, 0);
	}
	return n;
}
function Uc(r) {
	return new Promise((e, t) => {
		r.redraw(), r.once("idle", () => {
			r.getCanvas().toBlob((n) => {
				if (!n) {
					t(Error("Screenshot could not be created."));
					return;
				}
				e(n);
			}, "image/png");
		});
	});
}
var sn = [
	[
		"#1D5B79",
		"#468B97",
		"#EF6262",
		"#F3AA60"
	],
	[
		"#614BC3",
		"#33BBC5",
		"#85E6C5",
		"#C8FFE0"
	],
	[
		"#461959",
		"#7A316F",
		"#CD6688",
		"#AED8CC"
	],
	[
		"#0079FF",
		"#00DFA2",
		"#F6FA70",
		"#FF0060"
	],
	[
		"#39B5E0",
		"#A31ACB",
		"#FF78F0",
		"#F5EA5A"
	],
	[
		"#37E2D5",
		"#590696",
		"#C70A80",
		"#FBCB0A"
	],
	[
		"#FFD36E",
		"#FFF56D",
		"#99FFCD",
		"#9FB4FF"
	],
	[
		"#00EAD3",
		"#FFF5B7",
		"#FF449F",
		"#005F99"
	],
	[
		"#10A19D",
		"#540375",
		"#FF7000",
		"#FFBF00"
	]
];
function kr() {
	return sn[~~(Math.random() * sn.length)][~~(Math.random() * 4)];
}
function Pt() {
	return `maptiler_source_${Qa()}`;
}
function Rt() {
	return `maptiler_layer_${Qa()}`;
}
function ln(r, e) {
	if (e <= r[0].zoom) return r[0].value;
	if (e >= r[r.length - 1].zoom) return r[r.length - 1].value;
	for (let t = 0; t < r.length - 1; t += 1) if (e >= r[t].zoom && e < r[t + 1].zoom) {
		const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;
		return a * r[t + 1].value + (1 - a) * r[t].value;
	}
	return 0;
}
function je(r) {
	return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((e) => [e.zoom, e.value])
	];
}
function O(r) {
	return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((e) => [e.zoom, e.value])
	];
}
function di(r, e) {
	if (typeof e == "number" && typeof r == "number") return 2 * e + r;
	if (typeof e == "number" && Array.isArray(r)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((t) => [t.zoom, 2 * e + t.value])
	];
	if (typeof r == "number" && Array.isArray(e)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...e.flatMap((t) => [t.zoom, 2 * t.value + r])
	];
	if (Array.isArray(r) && Array.isArray(e)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1).flatMap((n) => [n, 2 * ln(e, n) + ln(r, n)])
	];
	return 0;
}
function hi(r, e) {
	return [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((t) => [t.propertyValue, t.value])
	];
}
function Nn(r) {
	const e = r.trimStart(), t = `${e}${" ".repeat(r.length - e.length)}`, n = Array.from(t);
	if (!n.every((s) => s === " " || s === "_")) throw new Error("A dash pattern must be composed only of whitespace and underscore characters.");
	if (!(n.some((s) => s === "_") && n.some((s) => s === " "))) throw new Error("A dash pattern must contain at least one underscore and one whitespace character");
	const i = [1];
	for (let s = 1; s < n.length; s += 1) n[s - 1] === n[s] ? i[i.length - 1] += 1 : i.push(1);
	return i;
}
function un(r, e) {
	return [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((t) => [t.value, t.color])
	];
}
function cn(r, e, t = !0) {
	return t ? [
		"interpolate",
		["linear"],
		["zoom"],
		0,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .025])
		],
		2,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .05])
		],
		4,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .1])
		],
		8,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .25])
		],
		16,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius])
		]
	] : [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((n) => [n.value, n.pointRadius])
	];
}
function mi(r, e, t = !0) {
	return t ? [
		"interpolate",
		["linear"],
		["zoom"],
		0,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .025])
		],
		2,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .05])
		],
		4,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .1])
		],
		8,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .25])
		],
		16,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value])
		]
	] : [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((n) => [n.propertyValue, n.value])
	];
}
function pn(r, e) {
	return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [
		"interpolate",
		["linear"],
		["get", e],
		...r.getRawColorStops().flatMap((t) => {
			const n = t.value, a = t.color;
			return [n, a.length === 4 ? a[3] / 255 : 1];
		})
	];
}
function yi(r, e = 10) {
	return [
		"interpolate",
		["linear"],
		["heatmap-density"],
		...Array.from({ length: e + 1 }, (t, n) => {
			const a = n / e;
			return [a, r.getColorHex(a)];
		}).flat()
	];
}
function Gt(r) {
	const e = r.toString(16);
	return e.length === 1 ? `0${e}` : e;
}
function Bc(r) {
	return `#${Gt(r[0])}${Gt(r[1])}${Gt(r[2])}${r.length === 4 ? Gt(r[3]) : ""}`;
}
var T = class T extends Array {
	constructor(t = {}) {
		super();
		g(this, "min", 0);
		g(this, "max", 1);
		"min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: !1 });
	}
	/**
	* Converts a array-definition color ramp definition into a usable ColorRamp instance.
	* Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
	* @param cr
	* @returns
	*/
	static fromArrayDefinition(t) {
		return new T({ stops: t.map((n) => ({
			value: n[0],
			color: n[1]
		})) });
	}
	setStops(t, n = { clone: !0 }) {
		const a = n.clone ? this.clone() : this;
		a.length = 0;
		let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
		for (let s = 0; s < t.length; s += 1) o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({
			value: t[s].value,
			color: t[s].color.slice()
		});
		return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;
	}
	scale(t, n, a = { clone: !0 }) {
		const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];
		for (let p = 0; p < this.length; p += 1) {
			const h = (this[p].value - i) / l * u + t;
			o ? c.push({
				value: h,
				color: this[p].color.slice()
			}) : this[p].value = h;
		}
		return o ? new T({ stops: c }) : this;
	}
	at(t) {
		return t < 0 ? this[this.length + t] : this[t];
	}
	clone() {
		return new T({ stops: this.getRawColorStops() });
	}
	getRawColorStops() {
		const t = [];
		for (let n = 0; n < this.length; n += 1) t.push({
			value: this[n].value,
			color: this[n].color
		});
		return t;
	}
	reverse(t = { clone: !0 }) {
		const n = t.clone ? this.clone() : this;
		for (let a = 0; a < ~~(n.length / 2); a += 1) {
			const o = n[a].color;
			n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;
		}
		return n;
	}
	getBounds() {
		return {
			min: this.min,
			max: this.max
		};
	}
	getColor(t, n = { smooth: !0 }) {
		if (t <= this[0].value) return this[0].color;
		if (t >= this.at(-1).value) return this.at(-1).color;
		for (let a = 0; a < this.length - 1; a += 1) {
			if (t > this[a + 1].value) continue;
			const o = this[a].color;
			if (!n.smooth) return o.slice();
			const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);
			return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));
		}
		return [
			0,
			0,
			0
		];
	}
	/**
	* Get the color as an hexadecimal string
	*/
	getColorHex(t, n = {
		smooth: !0,
		withAlpha: !1
	}) {
		return Bc(this.getColor(t, n));
	}
	/**
	* Get the color of the color ramp at a relative position in [0, 1]
	*/
	getColorRelative(t, n = { smooth: !0 }) {
		const a = this.getBounds();
		return this.getColor(a.min + t * (a.max - a.min), n);
	}
	getCanvasStrip(t = {
		horizontal: !0,
		size: 512,
		smooth: !0
	}) {
		const n = document.createElement("canvas");
		n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;
		const a = n.getContext("2d");
		if (!a) throw new Error("Canvs context is missing");
		const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;
		for (let d = 0; d < s; d += 1) {
			const f = this.getColor(l + d * p, { smooth: t.smooth });
			i[d * 4] = f[0], i[d * 4 + 1] = f[1], i[d * 4 + 2] = f[2], i[d * 4 + 3] = f.length > 3 ? f[3] : 255;
		}
		return a.putImageData(o, 0, 0), n;
	}
	/**
	* Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
	*/
	resample(t, n = 15) {
		const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);
		let s;
		if (t === "ease-in-square") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = d ** 2;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-square") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - (1 - d) ** 2;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-sqrt") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = d ** .5;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-in-sqrt") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - (1 - d) ** .5;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-exp") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - 2 ** (-10 * d);
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-in-exp") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 2 ** (10 * d - 10);
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else throw new Error("Invalid ressampling method.");
		return new T({ stops: s }).scale(a.min, a.max);
	}
	/**
	* Makes a clone of this color ramp that is fully transparant at the begining of their range
	*/
	transparentStart() {
		const t = this.getRawColorStops();
		t.unshift({
			value: t[0].value,
			color: t[0].color.slice()
		}), t[1].value += .001;
		for (const n of t) n.color.length === 3 && n.color.push(255);
		return t[0].color[3] = 0, new T({ stops: t });
	}
	/**
	* Check if this color ramp has a transparent start
	*/
	hasTransparentStart() {
		return this[0].color.length === 4 && this[0].color[3] === 0;
	}
};
var gi = {
	NULL: new T({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			0,
			0,
			0,
			0
		]
	}] }),
	GRAY: new T({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			255
		]
	}] }),
	JET: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				131
			]
		},
		{
			value: .125,
			color: [
				0,
				60,
				170
			]
		},
		{
			value: .375,
			color: [
				5,
				255,
				255
			]
		},
		{
			value: .625,
			color: [
				255,
				255,
				0
			]
		},
		{
			value: .875,
			color: [
				250,
				0,
				0
			]
		},
		{
			value: 1,
			color: [
				128,
				0,
				0
			]
		}
	] }),
	HSV: new T({ stops: [
		{
			value: 0,
			color: [
				255,
				0,
				0
			]
		},
		{
			value: .169,
			color: [
				253,
				255,
				2
			]
		},
		{
			value: .173,
			color: [
				247,
				255,
				2
			]
		},
		{
			value: .337,
			color: [
				0,
				252,
				4
			]
		},
		{
			value: .341,
			color: [
				0,
				252,
				10
			]
		},
		{
			value: .506,
			color: [
				1,
				249,
				255
			]
		},
		{
			value: .671,
			color: [
				2,
				0,
				253
			]
		},
		{
			value: .675,
			color: [
				8,
				0,
				253
			]
		},
		{
			value: .839,
			color: [
				255,
				0,
				251
			]
		},
		{
			value: .843,
			color: [
				255,
				0,
				245
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				6
			]
		}
	] }),
	HOT: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .3,
			color: [
				230,
				0,
				0
			]
		},
		{
			value: .6,
			color: [
				255,
				210,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	SPRING: new T({ stops: [{
		value: 0,
		color: [
			255,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			0
		]
	}] }),
	SUMMER: new T({ stops: [{
		value: 0,
		color: [
			0,
			128,
			102
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			102
		]
	}] }),
	AUTOMN: new T({ stops: [{
		value: 0,
		color: [
			255,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			0
		]
	}] }),
	WINTER: new T({ stops: [{
		value: 0,
		color: [
			0,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			0,
			255,
			128
		]
	}] }),
	BONE: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .376,
			color: [
				84,
				84,
				116
			]
		},
		{
			value: .753,
			color: [
				169,
				200,
				200
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	COPPER: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .804,
			color: [
				255,
				160,
				102
			]
		},
		{
			value: 1,
			color: [
				255,
				199,
				127
			]
		}
	] }),
	GREYS: new T({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			255
		]
	}] }),
	YIGNBU: new T({ stops: [
		{
			value: 0,
			color: [
				8,
				29,
				88
			]
		},
		{
			value: .125,
			color: [
				37,
				52,
				148
			]
		},
		{
			value: .25,
			color: [
				34,
				94,
				168
			]
		},
		{
			value: .375,
			color: [
				29,
				145,
				192
			]
		},
		{
			value: .5,
			color: [
				65,
				182,
				196
			]
		},
		{
			value: .625,
			color: [
				127,
				205,
				187
			]
		},
		{
			value: .75,
			color: [
				199,
				233,
				180
			]
		},
		{
			value: .875,
			color: [
				237,
				248,
				217
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				217
			]
		}
	] }),
	GREENS: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				68,
				27
			]
		},
		{
			value: .125,
			color: [
				0,
				109,
				44
			]
		},
		{
			value: .25,
			color: [
				35,
				139,
				69
			]
		},
		{
			value: .375,
			color: [
				65,
				171,
				93
			]
		},
		{
			value: .5,
			color: [
				116,
				196,
				118
			]
		},
		{
			value: .625,
			color: [
				161,
				217,
				155
			]
		},
		{
			value: .75,
			color: [
				199,
				233,
				192
			]
		},
		{
			value: .875,
			color: [
				229,
				245,
				224
			]
		},
		{
			value: 1,
			color: [
				247,
				252,
				245
			]
		}
	] }),
	YIORRD: new T({ stops: [
		{
			value: 0,
			color: [
				128,
				0,
				38
			]
		},
		{
			value: .125,
			color: [
				189,
				0,
				38
			]
		},
		{
			value: .25,
			color: [
				227,
				26,
				28
			]
		},
		{
			value: .375,
			color: [
				252,
				78,
				42
			]
		},
		{
			value: .5,
			color: [
				253,
				141,
				60
			]
		},
		{
			value: .625,
			color: [
				254,
				178,
				76
			]
		},
		{
			value: .75,
			color: [
				254,
				217,
				118
			]
		},
		{
			value: .875,
			color: [
				255,
				237,
				160
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				204
			]
		}
	] }),
	BLUERED: new T({ stops: [{
		value: 0,
		color: [
			0,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			255,
			0,
			0
		]
	}] }),
	RDBU: new T({ stops: [
		{
			value: 0,
			color: [
				5,
				10,
				172
			]
		},
		{
			value: .35,
			color: [
				106,
				137,
				247
			]
		},
		{
			value: .5,
			color: [
				190,
				190,
				190
			]
		},
		{
			value: .6,
			color: [
				220,
				170,
				132
			]
		},
		{
			value: .7,
			color: [
				230,
				145,
				90
			]
		},
		{
			value: 1,
			color: [
				178,
				10,
				28
			]
		}
	] }),
	PICNIC: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				255
			]
		},
		{
			value: .1,
			color: [
				51,
				153,
				255
			]
		},
		{
			value: .2,
			color: [
				102,
				204,
				255
			]
		},
		{
			value: .3,
			color: [
				153,
				204,
				255
			]
		},
		{
			value: .4,
			color: [
				204,
				204,
				255
			]
		},
		{
			value: .5,
			color: [
				255,
				255,
				255
			]
		},
		{
			value: .6,
			color: [
				255,
				204,
				255
			]
		},
		{
			value: .7,
			color: [
				255,
				153,
				255
			]
		},
		{
			value: .8,
			color: [
				255,
				102,
				204
			]
		},
		{
			value: .9,
			color: [
				255,
				102,
				102
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				0
			]
		}
	] }),
	RAINBOW: new T({ stops: [
		{
			value: 0,
			color: [
				150,
				0,
				90
			]
		},
		{
			value: .125,
			color: [
				0,
				0,
				200
			]
		},
		{
			value: .25,
			color: [
				0,
				25,
				255
			]
		},
		{
			value: .375,
			color: [
				0,
				152,
				255
			]
		},
		{
			value: .5,
			color: [
				44,
				255,
				150
			]
		},
		{
			value: .625,
			color: [
				151,
				255,
				0
			]
		},
		{
			value: .75,
			color: [
				255,
				234,
				0
			]
		},
		{
			value: .875,
			color: [
				255,
				111,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				0
			]
		}
	] }),
	PORTLAND: new T({ stops: [
		{
			value: 0,
			color: [
				12,
				51,
				131
			]
		},
		{
			value: .25,
			color: [
				10,
				136,
				186
			]
		},
		{
			value: .5,
			color: [
				242,
				211,
				56
			]
		},
		{
			value: .75,
			color: [
				242,
				143,
				56
			]
		},
		{
			value: 1,
			color: [
				217,
				30,
				30
			]
		}
	] }),
	BLACKBODY: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .2,
			color: [
				230,
				0,
				0
			]
		},
		{
			value: .4,
			color: [
				230,
				210,
				0
			]
		},
		{
			value: .7,
			color: [
				255,
				255,
				255
			]
		},
		{
			value: 1,
			color: [
				160,
				200,
				255
			]
		}
	] }),
	EARTH: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				130
			]
		},
		{
			value: .1,
			color: [
				0,
				180,
				180
			]
		},
		{
			value: .2,
			color: [
				40,
				210,
				40
			]
		},
		{
			value: .4,
			color: [
				230,
				230,
				50
			]
		},
		{
			value: .6,
			color: [
				120,
				70,
				20
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	ELECTRIC: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .15,
			color: [
				30,
				0,
				100
			]
		},
		{
			value: .4,
			color: [
				120,
				0,
				100
			]
		},
		{
			value: .6,
			color: [
				160,
				90,
				0
			]
		},
		{
			value: .8,
			color: [
				230,
				200,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				250,
				220
			]
		}
	] }),
	VIRIDIS: new T({ stops: [
		{
			value: 0,
			color: [
				68,
				1,
				84
			]
		},
		{
			value: .13,
			color: [
				71,
				44,
				122
			]
		},
		{
			value: .25,
			color: [
				59,
				81,
				139
			]
		},
		{
			value: .38,
			color: [
				44,
				113,
				142
			]
		},
		{
			value: .5,
			color: [
				33,
				144,
				141
			]
		},
		{
			value: .63,
			color: [
				39,
				173,
				129
			]
		},
		{
			value: .75,
			color: [
				92,
				200,
				99
			]
		},
		{
			value: .88,
			color: [
				170,
				220,
				50
			]
		},
		{
			value: 1,
			color: [
				253,
				231,
				37
			]
		}
	] }),
	INFERNO: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				4
			]
		},
		{
			value: .13,
			color: [
				31,
				12,
				72
			]
		},
		{
			value: .25,
			color: [
				85,
				15,
				109
			]
		},
		{
			value: .38,
			color: [
				136,
				34,
				106
			]
		},
		{
			value: .5,
			color: [
				186,
				54,
				85
			]
		},
		{
			value: .63,
			color: [
				227,
				89,
				51
			]
		},
		{
			value: .75,
			color: [
				249,
				140,
				10
			]
		},
		{
			value: .88,
			color: [
				249,
				201,
				50
			]
		},
		{
			value: 1,
			color: [
				252,
				255,
				164
			]
		}
	] }),
	MAGMA: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				4
			]
		},
		{
			value: .13,
			color: [
				28,
				16,
				68
			]
		},
		{
			value: .25,
			color: [
				79,
				18,
				123
			]
		},
		{
			value: .38,
			color: [
				129,
				37,
				129
			]
		},
		{
			value: .5,
			color: [
				181,
				54,
				122
			]
		},
		{
			value: .63,
			color: [
				229,
				80,
				100
			]
		},
		{
			value: .75,
			color: [
				251,
				135,
				97
			]
		},
		{
			value: .88,
			color: [
				254,
				194,
				135
			]
		},
		{
			value: 1,
			color: [
				252,
				253,
				191
			]
		}
	] }),
	PLASMA: new T({ stops: [
		{
			value: 0,
			color: [
				13,
				8,
				135
			]
		},
		{
			value: .13,
			color: [
				75,
				3,
				161
			]
		},
		{
			value: .25,
			color: [
				125,
				3,
				168
			]
		},
		{
			value: .38,
			color: [
				168,
				34,
				150
			]
		},
		{
			value: .5,
			color: [
				203,
				70,
				121
			]
		},
		{
			value: .63,
			color: [
				229,
				107,
				93
			]
		},
		{
			value: .75,
			color: [
				248,
				148,
				65
			]
		},
		{
			value: .88,
			color: [
				253,
				195,
				40
			]
		},
		{
			value: 1,
			color: [
				240,
				249,
				33
			]
		}
	] }),
	WARM: new T({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .13,
			color: [
				172,
				0,
				187
			]
		},
		{
			value: .25,
			color: [
				219,
				0,
				170
			]
		},
		{
			value: .38,
			color: [
				255,
				0,
				130
			]
		},
		{
			value: .5,
			color: [
				255,
				63,
				74
			]
		},
		{
			value: .63,
			color: [
				255,
				123,
				0
			]
		},
		{
			value: .75,
			color: [
				234,
				176,
				0
			]
		},
		{
			value: .88,
			color: [
				190,
				228,
				0
			]
		},
		{
			value: 1,
			color: [
				147,
				255,
				0
			]
		}
	] }),
	COOL: new T({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .13,
			color: [
				116,
				0,
				218
			]
		},
		{
			value: .25,
			color: [
				98,
				74,
				237
			]
		},
		{
			value: .38,
			color: [
				68,
				146,
				231
			]
		},
		{
			value: .5,
			color: [
				0,
				204,
				197
			]
		},
		{
			value: .63,
			color: [
				0,
				247,
				146
			]
		},
		{
			value: .75,
			color: [
				0,
				255,
				88
			]
		},
		{
			value: .88,
			color: [
				40,
				255,
				8
			]
		},
		{
			value: 1,
			color: [
				147,
				255,
				0
			]
		}
	] }),
	RAINBOW_SOFT: new T({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .1,
			color: [
				199,
				0,
				180
			]
		},
		{
			value: .2,
			color: [
				255,
				0,
				121
			]
		},
		{
			value: .3,
			color: [
				255,
				108,
				0
			]
		},
		{
			value: .4,
			color: [
				222,
				194,
				0
			]
		},
		{
			value: .5,
			color: [
				150,
				255,
				0
			]
		},
		{
			value: .6,
			color: [
				0,
				255,
				55
			]
		},
		{
			value: .7,
			color: [
				0,
				246,
				150
			]
		},
		{
			value: .8,
			color: [
				50,
				167,
				222
			]
		},
		{
			value: .9,
			color: [
				103,
				51,
				235
			]
		},
		{
			value: 1,
			color: [
				124,
				0,
				186
			]
		}
	] }),
	BATHYMETRY: new T({ stops: [
		{
			value: 0,
			color: [
				40,
				26,
				44
			]
		},
		{
			value: .13,
			color: [
				59,
				49,
				90
			]
		},
		{
			value: .25,
			color: [
				64,
				76,
				139
			]
		},
		{
			value: .38,
			color: [
				63,
				110,
				151
			]
		},
		{
			value: .5,
			color: [
				72,
				142,
				158
			]
		},
		{
			value: .63,
			color: [
				85,
				174,
				163
			]
		},
		{
			value: .75,
			color: [
				120,
				206,
				163
			]
		},
		{
			value: .88,
			color: [
				187,
				230,
				172
			]
		},
		{
			value: 1,
			color: [
				253,
				254,
				204
			]
		}
	] }),
	CDOM: new T({ stops: [
		{
			value: 0,
			color: [
				47,
				15,
				62
			]
		},
		{
			value: .13,
			color: [
				87,
				23,
				86
			]
		},
		{
			value: .25,
			color: [
				130,
				28,
				99
			]
		},
		{
			value: .38,
			color: [
				171,
				41,
				96
			]
		},
		{
			value: .5,
			color: [
				206,
				67,
				86
			]
		},
		{
			value: .63,
			color: [
				230,
				106,
				84
			]
		},
		{
			value: .75,
			color: [
				242,
				149,
				103
			]
		},
		{
			value: .88,
			color: [
				249,
				193,
				135
			]
		},
		{
			value: 1,
			color: [
				254,
				237,
				176
			]
		}
	] }),
	CHLOROPHYLL: new T({ stops: [
		{
			value: 0,
			color: [
				18,
				36,
				20
			]
		},
		{
			value: .13,
			color: [
				25,
				63,
				41
			]
		},
		{
			value: .25,
			color: [
				24,
				91,
				59
			]
		},
		{
			value: .38,
			color: [
				13,
				119,
				72
			]
		},
		{
			value: .5,
			color: [
				18,
				148,
				80
			]
		},
		{
			value: .63,
			color: [
				80,
				173,
				89
			]
		},
		{
			value: .75,
			color: [
				132,
				196,
				122
			]
		},
		{
			value: .88,
			color: [
				175,
				221,
				162
			]
		},
		{
			value: 1,
			color: [
				215,
				249,
				208
			]
		}
	] }),
	DENSITY: new T({ stops: [
		{
			value: 0,
			color: [
				54,
				14,
				36
			]
		},
		{
			value: .13,
			color: [
				89,
				23,
				80
			]
		},
		{
			value: .25,
			color: [
				110,
				45,
				132
			]
		},
		{
			value: .38,
			color: [
				120,
				77,
				178
			]
		},
		{
			value: .5,
			color: [
				120,
				113,
				213
			]
		},
		{
			value: .63,
			color: [
				115,
				151,
				228
			]
		},
		{
			value: .75,
			color: [
				134,
				185,
				227
			]
		},
		{
			value: .88,
			color: [
				177,
				214,
				227
			]
		},
		{
			value: 1,
			color: [
				230,
				241,
				241
			]
		}
	] }),
	FREESURFACE_BLUE: new T({ stops: [
		{
			value: 0,
			color: [
				30,
				4,
				110
			]
		},
		{
			value: .13,
			color: [
				47,
				14,
				176
			]
		},
		{
			value: .25,
			color: [
				41,
				45,
				236
			]
		},
		{
			value: .38,
			color: [
				25,
				99,
				212
			]
		},
		{
			value: .5,
			color: [
				68,
				131,
				200
			]
		},
		{
			value: .63,
			color: [
				114,
				156,
				197
			]
		},
		{
			value: .75,
			color: [
				157,
				181,
				203
			]
		},
		{
			value: .88,
			color: [
				200,
				208,
				216
			]
		},
		{
			value: 1,
			color: [
				241,
				237,
				236
			]
		}
	] }),
	FREESURFACE_RED: new T({ stops: [
		{
			value: 0,
			color: [
				60,
				9,
				18
			]
		},
		{
			value: .13,
			color: [
				100,
				17,
				27
			]
		},
		{
			value: .25,
			color: [
				142,
				20,
				29
			]
		},
		{
			value: .38,
			color: [
				177,
				43,
				27
			]
		},
		{
			value: .5,
			color: [
				192,
				87,
				63
			]
		},
		{
			value: .63,
			color: [
				205,
				125,
				105
			]
		},
		{
			value: .75,
			color: [
				216,
				162,
				148
			]
		},
		{
			value: .88,
			color: [
				227,
				199,
				193
			]
		},
		{
			value: 1,
			color: [
				241,
				237,
				236
			]
		}
	] }),
	OXYGEN: new T({ stops: [
		{
			value: 0,
			color: [
				64,
				5,
				5
			]
		},
		{
			value: .13,
			color: [
				106,
				6,
				15
			]
		},
		{
			value: .25,
			color: [
				144,
				26,
				7
			]
		},
		{
			value: .38,
			color: [
				168,
				64,
				3
			]
		},
		{
			value: .5,
			color: [
				188,
				100,
				4
			]
		},
		{
			value: .63,
			color: [
				206,
				136,
				11
			]
		},
		{
			value: .75,
			color: [
				220,
				174,
				25
			]
		},
		{
			value: .88,
			color: [
				231,
				215,
				44
			]
		},
		{
			value: 1,
			color: [
				248,
				254,
				105
			]
		}
	] }),
	PAR: new T({ stops: [
		{
			value: 0,
			color: [
				51,
				20,
				24
			]
		},
		{
			value: .13,
			color: [
				90,
				32,
				35
			]
		},
		{
			value: .25,
			color: [
				129,
				44,
				34
			]
		},
		{
			value: .38,
			color: [
				159,
				68,
				25
			]
		},
		{
			value: .5,
			color: [
				182,
				99,
				19
			]
		},
		{
			value: .63,
			color: [
				199,
				134,
				22
			]
		},
		{
			value: .75,
			color: [
				212,
				171,
				35
			]
		},
		{
			value: .88,
			color: [
				221,
				210,
				54
			]
		},
		{
			value: 1,
			color: [
				225,
				253,
				75
			]
		}
	] }),
	PHASE: new T({ stops: [
		{
			value: 0,
			color: [
				145,
				105,
				18
			]
		},
		{
			value: .13,
			color: [
				184,
				71,
				38
			]
		},
		{
			value: .25,
			color: [
				186,
				58,
				115
			]
		},
		{
			value: .38,
			color: [
				160,
				71,
				185
			]
		},
		{
			value: .5,
			color: [
				110,
				97,
				218
			]
		},
		{
			value: .63,
			color: [
				50,
				123,
				164
			]
		},
		{
			value: .75,
			color: [
				31,
				131,
				110
			]
		},
		{
			value: .88,
			color: [
				77,
				129,
				34
			]
		},
		{
			value: 1,
			color: [
				145,
				105,
				18
			]
		}
	] }),
	SALINITY: new T({ stops: [
		{
			value: 0,
			color: [
				42,
				24,
				108
			]
		},
		{
			value: .13,
			color: [
				33,
				50,
				162
			]
		},
		{
			value: .25,
			color: [
				15,
				90,
				145
			]
		},
		{
			value: .38,
			color: [
				40,
				118,
				137
			]
		},
		{
			value: .5,
			color: [
				59,
				146,
				135
			]
		},
		{
			value: .63,
			color: [
				79,
				175,
				126
			]
		},
		{
			value: .75,
			color: [
				120,
				203,
				104
			]
		},
		{
			value: .88,
			color: [
				193,
				221,
				100
			]
		},
		{
			value: 1,
			color: [
				253,
				239,
				154
			]
		}
	] }),
	TEMPERATURE: new T({ stops: [
		{
			value: 0,
			color: [
				4,
				35,
				51
			]
		},
		{
			value: .13,
			color: [
				23,
				51,
				122
			]
		},
		{
			value: .25,
			color: [
				85,
				59,
				157
			]
		},
		{
			value: .38,
			color: [
				129,
				79,
				143
			]
		},
		{
			value: .5,
			color: [
				175,
				95,
				130
			]
		},
		{
			value: .63,
			color: [
				222,
				112,
				101
			]
		},
		{
			value: .75,
			color: [
				249,
				146,
				66
			]
		},
		{
			value: .88,
			color: [
				249,
				196,
				65
			]
		},
		{
			value: 1,
			color: [
				232,
				250,
				91
			]
		}
	] }),
	TURBIDITY: new T({ stops: [
		{
			value: 0,
			color: [
				34,
				31,
				27
			]
		},
		{
			value: .13,
			color: [
				65,
				50,
				41
			]
		},
		{
			value: .25,
			color: [
				98,
				69,
				52
			]
		},
		{
			value: .38,
			color: [
				131,
				89,
				57
			]
		},
		{
			value: .5,
			color: [
				161,
				112,
				59
			]
		},
		{
			value: .63,
			color: [
				185,
				140,
				66
			]
		},
		{
			value: .75,
			color: [
				202,
				174,
				88
			]
		},
		{
			value: .88,
			color: [
				216,
				209,
				126
			]
		},
		{
			value: 1,
			color: [
				233,
				246,
				171
			]
		}
	] }),
	VELOCITY_BLUE: new T({ stops: [
		{
			value: 0,
			color: [
				17,
				32,
				64
			]
		},
		{
			value: .13,
			color: [
				35,
				52,
				116
			]
		},
		{
			value: .25,
			color: [
				29,
				81,
				156
			]
		},
		{
			value: .38,
			color: [
				31,
				113,
				162
			]
		},
		{
			value: .5,
			color: [
				50,
				144,
				169
			]
		},
		{
			value: .63,
			color: [
				87,
				173,
				176
			]
		},
		{
			value: .75,
			color: [
				149,
				196,
				189
			]
		},
		{
			value: .88,
			color: [
				203,
				221,
				211
			]
		},
		{
			value: 1,
			color: [
				254,
				251,
				230
			]
		}
	] }),
	VELOCITY_GREEN: new T({ stops: [
		{
			value: 0,
			color: [
				23,
				35,
				19
			]
		},
		{
			value: .13,
			color: [
				24,
				64,
				38
			]
		},
		{
			value: .25,
			color: [
				11,
				95,
				45
			]
		},
		{
			value: .38,
			color: [
				39,
				123,
				35
			]
		},
		{
			value: .5,
			color: [
				95,
				146,
				12
			]
		},
		{
			value: .63,
			color: [
				152,
				165,
				18
			]
		},
		{
			value: .75,
			color: [
				201,
				186,
				69
			]
		},
		{
			value: .88,
			color: [
				233,
				216,
				137
			]
		},
		{
			value: 1,
			color: [
				255,
				253,
				205
			]
		}
	] }),
	CUBEHELIX: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .07,
			color: [
				22,
				5,
				59
			]
		},
		{
			value: .13,
			color: [
				60,
				4,
				105
			]
		},
		{
			value: .2,
			color: [
				109,
				1,
				135
			]
		},
		{
			value: .27,
			color: [
				161,
				0,
				147
			]
		},
		{
			value: .33,
			color: [
				210,
				2,
				142
			]
		},
		{
			value: .4,
			color: [
				251,
				11,
				123
			]
		},
		{
			value: .47,
			color: [
				255,
				29,
				97
			]
		},
		{
			value: .53,
			color: [
				255,
				54,
				69
			]
		},
		{
			value: .6,
			color: [
				255,
				85,
				46
			]
		},
		{
			value: .67,
			color: [
				255,
				120,
				34
			]
		},
		{
			value: .73,
			color: [
				255,
				157,
				37
			]
		},
		{
			value: .8,
			color: [
				241,
				191,
				57
			]
		},
		{
			value: .87,
			color: [
				224,
				220,
				93
			]
		},
		{
			value: .93,
			color: [
				218,
				241,
				142
			]
		},
		{
			value: 1,
			color: [
				227,
				253,
				198
			]
		}
	] }),
	CIVIDIS: new T({ stops: [
		{
			value: 0,
			color: [
				0,
				32,
				77,
				255
			]
		},
		{
			value: .125,
			color: [
				5,
				54,
				110,
				255
			]
		},
		{
			value: .25,
			color: [
				65,
				77,
				108,
				255
			]
		},
		{
			value: .375,
			color: [
				97,
				100,
				111,
				255
			]
		},
		{
			value: .5,
			color: [
				125,
				124,
				121,
				255
			]
		},
		{
			value: .625,
			color: [
				156,
				149,
				120,
				255
			]
		},
		{
			value: .75,
			color: [
				190,
				175,
				111,
				255
			]
		},
		{
			value: .875,
			color: [
				225,
				204,
				94,
				255
			]
		},
		{
			value: 1,
			color: [
				255,
				235,
				70,
				255
			]
		}
	] }),
	TURBO: new T({ stops: [
		{
			value: 0,
			color: [
				48,
				18,
				59,
				255
			]
		},
		{
			value: .125,
			color: [
				70,
				107,
				227,
				255
			]
		},
		{
			value: .25,
			color: [
				40,
				187,
				236,
				255
			]
		},
		{
			value: .375,
			color: [
				49,
				242,
				153,
				255
			]
		},
		{
			value: .5,
			color: [
				162,
				252,
				60,
				255
			]
		},
		{
			value: .625,
			color: [
				237,
				208,
				58,
				255
			]
		},
		{
			value: .75,
			color: [
				251,
				128,
				34,
				255
			]
		},
		{
			value: .875,
			color: [
				210,
				49,
				5,
				255
			]
		},
		{
			value: 1,
			color: [
				122,
				4,
				3,
				255
			]
		}
	] }),
	ROCKET: new T({ stops: [
		{
			value: 0,
			color: [
				250,
				235,
				221,
				0
			]
		},
		{
			value: .133,
			color: [
				250,
				235,
				221,
				255
			]
		},
		{
			value: .266,
			color: [
				246,
				170,
				130,
				255
			]
		},
		{
			value: .4,
			color: [
				240,
				96,
				67,
				255
			]
		},
		{
			value: .533,
			color: [
				203,
				27,
				79,
				255
			]
		},
		{
			value: .666,
			color: [
				132,
				30,
				90,
				255
			]
		},
		{
			value: .8,
			color: [
				63,
				27,
				68,
				255
			]
		},
		{
			value: 1,
			color: [
				3,
				5,
				26,
				255
			]
		}
	] }),
	MAKO: new T({ stops: [
		{
			value: 0,
			color: [
				11,
				4,
				5,
				255
			]
		},
		{
			value: .125,
			color: [
				43,
				28,
				53,
				255
			]
		},
		{
			value: .25,
			color: [
				62,
				53,
				107,
				255
			]
		},
		{
			value: .375,
			color: [
				59,
				86,
				152,
				255
			]
		},
		{
			value: .5,
			color: [
				53,
				123,
				162,
				255
			]
		},
		{
			value: .625,
			color: [
				53,
				158,
				170,
				255
			]
		},
		{
			value: .75,
			color: [
				73,
				193,
				173,
				255
			]
		},
		{
			value: .875,
			color: [
				150,
				221,
				181,
				255
			]
		},
		{
			value: 1,
			color: [
				222,
				245,
				229,
				255
			]
		}
	] })
};
async function qc(r, e, t = {}) {
	var a, o;
	if (!e.sourceId && !e.data) throw new Error("Creating a polyline layer requires an existing .sourceId or a valid .data property");
	let n = e.data;
	if (typeof n == "string") {
		if (ir(n)) n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;
		else if (((a = n.split(".").pop()) == null ? void 0 : a.toLowerCase().trim()) === "gpx") n = ii(await (await fetch(n, t)).text());
		else if (((o = n.split(".").pop()) == null ? void 0 : o.toLowerCase().trim()) === "kml") n = si(await (await fetch(n, t)).text());
		else {
			const i = Vi(n) ?? jc(n);
			i && (n = i);
		}
		if (!n) throw new Error("Polyline data was provided as string but is incompatible with valid formats.");
	}
	return Vc(r, {
		...e,
		data: n
	});
}
function Vc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {
		polylineLayerId: n,
		polylineOutlineLayerId: "",
		polylineSourceId: t
	};
	e.data && !r.getSource(t) && r.addSource(t, {
		type: "geojson",
		data: e.data
	});
	const o = e.lineWidth ?? 3, i = e.lineColor ?? kr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;
	let c = e.lineDashArray ?? null;
	const p = e.outlineWidth ?? 1, d = e.outlineColor ?? "#FFFFFF", f = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;
	if (typeof c == "string" && (c = Nn(c)), e.outline === !0) {
		const m = `${n}_outline`;
		a.polylineOutlineLayerId = m, r.addLayer({
			id: m,
			type: "line",
			source: t,
			layout: {
				"line-join": e.lineJoin ?? "round",
				"line-cap": e.lineCap ?? "round"
			},
			minzoom: e.minzoom ?? 0,
			maxzoom: e.maxzoom ?? 23,
			paint: {
				"line-opacity": typeof f == "number" ? f : O(f),
				"line-color": typeof d == "string" ? d : je(d),
				"line-width": di(o, p),
				"line-blur": typeof h == "number" ? h : O(h)
			}
		}, e.beforeId);
	}
	return r.addLayer({
		id: n,
		type: "line",
		source: t,
		layout: {
			"line-join": e.lineJoin ?? "round",
			"line-cap": e.lineCap ?? "round"
		},
		minzoom: e.minzoom ?? 0,
		maxzoom: e.maxzoom ?? 23,
		paint: {
			"line-opacity": typeof s == "number" ? s : O(s),
			"line-color": typeof i == "string" ? i : je(i),
			"line-width": typeof o == "number" ? o : O(o),
			"line-blur": typeof l == "number" ? l : O(l),
			"line-gap-width": typeof u == "number" ? u : O(u),
			...c && { "line-dasharray": c }
		}
	}, e.beforeId), a;
}
function Gc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {
		polygonLayerId: n,
		polygonOutlineLayerId: e.outline ? `${n}_outline` : "",
		polygonSourceId: t
	};
	if (e.data && !r.getSource(t)) {
		let m = e.data;
		typeof m == "string" && ir(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {
			type: "geojson",
			data: m
		});
	}
	let o = e.outlineDashArray ?? null;
	const i = e.outlineWidth ?? 1, s = e.outlineColor ?? "#FFFFFF", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? kr(), p = e.fillOpacity ?? 1, d = e.outlinePosition ?? "center", f = e.pattern ?? null;
	typeof o == "string" && (o = Nn(o));
	const h = (m = null) => {
		if (r.addLayer({
			id: n,
			type: "fill",
			source: t,
			minzoom: e.minzoom ?? 0,
			maxzoom: e.maxzoom ?? 23,
			paint: {
				"fill-color": typeof c == "string" ? c : je(c),
				"fill-opacity": typeof p == "number" ? p : O(p),
				...m && { "fill-pattern": m }
			}
		}, e.beforeId), e.outline === !0) {
			let y;
			d === "inside" ? typeof i == "number" ? y = .5 * i : y = O(i.map(({ zoom: w, value: v }) => ({
				zoom: w,
				value: .5 * v
			}))) : d === "outside" ? typeof i == "number" ? y = -.5 * i : y = O(i.map((w) => ({
				zoom: w.zoom,
				value: -.5 * w.value
			}))) : y = 0, r.addLayer({
				id: a.polygonOutlineLayerId,
				type: "line",
				source: t,
				layout: {
					"line-join": e.outlineJoin ?? "round",
					"line-cap": e.outlineCap ?? "butt"
				},
				minzoom: e.minzoom ?? 0,
				maxzoom: e.maxzoom ?? 23,
				paint: {
					"line-opacity": typeof l == "number" ? l : O(l),
					"line-color": typeof s == "string" ? s : je(s),
					"line-width": typeof i == "number" ? i : O(i),
					"line-blur": typeof u == "number" ? u : O(u),
					"line-offset": y,
					...o && { "line-dasharray": o }
				}
			}, e.beforeId);
		}
	};
	return f ? r.hasImage(f) ? h(f) : r.loadImage(f).then((m) => {
		r.addImage(f, m.data), h(f);
	}).catch((m) => {
		console.error("Could not load the pattern image.", m.message), h();
	}) : h(), a;
}
function Hc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? !1, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : gi.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample("ease-out-square"), s = i.getBounds(), l = e.sourceId ?? Pt(), u = e.layerId ?? Rt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? !0, d = e.outline ?? !1, f = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? "#FFFFFF";
	let y;
	const w = e.zoomCompensation ?? !0, v = e.minzoom ?? 0, x = e.maxzoom ?? 23;
	typeof e.pointOpacity == "number" ? y = e.pointOpacity : Array.isArray(e.pointOpacity) ? y = O(e.pointOpacity) : e.cluster ? y = pn(i, "point_count") : e.property ? y = pn(i, e.property) : y = O([
		{
			zoom: v,
			value: 0
		},
		{
			zoom: v + .25,
			value: 1
		},
		{
			zoom: x - .25,
			value: 1
		},
		{
			zoom: x,
			value: 0
		}
	]);
	const A = {
		pointLayerId: u,
		clusterLayerId: "",
		labelLayerId: "",
		pointSourceId: l
	};
	if (e.data && !r.getSource(l)) {
		let E = e.data;
		typeof E == "string" && ir(E) && (E = `https://api.maptiler.com/data/${E}/features.json?key=${j.apiKey}`), r.addSource(l, {
			type: "geojson",
			data: E,
			cluster: a
		});
	}
	if (a) {
		A.clusterLayerId = `${u}_cluster`;
		const E = Array.from({ length: o }, (C, N) => {
			const ee = s.min + N * (s.max - s.min) / (o - 1);
			return {
				value: ee,
				pointRadius: t + (n - t) * (N / (o - 1)) ** .5,
				color: i.getColorHex(ee)
			};
		});
		r.addLayer({
			id: A.clusterLayerId,
			type: "circle",
			source: l,
			filter: ["has", "point_count"],
			paint: {
				"circle-color": typeof e.pointColor == "string" ? e.pointColor : un(E, "point_count"),
				"circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : cn(E, "point_count", !1),
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-opacity": y,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : je(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId), r.addLayer({
			id: A.pointLayerId,
			type: "circle",
			source: l,
			filter: ["!", ["has", "point_count"]],
			paint: {
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-color": typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(i.getBounds().min),
				"circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : E[0].pointRadius * .75,
				"circle-opacity": y,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : je(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	} else {
		let E = typeof e.pointColor == "string" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : kr(), C = typeof e.pointRadius == "number" ? w ? O([
			{
				zoom: 0,
				value: e.pointRadius * .025
			},
			{
				zoom: 2,
				value: e.pointRadius * .05
			},
			{
				zoom: 4,
				value: e.pointRadius * .1
			},
			{
				zoom: 8,
				value: e.pointRadius * .25
			},
			{
				zoom: 16,
				value: e.pointRadius * 1
			}
		]) : e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : w ? O([
			{
				zoom: 0,
				value: t * .05
			},
			{
				zoom: 2,
				value: t * .1
			},
			{
				zoom: 4,
				value: t * .2
			},
			{
				zoom: 8,
				value: t * .5
			},
			{
				zoom: 16,
				value: t * 1
			}
		]) : t;
		if (e.property && Array.isArray(e.pointColor)) {
			const N = Array.from({ length: o }, (ee, Le) => {
				const Ee = s.min + Le * (s.max - s.min) / (o - 1);
				return {
					value: Ee,
					pointRadius: typeof e.pointRadius == "number" ? e.pointRadius : t + (n - t) * (Le / (o - 1)) ** .5,
					color: typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(Ee)
				};
			});
			E = un(N, e.property), C = cn(N, e.property, w);
		}
		r.addLayer({
			id: A.pointLayerId,
			type: "circle",
			source: l,
			layout: { "circle-sort-key": e.property ? [
				"/",
				1,
				["get", e.property]
			] : 0 },
			paint: {
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-color": E,
				"circle-opacity": y,
				"circle-radius": C,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : je(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	}
	if (c !== !1 && (e.cluster || e.property)) {
		A.labelLayerId = `${u}_label`;
		const E = e.labelColor ?? "#fff", C = e.labelSize ?? 12;
		r.addLayer({
			id: A.labelLayerId,
			type: "symbol",
			source: l,
			filter: ["has", e.cluster ? "point_count" : e.property],
			layout: {
				"text-field": e.cluster ? "{point_count_abbreviated}" : `{${e.property}}`,
				"text-font": ["Noto Sans Regular"],
				"text-size": C,
				"text-pitch-alignment": p ? "viewport" : "map",
				"symbol-sort-key": [
					"/",
					1,
					["get", e.cluster ? "point_count" : e.property]
				]
			},
			paint: {
				"text-color": E,
				"text-opacity": y
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	}
	return A;
}
function Zc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? !0, s = e.opacity ?? [
		{
			zoom: a,
			value: 0
		},
		{
			zoom: a + .25,
			value: 1
		},
		{
			zoom: o - .25,
			value: 1
		},
		{
			zoom: o,
			value: 0
		}
	];
	let l = Array.isArray(e.colorRamp) ? e.colorRamp : gi.TURBO.transparentStart();
	const u = l.getBounds();
	(u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());
	const c = e.intensity ?? [
		{
			zoom: 0,
			value: .01
		},
		{
			zoom: 4,
			value: .2
		},
		{
			zoom: 16,
			value: 1
		}
	], p = e.property ?? null, d = e.weight ?? 1;
	let f = 1;
	p ? typeof d == "number" ? (f = d, typeof e.weight == "number" && console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`")) : Array.isArray(d) ? f = hi(d, p) : console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`") : typeof d == "number" ? f = d : Array.isArray(d) && console.warn("The options `.propertyValueWeights` can only be used when `.property` is provided.");
	const h = [
		{
			zoom: 0,
			value: 50 * .025
		},
		{
			zoom: 2,
			value: 50 * .05
		},
		{
			zoom: 4,
			value: 50 * .1
		},
		{
			zoom: 8,
			value: 50 * .25
		},
		{
			zoom: 16,
			value: 50
		}
	], m = e.radius ?? (i ? h : 10);
	let y = 1;
	typeof m == "number" ? y = m : Array.isArray(m) && "zoom" in m[0] ? y = O(m) : p && Array.isArray(m) && "propertyValue" in m[0] ? y = mi(m, p, i) : !p && Array.isArray(m) && "propertyValue" in m[0] ? (y = O(h), console.warn("The option `.radius` can only be property-driven if the option `.property` is provided.")) : y = O(h);
	const w = {
		heatmapLayerId: n,
		heatmapSourceId: t
	};
	if (e.data && !r.getSource(t)) {
		let v = e.data;
		typeof v == "string" && ir(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${j.apiKey}`), r.addSource(t, {
			type: "geojson",
			data: v
		});
	}
	return r.addLayer({
		id: n,
		type: "heatmap",
		source: t,
		minzoom: a,
		maxzoom: o,
		paint: {
			"heatmap-weight": f,
			"heatmap-intensity": typeof c == "number" ? c : O(c),
			"heatmap-color": yi(l),
			"heatmap-radius": y,
			"heatmap-opacity": typeof s == "number" ? s : O(s)
		}
	}, e.beforeId), w;
}
var Lp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	addHeatmap: Zc,
	addPoint: Hc,
	addPolygon: Gc,
	addPolyline: qc,
	colorDrivenByProperty: un,
	colorPalettes: sn,
	computeRampedOutlineWidth: di,
	dashArrayMaker: Nn,
	generateRandomLayerName: Rt,
	generateRandomSourceName: Pt,
	getRandomColor: kr,
	heatmapIntensityFromColorRamp: yi,
	lerpZoomNumberValues: ln,
	opacityDrivenByProperty: pn,
	paintColorOptionsToPaintSpec: je,
	radiusDrivenByProperty: cn,
	radiusDrivenByPropertyHeatmap: mi,
	rampedOptionsToLayerPaintSpec: O,
	rampedPropertyValueWeight: hi,
	takeScreenshot: Dc
}, Symbol.toStringTag, { value: "Module" }));
function Kc() {
	return "3.9.0";
}
var Ep = import_maplibre_gl.default.Map, Cp = import_maplibre_gl.default.Marker, Ap = import_maplibre_gl.default.Popup, Tp = import_maplibre_gl.default.Style, _p = import_maplibre_gl.default.CanvasSource, Ip = import_maplibre_gl.default.GeoJSONSource, Mp = import_maplibre_gl.default.ImageSource, Pp = import_maplibre_gl.default.RasterTileSource, Rp = import_maplibre_gl.default.RasterDEMTileSource, zp = import_maplibre_gl.default.VectorTileSource, Op = import_maplibre_gl.default.VideoSource, $p = import_maplibre_gl.default.NavigationControl, Fp = import_maplibre_gl.default.GeolocateControl, Np = import_maplibre_gl.default.AttributionControl, jp = import_maplibre_gl.default.LogoControl, Dp = import_maplibre_gl.default.ScaleControl, Up = import_maplibre_gl.default.FullscreenControl, Bp = import_maplibre_gl.default.TerrainControl, qp = import_maplibre_gl.default.BoxZoomHandler, Vp = import_maplibre_gl.default.ScrollZoomHandler, Gp = import_maplibre_gl.default.CooperativeGesturesHandler, Hp = import_maplibre_gl.default.KeyboardHandler, Zp = import_maplibre_gl.default.TwoFingersTouchPitchHandler, Kp = import_maplibre_gl.default.MapWheelEvent, Xp = import_maplibre_gl.default.MapTouchEvent, Yp = import_maplibre_gl.default.MapMouseEvent, Wp = import_maplibre_gl.default.config, Jp = import_maplibre_gl.default.getVersion, { setRTLTextPlugin: Qp, getRTLTextPluginStatus: ef, LngLat: vi, LngLatBounds: Xc, MercatorCoordinate: fn, Evented: tf, AJAXError: rf, prewarm: nf, clearPrewarmedResources: af, Hash: of, Point: bi, EdgeInsets: sf, DragRotateHandler: lf, DragPanHandler: uf, TwoFingersTouchZoomRotateHandler: cf, DoubleClickZoomHandler: pf, TwoFingersTouchZoomHandler: ff, TwoFingersTouchRotateHandler: df, getWorkerCount: hf, setWorkerCount: mf, getMaxParallelImageRequests: yf, setMaxParallelImageRequests: gf, getWorkerUrl: vf, setWorkerUrl: bf, addSourceType: wf, importScriptInWorkers: Sf, addProtocol: xf, removeProtocol: kf } = import_maplibre_gl.default;

//#endregion
export { rf as AJAXError, fp as AttributionControl, Np as AttributionControlMLGL, hp as BoxZoomHandler, qp as BoxZoomHandlerMLGL, op as CanvasSource, _p as CanvasSourceMLGL, T as ColorRamp, gi as ColorRampCollection, yp as CooperativeGesturesHandler, Gp as CooperativeGesturesHandlerMLGL, Be as CubemapFaceNames, Zu as CubemapImagesPresets, Br as CubemapLayer, Te as DOMcreate, Et as DOMremove, pf as DoubleClickZoomHandler, uf as DragPanHandler, lf as DragRotateHandler, sf as EdgeInsets, tf as Evented, Oi as FullscreenControl, Up as FullscreenControlMLGL, ip as GeoJSONSource, Ip as GeoJSONSourceMLGL, Pi as GeolocateControl, Fp as GeolocateControlMLGL, sc as GeolocationType, of as Hash, sp as ImageSource, Mp as ImageSourceMLGL, Lc as ImageViewer, re as ImageViewerEvent, kp as ImageViewerMarker, Ic as ImageViewerMarkerEvent, gp as KeyboardHandler, Hp as KeyboardHandlerMLGL, z as Language, vi as LngLat, Xc as LngLatBounds, Ri as LogoControl, jp as LogoControlMLGL, Go as Map, Ep as MapMLGL, Sp as MapMouseEvent, Yp as MapMouseEventMLGL, MapStyle, MapStyleVariant, wp as MapTouchEvent, Xp as MapTouchEventMLGL, bp as MapWheelEvent, Kp as MapWheelEventMLGL, bu as MaptilerCustomControl, tn as MaptilerExternalControl, vu as MaptilerGeolocateControl, Wn as MaptilerLogoControl, yu as MaptilerNavigationControl, wu as MaptilerProjectionControl, mu as MaptilerTerrainControl, Mi as Marker, Cp as MarkerMLGL, fn as MercatorCoordinate, $p as NavigationControMLGL, Wa as NavigationControl, bi as Point, np as Popup, Ap as PopupMLGL, qr as RadialGradientLayer, up as RasterDEMTileSource, Rp as RasterDEMTileSourceMLGL, lp as RasterTileSource, Pp as RasterTileSourceMLGL, ReferenceMapStyle, zi as ScaleControl, Dp as ScaleControlMLGL, mp as ScrollZoomHandler, Vp as ScrollZoomHandlerMLGL, $i as SdkConfig, ServiceError, ap as Style, Tp as StyleMLGL, Bp as TerrainControMLGL, dp as TerrainControl, vp as TwoFingersTouchPitchHandler, Zp as TwoFingersTouchPitchHandlerMLGL, df as TwoFingersTouchRotateHandler, ff as TwoFingersTouchZoomHandler, cf as TwoFingersTouchZoomRotateHandler, cp as VectorTileSource, zp as VectorTileSourceMLGL, pp as VideoSource, Op as VideoSourceMLGL, xf as addProtocol, wf as addSourceType, areSameLanguages, bufferToPixelDataBrowser, canParsePixelData, circumferenceAtLatitude, af as clearPrewarmedResources, j as config, Wp as configMLGL, coordinates, Ke as cubemapPresets, data, xp as displayWebGLContextLostWarning, elevation, expandMapStyle, geocoding, geolocation, getAutoLanguage, Yn as getBrowserLanguage, getBufferToPixelDataParser, getLanguageInfoFromCode, getLanguageInfoFromFlag, getLanguageInfoFromKey, Jp as getMapLibreVersion, yf as getMaxParallelImageRequests, ef as getRTLTextPluginStatus, getTileCache, Kc as getVersion, Gi as getWebGLSupportError, hf as getWorkerCount, vf as getWorkerUrl, ii as gpx, jc as gpxOrKml, oi as hasChildNodeWithName, Lp as helpers, Sf as importScriptInWorkers, isLanguageInfo, si as kml, mapStylePresetList, math, misc, nf as prewarm, kf as removeProtocol, gf as setMaxParallelImageRequests, Qp as setRTLTextPlugin, mf as setWorkerCount, bf as setWorkerUrl, staticMaps, $n as str2xml, styleToStyle, toLanguageInfo, Do as toggleProjection, jo as toggleTerrain, qa as xml2str };
//# sourceMappingURL=@maptiler_sdk.js.map